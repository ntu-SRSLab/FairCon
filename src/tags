!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABI	libsolidity/ast/Types.h	/^		ABI, \/\/\/< "abi"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
ABI	libsolidity/interface/ABI.h	/^class ABI$/;"	c	namespace:dev::solidity
ABI::formatType	libsolidity/interface/ABI.cpp	/^Json::Value ABI::formatType(string const& _name, Type const& _type, bool _forLibrary)$/;"	f	class:ABI	signature:(string const& _name, Type const& _type, bool _forLibrary)
ABI::formatTypeList	libsolidity/interface/ABI.cpp	/^Json::Value ABI::formatTypeList($/;"	f	class:ABI	signature:( vector<string> const& _names, vector<TypePointer> const& _types, bool _forLibrary )
ABI::generate	libsolidity/interface/ABI.cpp	/^Json::Value ABI::generate(ContractDefinition const& _contractDef)$/;"	f	class:ABI	signature:(ContractDefinition const& _contractDef)
ABIDecode	libsolidity/ast/Types.h	/^		ABIDecode,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ABIEncode	libsolidity/ast/Types.h	/^		ABIEncode,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ABIEncodePacked	libsolidity/ast/Types.h	/^		ABIEncodePacked,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ABIEncodeWithSelector	libsolidity/ast/Types.h	/^		ABIEncodeWithSelector,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ABIEncodeWithSignature	libsolidity/ast/Types.h	/^		ABIEncodeWithSignature,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ABIEncoderV2	libsolidity/ast/ExperimentalFeatures.h	/^	ABIEncoderV2, \/\/ new ABI encoder that makes use of Yul$/;"	m	class:dev::solidity::ExperimentalFeature	access:private
ABIFunctions	libsolidity/codegen/ABIFunctions.h	/^	explicit ABIFunctions(langutil::EVMVersion _evmVersion = langutil::EVMVersion{}) : m_evmVersion(_evmVersion) {}$/;"	f	class:dev::solidity::ABIFunctions	access:public	signature:(langutil::EVMVersion _evmVersion = langutil::EVMVersion{})
ABIFunctions	libsolidity/codegen/ABIFunctions.h	/^class ABIFunctions$/;"	c	namespace:dev::solidity
ABIFunctions::EncodingOptions::toFunctionNameSuffix	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::EncodingOptions::toFunctionNameSuffix() const$/;"	f	class:ABIFunctions::EncodingOptions	signature:() const
ABIFunctions::abiDecodingFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunction(Type const& _type, bool _fromMemory, bool _forUseOnStack)$/;"	f	class:ABIFunctions	signature:(Type const& _type, bool _fromMemory, bool _forUseOnStack)
ABIFunctions::abiDecodingFunctionArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionArray(ArrayType const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type, bool _fromMemory)
ABIFunctions::abiDecodingFunctionByteArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionByteArray(ArrayType const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type, bool _fromMemory)
ABIFunctions::abiDecodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionCalldataArray(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
ABIFunctions::abiDecodingFunctionCalldataStruct	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionCalldataStruct(StructType const& _type)$/;"	f	class:ABIFunctions	signature:(StructType const& _type)
ABIFunctions::abiDecodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionFunctionType(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack)$/;"	f	class:ABIFunctions	signature:(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack)
ABIFunctions::abiDecodingFunctionStruct	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionStruct(StructType const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(StructType const& _type, bool _fromMemory)
ABIFunctions::abiDecodingFunctionValueType	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionValueType(Type const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(Type const& _type, bool _fromMemory)
ABIFunctions::abiEncodeAndReturnUpdatedPosFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodeAndReturnUpdatedPosFunction($/;"	f	class:ABIFunctions	signature:( Type const& _givenType, Type const& _targetType, ABIFunctions::EncodingOptions const& _options )
ABIFunctions::abiEncodingFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunction($/;"	f	class:ABIFunctions	signature:( Type const& _from, Type const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionCalldataArray($/;"	f	class:ABIFunctions	signature:( Type const& _from, Type const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionCompactStorageArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionCompactStorageArray($/;"	f	class:ABIFunctions	signature:( ArrayType const& _from, ArrayType const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionFunctionType($/;"	f	class:ABIFunctions	signature:( FunctionType const& _from, Type const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionMemoryByteArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionMemoryByteArray($/;"	f	class:ABIFunctions	signature:( ArrayType const& _from, ArrayType const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionSimpleArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionSimpleArray($/;"	f	class:ABIFunctions	signature:( ArrayType const& _from, ArrayType const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionStringLiteral	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionStringLiteral($/;"	f	class:ABIFunctions	signature:( Type const& _from, Type const& _to, EncodingOptions const& _options )
ABIFunctions::abiEncodingFunctionStruct	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionStruct($/;"	f	class:ABIFunctions	signature:( StructType const& _from, StructType const& _to, EncodingOptions const& _options )
ABIFunctions::allocationFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::allocationFunction()$/;"	f	class:ABIFunctions	signature:()
ABIFunctions::arrayAllocationSizeFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayAllocationSizeFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
ABIFunctions::arrayDataAreaFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayDataAreaFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
ABIFunctions::arrayLengthFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayLengthFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
ABIFunctions::arrayStoreLengthForEncodingFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayStoreLengthForEncodingFunction(ArrayType const& _type, EncodingOptions const& _options)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type, EncodingOptions const& _options)
ABIFunctions::cleanupCombinedExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::cleanupCombinedExternalFunctionIdFunction()$/;"	f	class:ABIFunctions	signature:()
ABIFunctions::cleanupFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::cleanupFunction(Type const& _type, bool _revertOnFailure)$/;"	f	class:ABIFunctions	signature:(Type const& _type, bool _revertOnFailure)
ABIFunctions::combineExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::combineExternalFunctionIdFunction()$/;"	f	class:ABIFunctions	signature:()
ABIFunctions::conversionFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::conversionFunction(Type const& _from, Type const& _to)$/;"	f	class:ABIFunctions	signature:(Type const& _from, Type const& _to)
ABIFunctions::copyToMemoryFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::copyToMemoryFunction(bool _fromCalldata)$/;"	f	class:ABIFunctions	signature:(bool _fromCalldata)
ABIFunctions::createExternallyUsedFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::createExternallyUsedFunction(string const& _name, function<string ()> const& _creator)$/;"	f	class:ABIFunctions	signature:(string const& _name, function<string ()> const& _creator)
ABIFunctions::createFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::createFunction(string const& _name, function<string ()> const& _creator)$/;"	f	class:ABIFunctions	signature:(string const& _name, function<string ()> const& _creator)
ABIFunctions::headSize	libsolidity/codegen/ABIFunctions.cpp	/^size_t ABIFunctions::headSize(TypePointers const& _targetTypes)$/;"	f	class:ABIFunctions	signature:(TypePointers const& _targetTypes)
ABIFunctions::leftAlignFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::leftAlignFunction(Type const& _type)$/;"	f	class:ABIFunctions	signature:(Type const& _type)
ABIFunctions::nextArrayElementFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::nextArrayElementFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
ABIFunctions::requestedFunctions	libsolidity/codegen/ABIFunctions.cpp	/^pair<string, set<string>> ABIFunctions::requestedFunctions()$/;"	f	class:ABIFunctions	signature:()
ABIFunctions::roundUpFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::roundUpFunction()$/;"	f	class:ABIFunctions	signature:()
ABIFunctions::shiftLeftFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::shiftLeftFunction(size_t _numBits)$/;"	f	class:ABIFunctions	signature:(size_t _numBits)
ABIFunctions::shiftRightFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::shiftRightFunction(size_t _numBits)$/;"	f	class:ABIFunctions	signature:(size_t _numBits)
ABIFunctions::splitExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::splitExternalFunctionIdFunction()$/;"	f	class:ABIFunctions	signature:()
ABIFunctions::tupleDecoder	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::tupleDecoder(TypePointers const& _types, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(TypePointers const& _types, bool _fromMemory)
ABIFunctions::tupleEncoder	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::tupleEncoder($/;"	f	class:ABIFunctions	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes )
ABIFunctions::tupleEncoderPacked	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::tupleEncoderPacked($/;"	f	class:ABIFunctions	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes )
ADD	libevmasm/Instruction.h	/^	ADD,				\/\/\/< addition operation$/;"	m	class:dev::solidity::Instruction	access:private
ADDMOD	libevmasm/Instruction.h	/^	ADDMOD,				\/\/\/< unsigned modular addition$/;"	m	class:dev::solidity::Instruction	access:private
ADDRESS	libevmasm/Instruction.h	/^	ADDRESS = 0x30,		\/\/\/< get address of currently executing account$/;"	m	class:dev::solidity::Instruction	access:private
AND	libevmasm/Instruction.h	/^	AND,				\/\/\/< bitwise AND operation$/;"	m	class:dev::solidity::Instruction	access:private
ASTAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ASTAnnotation$/;"	s	namespace:dev::solidity
ASTConstVisitor	libsolidity/ast/ASTVisitor.h	/^class ASTConstVisitor$/;"	c	namespace:dev::solidity
ASTCopier	libyul/optimiser/ASTCopier.h	/^class ASTCopier: public ExpressionCopier, public StatementCopier$/;"	c	namespace:yul	inherits:ExpressionCopier,StatementCopier
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(FunctionCall const& _call)$/;"	f	class:ASTCopier	signature:(FunctionCall const& _call)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(FunctionalInstruction const& _instruction)$/;"	f	class:ASTCopier	signature:(FunctionalInstruction const& _instruction)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(Identifier const& _identifier)$/;"	f	class:ASTCopier	signature:(Identifier const& _identifier)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(Literal const& _literal)$/;"	f	class:ASTCopier	signature:(Literal const& _literal)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator ()(Block const& _block)$/;"	f	class:ASTCopier	signature:(Block const& _block)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Assignment const& _assignment)$/;"	f	class:ASTCopier	signature:(Assignment const& _assignment)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(ExpressionStatement const& _statement)$/;"	f	class:ASTCopier	signature:(ExpressionStatement const& _statement)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(ForLoop const& _forLoop)$/;"	f	class:ASTCopier	signature:(ForLoop const& _forLoop)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(FunctionDefinition const& _function)$/;"	f	class:ASTCopier	signature:(FunctionDefinition const& _function)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(If const& _if)$/;"	f	class:ASTCopier	signature:(If const& _if)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Instruction const&)$/;"	f	class:ASTCopier	signature:(Instruction const&)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Label const&)$/;"	f	class:ASTCopier	signature:(Label const&)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(StackAssignment const&)$/;"	f	class:ASTCopier	signature:(StackAssignment const&)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Switch const& _switch)$/;"	f	class:ASTCopier	signature:(Switch const& _switch)
ASTCopier::operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:ASTCopier	signature:(VariableDeclaration const& _varDecl)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^Block ASTCopier::translate(Block const& _block)$/;"	f	class:ASTCopier	signature:(Block const& _block)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^Case ASTCopier::translate(Case const& _case)$/;"	f	class:ASTCopier	signature:(Case const& _case)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::translate(Expression const& _expression)$/;"	f	class:ASTCopier	signature:(Expression const& _expression)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^Identifier ASTCopier::translate(Identifier const& _identifier)$/;"	f	class:ASTCopier	signature:(Identifier const& _identifier)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^Literal ASTCopier::translate(Literal const& _literal)$/;"	f	class:ASTCopier	signature:(Literal const& _literal)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::translate(Statement const& _statement)$/;"	f	class:ASTCopier	signature:(Statement const& _statement)
ASTCopier::translate	libyul/optimiser/ASTCopier.cpp	/^TypedName ASTCopier::translate(TypedName const& _typedName)$/;"	f	class:ASTCopier	signature:(TypedName const& _typedName)
ASTJsonConverter	libsolidity/ast/ASTJsonConverter.cpp	/^ASTJsonConverter::ASTJsonConverter(bool _legacy, map<string, unsigned> _sourceIndices):$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(bool _legacy, map<string, unsigned> _sourceIndices)
ASTJsonConverter	libsolidity/ast/ASTJsonConverter.h	/^	explicit ASTJsonConverter($/;"	p	class:dev::solidity::ASTJsonConverter	access:public	signature:( bool _legacy, std::map<std::string, unsigned> _sourceIndices = std::map<std::string, unsigned>() )
ASTJsonConverter	libsolidity/ast/ASTJsonConverter.h	/^class ASTJsonConverter: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ASTModifier	libyul/optimiser/ASTWalker.h	/^class ASTModifier: public boost::static_visitor<>$/;"	c	namespace:yul	inherits:boost::static_visitor
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(Assignment& _assignment)$/;"	f	class:ASTModifier	signature:(Assignment& _assignment)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(Block& _block)$/;"	f	class:ASTModifier	signature:(Block& _block)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(ExpressionStatement& _statement)$/;"	f	class:ASTModifier	signature:(ExpressionStatement& _statement)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(ForLoop& _for)$/;"	f	class:ASTModifier	signature:(ForLoop& _for)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(FunctionCall& _funCall)$/;"	f	class:ASTModifier	signature:(FunctionCall& _funCall)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(FunctionDefinition& _fun)$/;"	f	class:ASTModifier	signature:(FunctionDefinition& _fun)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(FunctionalInstruction& _instr)$/;"	f	class:ASTModifier	signature:(FunctionalInstruction& _instr)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(If& _if)$/;"	f	class:ASTModifier	signature:(If& _if)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(Switch& _switch)$/;"	f	class:ASTModifier	signature:(Switch& _switch)
ASTModifier::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(VariableDeclaration& _varDecl)$/;"	f	class:ASTModifier	signature:(VariableDeclaration& _varDecl)
ASTModifier::visit	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::visit(Expression& _e)$/;"	f	class:ASTModifier	signature:(Expression& _e)
ASTModifier::visit	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::visit(Statement& _st)$/;"	f	class:ASTModifier	signature:(Statement& _st)
ASTNode	libsolidity/ast/AST.cpp	/^ASTNode::ASTNode(SourceLocation const& _location):$/;"	f	class:ASTNode	signature:(SourceLocation const& _location)
ASTNode	libsolidity/ast/AST.h	/^class ASTNode: private boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
ASTNode::ASTNode	libsolidity/ast/AST.cpp	/^ASTNode::ASTNode(SourceLocation const& _location):$/;"	f	class:ASTNode	signature:(SourceLocation const& _location)
ASTNode::annotation	libsolidity/ast/AST.cpp	/^ASTAnnotation& ASTNode::annotation() const$/;"	f	class:ASTNode	signature:() const
ASTNode::resetID	libsolidity/ast/AST.cpp	/^void ASTNode::resetID()$/;"	f	class:ASTNode	signature:()
ASTNode::~ASTNode	libsolidity/ast/AST.cpp	/^ASTNode::~ASTNode()$/;"	f	class:ASTNode	signature:()
ASTNodeFactory	libsolidity/parsing/Parser.cpp	/^	ASTNodeFactory(Parser const& _parser, ASTPointer<ASTNode> const& _childNode):$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(Parser const& _parser, ASTPointer<ASTNode> const& _childNode)
ASTNodeFactory	libsolidity/parsing/Parser.cpp	/^	explicit ASTNodeFactory(Parser const& _parser):$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(Parser const& _parser)
ASTNodeFactory	libsolidity/parsing/Parser.cpp	/^class Parser::ASTNodeFactory$/;"	c	class:dev::solidity::Parser	file:
ASTPrinter	libsolidity/ast/ASTPrinter.cpp	/^ASTPrinter::ASTPrinter($/;"	f	class:dev::solidity::ASTPrinter	signature:( ASTNode const& _ast, string const& _source, GasEstimator::ASTGasConsumption const& _gasCosts )
ASTPrinter	libsolidity/ast/ASTPrinter.h	/^	ASTPrinter($/;"	p	class:dev::solidity::ASTPrinter	access:public	signature:( ASTNode const& _ast, std::string const& _source = std::string(), GasEstimator::ASTGasConsumption const& _gasCosts = GasEstimator::ASTGasConsumption() )
ASTPrinter	libsolidity/ast/ASTPrinter.h	/^class ASTPrinter: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ASTReduce	libsolidity/ast/ASTVisitor.h	/^	ASTReduce($/;"	f	class:dev::solidity::ASTReduce	access:public	signature:( std::function<bool(ASTNode const&)> _onNode, std::function<void(ASTNode const&, ASTNode const&)> _onEdge )
ASTReduce	libsolidity/ast/ASTVisitor.h	/^class ASTReduce: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ASTVisitor	libsolidity/ast/ASTVisitor.h	/^class ASTVisitor$/;"	c	namespace:dev::solidity
ASTWalker	libyul/optimiser/ASTWalker.h	/^class ASTWalker: public boost::static_visitor<>$/;"	c	namespace:yul	inherits:boost::static_visitor
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(Assignment const& _assignment)$/;"	f	class:ASTWalker	signature:(Assignment const& _assignment)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(Block const& _block)$/;"	f	class:ASTWalker	signature:(Block const& _block)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(ExpressionStatement const& _statement)$/;"	f	class:ASTWalker	signature:(ExpressionStatement const& _statement)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(ForLoop const& _for)$/;"	f	class:ASTWalker	signature:(ForLoop const& _for)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(FunctionCall const& _funCall)$/;"	f	class:ASTWalker	signature:(FunctionCall const& _funCall)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(FunctionDefinition const& _fun)$/;"	f	class:ASTWalker	signature:(FunctionDefinition const& _fun)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(FunctionalInstruction const& _instr)$/;"	f	class:ASTWalker	signature:(FunctionalInstruction const& _instr)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(If const& _if)$/;"	f	class:ASTWalker	signature:(If const& _if)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(Switch const& _switch)$/;"	f	class:ASTWalker	signature:(Switch const& _switch)
ASTWalker::operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:ASTWalker	signature:(VariableDeclaration const& _varDecl)
ASTWalker::visit	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::visit(Expression const& _e)$/;"	f	class:ASTWalker	signature:(Expression const& _e)
ASTWalker::visit	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::visit(Statement const& _st)$/;"	f	class:ASTWalker	signature:(Statement const& _st)
AbstractAssembly	libyul/backends/evm/AbstractAssembly.h	/^class AbstractAssembly$/;"	c	class:dev::solidity::Instruction	access:private
Access	libsolidity/analysis/ControlFlowGraph.h	/^		Access,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
Add	libdevcore/CommonData.h	/^	Add = 1,$/;"	m	class:dev::HexPrefix	access:private
AddMod	libsolidity/ast/Types.h	/^		AddMod, \/\/\/< ADDMOD$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Address	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
AddressType	libsolidity/ast/Types.cpp	/^AddressType::AddressType(StateMutability _stateMutability):$/;"	f	class:AddressType	signature:(StateMutability _stateMutability)
AddressType	libsolidity/ast/Types.h	/^	explicit AddressType(StateMutability _stateMutability);$/;"	p	class:dev::solidity::AddressType	access:public	signature:(StateMutability _stateMutability)
AddressType	libsolidity/ast/Types.h	/^class AddressType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
AddressType::AddressType	libsolidity/ast/Types.cpp	/^AddressType::AddressType(StateMutability _stateMutability):$/;"	f	class:AddressType	signature:(StateMutability _stateMutability)
AddressType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult AddressType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:AddressType	signature:(Token _operator, TypePointer const& _other) const
AddressType::canonicalName	libsolidity/ast/Types.cpp	/^string AddressType::canonicalName() const$/;"	f	class:AddressType	signature:() const
AddressType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult AddressType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:AddressType	signature:(Type const& _convertTo) const
AddressType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult AddressType::isImplicitlyConvertibleTo(Type const& _other) const$/;"	f	class:AddressType	signature:(Type const& _other) const
AddressType::literalValue	libsolidity/ast/Types.cpp	/^u256 AddressType::literalValue(Literal const* _literal) const$/;"	f	class:AddressType	signature:(Literal const* _literal) const
AddressType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap AddressType::nativeMembers(ContractDefinition const*) const$/;"	f	class:AddressType	signature:(ContractDefinition const*) const
AddressType::operator ==	libsolidity/ast/Types.cpp	/^bool AddressType::operator==(Type const& _other) const$/;"	f	class:AddressType	signature:(Type const& _other) const
AddressType::richIdentifier	libsolidity/ast/Types.cpp	/^string AddressType::richIdentifier() const$/;"	f	class:AddressType	signature:() const
AddressType::toString	libsolidity/ast/Types.cpp	/^string AddressType::toString(bool) const$/;"	f	class:AddressType	signature:(bool) const
AddressType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult AddressType::unaryOperatorResult(Token _operator) const$/;"	f	class:AddressType	signature:(Token _operator) const
AlignLeft	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	e	enum:dev::FixedHash::ConstructFromHashType
AlignRight	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	e	enum:dev::FixedHash::ConstructFromHashType
AnalysisSuccessful	libsolidity/interface/CompilerStack.h	/^		AnalysisSuccessful,$/;"	e	enum:dev::solidity::CompilerStack::State
AnsiColorized	libdevcore/AnsiColorized.h	/^	AnsiColorized(std::ostream& _os, bool const _enabled, std::vector<char const*>&& _formatting):$/;"	f	class:dev::AnsiColorized	access:public	signature:(std::ostream& _os, bool const _enabled, std::vector<char const*>&& _formatting)
AnsiColorized	libdevcore/AnsiColorized.h	/^class AnsiColorized$/;"	c	namespace:dev
ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule$/;"	s	namespace:__anon19	file:
ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule<Method, 1>$/;"	s	namespace:__anon19	file:
ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule<Method, 2>$/;"	s	namespace:__anon19	file:
ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule<Method, 3>$/;"	s	namespace:__anon19	file:
Array	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
ArrayKind	libsolidity/ast/Types.h	/^	enum class ArrayKind { Ordinary, Bytes, String };$/;"	c	class:dev::solidity::ArrayType	access:private
ArrayPop	libsolidity/ast/Types.h	/^		ArrayPop, \/\/\/< .pop() from a dynamically sized array in storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ArrayPush	libsolidity/ast/Types.h	/^		ArrayPush, \/\/\/< .push() to a dynamically sized array in storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ArraySort	libsolidity/formal/SolverInterface.h	/^	ArraySort(SortPointer _domain, SortPointer _range):$/;"	f	struct:dev::solidity::smt::ArraySort	access:public	signature:(SortPointer _domain, SortPointer _range)
ArraySort	libsolidity/formal/SolverInterface.h	/^struct ArraySort: public Sort$/;"	s	namespace:dev::solidity::smt	inherits:Sort
ArrayType	libsolidity/ast/Types.h	/^	ArrayType(DataLocation _location, TypePointer const& _baseType):$/;"	f	class:dev::solidity::ArrayType	access:public	signature:(DataLocation _location, TypePointer const& _baseType)
ArrayType	libsolidity/ast/Types.h	/^	ArrayType(DataLocation _location, TypePointer const& _baseType, u256 const& _length):$/;"	f	class:dev::solidity::ArrayType	access:public	signature:(DataLocation _location, TypePointer const& _baseType, u256 const& _length)
ArrayType	libsolidity/ast/Types.h	/^	explicit ArrayType(DataLocation _location, bool _isString = false):$/;"	f	class:dev::solidity::ArrayType	access:public	signature:(DataLocation _location, bool _isString = false)
ArrayType	libsolidity/ast/Types.h	/^class ArrayType: public ReferenceType$/;"	c	namespace:dev::solidity	inherits:ReferenceType
ArrayType::calldataEncodedSize	libsolidity/ast/Types.cpp	/^unsigned ArrayType::calldataEncodedSize(bool _padded) const$/;"	f	class:ArrayType	signature:(bool _padded) const
ArrayType::canBeUsedExternally	libsolidity/ast/Types.cpp	/^bool ArrayType::canBeUsedExternally(bool _inLibrary) const$/;"	f	class:ArrayType	signature:(bool _inLibrary) const
ArrayType::canonicalName	libsolidity/ast/Types.cpp	/^string ArrayType::canonicalName() const$/;"	f	class:ArrayType	signature:() const
ArrayType::copyForLocation	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::copyForLocation(DataLocation _location, bool _isPointer) const$/;"	f	class:ArrayType	signature:(DataLocation _location, bool _isPointer) const
ArrayType::decodingType	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::decodingType() const$/;"	f	class:ArrayType	signature:() const
ArrayType::encodingType	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::encodingType() const$/;"	f	class:ArrayType	signature:() const
ArrayType::interfaceType	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::interfaceType(bool _inLibrary) const$/;"	f	class:ArrayType	signature:(bool _inLibrary) const
ArrayType::isDynamicallyEncoded	libsolidity/ast/Types.cpp	/^bool ArrayType::isDynamicallyEncoded() const$/;"	f	class:ArrayType	signature:() const
ArrayType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ArrayType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ArrayType	signature:(Type const& _convertTo) const
ArrayType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ArrayType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ArrayType	signature:(Type const& _convertTo) const
ArrayType::memorySize	libsolidity/ast/Types.cpp	/^u256 ArrayType::memorySize() const$/;"	f	class:ArrayType	signature:() const
ArrayType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap ArrayType::nativeMembers(ContractDefinition const*) const$/;"	f	class:ArrayType	signature:(ContractDefinition const*) const
ArrayType::operator ==	libsolidity/ast/Types.cpp	/^bool ArrayType::operator==(Type const& _other) const$/;"	f	class:ArrayType	signature:(Type const& _other) const
ArrayType::richIdentifier	libsolidity/ast/Types.cpp	/^string ArrayType::richIdentifier() const$/;"	f	class:ArrayType	signature:() const
ArrayType::signatureInExternalFunction	libsolidity/ast/Types.cpp	/^string ArrayType::signatureInExternalFunction(bool _structsByName) const$/;"	f	class:ArrayType	signature:(bool _structsByName) const
ArrayType::sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned ArrayType::sizeOnStack() const$/;"	f	class:ArrayType	signature:() const
ArrayType::storageSize	libsolidity/ast/Types.cpp	/^u256 ArrayType::storageSize() const$/;"	f	class:ArrayType	signature:() const
ArrayType::toString	libsolidity/ast/Types.cpp	/^string ArrayType::toString(bool _short) const$/;"	f	class:ArrayType	signature:(bool _short) const
ArrayType::unlimitedCalldataEncodedSize	libsolidity/ast/Types.cpp	/^bigint ArrayType::unlimitedCalldataEncodedSize(bool _padded) const$/;"	f	class:ArrayType	signature:(bool _padded) const
ArrayType::validForCalldata	libsolidity/ast/Types.cpp	/^bool ArrayType::validForCalldata() const$/;"	f	class:ArrayType	signature:() const
ArrayTypeName	libsolidity/ast/AST.h	/^	ArrayTypeName($/;"	f	class:dev::solidity::ArrayTypeName	access:public	signature:( SourceLocation const& _location, ASTPointer<TypeName> const& _baseType, ASTPointer<Expression> const& _length )
ArrayTypeName	libsolidity/ast/AST.h	/^class ArrayTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
ArrayUtils	libsolidity/codegen/ArrayUtils.h	/^	explicit ArrayUtils(CompilerContext& _context): m_context(_context) {}$/;"	f	class:dev::solidity::ArrayUtils	access:public	signature:(CompilerContext& _context)
ArrayUtils	libsolidity/codegen/ArrayUtils.h	/^class ArrayUtils$/;"	c	namespace:dev::solidity
ArrayUtils::accessIndex	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _arrayType, bool _doBoundsCheck) const
ArrayUtils::clearArray	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::clearArray(ArrayType const& _typeIn) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _typeIn) const
ArrayUtils::clearDynamicArray	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::clearDynamicArray(ArrayType const& _type) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _type) const
ArrayUtils::clearStorageLoop	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::clearStorageLoop(TypePointer const& _type) const$/;"	f	class:ArrayUtils	signature:(TypePointer const& _type) const
ArrayUtils::convertLengthToSize	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::convertLengthToSize(ArrayType const& _arrayType, bool _pad) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _arrayType, bool _pad) const
ArrayUtils::copyArrayToMemory	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::copyArrayToMemory(ArrayType const& _sourceType, bool _padToWordBoundaries) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _sourceType, bool _padToWordBoundaries) const
ArrayUtils::copyArrayToStorage	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType const& _sourceType) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _targetType, ArrayType const& _sourceType) const
ArrayUtils::incrementByteOffset	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::incrementByteOffset(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const$/;"	f	class:ArrayUtils	signature:(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const
ArrayUtils::incrementDynamicArraySize	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::incrementDynamicArraySize(ArrayType const& _type) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _type) const
ArrayUtils::popStorageArrayElement	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::popStorageArrayElement(ArrayType const& _type) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _type) const
ArrayUtils::resizeDynamicArray	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::resizeDynamicArray(ArrayType const& _typeIn) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _typeIn) const
ArrayUtils::retrieveLength	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::retrieveLength(ArrayType const& _arrayType, unsigned _stackDepth) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _arrayType, unsigned _stackDepth) const
AsmAnalysisInfo	libyul/AsmAnalysisInfo.h	/^struct AsmAnalysisInfo$/;"	s	namespace:yul
AsmAnalyzer	libyul/AsmAnalysis.h	/^	explicit AsmAnalyzer($/;"	f	class:yul::AsmAnalyzer	access:public	signature:( AsmAnalysisInfo& _analysisInfo, langutil::ErrorReporter& _errorReporter, boost::optional<langutil::Error::Type> _errorTypeForLoose, std::shared_ptr<Dialect> _dialect, ExternalIdentifierAccess::Resolver const& _resolver = ExternalIdentifierAccess::Resolver() )
AsmAnalyzer	libyul/AsmAnalysis.h	/^class AsmAnalyzer: public boost::static_visitor<bool>$/;"	c	namespace:yul	inherits:boost::static_visitor
AsmAnalyzer::analyze	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::analyze(Block const& _block)$/;"	f	class:AsmAnalyzer	signature:(Block const& _block)
AsmAnalyzer::analyzeStrictAssertCorrect	libyul/AsmAnalysis.cpp	/^AsmAnalysisInfo AsmAnalyzer::analyzeStrictAssertCorrect($/;"	f	class:AsmAnalyzer	signature:( shared_ptr<Dialect> _dialect, Block const& _ast )
AsmAnalyzer::checkAssignment	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::checkAssignment(Identifier const& _variable, size_t _valueSize)$/;"	f	class:AsmAnalyzer	signature:(Identifier const& _variable, size_t _valueSize)
AsmAnalyzer::checkLooseFeature	libyul/AsmAnalysis.cpp	/^void AsmAnalyzer::checkLooseFeature(SourceLocation const& _location, string const& _description)$/;"	f	class:AsmAnalyzer	signature:(SourceLocation const& _location, string const& _description)
AsmAnalyzer::expectDeposit	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::expectDeposit(int _deposit, int _oldHeight, SourceLocation const& _location)$/;"	f	class:AsmAnalyzer	signature:(int _deposit, int _oldHeight, SourceLocation const& _location)
AsmAnalyzer::expectExpression	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::expectExpression(Expression const& _expr)$/;"	f	class:AsmAnalyzer	signature:(Expression const& _expr)
AsmAnalyzer::expectValidType	libyul/AsmAnalysis.cpp	/^void AsmAnalyzer::expectValidType(string const& type, SourceLocation const& _location)$/;"	f	class:AsmAnalyzer	signature:(string const& type, SourceLocation const& _location)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Assignment const& _assignment)$/;"	f	class:AsmAnalyzer	signature:(Assignment const& _assignment)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Block const& _block)$/;"	f	class:AsmAnalyzer	signature:(Block const& _block)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(ExpressionStatement const& _statement)$/;"	f	class:AsmAnalyzer	signature:(ExpressionStatement const& _statement)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(ForLoop const& _for)$/;"	f	class:AsmAnalyzer	signature:(ForLoop const& _for)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(FunctionCall const& _funCall)$/;"	f	class:AsmAnalyzer	signature:(FunctionCall const& _funCall)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(FunctionDefinition const& _funDef)$/;"	f	class:AsmAnalyzer	signature:(FunctionDefinition const& _funDef)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(FunctionalInstruction const& _instr)$/;"	f	class:AsmAnalyzer	signature:(FunctionalInstruction const& _instr)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Identifier const& _identifier)$/;"	f	class:AsmAnalyzer	signature:(Identifier const& _identifier)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(If const& _if)$/;"	f	class:AsmAnalyzer	signature:(If const& _if)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Label const& _label)$/;"	f	class:AsmAnalyzer	signature:(Label const& _label)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Literal const& _literal)$/;"	f	class:AsmAnalyzer	signature:(Literal const& _literal)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(StackAssignment const& _assignment)$/;"	f	class:AsmAnalyzer	signature:(StackAssignment const& _assignment)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Switch const& _switch)$/;"	f	class:AsmAnalyzer	signature:(Switch const& _switch)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:AsmAnalyzer	signature:(VariableDeclaration const& _varDecl)
AsmAnalyzer::operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(yul::Instruction const& _instruction)$/;"	f	class:AsmAnalyzer	signature:(yul::Instruction const& _instruction)
AsmAnalyzer::scope	libyul/AsmAnalysis.cpp	/^Scope& AsmAnalyzer::scope(Block const* _block)$/;"	f	class:AsmAnalyzer	signature:(Block const* _block)
AsmAnalyzer::warnOnInstructions	libyul/AsmAnalysis.cpp	/^void AsmAnalyzer::warnOnInstructions(solidity::Instruction _instr, SourceLocation const& _location)$/;"	f	class:AsmAnalyzer	signature:(solidity::Instruction _instr, SourceLocation const& _location)
AsmFlavour	libyul/Dialect.h	/^enum class AsmFlavour$/;"	c	namespace:yul
AsmPrinter	libyul/AsmPrinter.h	/^	explicit AsmPrinter(bool _yul = false): m_yul(_yul) {}$/;"	f	class:yul::AsmPrinter	access:public	signature:(bool _yul = false)
AsmPrinter	libyul/AsmPrinter.h	/^class AsmPrinter: public boost::static_visitor<std::string>$/;"	c	namespace:yul	inherits:boost::static_visitor
AsmPrinter::appendTypeName	libyul/AsmPrinter.cpp	/^string AsmPrinter::appendTypeName(YulString _type) const$/;"	f	class:AsmPrinter	signature:(YulString _type) const
AsmPrinter::formatTypedName	libyul/AsmPrinter.cpp	/^string AsmPrinter::formatTypedName(TypedName _variable) const$/;"	f	class:AsmPrinter	signature:(TypedName _variable) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Assignment const& _assignment) const$/;"	f	class:AsmPrinter	signature:(Assignment const& _assignment) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Block const& _block) const$/;"	f	class:AsmPrinter	signature:(Block const& _block) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(ExpressionStatement const& _statement) const$/;"	f	class:AsmPrinter	signature:(ExpressionStatement const& _statement) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(ForLoop const& _forLoop) const$/;"	f	class:AsmPrinter	signature:(ForLoop const& _forLoop) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(FunctionCall const& _functionCall) const$/;"	f	class:AsmPrinter	signature:(FunctionCall const& _functionCall) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(FunctionDefinition const& _functionDefinition) const$/;"	f	class:AsmPrinter	signature:(FunctionDefinition const& _functionDefinition) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(FunctionalInstruction const& _functionalInstruction) const$/;"	f	class:AsmPrinter	signature:(FunctionalInstruction const& _functionalInstruction) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Identifier const& _identifier) const$/;"	f	class:AsmPrinter	signature:(Identifier const& _identifier) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(If const& _if) const$/;"	f	class:AsmPrinter	signature:(If const& _if) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Label const& _label) const$/;"	f	class:AsmPrinter	signature:(Label const& _label) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Literal const& _literal) const$/;"	f	class:AsmPrinter	signature:(Literal const& _literal) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(StackAssignment const& _assignment) const$/;"	f	class:AsmPrinter	signature:(StackAssignment const& _assignment) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Switch const& _switch) const$/;"	f	class:AsmPrinter	signature:(Switch const& _switch) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(VariableDeclaration const& _variableDeclaration) const$/;"	f	class:AsmPrinter	signature:(VariableDeclaration const& _variableDeclaration) const
AsmPrinter::operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(yul::Instruction const& _instruction) const$/;"	f	class:AsmPrinter	signature:(yul::Instruction const& _instruction) const
Assembly	libevmasm/Assembly.h	/^class Assembly$/;"	c	namespace:dev::eth
Assembly	libyul/AssemblyStack.h	/^	enum class Language { Yul, Assembly, StrictAssembly };$/;"	m	class:yul::AssemblyStack::Language	access:private
Assembly::append	libevmasm/Assembly.cpp	/^AssemblyItem const& Assembly::append(AssemblyItem const& _i)$/;"	f	class:Assembly	signature:(AssemblyItem const& _i)
Assembly::append	libevmasm/Assembly.cpp	/^void Assembly::append(Assembly const& _a)$/;"	f	class:Assembly	signature:(Assembly const& _a)
Assembly::append	libevmasm/Assembly.cpp	/^void Assembly::append(Assembly const& _a, int _deposit)$/;"	f	class:Assembly	signature:(Assembly const& _a, int _deposit)
Assembly::assemble	libevmasm/Assembly.cpp	/^LinkerObject const& Assembly::assemble() const$/;"	f	class:Assembly	signature:() const
Assembly::assemblyJSON	libevmasm/Assembly.cpp	/^Json::Value Assembly::assemblyJSON(StringMap const& _sourceCodes) const$/;"	f	class:Assembly	signature:(StringMap const& _sourceCodes) const
Assembly::assemblyStream	libevmasm/Assembly.cpp	/^void Assembly::assemblyStream(ostream& _out, string const& _prefix, StringMap const& _sourceCodes) const$/;"	f	class:Assembly	signature:(ostream& _out, string const& _prefix, StringMap const& _sourceCodes) const
Assembly::assemblyString	libevmasm/Assembly.cpp	/^string Assembly::assemblyString(StringMap const& _sourceCodes) const$/;"	f	class:Assembly	signature:(StringMap const& _sourceCodes) const
Assembly::bytesRequired	libevmasm/Assembly.cpp	/^unsigned Assembly::bytesRequired(unsigned subTagSize) const$/;"	f	class:Assembly	signature:(unsigned subTagSize) const
Assembly::createJsonValue	libevmasm/Assembly.cpp	/^Json::Value Assembly::createJsonValue(string _name, int _begin, int _end, string _value, string _jumpType)$/;"	f	class:Assembly	signature:(string _name, int _begin, int _end, string _value, string _jumpType)
Assembly::injectStart	libevmasm/Assembly.cpp	/^void Assembly::injectStart(AssemblyItem const& _i)$/;"	f	class:Assembly	signature:(AssemblyItem const& _i)
Assembly::namedTag	libevmasm/Assembly.cpp	/^AssemblyItem Assembly::namedTag(string const& _name)$/;"	f	class:Assembly	signature:(string const& _name)
Assembly::newPushLibraryAddress	libevmasm/Assembly.cpp	/^AssemblyItem Assembly::newPushLibraryAddress(string const& _identifier)$/;"	f	class:Assembly	signature:(string const& _identifier)
Assembly::optimise	libevmasm/Assembly.cpp	/^Assembly& Assembly::optimise(OptimiserSettings const& _settings)$/;"	f	class:Assembly	signature:(OptimiserSettings const& _settings)
Assembly::optimise	libevmasm/Assembly.cpp	/^Assembly& Assembly::optimise(bool _enable, EVMVersion _evmVersion, bool _isCreation, size_t _runs)$/;"	f	class:Assembly	signature:(bool _enable, EVMVersion _evmVersion, bool _isCreation, size_t _runs)
Assembly::optimiseInternal	libevmasm/Assembly.cpp	/^map<u256, u256> Assembly::optimiseInternal($/;"	f	class:Assembly	signature:( OptimiserSettings const& _settings, std::set<size_t> _tagsReferencedFromOutside )
Assembly::toStringInHex	libevmasm/Assembly.cpp	/^string Assembly::toStringInHex(u256 _value)$/;"	f	class:Assembly	signature:(u256 _value)
AssemblyException	libevmasm/Exceptions.h	/^struct AssemblyException: virtual Exception {};$/;"	s	namespace:dev::eth	inherits:Exception
AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(AssemblyItem const&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const&)
AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(AssemblyItem&&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem&&)
AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(AssemblyItemType _type, u256 _data = 0, langutil::SourceLocation _location = langutil::SourceLocation()):$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItemType _type, u256 _data = 0, langutil::SourceLocation _location = langutil::SourceLocation())
AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(solidity::Instruction _i, langutil::SourceLocation _location = langutil::SourceLocation()):$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(solidity::Instruction _i, langutil::SourceLocation _location = langutil::SourceLocation())
AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(u256 _push, langutil::SourceLocation _location = langutil::SourceLocation()):$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(u256 _push, langutil::SourceLocation _location = langutil::SourceLocation())
AssemblyItem	libevmasm/AssemblyItem.h	/^class AssemblyItem$/;"	c	namespace:dev::eth
AssemblyItem::arguments	libevmasm/AssemblyItem.cpp	/^int AssemblyItem::arguments() const$/;"	f	class:AssemblyItem	signature:() const
AssemblyItem::bytesRequired	libevmasm/AssemblyItem.cpp	/^unsigned AssemblyItem::bytesRequired(unsigned _addressLength) const$/;"	f	class:AssemblyItem	signature:(unsigned _addressLength) const
AssemblyItem::canBeFunctional	libevmasm/AssemblyItem.cpp	/^bool AssemblyItem::canBeFunctional() const$/;"	f	class:AssemblyItem	signature:() const
AssemblyItem::getJumpTypeAsString	libevmasm/AssemblyItem.cpp	/^string AssemblyItem::getJumpTypeAsString() const$/;"	f	class:AssemblyItem	signature:() const
AssemblyItem::returnValues	libevmasm/AssemblyItem.cpp	/^int AssemblyItem::returnValues() const$/;"	f	class:AssemblyItem	signature:() const
AssemblyItem::setPushTagSubIdAndTag	libevmasm/AssemblyItem.cpp	/^void AssemblyItem::setPushTagSubIdAndTag(size_t _subId, size_t _tag)$/;"	f	class:AssemblyItem	signature:(size_t _subId, size_t _tag)
AssemblyItem::splitForeignPushTag	libevmasm/AssemblyItem.cpp	/^pair<size_t, size_t> AssemblyItem::splitForeignPushTag() const$/;"	f	class:AssemblyItem	signature:() const
AssemblyItem::toAssemblyText	libevmasm/AssemblyItem.cpp	/^string AssemblyItem::toAssemblyText() const$/;"	f	class:AssemblyItem	signature:() const
AssemblyItem::toSubAssemblyTag	libevmasm/AssemblyItem.cpp	/^AssemblyItem AssemblyItem::toSubAssemblyTag(size_t _subId) const$/;"	f	class:AssemblyItem	signature:(size_t _subId) const
AssemblyItemType	libevmasm/AssemblyItem.h	/^enum AssemblyItemType {$/;"	g	namespace:dev::eth
AssemblyStack	libyul/AssemblyStack.h	/^	explicit AssemblyStack(langutil::EVMVersion _evmVersion = langutil::EVMVersion(), Language _language = Language::Assembly):$/;"	f	class:yul::AssemblyStack	access:public	signature:(langutil::EVMVersion _evmVersion = langutil::EVMVersion(), Language _language = Language::Assembly)
AssemblyStack	libyul/AssemblyStack.h	/^class AssemblyStack$/;"	c	namespace:yul
AssemblyStack::analyzeParsed	libyul/AssemblyStack.cpp	/^bool AssemblyStack::analyzeParsed()$/;"	f	class:AssemblyStack	signature:()
AssemblyStack::analyzeParsed	libyul/AssemblyStack.cpp	/^bool AssemblyStack::analyzeParsed(Object& _object)$/;"	f	class:AssemblyStack	signature:(Object& _object)
AssemblyStack::assemble	libyul/AssemblyStack.cpp	/^MachineAssemblyObject AssemblyStack::assemble(Machine _machine, bool _optimize) const$/;"	f	class:AssemblyStack	signature:(Machine _machine, bool _optimize) const
AssemblyStack::compileEVM	libyul/AssemblyStack.cpp	/^void AssemblyStack::compileEVM(AbstractAssembly& _assembly, bool _evm15, bool _optimize) const$/;"	f	class:AssemblyStack	signature:(AbstractAssembly& _assembly, bool _evm15, bool _optimize) const
AssemblyStack::optimize	libyul/AssemblyStack.cpp	/^void AssemblyStack::optimize()$/;"	f	class:AssemblyStack	signature:()
AssemblyStack::optimize	libyul/AssemblyStack.cpp	/^void AssemblyStack::optimize(Object& _object)$/;"	f	class:AssemblyStack	signature:(Object& _object)
AssemblyStack::parseAndAnalyze	libyul/AssemblyStack.cpp	/^bool AssemblyStack::parseAndAnalyze(std::string const& _sourceName, std::string const& _source)$/;"	f	class:AssemblyStack	signature:(std::string const& _sourceName, std::string const& _source)
AssemblyStack::parserResult	libyul/AssemblyStack.cpp	/^shared_ptr<Object> AssemblyStack::parserResult() const$/;"	f	class:AssemblyStack	signature:() const
AssemblyStack::print	libyul/AssemblyStack.cpp	/^string AssemblyStack::print() const$/;"	f	class:AssemblyStack	signature:() const
AssemblyStack::scanner	libyul/AssemblyStack.cpp	/^Scanner const& AssemblyStack::scanner() const$/;"	f	class:AssemblyStack	signature:() const
AssemblyViewPureChecker	libsolidity/analysis/ViewPureChecker.cpp	/^	explicit AssemblyViewPureChecker(std::function<void(StateMutability, SourceLocation const&)> _reportMutability):$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(std::function<void(StateMutability, SourceLocation const&)> _reportMutability)
AssemblyViewPureChecker	libsolidity/analysis/ViewPureChecker.cpp	/^class AssemblyViewPureChecker: public boost::static_visitor<void>$/;"	c	namespace:__anon11	file:	inherits:boost::static_visitor
Assert	libsolidity/ast/Types.h	/^		Assert, \/\/\/< assert()$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Assignment	libsolidity/analysis/ControlFlowGraph.h	/^		Assignment,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
Assignment	libsolidity/ast/AST.h	/^	Assignment($/;"	f	class:dev::solidity::Assignment	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _leftHandSide, Token _assignmentOperator, ASTPointer<Expression> const& _rightHandSide )
Assignment	libsolidity/ast/AST.h	/^class Assignment: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
Assignment	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	s	namespace:yul
AssignmentCounter	libyul/optimiser/Metrics.h	/^class AssignmentCounter: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
AssignmentCounter::assignmentCount	libyul/optimiser/Metrics.cpp	/^size_t AssignmentCounter::assignmentCount(YulString _name) const$/;"	f	class:AssignmentCounter	signature:(YulString _name) const
AssignmentCounter::operator ()	libyul/optimiser/Metrics.cpp	/^void AssignmentCounter::operator()(Assignment const& _assignment)$/;"	f	class:AssignmentCounter	signature:(Assignment const& _assignment)
AssignmentRemover	libyul/optimiser/RedundantAssignEliminator.h	/^	explicit AssignmentRemover(std::set<Assignment const*> const& _toRemove):$/;"	f	class:yul::AssignmentRemover	access:public	signature:(std::set<Assignment const*> const& _toRemove)
AssignmentRemover	libyul/optimiser/RedundantAssignEliminator.h	/^class AssignmentRemover: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
AssignmentRemover::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void AssignmentRemover::operator()(Block& _block)$/;"	f	class:AssignmentRemover	signature:(Block& _block)
AssignmentToBinaryOp	liblangutil/Token.h	/^	inline Token AssignmentToBinaryOp(Token op)$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
Assignments	libyul/optimiser/NameCollector.h	/^class Assignments: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
Assignments::operator ()	libyul/optimiser/NameCollector.cpp	/^void Assignments::operator()(Assignment const& _assignment)$/;"	f	class:Assignments	signature:(Assignment const& _assignment)
BALANCE	libevmasm/Instruction.h	/^	BALANCE,			\/\/\/< get balance of the given account$/;"	m	class:dev::solidity::Instruction	access:private
BEGINDATA	libevmasm/Instruction.h	/^	BEGINDATA,          \/\/\/< begin the data section -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
BEGINSUB	libevmasm/Instruction.h	/^	BEGINSUB,           \/\/\/< set a potential jumpsub destination -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
BLACK	libdevcore/AnsiColorized.h	/^static constexpr char const* BLACK = "\\033[30m";$/;"	m	namespace:dev::formatting
BLACK_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* BLACK_BACKGROUND = "\\033[40m";$/;"	m	namespace:dev::formatting
BLOCKHASH	libevmasm/Instruction.h	/^	BLOCKHASH = 0x40,	\/\/\/< get hash of most recent complete block$/;"	m	class:dev::solidity::Instruction	access:private
BLUE	libdevcore/AnsiColorized.h	/^static constexpr char const* BLUE = "\\033[34m";$/;"	m	namespace:dev::formatting
BLUE_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* BLUE_BACKGROUND = "\\033[44m";$/;"	m	namespace:dev::formatting
BOLD	libdevcore/AnsiColorized.h	/^static constexpr char const* BOLD = "\\033[1m";$/;"	m	namespace:dev::formatting
BREAK	solse/SolidityExprTranslator.h	/^enum TerminationCode { NONE, RETURN, CONTINUE, BREAK, THROW };$/;"	e	enum:TerminationCode
BRIGHT	libdevcore/AnsiColorized.h	/^static constexpr char const* BRIGHT = BOLD;$/;"	m	namespace:dev::formatting
BYTE	libevmasm/Instruction.h	/^	BYTE,				\/\/\/< retrieve single byte from word$/;"	m	class:dev::solidity::Instruction	access:private
Balance	libevmasm/Instruction.h	/^	Balance,	\/\/ 400, Balance$/;"	m	class:dev::solidity::Instruction::Tier	access:private
BareCall	libsolidity/ast/Types.h	/^		BareCall, \/\/\/< CALL without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
BareCallCode	libsolidity/ast/Types.h	/^		BareCallCode, \/\/\/< CALLCODE without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
BareDelegateCall	libsolidity/ast/Types.h	/^		BareDelegateCall, \/\/\/< DELEGATECALL without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
BareStaticCall	libsolidity/ast/Types.h	/^		BareStaticCall, \/\/\/< STATICCALL without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Base	libevmasm/Instruction.h	/^	Base,		\/\/ 2, Quick$/;"	m	class:dev::solidity::Instruction::Tier	access:private
BasicBlock	libevmasm/ControlFlowGraph.h	/^struct BasicBlock$/;"	s	namespace:dev::eth
BinaryOperation	libsolidity/ast/AST.h	/^	BinaryOperation($/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _left, Token _operator, ASTPointer<Expression> const& _right )
BinaryOperation	libsolidity/ast/AST.h	/^class BinaryOperation: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
BinaryOperation::annotation	libsolidity/ast/AST.cpp	/^BinaryOperationAnnotation& BinaryOperation::annotation() const$/;"	f	class:BinaryOperation	signature:() const
BinaryOperationAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct BinaryOperationAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
Block	libsolidity/ast/AST.h	/^	Block($/;"	f	class:dev::solidity::Block	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, std::vector<ASTPointer<Statement>> const& _statements )
Block	libsolidity/ast/AST.h	/^class Block: public Statement, public Scopable$/;"	c	namespace:dev::solidity	inherits:Statement,Scopable
Block	libsolidity/ast/Types.h	/^		Block, \/\/\/< "block"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
Block	libyul/AsmData.h	/^struct Block { langutil::SourceLocation location; std::vector<Statement> statements; };$/;"	s	namespace:yul
BlockDeduplicator	libevmasm/BlockDeduplicator.h	/^	explicit BlockDeduplicator(AssemblyItems& _items): m_items(_items) {}$/;"	f	class:dev::eth::BlockDeduplicator	access:public	signature:(AssemblyItems& _items)
BlockDeduplicator	libevmasm/BlockDeduplicator.h	/^class BlockDeduplicator$/;"	c	namespace:dev::eth
BlockDeduplicator::BlockIterator::operator *	libevmasm/BlockDeduplicator.cpp	/^AssemblyItem const& BlockDeduplicator::BlockIterator::operator*() const$/;"	f	class:BlockDeduplicator::BlockIterator	signature:() const
BlockDeduplicator::BlockIterator::operator ++	libevmasm/BlockDeduplicator.cpp	/^BlockDeduplicator::BlockIterator& BlockDeduplicator::BlockIterator::operator++()$/;"	f	class:BlockDeduplicator::BlockIterator	signature:()
BlockDeduplicator::applyTagReplacement	libevmasm/BlockDeduplicator.cpp	/^bool BlockDeduplicator::applyTagReplacement($/;"	f	class:BlockDeduplicator	signature:( AssemblyItems& _items, map<u256, u256> const& _replacements, size_t _subId )
BlockDeduplicator::deduplicate	libevmasm/BlockDeduplicator.cpp	/^bool BlockDeduplicator::deduplicate()$/;"	f	class:BlockDeduplicator	signature:()
BlockFlattener	libyul/optimiser/BlockFlattener.h	/^class BlockFlattener: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
BlockFlattener::operator ()	libyul/optimiser/BlockFlattener.cpp	/^void BlockFlattener::operator()(Block& _block)$/;"	f	class:BlockFlattener	signature:(Block& _block)
BlockHash	libsolidity/ast/Types.h	/^		BlockHash, \/\/\/< BLOCKHASH$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
BlockId	libevmasm/ControlFlowGraph.cpp	/^BlockId::BlockId(u256 const& _id):$/;"	f	class:BlockId	signature:(u256 const& _id)
BlockId	libevmasm/ControlFlowGraph.h	/^	BlockId() { *this = invalid(); }$/;"	f	class:dev::eth::BlockId	access:public	signature:()
BlockId	libevmasm/ControlFlowGraph.h	/^	explicit BlockId(u256 const& _id);$/;"	p	class:dev::eth::BlockId	access:public	signature:(u256 const& _id)
BlockId	libevmasm/ControlFlowGraph.h	/^	explicit BlockId(unsigned _id): m_id(_id) {}$/;"	f	class:dev::eth::BlockId	access:public	signature:(unsigned _id)
BlockId	libevmasm/ControlFlowGraph.h	/^class BlockId$/;"	c	namespace:dev::eth
BlockId::BlockId	libevmasm/ControlFlowGraph.cpp	/^BlockId::BlockId(u256 const& _id):$/;"	f	class:BlockId	signature:(u256 const& _id)
BlockIterator	libevmasm/BlockDeduplicator.h	/^		BlockIterator($/;"	f	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:( AssemblyItems::const_iterator _it, AssemblyItems::const_iterator _end, AssemblyItem const* _replaceItem = nullptr, AssemblyItem const* _replaceWith = nullptr )
BlockIterator	libevmasm/BlockDeduplicator.h	/^	struct BlockIterator: std::iterator<std::forward_iterator_tag, AssemblyItem const>$/;"	s	class:dev::eth::BlockDeduplicator	inherits:std::iterator	access:private
BlockScope	libyul/optimiser/RedundantAssignEliminator.h	/^		explicit BlockScope(RedundantAssignEliminator& _rae): m_rae(_rae)$/;"	f	class:yul::RedundantAssignEliminator::BlockScope	access:public	signature:(RedundantAssignEliminator& _rae)
BlockScope	libyul/optimiser/RedundantAssignEliminator.h	/^	class BlockScope$/;"	c	class:yul::RedundantAssignEliminator	access:private
BodyCopier	libyul/optimiser/FullInliner.h	/^	BodyCopier($/;"	f	class:yul::BodyCopier	access:public	signature:( NameDispenser& _nameDispenser, std::map<YulString, YulString> const& _variableReplacements )
BodyCopier	libyul/optimiser/FullInliner.h	/^class BodyCopier: public ASTCopier$/;"	c	namespace:yul	inherits:ASTCopier
BodyCopier::operator ()	libyul/optimiser/FullInliner.cpp	/^Statement BodyCopier::operator()(FunctionDefinition const&)$/;"	f	class:BodyCopier	signature:(FunctionDefinition const&)
BodyCopier::operator ()	libyul/optimiser/FullInliner.cpp	/^Statement BodyCopier::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:BodyCopier	signature:(VariableDeclaration const& _varDecl)
BodyCopier::translateIdentifier	libyul/optimiser/FullInliner.cpp	/^YulString BodyCopier::translateIdentifier(YulString _name)$/;"	f	class:BodyCopier	signature:(YulString _name)
Bool	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
Bool	libsolidity/formal/SolverInterface.h	/^	Bool,$/;"	m	class:dev::solidity::smt::Kind	access:private
BoolType	libsolidity/ast/Types.h	/^class BoolType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
BoolType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult BoolType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:BoolType	signature:(Token _operator, TypePointer const& _other) const
BoolType::literalValue	libsolidity/ast/Types.cpp	/^u256 BoolType::literalValue(Literal const* _literal) const$/;"	f	class:BoolType	signature:(Literal const* _literal) const
BoolType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult BoolType::unaryOperatorResult(Token _operator) const$/;"	f	class:BoolType	signature:(Token _operator) const
Boolean	libyul/AsmData.h	/^enum class LiteralKind { Number, Boolean, String };$/;"	m	class:yul::LiteralKind	access:private
BreadthFirstSearch	libdevcore/Algorithms.h	/^struct BreadthFirstSearch$/;"	s	namespace:dev
Break	libsolidity/ast/AST.h	/^	explicit Break(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):$/;"	f	class:dev::solidity::Break	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _docString)
Break	libsolidity/ast/AST.h	/^class Break: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.cpp	/^ControlFlowBuilder::BreakContinueScope::BreakContinueScope($/;"	f	class:ControlFlowBuilder::BreakContinueScope	signature:( ControlFlowBuilder& _parser, CFGNode* _breakJump, CFGNode* _continueJump )
BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.h	/^		BreakContinueScope(ControlFlowBuilder& _parser, CFGNode* _breakJump, CFGNode* _continueJump);$/;"	p	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:public	signature:(ControlFlowBuilder& _parser, CFGNode* _breakJump, CFGNode* _continueJump)
BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.h	/^	class BreakContinueScope$/;"	c	class:dev::solidity::ControlFlowBuilder	access:private
BreakableStatement	libsolidity/ast/AST.h	/^	explicit BreakableStatement($/;"	f	class:dev::solidity::BreakableStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString )
BreakableStatement	libsolidity/ast/AST.h	/^class BreakableStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
BuiltinFunction	libyul/Dialect.h	/^struct BuiltinFunction$/;"	s	namespace:yul
BuiltinFunctionForEVM	libyul/backends/evm/EVMDialect.h	/^struct BuiltinFunctionForEVM: BuiltinFunction$/;"	s	namespace:yul	inherits:BuiltinFunction
ByteArrayPush	libsolidity/ast/Types.h	/^		ByteArrayPush, \/\/\/< .push() to a dynamically sized byte array in storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Bytes	libsolidity/ast/Types.h	/^	enum class ArrayKind { Ordinary, Bytes, String };$/;"	m	class:dev::solidity::ArrayType::ArrayKind	access:private
Byzantium	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
CALL	libevmasm/Instruction.h	/^	CALL,				\/\/\/< message-call into an account$/;"	m	class:dev::solidity::Instruction	access:private
CALLCODE	libevmasm/Instruction.h	/^	CALLCODE,			\/\/\/< message-call with another account's code only$/;"	m	class:dev::solidity::Instruction	access:private
CALLDATACOPY	libevmasm/Instruction.h	/^	CALLDATACOPY,		\/\/\/< copy input data in current environment to memory$/;"	m	class:dev::solidity::Instruction	access:private
CALLDATALOAD	libevmasm/Instruction.h	/^	CALLDATALOAD,		\/\/\/< get input data of current environment$/;"	m	class:dev::solidity::Instruction	access:private
CALLDATASIZE	libevmasm/Instruction.h	/^	CALLDATASIZE,		\/\/\/< get size of input data in current environment$/;"	m	class:dev::solidity::Instruction	access:private
CALLER	libevmasm/Instruction.h	/^	CALLER,				\/\/\/< get caller address$/;"	m	class:dev::solidity::Instruction	access:private
CALLVALUE	libevmasm/Instruction.h	/^	CALLVALUE,			\/\/\/< get deposited value by the instruction\/transaction responsible for this execution$/;"	m	class:dev::solidity::Instruction	access:private
CFG	libsolidity/analysis/ControlFlowGraph.h	/^	explicit CFG(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::CFG	access:public	signature:(langutil::ErrorReporter& _errorReporter)
CFG	libsolidity/analysis/ControlFlowGraph.h	/^class CFG: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
CFG::NodeContainer::newNode	libsolidity/analysis/ControlFlowGraph.cpp	/^CFGNode* CFG::NodeContainer::newNode()$/;"	f	class:CFG::NodeContainer	signature:()
CFG::accept	libsolidity/analysis/ControlFlowGraph.cpp	/^void CFG::accept(CFGConstVisitor& _visitor) const$/;"	f	class:CFG	signature:(CFGConstVisitor& _visitor) const
CFG::constructFlow	libsolidity/analysis/ControlFlowGraph.cpp	/^bool CFG::constructFlow(ASTNode const& _astRoot)$/;"	f	class:CFG	signature:(ASTNode const& _astRoot)
CFG::functionFlow	libsolidity/analysis/ControlFlowGraph.cpp	/^FunctionFlow const& CFG::functionFlow(FunctionDefinition const& _function) const$/;"	f	class:CFG	signature:(FunctionDefinition const& _function) const
CFG::visit	libsolidity/analysis/ControlFlowGraph.cpp	/^bool CFG::visit(FunctionDefinition const& _function)$/;"	f	class:CFG	signature:(FunctionDefinition const& _function)
CFGConstVisitor	libsolidity/analysis/ControlFlowGraph.h	/^class CFGConstVisitor$/;"	c	namespace:dev::solidity
CFGNode	libsolidity/analysis/ControlFlowGraph.h	/^struct CFGNode$/;"	s	namespace:dev::solidity
CODECOPY	libevmasm/Instruction.h	/^	CODECOPY,			\/\/\/< copy code running in current environment to memory$/;"	m	class:dev::solidity::Instruction	access:private
CODESIZE	libevmasm/Instruction.h	/^	CODESIZE,			\/\/\/< get size of code running in current environment$/;"	m	class:dev::solidity::Instruction	access:private
COINBASE	libevmasm/Instruction.h	/^	COINBASE,			\/\/\/< get the block's coinbase address$/;"	m	class:dev::solidity::Instruction	access:private
CONFLICTING	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
CONST	liblangutil/UndefMacros.h	32;"	d
CONTINUE	solse/SolidityExprTranslator.h	/^enum TerminationCode { NONE, RETURN, CONTINUE, BREAK, THROW };$/;"	e	enum:TerminationCode
CREATE	libevmasm/Instruction.h	/^	CREATE = 0xf0,		\/\/\/< create a new account with associated code$/;"	m	class:dev::solidity::Instruction	access:private
CREATE2	libevmasm/Instruction.h	/^	CREATE2 = 0xf5,		\/\/\/< create new account with associated code at address `sha3(0xff + sender + salt + init code) % 2**160`$/;"	m	class:dev::solidity::Instruction	access:private
CSECodeGenerator	libevmasm/CommonSubexpressionEliminator.cpp	/^CSECodeGenerator::CSECodeGenerator($/;"	f	class:CSECodeGenerator	signature:( ExpressionClasses& _expressionClasses, vector<CSECodeGenerator::StoreOperation> const& _storeOperations )
CSECodeGenerator	libevmasm/CommonSubexpressionEliminator.h	/^class CSECodeGenerator$/;"	c	namespace:dev::eth
CSECodeGenerator::CSECodeGenerator	libevmasm/CommonSubexpressionEliminator.cpp	/^CSECodeGenerator::CSECodeGenerator($/;"	f	class:CSECodeGenerator	signature:( ExpressionClasses& _expressionClasses, vector<CSECodeGenerator::StoreOperation> const& _storeOperations )
CSECodeGenerator::addDependencies	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::addDependencies(Id _c)$/;"	f	class:CSECodeGenerator	signature:(Id _c)
CSECodeGenerator::appendDup	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::appendDup(int _fromPosition, SourceLocation const& _location)$/;"	f	class:CSECodeGenerator	signature:(int _fromPosition, SourceLocation const& _location)
CSECodeGenerator::appendItem	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::appendItem(AssemblyItem const& _item)$/;"	f	class:CSECodeGenerator	signature:(AssemblyItem const& _item)
CSECodeGenerator::appendOrRemoveSwap	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::appendOrRemoveSwap(int _fromPosition, SourceLocation const& _location)$/;"	f	class:CSECodeGenerator	signature:(int _fromPosition, SourceLocation const& _location)
CSECodeGenerator::canBeRemoved	libevmasm/CommonSubexpressionEliminator.cpp	/^bool CSECodeGenerator::canBeRemoved(Id _element, Id _result, int _fromPosition)$/;"	f	class:CSECodeGenerator	signature:(Id _element, Id _result, int _fromPosition)
CSECodeGenerator::classElementPosition	libevmasm/CommonSubexpressionEliminator.cpp	/^int CSECodeGenerator::classElementPosition(Id _id) const$/;"	f	class:CSECodeGenerator	signature:(Id _id) const
CSECodeGenerator::generateClassElement	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::generateClassElement(Id _c, bool _allowSequenced)$/;"	f	class:CSECodeGenerator	signature:(Id _c, bool _allowSequenced)
CSECodeGenerator::generateCode	libevmasm/CommonSubexpressionEliminator.cpp	/^AssemblyItems CSECodeGenerator::generateCode($/;"	f	class:CSECodeGenerator	signature:( unsigned _initialSequenceNumber, int _initialStackHeight, map<int, Id> const& _initialStack, map<int, Id> const& _targetStackContents )
CSECodeGenerator::removeStackTopIfPossible	libevmasm/CommonSubexpressionEliminator.cpp	/^bool CSECodeGenerator::removeStackTopIfPossible()$/;"	f	class:CSECodeGenerator	signature:()
CVC4Interface	libsolidity/formal/CVC4Interface.cpp	/^CVC4Interface::CVC4Interface():$/;"	f	class:CVC4Interface	signature:()
CVC4Interface	libsolidity/formal/CVC4Interface.h	/^	CVC4Interface();$/;"	p	class:dev::solidity::smt::CVC4Interface	access:public	signature:()
CVC4Interface	libsolidity/formal/CVC4Interface.h	/^class CVC4Interface: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
CVC4Interface::CVC4Interface	libsolidity/formal/CVC4Interface.cpp	/^CVC4Interface::CVC4Interface():$/;"	f	class:CVC4Interface	signature:()
CVC4Interface::addAssertion	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::addAssertion(Expression const& _expr)$/;"	f	class:CVC4Interface	signature:(Expression const& _expr)
CVC4Interface::check	libsolidity/formal/CVC4Interface.cpp	/^pair<CheckResult, vector<string>> CVC4Interface::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:CVC4Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
CVC4Interface::cvc4Sort	libsolidity/formal/CVC4Interface.cpp	/^CVC4::Type CVC4Interface::cvc4Sort(Sort const& _sort)$/;"	f	class:CVC4Interface	signature:(Sort const& _sort)
CVC4Interface::cvc4Sort	libsolidity/formal/CVC4Interface.cpp	/^vector<CVC4::Type> CVC4Interface::cvc4Sort(vector<SortPointer> const& _sorts)$/;"	f	class:CVC4Interface	signature:(vector<SortPointer> const& _sorts)
CVC4Interface::declareVariable	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:CVC4Interface	signature:(string const& _name, Sort const& _sort)
CVC4Interface::pop	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::pop()$/;"	f	class:CVC4Interface	signature:()
CVC4Interface::push	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::push()$/;"	f	class:CVC4Interface	signature:()
CVC4Interface::reset	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::reset()$/;"	f	class:CVC4Interface	signature:()
CVC4Interface::toCVC4Expr	libsolidity/formal/CVC4Interface.cpp	/^CVC4::Expr CVC4Interface::toCVC4Expr(Expression const& _expr)$/;"	f	class:CVC4Interface	signature:(Expression const& _expr)
CYAN	libdevcore/AnsiColorized.h	/^static constexpr char const* CYAN = "\\033[36m";$/;"	m	namespace:dev::formatting
CYAN_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* CYAN_BACKGROUND = "\\033[46m";$/;"	m	namespace:dev::formatting
CallData	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
CallData	libsolidity/ast/Types.h	/^enum class DataLocation { Storage, CallData, Memory };$/;"	m	class:dev::solidity::DataLocation	access:private
CallableDeclaration	libsolidity/ast/AST.h	/^	CallableDeclaration($/;"	f	class:dev::solidity::CallableDeclaration	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, Declaration::Visibility _visibility, ASTPointer<ParameterList> const& _parameters, ASTPointer<ParameterList> const& _returnParameters = ASTPointer<ParameterList>() )
CallableDeclaration	libsolidity/ast/AST.h	/^class CallableDeclaration: public Declaration, public VariableScope$/;"	c	namespace:dev::solidity	inherits:Declaration,VariableScope
Case	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	s	namespace:yul
Category	libsolidity/ast/Types.h	/^	enum class Category$/;"	c	class:dev::solidity::Type	access:public
CharStream	liblangutil/CharStream.h	/^	CharStream() = default;$/;"	p	class:langutil::CharStream	access:public	signature:()
CharStream	liblangutil/CharStream.h	/^	explicit CharStream(std::string const& _source, std::string const& name):$/;"	f	class:langutil::CharStream	access:public	signature:(std::string const& _source, std::string const& name)
CharStream	liblangutil/CharStream.h	/^class CharStream$/;"	c	namespace:langutil
CharStream::advanceAndGet	liblangutil/CharStream.cpp	/^char CharStream::advanceAndGet(size_t _chars)$/;"	f	class:CharStream	signature:(size_t _chars)
CharStream::lineAtPosition	liblangutil/CharStream.cpp	/^string CharStream::lineAtPosition(int _position) const$/;"	f	class:CharStream	signature:(int _position) const
CharStream::rollback	liblangutil/CharStream.cpp	/^char CharStream::rollback(size_t _amount)$/;"	f	class:CharStream	signature:(size_t _amount)
CharStream::translatePositionToLineColumn	liblangutil/CharStream.cpp	/^tuple<int, int> CharStream::translatePositionToLineColumn(int _position) const$/;"	f	class:CharStream	signature:(int _position) const
CheckResult	libsolidity/formal/SolverInterface.h	/^enum class CheckResult$/;"	c	namespace:dev::solidity::smt
Checker	libsolidity/analysis/StaticAnalyzer.cpp	/^		Checker(FunctionDefinition const& _f) { _f.accept(*this); }$/;"	f	class:dev::solidity::ConstructorUsesAssembly::Checker	access:public	signature:(FunctionDefinition const& _f)
Checker	libsolidity/analysis/StaticAnalyzer.cpp	/^	class Checker: public ASTConstVisitor$/;"	c	class:dev::solidity::ConstructorUsesAssembly	file:	inherits:ASTConstVisitor	access:private
CodeCopyMethod	libevmasm/ConstantOptimiser.h	/^	explicit CodeCopyMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::CodeCopyMethod	access:public	signature:(Params const& _params, u256 const& _value)
CodeCopyMethod	libevmasm/ConstantOptimiser.h	/^class CodeCopyMethod: public ConstantOptimisationMethod$/;"	c	namespace:dev::eth	inherits:ConstantOptimisationMethod
CodeCopyMethod::copyRoutine	libevmasm/ConstantOptimiser.cpp	/^AssemblyItems const& CodeCopyMethod::copyRoutine()$/;"	f	class:CodeCopyMethod	signature:()
CodeCopyMethod::execute	libevmasm/ConstantOptimiser.cpp	/^AssemblyItems CodeCopyMethod::execute(Assembly& _assembly) const$/;"	f	class:CodeCopyMethod	signature:(Assembly& _assembly) const
CodeCopyMethod::gasNeeded	libevmasm/ConstantOptimiser.cpp	/^bigint CodeCopyMethod::gasNeeded() const$/;"	f	class:CodeCopyMethod	signature:() const
CodeCost	libyul/optimiser/Metrics.h	/^class CodeCost: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
CodeCost::codeCost	libyul/optimiser/Metrics.cpp	/^size_t CodeCost::codeCost(Expression const& _expr)$/;"	f	class:CodeCost	signature:(Expression const& _expr)
CodeCost::operator ()	libyul/optimiser/Metrics.cpp	/^void CodeCost::operator()(FunctionCall const& _funCall)$/;"	f	class:CodeCost	signature:(FunctionCall const& _funCall)
CodeCost::operator ()	libyul/optimiser/Metrics.cpp	/^void CodeCost::operator()(FunctionalInstruction const& _instr)$/;"	f	class:CodeCost	signature:(FunctionalInstruction const& _instr)
CodeCost::operator ()	libyul/optimiser/Metrics.cpp	/^void CodeCost::operator()(Literal const& _literal)$/;"	f	class:CodeCost	signature:(Literal const& _literal)
CodeCost::visit	libyul/optimiser/Metrics.cpp	/^void CodeCost::visit(Expression const& _expression)$/;"	f	class:CodeCost	signature:(Expression const& _expression)
CodeCost::visit	libyul/optimiser/Metrics.cpp	/^void CodeCost::visit(Statement const& _statement)$/;"	f	class:CodeCost	signature:(Statement const& _statement)
CodeGenerator	libyul/backends/evm/AsmCodeGen.h	/^class CodeGenerator$/;"	c	namespace:yul
CodeGenerator::assemble	libyul/backends/evm/AsmCodeGen.cpp	/^void CodeGenerator::assemble($/;"	f	class:CodeGenerator	signature:( Block const& _parsedData, AsmAnalysisInfo& _analysisInfo, eth::Assembly& _assembly, langutil::EVMVersion _evmVersion, ExternalIdentifierAccess const& _identifierAccess, bool _useNamedLabelsForFunctions, bool _optimize )
CodeSize	libyul/optimiser/Metrics.h	/^	CodeSize(bool _ignoreFunctions = true): m_ignoreFunctions(_ignoreFunctions) {}$/;"	f	class:yul::CodeSize	access:private	signature:(bool _ignoreFunctions = true)
CodeSize	libyul/optimiser/Metrics.h	/^class CodeSize: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
CodeSize::codeSize	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSize(Block const& _block)$/;"	f	class:CodeSize	signature:(Block const& _block)
CodeSize::codeSize	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSize(Expression const& _expression)$/;"	f	class:CodeSize	signature:(Expression const& _expression)
CodeSize::codeSize	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSize(Statement const& _statement)$/;"	f	class:CodeSize	signature:(Statement const& _statement)
CodeSize::codeSizeIncludingFunctions	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSizeIncludingFunctions(Block const& _block)$/;"	f	class:CodeSize	signature:(Block const& _block)
CodeSize::visit	libyul/optimiser/Metrics.cpp	/^void CodeSize::visit(Expression const& _expression)$/;"	f	class:CodeSize	signature:(Expression const& _expression)
CodeSize::visit	libyul/optimiser/Metrics.cpp	/^void CodeSize::visit(Statement const& _statement)$/;"	f	class:CodeSize	signature:(Statement const& _statement)
CodeTransform	libyul/backends/evm/EVMCodeTransform.cpp	/^CodeTransform::CodeTransform($/;"	f	class:CodeTransform	signature:( AbstractAssembly& _assembly, AsmAnalysisInfo& _analysisInfo, Block const& _block, bool _allowStackOpt, EVMDialect const& _dialect, bool _evm15, ExternalIdentifierAccess const& _identifierAccess, bool _useNamedLabelsForFunctions, int _stackAdjustment, shared_ptr<Context> _context )
CodeTransform	libyul/backends/evm/EVMCodeTransform.h	/^	CodeTransform($/;"	f	class:yul::CodeTransform	access:public	signature:( AbstractAssembly& _assembly, AsmAnalysisInfo& _analysisInfo, Block const& _block, EVMDialect const& _dialect, bool _allowStackOpt = false, bool _evm15 = false, ExternalIdentifierAccess const& _identifierAccess = ExternalIdentifierAccess(), bool _useNamedLabelsForFunctions = false )
CodeTransform	libyul/backends/evm/EVMCodeTransform.h	/^class CodeTransform: public boost::static_visitor<>$/;"	c	namespace:yul	inherits:boost::static_visitor
CodeTransform::CodeTransform	libyul/backends/evm/EVMCodeTransform.cpp	/^CodeTransform::CodeTransform($/;"	f	class:CodeTransform	signature:( AbstractAssembly& _assembly, AsmAnalysisInfo& _analysisInfo, Block const& _block, bool _allowStackOpt, EVMDialect const& _dialect, bool _evm15, ExternalIdentifierAccess const& _identifierAccess, bool _useNamedLabelsForFunctions, int _stackAdjustment, shared_ptr<Context> _context )
CodeTransform::checkStackHeight	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::checkStackHeight(void const* _astElement) const$/;"	f	class:CodeTransform	signature:(void const* _astElement) const
CodeTransform::decreaseReference	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::decreaseReference(YulString, Scope::Variable const& _var)$/;"	f	class:CodeTransform	signature:(YulString, Scope::Variable const& _var)
CodeTransform::deleteVariable	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::deleteVariable(Scope::Variable const& _var)$/;"	f	class:CodeTransform	signature:(Scope::Variable const& _var)
CodeTransform::expectDeposit	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::expectDeposit(int _deposit, int _oldHeight) const$/;"	f	class:CodeTransform	signature:(int _deposit, int _oldHeight) const
CodeTransform::finalizeBlock	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::finalizeBlock(Block const& _block, int blockStartStackHeight)$/;"	f	class:CodeTransform	signature:(Block const& _block, int blockStartStackHeight)
CodeTransform::freeUnusedVariables	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::freeUnusedVariables()$/;"	f	class:CodeTransform	signature:()
CodeTransform::functionEntryID	libyul/backends/evm/EVMCodeTransform.cpp	/^AbstractAssembly::LabelID CodeTransform::functionEntryID(YulString _name, Scope::Function const& _function)$/;"	f	class:CodeTransform	signature:(YulString _name, Scope::Function const& _function)
CodeTransform::generateAssignment	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::generateAssignment(Identifier const& _variableName)$/;"	f	class:CodeTransform	signature:(Identifier const& _variableName)
CodeTransform::generateMultiAssignment	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::generateMultiAssignment(vector<Identifier> const& _variableNames)$/;"	f	class:CodeTransform	signature:(vector<Identifier> const& _variableNames)
CodeTransform::labelFromIdentifier	libyul/backends/evm/EVMCodeTransform.cpp	/^AbstractAssembly::LabelID CodeTransform::labelFromIdentifier(Identifier const& _identifier)$/;"	f	class:CodeTransform	signature:(Identifier const& _identifier)
CodeTransform::labelID	libyul/backends/evm/EVMCodeTransform.cpp	/^AbstractAssembly::LabelID CodeTransform::labelID(Scope::Label const& _label)$/;"	f	class:CodeTransform	signature:(Scope::Label const& _label)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Assignment const& _assignment)$/;"	f	class:CodeTransform	signature:(Assignment const& _assignment)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Block const& _block)$/;"	f	class:CodeTransform	signature:(Block const& _block)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(ExpressionStatement const& _statement)$/;"	f	class:CodeTransform	signature:(ExpressionStatement const& _statement)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(ForLoop const& _forLoop)$/;"	f	class:CodeTransform	signature:(ForLoop const& _forLoop)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(FunctionCall const& _call)$/;"	f	class:CodeTransform	signature:(FunctionCall const& _call)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(FunctionDefinition const& _function)$/;"	f	class:CodeTransform	signature:(FunctionDefinition const& _function)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(FunctionalInstruction const& _instruction)$/;"	f	class:CodeTransform	signature:(FunctionalInstruction const& _instruction)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Identifier const& _identifier)$/;"	f	class:CodeTransform	signature:(Identifier const& _identifier)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(If const& _if)$/;"	f	class:CodeTransform	signature:(If const& _if)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Label const& _label)$/;"	f	class:CodeTransform	signature:(Label const& _label)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Literal const& _literal)$/;"	f	class:CodeTransform	signature:(Literal const& _literal)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(StackAssignment const& _assignment)$/;"	f	class:CodeTransform	signature:(StackAssignment const& _assignment)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Switch const& _switch)$/;"	f	class:CodeTransform	signature:(Switch const& _switch)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:CodeTransform	signature:(VariableDeclaration const& _varDecl)
CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(yul::Instruction const& _instruction)$/;"	f	class:CodeTransform	signature:(yul::Instruction const& _instruction)
CodeTransform::stackError	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::stackError(StackTooDeepError _error, int _targetStackHeight)$/;"	f	class:CodeTransform	signature:(StackTooDeepError _error, int _targetStackHeight)
CodeTransform::unreferenced	libyul/backends/evm/EVMCodeTransform.cpp	/^bool CodeTransform::unreferenced(Scope::Variable const& _var) const$/;"	f	class:CodeTransform	signature:(Scope::Variable const& _var) const
CodeTransform::variableHeightDiff	libyul/backends/evm/EVMCodeTransform.cpp	/^int CodeTransform::variableHeightDiff(Scope::Variable const& _var, YulString _varName, bool _forSwap)$/;"	f	class:CodeTransform	signature:(Scope::Variable const& _var, YulString _varName, bool _forSwap)
CodeTransform::visitExpression	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::visitExpression(Expression const& _expression)$/;"	f	class:CodeTransform	signature:(Expression const& _expression)
CodeTransform::visitStatements	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::visitStatements(vector<Statement> const& _statements)$/;"	f	class:CodeTransform	signature:(vector<Statement> const& _statements)
CodeTransformContext	libyul/backends/evm/EVMCodeTransform.h	/^struct CodeTransformContext$/;"	s	namespace:yul
CodegenException	libyul/Exceptions.h	/^struct CodegenException: virtual YulException {};$/;"	s	namespace:yul	inherits:YulException
CommonSubexpressionEliminator	libevmasm/CommonSubexpressionEliminator.h	/^	explicit CommonSubexpressionEliminator(KnownState const& _state): m_initialState(_state), m_state(_state) {}$/;"	f	class:dev::eth::CommonSubexpressionEliminator	access:public	signature:(KnownState const& _state)
CommonSubexpressionEliminator	libevmasm/CommonSubexpressionEliminator.h	/^class CommonSubexpressionEliminator$/;"	c	namespace:dev::eth
CommonSubexpressionEliminator	libyul/optimiser/CommonSubexpressionEliminator.h	/^	CommonSubexpressionEliminator(Dialect const& _dialect): DataFlowAnalyzer(_dialect) {}$/;"	f	class:yul::CommonSubexpressionEliminator	access:public	signature:(Dialect const& _dialect)
CommonSubexpressionEliminator	libyul/optimiser/CommonSubexpressionEliminator.h	/^class CommonSubexpressionEliminator: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
CommonSubexpressionEliminator::feedItem	libevmasm/CommonSubexpressionEliminator.cpp	/^void CommonSubexpressionEliminator::feedItem(AssemblyItem const& _item, bool _copyItem)$/;"	f	class:CommonSubexpressionEliminator	signature:(AssemblyItem const& _item, bool _copyItem)
CommonSubexpressionEliminator::getOptimizedItems	libevmasm/CommonSubexpressionEliminator.cpp	/^vector<AssemblyItem> CommonSubexpressionEliminator::getOptimizedItems()$/;"	f	class:CommonSubexpressionEliminator	signature:()
CommonSubexpressionEliminator::optimizeBreakingItem	libevmasm/CommonSubexpressionEliminator.cpp	/^void CommonSubexpressionEliminator::optimizeBreakingItem()$/;"	f	class:CommonSubexpressionEliminator	signature:()
CommonSubexpressionEliminator::visit	libyul/optimiser/CommonSubexpressionEliminator.cpp	/^void CommonSubexpressionEliminator::visit(Expression& _e)$/;"	f	class:CommonSubexpressionEliminator	signature:(Expression& _e)
CommutativeSwap	libevmasm/PeepholeOptimiser.cpp	/^struct CommutativeSwap: SimplePeepholeOptimizerMethod<CommutativeSwap, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
CompilabilityChecker	libyul/CompilabilityChecker.h	/^class CompilabilityChecker$/;"	c	namespace:yul
CompilabilityChecker::run	libyul/CompilabilityChecker.cpp	/^std::map<YulString, int> CompilabilityChecker::run(std::shared_ptr<Dialect> _dialect, Block const& _ast)$/;"	f	class:CompilabilityChecker	signature:(std::shared_ptr<Dialect> _dialect, Block const& _ast)
CompilationSuccessful	libsolidity/interface/CompilerStack.h	/^		CompilationSuccessful$/;"	e	enum:dev::solidity::CompilerStack::State
Compiler	libsolidity/codegen/Compiler.h	/^	explicit Compiler(langutil::EVMVersion _evmVersion, OptimiserSettings _optimiserSettings):$/;"	f	class:dev::solidity::Compiler	access:public	signature:(langutil::EVMVersion _evmVersion, OptimiserSettings _optimiserSettings)
Compiler	libsolidity/codegen/Compiler.h	/^class Compiler$/;"	c	namespace:dev::solidity
Compiler::compileContract	libsolidity/codegen/Compiler.cpp	/^void Compiler::compileContract($/;"	f	class:Compiler	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers, bytes const& _metadata )
Compiler::functionEntryLabel	libsolidity/codegen/Compiler.cpp	/^eth::AssemblyItem Compiler::functionEntryLabel(FunctionDefinition const& _function) const$/;"	f	class:Compiler	signature:(FunctionDefinition const& _function) const
Compiler::runtimeAssemblyPtr	libsolidity/codegen/Compiler.cpp	/^std::shared_ptr<eth::Assembly> Compiler::runtimeAssemblyPtr() const$/;"	f	class:Compiler	signature:() const
CompilerContext	libsolidity/codegen/CompilerContext.h	/^	explicit CompilerContext(langutil::EVMVersion _evmVersion, CompilerContext* _runtimeContext = nullptr):$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(langutil::EVMVersion _evmVersion, CompilerContext* _runtimeContext = nullptr)
CompilerContext	libsolidity/codegen/CompilerContext.h	/^class CompilerContext$/;"	c	namespace:dev::solidity
CompilerError	liblangutil/Exceptions.h	/^struct CompilerError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
CompilerStack	libsolidity/interface/CompilerStack.h	/^	explicit CompilerStack(ReadCallback::Callback const& _readFile = ReadCallback::Callback()):$/;"	f	class:dev::solidity::CompilerStack	access:public	signature:(ReadCallback::Callback const& _readFile = ReadCallback::Callback())
CompilerStack	libsolidity/interface/CompilerStack.h	/^class CompilerStack: boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
CompilerStack::CompilerStack::contract	libsolidity/interface/CompilerStack.cpp	/^CompilerStack::Contract const& CompilerStack::contract(string const& _contractName) const$/;"	f	class:CompilerStack::CompilerStack	signature:(string const& _contractName) const
CompilerStack::CompilerStack::source	libsolidity/interface/CompilerStack.cpp	/^CompilerStack::Source const& CompilerStack::source(string const& _sourceName) const$/;"	f	class:CompilerStack::CompilerStack	signature:(string const& _sourceName) const
CompilerStack::Source::keccak256	libsolidity/interface/CompilerStack.cpp	/^h256 const& CompilerStack::Source::keccak256() const$/;"	f	class:CompilerStack::Source	signature:() const
CompilerStack::Source::swarmHash	libsolidity/interface/CompilerStack.cpp	/^h256 const& CompilerStack::Source::swarmHash() const$/;"	f	class:CompilerStack::Source	signature:() const
CompilerStack::addSMTLib2Response	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::addSMTLib2Response(h256 const& _hash, string const& _response)$/;"	f	class:CompilerStack	signature:(h256 const& _hash, string const& _response)
CompilerStack::addSource	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::addSource(string const& _name, string const& _content, bool _isLibrary)$/;"	f	class:CompilerStack	signature:(string const& _name, string const& _content, bool _isLibrary)
CompilerStack::analyze	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::analyze()$/;"	f	class:CompilerStack	signature:()
CompilerStack::applyRemapping	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::applyRemapping(string const& _path, string const& _context)$/;"	f	class:CompilerStack	signature:(string const& _path, string const& _context)
CompilerStack::assemblyJSON	libsolidity/interface/CompilerStack.cpp	/^Json::Value CompilerStack::assemblyJSON(string const& _contractName, StringMap _sourceCodes) const$/;"	f	class:CompilerStack	signature:(string const& _contractName, StringMap _sourceCodes) const
CompilerStack::assemblyString	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::assemblyString(string const& _contractName, StringMap _sourceCodes) const$/;"	f	class:CompilerStack	signature:(string const& _contractName, StringMap _sourceCodes) const
CompilerStack::ast	libsolidity/interface/CompilerStack.cpp	/^SourceUnit const& CompilerStack::ast(string const& _sourceName) const$/;"	f	class:CompilerStack	signature:(string const& _sourceName) const
CompilerStack::compile	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::compile()$/;"	f	class:CompilerStack	signature:()
CompilerStack::compileContract	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::compileContract($/;"	f	class:CompilerStack	signature:( ContractDefinition const& _contract, map<ContractDefinition const*, shared_ptr<Compiler const>>& _otherCompilers )
CompilerStack::computeSourceMapping	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::computeSourceMapping(eth::AssemblyItems const& _items) const$/;"	f	class:CompilerStack	signature:(eth::AssemblyItems const& _items) const
CompilerStack::contractDefinition	libsolidity/interface/CompilerStack.cpp	/^ContractDefinition const& CompilerStack::contractDefinition(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
CompilerStack::contractNames	libsolidity/interface/CompilerStack.cpp	/^vector<string> CompilerStack::contractNames() const$/;"	f	class:CompilerStack	signature:() const
CompilerStack::createCBORMetadata	libsolidity/interface/CompilerStack.cpp	/^bytes CompilerStack::createCBORMetadata(string const& _metadata, bool _experimentalMode)$/;"	f	class:CompilerStack	signature:(string const& _metadata, bool _experimentalMode)
CompilerStack::createMetadata	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::createMetadata(Contract const& _contract) const$/;"	f	class:CompilerStack	signature:(Contract const& _contract) const
CompilerStack::functionEntryPoint	libsolidity/interface/CompilerStack.cpp	/^size_t CompilerStack::functionEntryPoint($/;"	f	class:CompilerStack	signature:( std::string const& _contractName, FunctionDefinition const& _function ) const
CompilerStack::gasEstimates	libsolidity/interface/CompilerStack.cpp	/^Json::Value CompilerStack::gasEstimates(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
CompilerStack::isRequestedContract	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::isRequestedContract(ContractDefinition const& _contract) const$/;"	f	class:CompilerStack	signature:(ContractDefinition const& _contract) const
CompilerStack::lastContractName	libsolidity/interface/CompilerStack.cpp	/^string const CompilerStack::lastContractName() const$/;"	f	class:CompilerStack	signature:() const
CompilerStack::link	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::link()$/;"	f	class:CompilerStack	signature:()
CompilerStack::loadMissingSources	libsolidity/interface/CompilerStack.cpp	/^StringMap CompilerStack::loadMissingSources(SourceUnit const& _ast, std::string const& _sourcePath)$/;"	f	class:CompilerStack	signature:(SourceUnit const& _ast, std::string const& _sourcePath)
CompilerStack::metadata	libsolidity/interface/CompilerStack.cpp	/^string const& CompilerStack::metadata(Contract const& _contract) const$/;"	f	class:CompilerStack	signature:(Contract const& _contract) const
CompilerStack::metadata	libsolidity/interface/CompilerStack.cpp	/^string const& CompilerStack::metadata(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
CompilerStack::methodIdentifiers	libsolidity/interface/CompilerStack.cpp	/^Json::Value CompilerStack::methodIdentifiers(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
CompilerStack::parse	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::parse()$/;"	f	class:CompilerStack	signature:()
CompilerStack::parseAndAnalyze	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::parseAndAnalyze()$/;"	f	class:CompilerStack	signature:()
CompilerStack::parseRemapping	libsolidity/interface/CompilerStack.cpp	/^boost::optional<CompilerStack::Remapping> CompilerStack::parseRemapping(string const& _remapping)$/;"	f	class:CompilerStack	signature:(string const& _remapping)
CompilerStack::positionFromSourceLocation	libsolidity/interface/CompilerStack.cpp	/^tuple<int, int, int, int> CompilerStack::positionFromSourceLocation(SourceLocation const& _sourceLocation) const$/;"	f	class:CompilerStack	signature:(SourceLocation const& _sourceLocation) const
CompilerStack::reset	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::reset(bool _keepSources)$/;"	f	class:CompilerStack	signature:(bool _keepSources)
CompilerStack::resolveImports	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::resolveImports()$/;"	f	class:CompilerStack	signature:()
CompilerStack::runtimeSourceMapping	libsolidity/interface/CompilerStack.cpp	/^string const* CompilerStack::runtimeSourceMapping(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
CompilerStack::scanner	libsolidity/interface/CompilerStack.cpp	/^Scanner const& CompilerStack::scanner(string const& _sourceName) const$/;"	f	class:CompilerStack	signature:(string const& _sourceName) const
CompilerStack::setEVMVersion	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setEVMVersion(langutil::EVMVersion _version)$/;"	f	class:CompilerStack	signature:(langutil::EVMVersion _version)
CompilerStack::setLibraries	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setLibraries(std::map<std::string, h160> const& _libraries)$/;"	f	class:CompilerStack	signature:(std::map<std::string, h160> const& _libraries)
CompilerStack::setOptimiserSettings	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setOptimiserSettings(OptimiserSettings _settings)$/;"	f	class:CompilerStack	signature:(OptimiserSettings _settings)
CompilerStack::setOptimiserSettings	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setOptimiserSettings(bool _optimize, unsigned _runs)$/;"	f	class:CompilerStack	signature:(bool _optimize, unsigned _runs)
CompilerStack::setRemappings	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setRemappings(vector<Remapping> const& _remappings)$/;"	f	class:CompilerStack	signature:(vector<Remapping> const& _remappings)
CompilerStack::sourceIndices	libsolidity/interface/CompilerStack.cpp	/^map<string, unsigned> CompilerStack::sourceIndices() const$/;"	f	class:CompilerStack	signature:() const
CompilerStack::sourceMapping	libsolidity/interface/CompilerStack.cpp	/^string const* CompilerStack::sourceMapping(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
CompilerStack::sourceNames	libsolidity/interface/CompilerStack.cpp	/^vector<string> CompilerStack::sourceNames() const$/;"	f	class:CompilerStack	signature:() const
CompilerStack::useMetadataLiteralSources	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::useMetadataLiteralSources(bool _metadataLiteralSources)$/;"	f	class:CompilerStack	signature:(bool _metadataLiteralSources)
CompilerUtils	libsolidity/codegen/CompilerUtils.h	/^	explicit CompilerUtils(CompilerContext& _context): m_context(_context) {}$/;"	f	class:dev::solidity::CompilerUtils	access:public	signature:(CompilerContext& _context)
CompilerUtils	libsolidity/codegen/CompilerUtils.h	/^class CompilerUtils$/;"	c	namespace:dev::solidity
ComputeMethod	libevmasm/ConstantOptimiser.h	/^	explicit ComputeMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::ComputeMethod	access:public	signature:(Params const& _params, u256 const& _value)
ComputeMethod	libevmasm/ConstantOptimiser.h	/^class ComputeMethod: public ConstantOptimisationMethod$/;"	c	namespace:dev::eth	inherits:ConstantOptimisationMethod
ComputeMethod::checkRepresentation	libevmasm/ConstantOptimiser.cpp	/^bool ComputeMethod::checkRepresentation(u256 const& _value, AssemblyItems const& _routine) const$/;"	f	class:ComputeMethod	signature:(u256 const& _value, AssemblyItems const& _routine) const
ComputeMethod::findRepresentation	libevmasm/ConstantOptimiser.cpp	/^AssemblyItems ComputeMethod::findRepresentation(u256 const& _value)$/;"	f	class:ComputeMethod	signature:(u256 const& _value)
ComputeMethod::gasNeeded	libevmasm/ConstantOptimiser.cpp	/^bigint ComputeMethod::gasNeeded(AssemblyItems const& _routine) const$/;"	f	class:ComputeMethod	signature:(AssemblyItems const& _routine) const
Conditional	libsolidity/ast/AST.h	/^	Conditional($/;"	f	class:dev::solidity::Conditional	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _condition, ASTPointer<Expression> const& _trueExpression, ASTPointer<Expression> const& _falseExpression )
Conditional	libsolidity/ast/AST.h	/^class Conditional: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
Conjunction	libsolidity/analysis/SemVerHandler.h	/^	struct Conjunction$/;"	s	struct:dev::solidity::SemVerMatchExpression	access:public
Constant	libyul/optimiser/SimplificationRules.h	/^	Constant,$/;"	m	class:yul::PatternKind	access:private
ConstantEvaluator	libsolidity/analysis/ConstantEvaluator.h	/^	ConstantEvaluator($/;"	f	class:dev::solidity::ConstantEvaluator	access:public	signature:( langutil::ErrorReporter& _errorReporter, size_t _newDepth = 0, std::shared_ptr<std::map<ASTNode const*, TypePointer>> _types = std::make_shared<std::map<ASTNode const*, TypePointer>>() )
ConstantEvaluator	libsolidity/analysis/ConstantEvaluator.h	/^class ConstantEvaluator: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(BinaryOperation const& _operation)$/;"	f	class:ConstantEvaluator	signature:(BinaryOperation const& _operation)
ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(Identifier const& _identifier)$/;"	f	class:ConstantEvaluator	signature:(Identifier const& _identifier)
ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(Literal const& _literal)$/;"	f	class:ConstantEvaluator	signature:(Literal const& _literal)
ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(TupleExpression const& _tuple)$/;"	f	class:ConstantEvaluator	signature:(TupleExpression const& _tuple)
ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(UnaryOperation const& _operation)$/;"	f	class:ConstantEvaluator	signature:(UnaryOperation const& _operation)
ConstantEvaluator::evaluate	libsolidity/analysis/ConstantEvaluator.cpp	/^TypePointer ConstantEvaluator::evaluate(Expression const& _expr)$/;"	f	class:ConstantEvaluator	signature:(Expression const& _expr)
ConstantEvaluator::setType	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::setType(ASTNode const& _node, TypePointer const& _type)$/;"	f	class:ConstantEvaluator	signature:(ASTNode const& _node, TypePointer const& _type)
ConstantEvaluator::type	libsolidity/analysis/ConstantEvaluator.cpp	/^TypePointer ConstantEvaluator::type(ASTNode const& _node)$/;"	f	class:ConstantEvaluator	signature:(ASTNode const& _node)
ConstantOptimisationMethod	libevmasm/ConstantOptimiser.h	/^	explicit ConstantOptimisationMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(Params const& _params, u256 const& _value)
ConstantOptimisationMethod	libevmasm/ConstantOptimiser.h	/^class ConstantOptimisationMethod$/;"	c	namespace:dev::eth
ConstantOptimisationMethod::bytesRequired	libevmasm/ConstantOptimiser.cpp	/^size_t ConstantOptimisationMethod::bytesRequired(AssemblyItems const& _items)$/;"	f	class:ConstantOptimisationMethod	signature:(AssemblyItems const& _items)
ConstantOptimisationMethod::dataGas	libevmasm/ConstantOptimiser.cpp	/^bigint ConstantOptimisationMethod::dataGas(bytes const& _data) const$/;"	f	class:ConstantOptimisationMethod	signature:(bytes const& _data) const
ConstantOptimisationMethod::optimiseConstants	libevmasm/ConstantOptimiser.cpp	/^unsigned ConstantOptimisationMethod::optimiseConstants($/;"	f	class:ConstantOptimisationMethod	signature:( bool _isCreation, size_t _runs, langutil::EVMVersion _evmVersion, Assembly& _assembly )
ConstantOptimisationMethod::replaceConstants	libevmasm/ConstantOptimiser.cpp	/^void ConstantOptimisationMethod::replaceConstants($/;"	f	class:ConstantOptimisationMethod	signature:( AssemblyItems& _items, map<u256, AssemblyItems> const& _replacements )
ConstantOptimisationMethod::simpleRunGas	libevmasm/ConstantOptimiser.cpp	/^bigint ConstantOptimisationMethod::simpleRunGas(AssemblyItems const& _items)$/;"	f	class:ConstantOptimisationMethod	signature:(AssemblyItems const& _items)
Constantinople	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
ConstructFromHashType	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	g	class:dev::FixedHash	access:public
ConstructFromStringType	libdevcore/FixedHash.h	/^	enum ConstructFromStringType { FromHex, FromBinary };$/;"	g	class:dev::FixedHash	access:public
ConstructorUsesAssembly	libsolidity/analysis/StaticAnalyzer.cpp	/^class dev::solidity::ConstructorUsesAssembly$/;"	c	class:dev::solidity	file:
ContextInfo	solse/SolidityExprTranslator.h	/^    ContextInfo(bool _debugMode=false )$/;"	f	class:ContextInfo	access:public	signature:(bool _debugMode=false )
ContextInfo	solse/SolidityExprTranslator.h	/^class ContextInfo {$/;"	c
ContextInfo::ContextInfo	solse/SolidityExprTranslator.h	/^    ContextInfo(bool _debugMode=false )$/;"	f	class:ContextInfo	access:public	signature:(bool _debugMode=false )
ContextInfo::abnormalTerminationCode	solse/SolidityExprTranslator.h	/^    TerminationCode  abnormalTerminationCode = NONE;$/;"	m	class:ContextInfo	access:public
ContextInfo::collectContext	solse/SolidityExprTranslator.cpp	/^void ContextInfo::collectContext(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records,$/;"	f	class:ContextInfo	signature:(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records, std::unordered_map<std::string, std::vector<std::string>>& local_variable_records)
ContextInfo::collectContext	solse/SolidityExprTranslator.h	/^    void collectContext(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records,$/;"	p	class:ContextInfo	access:public	signature:(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records, std::unordered_map<std::string, std::vector<std::string>>& local_variable_records)
ContextInfo::debugMode	solse/SolidityExprTranslator.h	/^    bool debugMode;$/;"	m	class:ContextInfo	access:private
ContextInfo::dev::solidity::funcScope	solse/SolidityExprTranslator.h	/^    dev::solidity::FunctionDefinition const* funcScope = nullptr;$/;"	m	class:ContextInfo::dev::solidity	access:public
ContextInfo::funcCallDepthMap	solse/SolidityExprTranslator.h	/^    std::unordered_map<std::string, int> funcCallDepthMap;$/;"	m	class:ContextInfo	access:public
ContextInfo::goHead	solse/SolidityExprTranslator.h	/^    bool goHead = true;$/;"	m	class:ContextInfo	access:public
ContextInfo::localVarValueZ3ExprMap	solse/SolidityExprTranslator.h	/^    std::unordered_map<std::string, z3::expr> localVarValueZ3ExprMap;$/;"	m	class:ContextInfo	access:public
ContextInfo::mechanism	solse/SolidityExprTranslator.h	/^    Mechanism mechanism;$/;"	m	class:ContextInfo	access:public
ContextInfo::operator =	solse/SolidityExprTranslator.h	/^    ContextInfo& operator=(const ContextInfo& other) {$/;"	f	class:ContextInfo	access:public	signature:(const ContextInfo& other)
ContextInfo::pathCondition	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> pathCondition;$/;"	m	class:ContextInfo	access:public
ContextInfo::printContext	solse/SolidityExprTranslator.cpp	/^printContext(){$/;"	f	class:ContextInfo	signature:()
ContextInfo::printContext	solse/SolidityExprTranslator.h	/^    void printContext();$/;"	p	class:ContextInfo	access:public	signature:()
ContextInfo::sol_collusion_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<std::tuple<ASTPointer<Expression const>,ASTPointer<Expression const> >> sol_collusion_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_efficient_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_efficient_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_max_exps	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_max_exps;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_min_exps	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_min_exps;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_optimal_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_optimal_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_revenue	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_revenue;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_truth_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_truth_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_utilities	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_utilities;$/;"	m	class:ContextInfo	access:public
ContextInfo::sol_winners	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_winners;$/;"	m	class:ContextInfo	access:public
ContextInfo::stateVarValueZ3ExprMap	solse/SolidityExprTranslator.h	/^    std::unordered_map<std::string, z3::expr> stateVarValueZ3ExprMap;$/;"	m	class:ContextInfo	access:public
ContextInfo::toString	solse/SolidityExprTranslator.cpp	/^toString() {$/;"	f	class:ContextInfo	signature:()
ContextInfo::toString	solse/SolidityExprTranslator.h	/^    std::string toString();$/;"	p	class:ContextInfo	access:public	signature:()
ContextInfo::z3_collusion_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr, z3::expr,z3::expr, z3::expr, z3::expr> > z3_collusion_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_efficient_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr, ASTPointer<Expression const >, ASTPointer<Expression const>> > z3_efficient_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_efficient_expectation_register	solse/SolidityExprTranslator.h	/^    std::map<std::pair<std::string, std::string>, z3::expr> z3_efficient_expectation_register;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_max_exps	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_max_exps;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_min_exps	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_min_exps;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_optimal_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr,ASTPointer<Expression const >, ASTPointer<Expression const> > > z3_optimal_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_optimal_payment_register	solse/SolidityExprTranslator.h	/^    std::map<std::pair<std::string, std::string>, z3::expr> z3_optimal_payment_register;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_revenue	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_revenue;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_truth_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr, z3::expr, z3::expr> > z3_truth_check_exprs;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_utilities	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_utilities;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_validate_outcome_postconditions	solse/SolidityExprTranslator.h	/^    std::map<std::string, z3::expr> z3_validate_outcome_postconditions;$/;"	m	class:ContextInfo	access:public
ContextInfo::z3_winners	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_winners;$/;"	m	class:ContextInfo	access:public
Continue	libsolidity/ast/AST.h	/^	explicit Continue(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):$/;"	f	class:dev::solidity::Continue	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _docString)
Continue	libsolidity/ast/AST.h	/^class Continue: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
Contract	libsolidity/ast/AST.h	/^	enum class ContractKind { Interface, Contract, Library };$/;"	m	class:dev::solidity::ContractDefinition::ContractKind	access:private
Contract	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
Contract	libsolidity/interface/CompilerStack.h	/^	struct Contract$/;"	s	class:dev::solidity::CompilerStack	access:private
ContractCompiler	libsolidity/codegen/ContractCompiler.h	/^	explicit ContractCompiler($/;"	f	class:dev::solidity::ContractCompiler	access:public	signature:( ContractCompiler* _runtimeCompiler, CompilerContext& _context, OptimiserSettings _optimiserSettings )
ContractCompiler	libsolidity/codegen/ContractCompiler.h	/^class ContractCompiler: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ContractCompiler::appendBaseConstructor	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendBaseConstructor(FunctionDefinition const& _constructor)$/;"	f	class:ContractCompiler	signature:(FunctionDefinition const& _constructor)
ContractCompiler::appendCallValueCheck	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendCallValueCheck()$/;"	f	class:ContractCompiler	signature:()
ContractCompiler::appendConstructor	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendConstructor(FunctionDefinition const& _constructor)$/;"	f	class:ContractCompiler	signature:(FunctionDefinition const& _constructor)
ContractCompiler::appendDelegatecallCheck	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendDelegatecallCheck()$/;"	f	class:ContractCompiler	signature:()
ContractCompiler::appendFunctionSelector	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendFunctionSelector(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
ContractCompiler::appendInitAndConstructorCode	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendInitAndConstructorCode(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
ContractCompiler::appendInternalSelector	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendInternalSelector($/;"	f	class:ContractCompiler	signature:( map<FixedHash<4>, eth::AssemblyItem const> const& _entryPoints, vector<FixedHash<4>> const& _ids, eth::AssemblyItem const& _notFoundTag, size_t _runs )
ContractCompiler::appendMissingFunctions	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendMissingFunctions()$/;"	f	class:ContractCompiler	signature:()
ContractCompiler::appendModifierOrFunctionCode	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendModifierOrFunctionCode()$/;"	f	class:ContractCompiler	signature:()
ContractCompiler::appendReturnValuePacker	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary)$/;"	f	class:ContractCompiler	signature:(TypePointers const& _typeParameters, bool _isLibrary)
ContractCompiler::appendStackVariableInitialisation	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendStackVariableInitialisation(VariableDeclaration const& _variable)$/;"	f	class:ContractCompiler	signature:(VariableDeclaration const& _variable)
ContractCompiler::compileConstructor	libsolidity/codegen/ContractCompiler.cpp	/^size_t ContractCompiler::compileConstructor($/;"	f	class:ContractCompiler	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers )
ContractCompiler::compileContract	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::compileContract($/;"	f	class:ContractCompiler	signature:( ContractDefinition const& _contract, map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers )
ContractCompiler::compileExpression	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::compileExpression(Expression const& _expression, TypePointer const& _targetType)$/;"	f	class:ContractCompiler	signature:(Expression const& _expression, TypePointer const& _targetType)
ContractCompiler::deployLibrary	libsolidity/codegen/ContractCompiler.cpp	/^size_t ContractCompiler::deployLibrary(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
ContractCompiler::endVisit	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::endVisit(Block const& _block)$/;"	f	class:ContractCompiler	signature:(Block const& _block)
ContractCompiler::initializeContext	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::initializeContext($/;"	f	class:ContractCompiler	signature:( ContractDefinition const& _contract, map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers )
ContractCompiler::initializeStateVariables	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::initializeStateVariables(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
ContractCompiler::packIntoContractCreator	libsolidity/codegen/ContractCompiler.cpp	/^size_t ContractCompiler::packIntoContractCreator(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
ContractCompiler::popScopedVariables	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::popScopedVariables(ASTNode const* _node)$/;"	f	class:ContractCompiler	signature:(ASTNode const* _node)
ContractCompiler::registerStateVariables	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::registerStateVariables(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
ContractCompiler::storeStackHeight	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::storeStackHeight(ASTNode const* _node)$/;"	f	class:ContractCompiler	signature:(ASTNode const* _node)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Block const& _block)$/;"	f	class:ContractCompiler	signature:(Block const& _block)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Break const& _breakStatement)$/;"	f	class:ContractCompiler	signature:(Break const& _breakStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Continue const& _continueStatement)$/;"	f	class:ContractCompiler	signature:(Continue const& _continueStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(EmitStatement const& _emit)$/;"	f	class:ContractCompiler	signature:(EmitStatement const& _emit)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(ExpressionStatement const& _expressionStatement)$/;"	f	class:ContractCompiler	signature:(ExpressionStatement const& _expressionStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(ForStatement const& _forStatement)$/;"	f	class:ContractCompiler	signature:(ForStatement const& _forStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(FunctionDefinition const& _function)$/;"	f	class:ContractCompiler	signature:(FunctionDefinition const& _function)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(IfStatement const& _ifStatement)$/;"	f	class:ContractCompiler	signature:(IfStatement const& _ifStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:ContractCompiler	signature:(InlineAssembly const& _inlineAssembly)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(PlaceholderStatement const& _placeholderStatement)$/;"	f	class:ContractCompiler	signature:(PlaceholderStatement const& _placeholderStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Return const& _return)$/;"	f	class:ContractCompiler	signature:(Return const& _return)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Throw const&)$/;"	f	class:ContractCompiler	signature:(Throw const&)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(VariableDeclaration const& _variableDeclaration)$/;"	f	class:ContractCompiler	signature:(VariableDeclaration const& _variableDeclaration)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(VariableDeclarationStatement const& _variableDeclarationStatement)$/;"	f	class:ContractCompiler	signature:(VariableDeclarationStatement const& _variableDeclarationStatement)
ContractCompiler::visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(WhileStatement const& _whileStatement)$/;"	f	class:ContractCompiler	signature:(WhileStatement const& _whileStatement)
ContractDefinition	libsolidity/ast/AST.h	/^	ContractDefinition($/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, ASTPointer<ASTString> const& _documentation, std::vector<ASTPointer<InheritanceSpecifier>> const& _baseContracts, std::vector<ASTPointer<ASTNode>> const& _subNodes, ContractKind _contractKind = ContractKind::Contract )
ContractDefinition	libsolidity/ast/AST.h	/^class ContractDefinition: public Declaration, public Documented$/;"	c	namespace:dev::solidity	inherits:Declaration,Documented
ContractDefinition::annotation	libsolidity/ast/AST.cpp	/^ContractDefinitionAnnotation& ContractDefinition::annotation() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::canBeDeployed	libsolidity/ast/AST.cpp	/^bool ContractDefinition::canBeDeployed() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::constructor	libsolidity/ast/AST.cpp	/^FunctionDefinition const* ContractDefinition::constructor() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::constructorIsPublic	libsolidity/ast/AST.cpp	/^bool ContractDefinition::constructorIsPublic() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::fallbackFunction	libsolidity/ast/AST.cpp	/^FunctionDefinition const* ContractDefinition::fallbackFunction() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::inheritableMembers	libsolidity/ast/AST.cpp	/^vector<Declaration const*> const& ContractDefinition::inheritableMembers() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::interfaceEvents	libsolidity/ast/AST.cpp	/^vector<EventDefinition const*> const& ContractDefinition::interfaceEvents() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::interfaceFunctionList	libsolidity/ast/AST.cpp	/^vector<pair<FixedHash<4>, FunctionTypePointer>> const& ContractDefinition::interfaceFunctionList() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::interfaceFunctions	libsolidity/ast/AST.cpp	/^map<FixedHash<4>, FunctionTypePointer> ContractDefinition::interfaceFunctions() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinition::type	libsolidity/ast/AST.cpp	/^TypePointer ContractDefinition::type() const$/;"	f	class:ContractDefinition	signature:() const
ContractDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ContractDefinitionAnnotation: TypeDeclarationAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:TypeDeclarationAnnotation,DocumentedAnnotation
ContractKind	libsolidity/ast/AST.h	/^	enum class ContractKind { Interface, Contract, Library };$/;"	c	class:dev::solidity::ContractDefinition	access:public
ContractLevelChecker	libsolidity/analysis/ContractLevelChecker.h	/^	explicit ContractLevelChecker(langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::ContractLevelChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter)
ContractLevelChecker	libsolidity/analysis/ContractLevelChecker.h	/^class ContractLevelChecker$/;"	c	namespace:dev::solidity
ContractLevelChecker::annotateBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::annotateBaseConstructorArguments($/;"	f	class:ContractLevelChecker	signature:( ContractDefinition const& _currentContract, FunctionDefinition const* _baseConstructor, ASTNode const* _argumentNode )
ContractLevelChecker::check	libsolidity/analysis/ContractLevelChecker.cpp	/^bool ContractLevelChecker::check(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkAbstractFunctions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkAbstractFunctions(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkBaseABICompatibility	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkBaseABICompatibility(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkBaseConstructorArguments(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkConstructor	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkConstructor(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkDuplicateEvents	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkDuplicateEvents(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkDuplicateFunctions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkDuplicateFunctions(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkExternalTypeClashes	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkExternalTypeClashes(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkFallbackFunction	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkFallbackFunction(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkFunctionOverride	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkFunctionOverride(FunctionDefinition const& _function, FunctionDefinition const& _super)$/;"	f	class:ContractLevelChecker	signature:(FunctionDefinition const& _function, FunctionDefinition const& _super)
ContractLevelChecker::checkHashCollisions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkHashCollisions(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkIllegalOverrides	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkIllegalOverrides(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::checkLibraryRequirements	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkLibraryRequirements(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
ContractLevelChecker::findDuplicateDefinitions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::findDuplicateDefinitions(map<string, vector<T>> const& _definitions, string _message)$/;"	f	class:ContractLevelChecker	signature:(map<string, vector<T>> const& _definitions, string _message)
ContractLevelChecker::overrideError	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::overrideError(FunctionDefinition const& function, FunctionDefinition const& super, string message)$/;"	f	class:ContractLevelChecker	signature:(FunctionDefinition const& function, FunctionDefinition const& super, string message)
ContractType	libsolidity/ast/Types.h	/^	explicit ContractType(ContractDefinition const& _contract, bool _super = false):$/;"	f	class:dev::solidity::ContractType	access:public	signature:(ContractDefinition const& _contract, bool _super = false)
ContractType	libsolidity/ast/Types.h	/^class ContractType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
ContractType::canonicalName	libsolidity/ast/Types.cpp	/^string ContractType::canonicalName() const$/;"	f	class:ContractType	signature:() const
ContractType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ContractType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ContractType	signature:(Type const& _convertTo) const
ContractType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ContractType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ContractType	signature:(Type const& _convertTo) const
ContractType::isPayable	libsolidity/ast/Types.cpp	/^bool ContractType::isPayable() const$/;"	f	class:ContractType	signature:() const
ContractType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap ContractType::nativeMembers(ContractDefinition const* _contract) const$/;"	f	class:ContractType	signature:(ContractDefinition const* _contract) const
ContractType::newExpressionType	libsolidity/ast/Types.cpp	/^shared_ptr<FunctionType const> const& ContractType::newExpressionType() const$/;"	f	class:ContractType	signature:() const
ContractType::operator ==	libsolidity/ast/Types.cpp	/^bool ContractType::operator==(Type const& _other) const$/;"	f	class:ContractType	signature:(Type const& _other) const
ContractType::richIdentifier	libsolidity/ast/Types.cpp	/^string ContractType::richIdentifier() const$/;"	f	class:ContractType	signature:() const
ContractType::stateVariables	libsolidity/ast/Types.cpp	/^vector<tuple<VariableDeclaration const*, u256, unsigned>> ContractType::stateVariables() const$/;"	f	class:ContractType	signature:() const
ContractType::toString	libsolidity/ast/Types.cpp	/^string ContractType::toString(bool) const$/;"	f	class:ContractType	signature:(bool) const
ContractType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult ContractType::unaryOperatorResult(Token _operator) const$/;"	f	class:ContractType	signature:(Token _operator) const
ControlFlowAnalyzer	libsolidity/analysis/ControlFlowAnalyzer.h	/^	explicit ControlFlowAnalyzer(CFG const& _cfg, langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::ControlFlowAnalyzer	access:public	signature:(CFG const& _cfg, langutil::ErrorReporter& _errorReporter)
ControlFlowAnalyzer	libsolidity/analysis/ControlFlowAnalyzer.h	/^class ControlFlowAnalyzer: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ControlFlowAnalyzer::analyze	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^bool ControlFlowAnalyzer::analyze(ASTNode const& _astRoot)$/;"	f	class:ControlFlowAnalyzer	signature:(ASTNode const& _astRoot)
ControlFlowAnalyzer::checkUninitializedAccess	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^void ControlFlowAnalyzer::checkUninitializedAccess(CFGNode const* _entry, CFGNode const* _exit) const$/;"	f	class:ControlFlowAnalyzer	signature:(CFGNode const* _entry, CFGNode const* _exit) const
ControlFlowAnalyzer::checkUnreachable	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^void ControlFlowAnalyzer::checkUnreachable(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const$/;"	f	class:ControlFlowAnalyzer	signature:(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const
ControlFlowAnalyzer::visit	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^bool ControlFlowAnalyzer::visit(FunctionDefinition const& _function)$/;"	f	class:ControlFlowAnalyzer	signature:(FunctionDefinition const& _function)
ControlFlowBuilder	libsolidity/analysis/ControlFlowBuilder.cpp	/^ControlFlowBuilder::ControlFlowBuilder(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow):$/;"	f	class:ControlFlowBuilder	signature:(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow)
ControlFlowBuilder	libsolidity/analysis/ControlFlowBuilder.h	/^	explicit ControlFlowBuilder(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow)
ControlFlowBuilder	libsolidity/analysis/ControlFlowBuilder.h	/^class ControlFlowBuilder: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ControlFlowBuilder::BreakContinueScope::BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.cpp	/^ControlFlowBuilder::BreakContinueScope::BreakContinueScope($/;"	f	class:ControlFlowBuilder::BreakContinueScope	signature:( ControlFlowBuilder& _parser, CFGNode* _breakJump, CFGNode* _continueJump )
ControlFlowBuilder::BreakContinueScope::~BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.cpp	/^ControlFlowBuilder::BreakContinueScope::~BreakContinueScope()$/;"	f	class:ControlFlowBuilder::BreakContinueScope	signature:()
ControlFlowBuilder::ControlFlowBuilder	libsolidity/analysis/ControlFlowBuilder.cpp	/^ControlFlowBuilder::ControlFlowBuilder(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow):$/;"	f	class:ControlFlowBuilder	signature:(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow)
ControlFlowBuilder::appendControlFlow	libsolidity/analysis/ControlFlowBuilder.cpp	/^void ControlFlowBuilder::appendControlFlow(ASTNode const& _node)$/;"	f	class:ControlFlowBuilder	signature:(ASTNode const& _node)
ControlFlowBuilder::connect	libsolidity/analysis/ControlFlowBuilder.cpp	/^void ControlFlowBuilder::connect(CFGNode* _from, CFGNode* _to)$/;"	f	class:ControlFlowBuilder	signature:(CFGNode* _from, CFGNode* _to)
ControlFlowBuilder::createFlow	libsolidity/analysis/ControlFlowBuilder.cpp	/^CFGNode* ControlFlowBuilder::createFlow(CFGNode* _entry, ASTNode const& _node)$/;"	f	class:ControlFlowBuilder	signature:(CFGNode* _entry, ASTNode const& _node)
ControlFlowBuilder::createFunctionFlow	libsolidity/analysis/ControlFlowBuilder.cpp	/^unique_ptr<FunctionFlow> ControlFlowBuilder::createFunctionFlow($/;"	f	class:ControlFlowBuilder	signature:( CFG::NodeContainer& _nodeContainer, FunctionDefinition const& _function )
ControlFlowBuilder::createLabelHere	libsolidity/analysis/ControlFlowBuilder.cpp	/^CFGNode* ControlFlowBuilder::createLabelHere()$/;"	f	class:ControlFlowBuilder	signature:()
ControlFlowBuilder::newLabel	libsolidity/analysis/ControlFlowBuilder.cpp	/^CFGNode* ControlFlowBuilder::newLabel()$/;"	f	class:ControlFlowBuilder	signature:()
ControlFlowBuilder::placeAndConnectLabel	libsolidity/analysis/ControlFlowBuilder.cpp	/^void ControlFlowBuilder::placeAndConnectLabel(CFGNode* _node)$/;"	f	class:ControlFlowBuilder	signature:(CFGNode* _node)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(BinaryOperation const& _operation)$/;"	f	class:ControlFlowBuilder	signature:(BinaryOperation const& _operation)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Break const& _break)$/;"	f	class:ControlFlowBuilder	signature:(Break const& _break)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Conditional const& _conditional)$/;"	f	class:ControlFlowBuilder	signature:(Conditional const& _conditional)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Continue const& _continue)$/;"	f	class:ControlFlowBuilder	signature:(Continue const& _continue)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(ForStatement const& _forStatement)$/;"	f	class:ControlFlowBuilder	signature:(ForStatement const& _forStatement)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(FunctionCall const& _functionCall)$/;"	f	class:ControlFlowBuilder	signature:(FunctionCall const& _functionCall)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(FunctionDefinition const& _functionDefinition)$/;"	f	class:ControlFlowBuilder	signature:(FunctionDefinition const& _functionDefinition)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(FunctionTypeName const& _functionTypeName)$/;"	f	class:ControlFlowBuilder	signature:(FunctionTypeName const& _functionTypeName)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Identifier const& _identifier)$/;"	f	class:ControlFlowBuilder	signature:(Identifier const& _identifier)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(IfStatement const& _ifStatement)$/;"	f	class:ControlFlowBuilder	signature:(IfStatement const& _ifStatement)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:ControlFlowBuilder	signature:(InlineAssembly const& _inlineAssembly)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(ModifierInvocation const& _modifierInvocation)$/;"	f	class:ControlFlowBuilder	signature:(ModifierInvocation const& _modifierInvocation)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(PlaceholderStatement const&)$/;"	f	class:ControlFlowBuilder	signature:(PlaceholderStatement const&)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Return const& _return)$/;"	f	class:ControlFlowBuilder	signature:(Return const& _return)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Throw const& _throw)$/;"	f	class:ControlFlowBuilder	signature:(Throw const& _throw)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(VariableDeclaration const& _variableDeclaration)$/;"	f	class:ControlFlowBuilder	signature:(VariableDeclaration const& _variableDeclaration)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(VariableDeclarationStatement const& _variableDeclarationStatement)$/;"	f	class:ControlFlowBuilder	signature:(VariableDeclarationStatement const& _variableDeclarationStatement)
ControlFlowBuilder::visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(WhileStatement const& _whileStatement)$/;"	f	class:ControlFlowBuilder	signature:(WhileStatement const& _whileStatement)
ControlFlowBuilder::visitNode	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visitNode(ASTNode const& _node)$/;"	f	class:ControlFlowBuilder	signature:(ASTNode const& _node)
ControlFlowGraph	libevmasm/ControlFlowGraph.h	/^	explicit ControlFlowGraph(AssemblyItems const& _items, bool _joinKnowledge = true):$/;"	f	class:dev::eth::ControlFlowGraph	access:public	signature:(AssemblyItems const& _items, bool _joinKnowledge = true)
ControlFlowGraph	libevmasm/ControlFlowGraph.h	/^class ControlFlowGraph$/;"	c	namespace:dev::eth
ControlFlowGraph::findLargestTag	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::findLargestTag()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::gatherKnowledge	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::gatherKnowledge()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::generateNewId	libevmasm/ControlFlowGraph.cpp	/^BlockId ControlFlowGraph::generateNewId()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::optimisedBlocks	libevmasm/ControlFlowGraph.cpp	/^BasicBlocks ControlFlowGraph::optimisedBlocks()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::rebuildCode	libevmasm/ControlFlowGraph.cpp	/^BasicBlocks ControlFlowGraph::rebuildCode()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::removeUnusedBlocks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::removeUnusedBlocks()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::resolveNextLinks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::resolveNextLinks()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::setPrevLinks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::setPrevLinks()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowGraph::splitBlocks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::splitBlocks()$/;"	f	class:ControlFlowGraph	signature:()
ControlFlowPrinter	libsolidity/analysis/ControlFlowPrinter.h	/^	explicit ControlFlowPrinter(CFG const& _cfg):$/;"	f	class:dev::solidity::ControlFlowPrinter	access:public	signature:(CFG const& _cfg)
ControlFlowPrinter	libsolidity/analysis/ControlFlowPrinter.h	/^class ControlFlowPrinter: private CFGConstVisitor$/;"	c	namespace:dev::solidity	inherits:CFGConstVisitor
ControlFlowPrinter::print	libsolidity/analysis/ControlFlowPrinter.cpp	/^void ControlFlowPrinter::print(ostream& _stream)$/;"	f	class:ControlFlowPrinter	signature:(ostream& _stream)
ControlFlowPrinter::printFunctionFlow	libsolidity/analysis/ControlFlowPrinter.cpp	/^void ControlFlowPrinter::printFunctionFlow(CFGNode const* _entry) const$/;"	f	class:ControlFlowPrinter	signature:(CFGNode const* _entry) const
ControlFlowPrinter::visit	libsolidity/analysis/ControlFlowPrinter.cpp	/^bool ControlFlowPrinter::visit(FunctionDefinition const& _function)$/;"	f	class:ControlFlowPrinter	signature:(FunctionDefinition const& _function)
ControlFlowPrinter::writeLine	libsolidity/analysis/ControlFlowPrinter.cpp	/^void ControlFlowPrinter::writeLine(string const& _line) const$/;"	f	class:ControlFlowPrinter	signature:(string const& _line) const
Creation	libsolidity/ast/Types.h	/^		Creation, \/\/\/< external call using CREATE$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
CycleDetector	libdevcore/Algorithms.h	/^	explicit CycleDetector(Visitor _visit):$/;"	f	class:dev::CycleDetector	access:public	signature:(Visitor _visit)
CycleDetector	libdevcore/Algorithms.h	/^class CycleDetector$/;"	c	namespace:dev
DELEGATECALL	libevmasm/Instruction.h	/^	DELEGATECALL,		\/\/\/< like CALLCODE but keeps caller's value and sender$/;"	m	class:dev::solidity::Instruction	access:private
DELETE	liblangutil/UndefMacros.h	28;"	d
DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	/^DEV_SIMPLE_EXCEPTION(BadHexCharacter);$/;"	p	namespace:dev	signature:(BadHexCharacter)
DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	/^DEV_SIMPLE_EXCEPTION(FileError);$/;"	p	namespace:dev	signature:(FileError)
DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	/^DEV_SIMPLE_EXCEPTION(InvalidAddress);$/;"	p	namespace:dev	signature:(InvalidAddress)
DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	45;"	d
DEV_SIMPLE_EXCEPTION	libdevcore/IndentedWriter.h	/^DEV_SIMPLE_EXCEPTION(IndentedWriterError);$/;"	p	namespace:dev	signature:(IndentedWriterError)
DEV_SIMPLE_EXCEPTION	libdevcore/Whiskers.h	/^DEV_SIMPLE_EXCEPTION(WhiskersError);$/;"	p	namespace:dev	signature:(WhiskersError)
DEV_SIMPLE_EXCEPTION	libevmasm/Instruction.h	/^DEV_SIMPLE_EXCEPTION(InvalidDeposit);$/;"	p	namespace:dev::solidity	signature:(InvalidDeposit)
DEV_SIMPLE_EXCEPTION	libevmasm/Instruction.h	/^DEV_SIMPLE_EXCEPTION(InvalidOpcode);$/;"	p	namespace:dev::solidity	signature:(InvalidOpcode)
DEV_SIMPLE_EXCEPTION	libsolidity/formal/SolverInterface.h	/^DEV_SIMPLE_EXCEPTION(SolverError);$/;"	p	namespace:dev::solidity::smt	signature:(SolverError)
DIFFICULTY	libevmasm/Instruction.h	/^	DIFFICULTY,			\/\/\/< get the block's difficulty$/;"	m	class:dev::solidity::Instruction	access:private
DIV	libevmasm/Instruction.h	/^	DIV,				\/\/\/< integer division operation$/;"	m	class:dev::solidity::Instruction	access:private
DUP1	libevmasm/Instruction.h	/^	DUP1 = 0x80,		\/\/\/< copies the highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP10	libevmasm/Instruction.h	/^	DUP10,				\/\/\/< copies the 10th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP11	libevmasm/Instruction.h	/^	DUP11,				\/\/\/< copies the 11th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP12	libevmasm/Instruction.h	/^	DUP12,				\/\/\/< copies the 12th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP13	libevmasm/Instruction.h	/^	DUP13,				\/\/\/< copies the 13th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP14	libevmasm/Instruction.h	/^	DUP14,				\/\/\/< copies the 14th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP15	libevmasm/Instruction.h	/^	DUP15,				\/\/\/< copies the 15th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP16	libevmasm/Instruction.h	/^	DUP16,				\/\/\/< copies the 16th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP2	libevmasm/Instruction.h	/^	DUP2,				\/\/\/< copies the second highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP3	libevmasm/Instruction.h	/^	DUP3,				\/\/\/< copies the third highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP4	libevmasm/Instruction.h	/^	DUP4,				\/\/\/< copies the 4th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP5	libevmasm/Instruction.h	/^	DUP5,				\/\/\/< copies the 5th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP6	libevmasm/Instruction.h	/^	DUP6,				\/\/\/< copies the 6th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP7	libevmasm/Instruction.h	/^	DUP7,				\/\/\/< copies the 7th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP8	libevmasm/Instruction.h	/^	DUP8,				\/\/\/< copies the 8th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
DUP9	libevmasm/Instruction.h	/^	DUP9,				\/\/\/< copies the 9th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
Data	libyul/Object.h	/^	Data(YulString _name, dev::bytes _data): data(std::move(_data)) { name = _name; }$/;"	f	struct:yul::Data	access:public	signature:(YulString _name, dev::bytes _data)
Data	libyul/Object.h	/^struct Data: ObjectNode$/;"	s	namespace:yul	inherits:ObjectNode
Data::toString	libyul/Object.cpp	/^string Data::toString(bool) const$/;"	f	class:Data	signature:(bool) const
DataFlowAnalyzer	libyul/optimiser/DataFlowAnalyzer.h	/^	explicit DataFlowAnalyzer(Dialect const& _dialect): m_dialect(_dialect) {}$/;"	f	class:yul::DataFlowAnalyzer	access:public	signature:(Dialect const& _dialect)
DataFlowAnalyzer	libyul/optimiser/DataFlowAnalyzer.h	/^class DataFlowAnalyzer: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
DataFlowAnalyzer::clearValues	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::clearValues(set<YulString> _variables)$/;"	f	class:DataFlowAnalyzer	signature:(set<YulString> _variables)
DataFlowAnalyzer::handleAssignment	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::handleAssignment(set<YulString> const& _variables, Expression* _value)$/;"	f	class:DataFlowAnalyzer	signature:(set<YulString> const& _variables, Expression* _value)
DataFlowAnalyzer::inScope	libyul/optimiser/DataFlowAnalyzer.cpp	/^bool DataFlowAnalyzer::inScope(YulString _variableName) const$/;"	f	class:DataFlowAnalyzer	signature:(YulString _variableName) const
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(Assignment& _assignment)$/;"	f	class:DataFlowAnalyzer	signature:(Assignment& _assignment)
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(Block& _block)$/;"	f	class:DataFlowAnalyzer	signature:(Block& _block)
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(ForLoop& _for)$/;"	f	class:DataFlowAnalyzer	signature:(ForLoop& _for)
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(FunctionDefinition& _fun)$/;"	f	class:DataFlowAnalyzer	signature:(FunctionDefinition& _fun)
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(If& _if)$/;"	f	class:DataFlowAnalyzer	signature:(If& _if)
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(Switch& _switch)$/;"	f	class:DataFlowAnalyzer	signature:(Switch& _switch)
DataFlowAnalyzer::operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(VariableDeclaration& _varDecl)$/;"	f	class:DataFlowAnalyzer	signature:(VariableDeclaration& _varDecl)
DataFlowAnalyzer::popScope	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::popScope()$/;"	f	class:DataFlowAnalyzer	signature:()
DataFlowAnalyzer::pushScope	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::pushScope(bool _functionScope)$/;"	f	class:DataFlowAnalyzer	signature:(bool _functionScope)
DataLocation	libsolidity/ast/Types.h	/^enum class DataLocation { Storage, CallData, Memory };$/;"	c	namespace:dev::solidity
Day	libsolidity/ast/AST.h	/^		Day = static_cast<int>(Token::SubDay),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
Declaration	libsolidity/analysis/ControlFlowGraph.h	/^		Declaration,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
Declaration	libsolidity/ast/AST.h	/^	Declaration($/;"	f	class:dev::solidity::Declaration	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, Visibility _visibility = Visibility::Default )
Declaration	libsolidity/ast/AST.h	/^class Declaration: public ASTNode, public Scopable$/;"	c	namespace:dev::solidity	inherits:ASTNode,Scopable
DeclarationContainer	libsolidity/analysis/DeclarationContainer.h	/^	explicit DeclarationContainer($/;"	f	class:dev::solidity::DeclarationContainer	access:public	signature:( ASTNode const* _enclosingNode = nullptr, DeclarationContainer const* _enclosingContainer = nullptr )
DeclarationContainer	libsolidity/analysis/DeclarationContainer.h	/^class DeclarationContainer$/;"	c	namespace:dev::solidity
DeclarationContainer::activateVariable	libsolidity/analysis/DeclarationContainer.cpp	/^void DeclarationContainer::activateVariable(ASTString const& _name)$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name)
DeclarationContainer::conflictingDeclaration	libsolidity/analysis/DeclarationContainer.cpp	/^Declaration const* DeclarationContainer::conflictingDeclaration($/;"	f	class:DeclarationContainer	signature:( Declaration const& _declaration, ASTString const* _name ) const
DeclarationContainer::isInvisible	libsolidity/analysis/DeclarationContainer.cpp	/^bool DeclarationContainer::isInvisible(ASTString const& _name) const$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name) const
DeclarationContainer::registerDeclaration	libsolidity/analysis/DeclarationContainer.cpp	/^bool DeclarationContainer::registerDeclaration($/;"	f	class:DeclarationContainer	signature:( Declaration const& _declaration, ASTString const* _name, bool _invisible, bool _update )
DeclarationContainer::resolveName	libsolidity/analysis/DeclarationContainer.cpp	/^vector<Declaration const*> DeclarationContainer::resolveName(ASTString const& _name, bool _recursive, bool _alsoInvisible) const$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name, bool _recursive, bool _alsoInvisible) const
DeclarationContainer::similarNames	libsolidity/analysis/DeclarationContainer.cpp	/^vector<ASTString> DeclarationContainer::similarNames(ASTString const& _name) const$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name) const
DeclarationError	liblangutil/Exceptions.h	/^		DeclarationError,$/;"	m	class:langutil::Error::Type	access:private
DeclarationRegistrationHelper	libsolidity/analysis/NameAndTypeResolver.cpp	/^DeclarationRegistrationHelper::DeclarationRegistrationHelper($/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:( map<ASTNode const*, shared_ptr<DeclarationContainer>>& _scopes, ASTNode& _astRoot, ErrorReporter& _errorReporter, ASTNode const* _currentScope )
DeclarationRegistrationHelper	libsolidity/analysis/NameAndTypeResolver.h	/^	DeclarationRegistrationHelper($/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:public	signature:( std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& _scopes, ASTNode& _astRoot, langutil::ErrorReporter& _errorReporter, ASTNode const* _currentScope = nullptr )
DeclarationRegistrationHelper	libsolidity/analysis/NameAndTypeResolver.h	/^class DeclarationRegistrationHelper: private ASTVisitor$/;"	c	namespace:dev::solidity	inherits:ASTVisitor
Default	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
DelegateCall	libsolidity/ast/Types.h	/^		DelegateCall, \/\/\/< external call using DELEGATECALL, i.e. not exchanging the storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Dialect	libyul/Dialect.h	/^	Dialect(AsmFlavour _flavour): flavour(_flavour) {}$/;"	f	struct:yul::Dialect	access:public	signature:(AsmFlavour _flavour)
Dialect	libyul/Dialect.h	/^struct Dialect: boost::noncopyable$/;"	s	namespace:yul	inherits:boost::noncopyable
DisableConsoleBuffering	libdevcore/CommonIO.cpp	/^	DisableConsoleBuffering()$/;"	f	class:DisableConsoleBuffering	access:public	signature:()
DisableConsoleBuffering	libdevcore/CommonIO.cpp	/^class DisableConsoleBuffering$/;"	c	file:
DisableConsoleBuffering::DisableConsoleBuffering	libdevcore/CommonIO.cpp	/^	DisableConsoleBuffering()$/;"	f	class:DisableConsoleBuffering	access:public	signature:()
DisableConsoleBuffering::m_oldMode	libdevcore/CommonIO.cpp	/^	DWORD m_oldMode;$/;"	m	class:DisableConsoleBuffering	file:	access:private
DisableConsoleBuffering::m_stdin	libdevcore/CommonIO.cpp	/^	HANDLE m_stdin;$/;"	m	class:DisableConsoleBuffering	file:	access:private
DisableConsoleBuffering::m_termios	libdevcore/CommonIO.cpp	/^	struct termios m_termios;$/;"	m	class:DisableConsoleBuffering	typeref:struct:DisableConsoleBuffering::termios	file:	access:private
DisableConsoleBuffering::~DisableConsoleBuffering	libdevcore/CommonIO.cpp	/^	~DisableConsoleBuffering()$/;"	f	class:DisableConsoleBuffering	access:public	signature:()
Disambiguator	libyul/optimiser/Disambiguator.h	/^	explicit Disambiguator($/;"	f	class:yul::Disambiguator	access:public	signature:( Dialect const& _dialect, AsmAnalysisInfo const& _analysisInfo, std::set<YulString> const& _externallyUsedIdentifiers = {} )
Disambiguator	libyul/optimiser/Disambiguator.h	/^class Disambiguator: public ASTCopier$/;"	c	namespace:yul	inherits:ASTCopier
Disambiguator::enterFunction	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::enterFunction(FunctionDefinition const& _function)$/;"	f	class:Disambiguator	signature:(FunctionDefinition const& _function)
Disambiguator::enterScope	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::enterScope(Block const& _block)$/;"	f	class:Disambiguator	signature:(Block const& _block)
Disambiguator::enterScopeInternal	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::enterScopeInternal(Scope& _scope)$/;"	f	class:Disambiguator	signature:(Scope& _scope)
Disambiguator::leaveFunction	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::leaveFunction(FunctionDefinition const& _function)$/;"	f	class:Disambiguator	signature:(FunctionDefinition const& _function)
Disambiguator::leaveScope	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::leaveScope(Block const& _block)$/;"	f	class:Disambiguator	signature:(Block const& _block)
Disambiguator::leaveScopeInternal	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::leaveScopeInternal(Scope& _scope)$/;"	f	class:Disambiguator	signature:(Scope& _scope)
Disambiguator::translateIdentifier	libyul/optimiser/Disambiguator.cpp	/^YulString Disambiguator::translateIdentifier(YulString _originalName)$/;"	f	class:Disambiguator	signature:(YulString _originalName)
DocStringAnalyser	libsolidity/analysis/DocStringAnalyser.h	/^	DocStringAnalyser(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::DocStringAnalyser	access:public	signature:(langutil::ErrorReporter& _errorReporter)
DocStringAnalyser	libsolidity/analysis/DocStringAnalyser.h	/^class DocStringAnalyser: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
DocStringAnalyser::analyseDocStrings	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::analyseDocStrings(SourceUnit const& _sourceUnit)$/;"	f	class:DocStringAnalyser	signature:(SourceUnit const& _sourceUnit)
DocStringAnalyser::appendError	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::appendError(string const& _description)$/;"	f	class:DocStringAnalyser	signature:(string const& _description)
DocStringAnalyser::checkParameters	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::checkParameters($/;"	f	class:DocStringAnalyser	signature:( CallableDeclaration const& _callable, DocumentedAnnotation& _annotation )
DocStringAnalyser::handleCallable	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::handleCallable($/;"	f	class:DocStringAnalyser	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
DocStringAnalyser::handleConstructor	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::handleConstructor($/;"	f	class:DocStringAnalyser	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
DocStringAnalyser::parseDocStrings	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::parseDocStrings($/;"	f	class:DocStringAnalyser	signature:( Documented const& _node, DocumentedAnnotation& _annotation, set<string> const& _validTags, string const& _nodeName )
DocStringAnalyser::visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(ContractDefinition const& _contract)$/;"	f	class:DocStringAnalyser	signature:(ContractDefinition const& _contract)
DocStringAnalyser::visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(EventDefinition const& _event)$/;"	f	class:DocStringAnalyser	signature:(EventDefinition const& _event)
DocStringAnalyser::visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(FunctionDefinition const& _function)$/;"	f	class:DocStringAnalyser	signature:(FunctionDefinition const& _function)
DocStringAnalyser::visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(ModifierDefinition const& _modifier)$/;"	f	class:DocStringAnalyser	signature:(ModifierDefinition const& _modifier)
DocStringParser	libsolidity/parsing/DocStringParser.h	/^class DocStringParser$/;"	c	namespace:dev::solidity
DocStringParser::appendDocTag	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::appendDocTag(iter _pos, iter _end)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end)
DocStringParser::appendError	libsolidity/parsing/DocStringParser.cpp	/^void DocStringParser::appendError(string const& _description)$/;"	f	class:DocStringParser	signature:(string const& _description)
DocStringParser::newTag	libsolidity/parsing/DocStringParser.cpp	/^void DocStringParser::newTag(string const& _tagName)$/;"	f	class:DocStringParser	signature:(string const& _tagName)
DocStringParser::parse	libsolidity/parsing/DocStringParser.cpp	/^bool DocStringParser::parse(string const& _docString, ErrorReporter& _errorReporter)$/;"	f	class:DocStringParser	signature:(string const& _docString, ErrorReporter& _errorReporter)
DocStringParser::parseDocTag	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::parseDocTag(iter _pos, iter _end, string const& _tag)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end, string const& _tag)
DocStringParser::parseDocTagLine	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::parseDocTagLine(iter _pos, iter _end, bool _appending)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end, bool _appending)
DocStringParser::parseDocTagParam	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::parseDocTagParam(iter _pos, iter _end)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end)
DocTag	libsolidity/ast/ASTAnnotations.h	/^struct DocTag$/;"	s	namespace:dev::solidity
DocstringParsingError	liblangutil/Exceptions.h	/^		DocstringParsingError,$/;"	m	class:langutil::Error::Type	access:private
DocumentationType	solse/CommandLineInterface.h	/^enum class DocumentationType: uint8_t;$/;"	c	namespace:dev::solidity	inherits:uint8_t,CommandLineInterface
Documented	libsolidity/ast/AST.h	/^	explicit Documented(ASTPointer<ASTString> const& _documentation): m_documentation(_documentation) {}$/;"	f	class:dev::solidity::Documented	access:public	signature:(ASTPointer<ASTString> const& _documentation)
Documented	libsolidity/ast/AST.h	/^class Documented$/;"	c	namespace:dev::solidity
DocumentedAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct DocumentedAnnotation$/;"	s	namespace:dev::solidity
DontAdd	libdevcore/CommonData.h	/^	DontAdd = 0,$/;"	m	class:dev::HexPrefix	access:private
DontThrow	libdevcore/CommonData.h	/^	DontThrow = 0,$/;"	m	class:dev::WhenError	access:private
DoublePush	libevmasm/PeepholeOptimiser.cpp	/^struct DoublePush: SimplePeepholeOptimizerMethod<DoublePush, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
DoubleSwap	libevmasm/PeepholeOptimiser.cpp	/^struct DoubleSwap: SimplePeepholeOptimizerMethod<DoubleSwap, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
ECRecover	libsolidity/ast/Types.h	/^		ECRecover, \/\/\/< CALL to special contract for ecrecover$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
EQ	libevmasm/Instruction.h	/^	EQ,					\/\/\/< equality comparison$/;"	m	class:dev::solidity::Instruction	access:private
ETH_BUILD_COMPILER	solidity/BuildInfo.h	7;"	d
ETH_BUILD_OS	solidity/BuildInfo.h	6;"	d
ETH_BUILD_PLATFORM	solidity/BuildInfo.h	8;"	d
ETH_BUILD_TYPE	solidity/BuildInfo.h	5;"	d
ETH_FUNC	libdevcore/Assertions.h	33;"	d
ETH_PROJECT_VERSION	solidity/BuildInfo.h	3;"	d
EVM	libyul/AssemblyStack.h	/^	enum class Machine { EVM, EVM15, eWasm };$/;"	m	class:yul::AssemblyStack::Machine	access:private
EVM15	libyul/AssemblyStack.h	/^	enum class Machine { EVM, EVM15, eWasm };$/;"	m	class:yul::AssemblyStack::Machine	access:private
EVMAssembly	libyul/backends/evm/EVMAssembly.h	/^	explicit EVMAssembly(bool _evm15 = false): m_evm15(_evm15) { }$/;"	f	class:yul::EVMAssembly	access:public	signature:(bool _evm15 = false)
EVMAssembly	libyul/backends/evm/EVMAssembly.h	/^class EVMAssembly: public AbstractAssembly$/;"	c	namespace:yul	inherits:AbstractAssembly
EVMAssembly::appendAssemblySize	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendAssemblySize()$/;"	f	class:EVMAssembly	signature:()
EVMAssembly::appendBeginsub	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendBeginsub(LabelID _labelId, int _arguments)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId, int _arguments)
EVMAssembly::appendConstant	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendConstant(u256 const& _constant)$/;"	f	class:EVMAssembly	signature:(u256 const& _constant)
EVMAssembly::appendData	libyul/backends/evm/EVMAssembly.cpp	/^AbstractAssembly::SubID EVMAssembly::appendData(bytes const&)$/;"	f	class:EVMAssembly	signature:(bytes const&)
EVMAssembly::appendDataOffset	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendDataOffset(AbstractAssembly::SubID)$/;"	f	class:EVMAssembly	signature:(AbstractAssembly::SubID)
EVMAssembly::appendDataSize	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendDataSize(AbstractAssembly::SubID)$/;"	f	class:EVMAssembly	signature:(AbstractAssembly::SubID)
EVMAssembly::appendInstruction	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendInstruction(solidity::Instruction _instr)$/;"	f	class:EVMAssembly	signature:(solidity::Instruction _instr)
EVMAssembly::appendJump	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJump(int _stackDiffAfter)$/;"	f	class:EVMAssembly	signature:(int _stackDiffAfter)
EVMAssembly::appendJumpTo	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJumpTo(LabelID _labelId, int _stackDiffAfter)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId, int _stackDiffAfter)
EVMAssembly::appendJumpToIf	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJumpToIf(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
EVMAssembly::appendJumpsub	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJumpsub(LabelID _labelId, int _arguments, int _returns)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId, int _arguments, int _returns)
EVMAssembly::appendLabel	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLabel(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
EVMAssembly::appendLabelReference	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLabelReference(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
EVMAssembly::appendLabelReferenceInternal	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLabelReferenceInternal(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
EVMAssembly::appendLinkerSymbol	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLinkerSymbol(string const&)$/;"	f	class:EVMAssembly	signature:(string const&)
EVMAssembly::appendReturnsub	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendReturnsub(int _returns, int _stackDiffAfter)$/;"	f	class:EVMAssembly	signature:(int _returns, int _stackDiffAfter)
EVMAssembly::createSubAssembly	libyul/backends/evm/EVMAssembly.cpp	/^pair<shared_ptr<AbstractAssembly>, AbstractAssembly::SubID> EVMAssembly::createSubAssembly()$/;"	f	class:EVMAssembly	signature:()
EVMAssembly::finalize	libyul/backends/evm/EVMAssembly.cpp	/^eth::LinkerObject EVMAssembly::finalize()$/;"	f	class:EVMAssembly	signature:()
EVMAssembly::namedLabel	libyul/backends/evm/EVMAssembly.cpp	/^AbstractAssembly::LabelID EVMAssembly::namedLabel(string const& _name)$/;"	f	class:EVMAssembly	signature:(string const& _name)
EVMAssembly::newLabelId	libyul/backends/evm/EVMAssembly.cpp	/^EVMAssembly::LabelID EVMAssembly::newLabelId()$/;"	f	class:EVMAssembly	signature:()
EVMAssembly::setLabelToCurrentPosition	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::setLabelToCurrentPosition(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
EVMAssembly::setSourceLocation	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::setSourceLocation(SourceLocation const&)$/;"	f	class:EVMAssembly	signature:(SourceLocation const&)
EVMAssembly::updateReference	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::updateReference(size_t pos, size_t size, u256 value)$/;"	f	class:EVMAssembly	signature:(size_t pos, size_t size, u256 value)
EVMDialect	libyul/backends/evm/EVMDialect.cpp	/^EVMDialect::EVMDialect(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion):$/;"	f	class:EVMDialect	signature:(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion)
EVMDialect	libyul/backends/evm/EVMDialect.h	/^	EVMDialect(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion);$/;"	p	struct:yul::EVMDialect	access:public	signature:(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion)
EVMDialect	libyul/backends/evm/EVMDialect.h	/^struct EVMDialect: public Dialect$/;"	s	namespace:yul	inherits:Dialect
EVMDialect::EVMDialect	libyul/backends/evm/EVMDialect.cpp	/^EVMDialect::EVMDialect(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion):$/;"	f	class:EVMDialect	signature:(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion)
EVMDialect::addFunction	libyul/backends/evm/EVMDialect.cpp	/^void EVMDialect::addFunction($/;"	f	class:EVMDialect	signature:( string _name, size_t _params, size_t _returns, bool _movable, bool _literalArguments, std::function<void(FunctionCall const&, AbstractAssembly&, std::function<void()>)> _generateCode )
EVMDialect::builtin	libyul/backends/evm/EVMDialect.cpp	/^BuiltinFunctionForEVM const* EVMDialect::builtin(YulString _name) const$/;"	f	class:EVMDialect	signature:(YulString _name) const
EVMDialect::looseAssemblyForEVM	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<EVMDialect> EVMDialect::looseAssemblyForEVM(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
EVMDialect::setCurrentObject	libyul/backends/evm/EVMDialect.cpp	/^void EVMDialect::setCurrentObject(Object const* _object)$/;"	f	class:EVMDialect	signature:(Object const* _object)
EVMDialect::setSubIDs	libyul/backends/evm/EVMDialect.cpp	/^void EVMDialect::setSubIDs(map<YulString, AbstractAssembly::SubID> _subIDs)$/;"	f	class:EVMDialect	signature:(map<YulString, AbstractAssembly::SubID> _subIDs)
EVMDialect::strictAssemblyForEVM	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<EVMDialect> EVMDialect::strictAssemblyForEVM(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
EVMDialect::strictAssemblyForEVMObjects	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<EVMDialect> EVMDialect::strictAssemblyForEVMObjects(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
EVMDialect::yulForEVM	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<yul::EVMDialect> EVMDialect::yulForEVM(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
EVMObjectCompiler	libyul/backends/evm/EVMObjectCompiler.h	/^	EVMObjectCompiler(AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15):$/;"	f	class:yul::EVMObjectCompiler	access:private	signature:(AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15)
EVMObjectCompiler	libyul/backends/evm/EVMObjectCompiler.h	/^class EVMObjectCompiler$/;"	c	namespace:yul
EVMObjectCompiler::compile	libyul/backends/evm/EVMObjectCompiler.cpp	/^void EVMObjectCompiler::compile(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize)$/;"	f	class:EVMObjectCompiler	signature:(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize)
EVMObjectCompiler::run	libyul/backends/evm/EVMObjectCompiler.cpp	/^void EVMObjectCompiler::run(Object& _object, bool _optimize)$/;"	f	class:EVMObjectCompiler	signature:(Object& _object, bool _optimize)
EVMVersion	liblangutil/EVMVersion.h	/^	EVMVersion() = default;$/;"	p	class:langutil::EVMVersion	access:public	signature:()
EVMVersion	liblangutil/EVMVersion.h	/^	EVMVersion(Version _version): m_version(_version) {}$/;"	f	class:langutil::EVMVersion	access:private	signature:(Version _version)
EVMVersion	liblangutil/EVMVersion.h	/^class EVMVersion:$/;"	c	namespace:langutil	inherits:boost::less_than_comparable,boost::equality_comparable
EXP	libevmasm/Instruction.h	/^	EXP,				\/\/\/< exponential operation$/;"	m	class:dev::solidity::Instruction	access:private
EXPR_H	solse/SolidityExprTranslator.h	2;"	d
EXTCODECOPY	libevmasm/Instruction.h	/^	EXTCODECOPY,		\/\/\/< copy external code (from another contract)$/;"	m	class:dev::solidity::Instruction	access:private
EXTCODEHASH	libevmasm/Instruction.h	/^	EXTCODEHASH = 0x3f,	\/\/\/< get external code hash (from another contract)$/;"	m	class:dev::solidity::Instruction	access:private
EXTCODESIZE	libevmasm/Instruction.h	/^	EXTCODESIZE,		\/\/\/< get external code size (from another contract)$/;"	m	class:dev::solidity::Instruction	access:private
ElementaryTypeName	libsolidity/ast/AST.h	/^	ElementaryTypeName($/;"	f	class:dev::solidity::ElementaryTypeName	access:public	signature:( SourceLocation const& _location, ElementaryTypeNameToken const& _elem, boost::optional<StateMutability> _stateMutability = {} )
ElementaryTypeName	libsolidity/ast/AST.h	/^class ElementaryTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
ElementaryTypeNameExpression	libsolidity/ast/AST.h	/^	ElementaryTypeNameExpression(SourceLocation const& _location, ElementaryTypeNameToken const& _type):$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	access:public	signature:(SourceLocation const& _location, ElementaryTypeNameToken const& _type)
ElementaryTypeNameExpression	libsolidity/ast/AST.h	/^class ElementaryTypeNameExpression: public PrimaryExpression$/;"	c	namespace:dev::solidity	inherits:PrimaryExpression
ElementaryTypeNameToken	liblangutil/Token.h	/^	ElementaryTypeNameToken(Token _token, unsigned const& _firstNumber, unsigned const& _secondNumber)$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:(Token _token, unsigned const& _firstNumber, unsigned const& _secondNumber)
ElementaryTypeNameToken	liblangutil/Token.h	/^class ElementaryTypeNameToken$/;"	c	namespace:langutil
EmitStatement	libsolidity/ast/AST.h	/^	explicit EmitStatement($/;"	f	class:dev::solidity::EmitStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<FunctionCall> const& _functionCall )
EmitStatement	libsolidity/ast/AST.h	/^class EmitStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
Empty	libsolidity/interface/CompilerStack.h	/^		Empty,$/;"	e	enum:dev::solidity::CompilerStack::State
EncodingOptions	libsolidity/codegen/ABIFunctions.h	/^	struct EncodingOptions$/;"	s	class:dev::solidity::ABIFunctions	access:private
EndType	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	c	struct:dev::eth::BasicBlock	access:public
Enum	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
EnumDefinition	libsolidity/ast/AST.h	/^	EnumDefinition($/;"	f	class:dev::solidity::EnumDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, std::vector<ASTPointer<EnumValue>> const& _members )
EnumDefinition	libsolidity/ast/AST.h	/^class EnumDefinition: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
EnumDefinition::annotation	libsolidity/ast/AST.cpp	/^TypeDeclarationAnnotation& EnumDefinition::annotation() const$/;"	f	class:EnumDefinition	signature:() const
EnumDefinition::type	libsolidity/ast/AST.cpp	/^TypePointer EnumDefinition::type() const$/;"	f	class:EnumDefinition	signature:() const
EnumType	libsolidity/ast/Types.h	/^	explicit EnumType(EnumDefinition const& _enum): m_enum(_enum) {}$/;"	f	class:dev::solidity::EnumType	access:public	signature:(EnumDefinition const& _enum)
EnumType	libsolidity/ast/Types.h	/^class EnumType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
EnumType::canonicalName	libsolidity/ast/Types.cpp	/^string EnumType::canonicalName() const$/;"	f	class:EnumType	signature:() const
EnumType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult EnumType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:EnumType	signature:(Type const& _convertTo) const
EnumType::memberValue	libsolidity/ast/Types.cpp	/^unsigned EnumType::memberValue(ASTString const& _member) const$/;"	f	class:EnumType	signature:(ASTString const& _member) const
EnumType::numberOfMembers	libsolidity/ast/Types.cpp	/^size_t EnumType::numberOfMembers() const$/;"	f	class:EnumType	signature:() const
EnumType::operator ==	libsolidity/ast/Types.cpp	/^bool EnumType::operator==(Type const& _other) const$/;"	f	class:EnumType	signature:(Type const& _other) const
EnumType::richIdentifier	libsolidity/ast/Types.cpp	/^string EnumType::richIdentifier() const$/;"	f	class:EnumType	signature:() const
EnumType::storageBytes	libsolidity/ast/Types.cpp	/^unsigned EnumType::storageBytes() const$/;"	f	class:EnumType	signature:() const
EnumType::toString	libsolidity/ast/Types.cpp	/^string EnumType::toString(bool) const$/;"	f	class:EnumType	signature:(bool) const
EnumType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult EnumType::unaryOperatorResult(Token _operator) const$/;"	f	class:EnumType	signature:(Token _operator) const
EnumValue	libsolidity/ast/AST.h	/^	EnumValue(SourceLocation const& _location, ASTPointer<ASTString> const& _name):$/;"	f	class:dev::solidity::EnumValue	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _name)
EnumValue	libsolidity/ast/AST.h	/^class EnumValue: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
EnumValue::type	libsolidity/ast/AST.cpp	/^TypePointer EnumValue::type() const$/;"	f	class:EnumValue	signature:() const
EquivalentFunctionCombiner	libyul/optimiser/EquivalentFunctionCombiner.h	/^	EquivalentFunctionCombiner(std::map<YulString, FunctionDefinition const*> _duplicates): m_duplicates(std::move(_duplicates)) {}$/;"	f	class:yul::EquivalentFunctionCombiner	access:private	signature:(std::map<YulString, FunctionDefinition const*> _duplicates)
EquivalentFunctionCombiner	libyul/optimiser/EquivalentFunctionCombiner.h	/^class EquivalentFunctionCombiner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
EquivalentFunctionCombiner::operator ()	libyul/optimiser/EquivalentFunctionCombiner.cpp	/^void EquivalentFunctionCombiner::operator()(FunctionCall& _funCall)$/;"	f	class:EquivalentFunctionCombiner	signature:(FunctionCall& _funCall)
EquivalentFunctionCombiner::run	libyul/optimiser/EquivalentFunctionCombiner.cpp	/^void EquivalentFunctionCombiner::run(Block& _ast)$/;"	f	class:EquivalentFunctionCombiner	signature:(Block& _ast)
EquivalentFunctionDetector	libyul/optimiser/EquivalentFunctionDetector.h	/^	EquivalentFunctionDetector() = default;$/;"	p	class:yul::EquivalentFunctionDetector	access:private	signature:()
EquivalentFunctionDetector	libyul/optimiser/EquivalentFunctionDetector.h	/^class EquivalentFunctionDetector: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
EquivalentFunctionDetector::RoughHeuristic::codeSize	libyul/optimiser/EquivalentFunctionDetector.cpp	/^size_t EquivalentFunctionDetector::RoughHeuristic::codeSize() const$/;"	f	class:EquivalentFunctionDetector::RoughHeuristic	signature:() const
EquivalentFunctionDetector::RoughHeuristic::operator <	libyul/optimiser/EquivalentFunctionDetector.cpp	/^bool EquivalentFunctionDetector::RoughHeuristic::operator<(EquivalentFunctionDetector::RoughHeuristic const& _rhs) const$/;"	f	class:EquivalentFunctionDetector::RoughHeuristic	signature:(EquivalentFunctionDetector::RoughHeuristic const& _rhs) const
EquivalentFunctionDetector::operator ()	libyul/optimiser/EquivalentFunctionDetector.cpp	/^void EquivalentFunctionDetector::operator()(FunctionDefinition const& _fun)$/;"	f	class:EquivalentFunctionDetector	signature:(FunctionDefinition const& _fun)
Error	liblangutil/Exceptions.cpp	/^Error::Error(Error::Type _type, std::string const& _description, SourceLocation const& _location):$/;"	f	class:Error	signature:(Error::Type _type, std::string const& _description, SourceLocation const& _location)
Error	liblangutil/Exceptions.cpp	/^Error::Error(Type _type, SourceLocation const& _location, string const& _description):$/;"	f	class:Error	signature:(Type _type, SourceLocation const& _location, string const& _description)
Error	liblangutil/Exceptions.h	/^	Error(Type _type, std::string const& _description, SourceLocation const& _location = SourceLocation());$/;"	p	class:langutil::Error	access:public	signature:(Type _type, std::string const& _description, SourceLocation const& _location = SourceLocation())
Error	liblangutil/Exceptions.h	/^	explicit Error($/;"	p	class:langutil::Error	access:public	signature:( Type _type, SourceLocation const& _location = SourceLocation(), std::string const& _description = std::string() )
Error	liblangutil/Exceptions.h	/^class Error: virtual public dev::Exception$/;"	c	namespace:langutil	inherits:dev::Exception
Error::Error	liblangutil/Exceptions.cpp	/^Error::Error(Error::Type _type, std::string const& _description, SourceLocation const& _location):$/;"	f	class:Error	signature:(Error::Type _type, std::string const& _description, SourceLocation const& _location)
Error::Error	liblangutil/Exceptions.cpp	/^Error::Error(Type _type, SourceLocation const& _location, string const& _description):$/;"	f	class:Error	signature:(Type _type, SourceLocation const& _location, string const& _description)
ErrorReporter	liblangutil/ErrorReporter.h	/^	explicit ErrorReporter(ErrorList& _errors):$/;"	f	class:langutil::ErrorReporter	access:public	signature:(ErrorList& _errors)
ErrorReporter	liblangutil/ErrorReporter.h	/^class ErrorReporter$/;"	c	namespace:langutil
ErrorReporter::checkForExcessiveErrors	liblangutil/ErrorReporter.cpp	/^bool ErrorReporter::checkForExcessiveErrors(Error::Type _type)$/;"	f	class:ErrorReporter	signature:(Error::Type _type)
ErrorReporter::clear	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::clear()$/;"	f	class:ErrorReporter	signature:()
ErrorReporter::declarationError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::declarationError(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
ErrorReporter::declarationError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::declarationError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
ErrorReporter::docstringParsingError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::docstringParsingError(string const& _description)$/;"	f	class:ErrorReporter	signature:(string const& _description)
ErrorReporter::error	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::error(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
ErrorReporter::error	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::error(Error::Type _type, SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, string const& _description)
ErrorReporter::errors	liblangutil/ErrorReporter.cpp	/^ErrorList const& ErrorReporter::errors() const$/;"	f	class:ErrorReporter	signature:() const
ErrorReporter::fatalDeclarationError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalDeclarationError(SourceLocation const& _location, std::string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, std::string const& _description)
ErrorReporter::fatalError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalError(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
ErrorReporter::fatalError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalError(Error::Type _type, SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, string const& _description)
ErrorReporter::fatalParserError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalParserError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
ErrorReporter::fatalTypeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalTypeError(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
ErrorReporter::fatalTypeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalTypeError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
ErrorReporter::operator =	liblangutil/ErrorReporter.cpp	/^ErrorReporter& ErrorReporter::operator=(ErrorReporter const& _errorReporter)$/;"	f	class:ErrorReporter	signature:(ErrorReporter const& _errorReporter)
ErrorReporter::parserError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::parserError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
ErrorReporter::syntaxError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::syntaxError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
ErrorReporter::typeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::typeError(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
ErrorReporter::typeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::typeError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
ErrorReporter::warning	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::warning($/;"	f	class:ErrorReporter	signature:( SourceLocation const& _location, string const& _description )
ErrorReporter::warning	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::warning($/;"	f	class:ErrorReporter	signature:( SourceLocation const& _location, string const& _description, SecondarySourceLocation const& _secondaryLocation )
ErrorReporter::warning	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::warning(string const& _description)$/;"	f	class:ErrorReporter	signature:(string const& _description)
EthAssemblyAdapter	libyul/backends/evm/AsmCodeGen.cpp	/^EthAssemblyAdapter::EthAssemblyAdapter(eth::Assembly& _assembly):$/;"	f	class:EthAssemblyAdapter	signature:(eth::Assembly& _assembly)
EthAssemblyAdapter	libyul/backends/evm/AsmCodeGen.h	/^	explicit EthAssemblyAdapter(dev::eth::Assembly& _assembly);$/;"	p	class:yul::EthAssemblyAdapter	access:public	signature:(dev::eth::Assembly& _assembly)
EthAssemblyAdapter	libyul/backends/evm/AsmCodeGen.h	/^class EthAssemblyAdapter: public AbstractAssembly$/;"	c	namespace:yul	inherits:AbstractAssembly
EthAssemblyAdapter::EthAssemblyAdapter	libyul/backends/evm/AsmCodeGen.cpp	/^EthAssemblyAdapter::EthAssemblyAdapter(eth::Assembly& _assembly):$/;"	f	class:EthAssemblyAdapter	signature:(eth::Assembly& _assembly)
EthAssemblyAdapter::appendAssemblySize	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendAssemblySize()$/;"	f	class:EthAssemblyAdapter	signature:()
EthAssemblyAdapter::appendBeginsub	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendBeginsub(LabelID, int)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID, int)
EthAssemblyAdapter::appendConstant	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendConstant(u256 const& _constant)$/;"	f	class:EthAssemblyAdapter	signature:(u256 const& _constant)
EthAssemblyAdapter::appendData	libyul/backends/evm/AsmCodeGen.cpp	/^AbstractAssembly::SubID EthAssemblyAdapter::appendData(bytes const& _data)$/;"	f	class:EthAssemblyAdapter	signature:(bytes const& _data)
EthAssemblyAdapter::appendDataOffset	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendDataOffset(AbstractAssembly::SubID _sub)$/;"	f	class:EthAssemblyAdapter	signature:(AbstractAssembly::SubID _sub)
EthAssemblyAdapter::appendDataSize	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendDataSize(AbstractAssembly::SubID _sub)$/;"	f	class:EthAssemblyAdapter	signature:(AbstractAssembly::SubID _sub)
EthAssemblyAdapter::appendInstruction	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendInstruction(solidity::Instruction _instruction)$/;"	f	class:EthAssemblyAdapter	signature:(solidity::Instruction _instruction)
EthAssemblyAdapter::appendJump	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJump(int _stackDiffAfter)$/;"	f	class:EthAssemblyAdapter	signature:(int _stackDiffAfter)
EthAssemblyAdapter::appendJumpTo	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJumpTo(LabelID _labelId, int _stackDiffAfter)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId, int _stackDiffAfter)
EthAssemblyAdapter::appendJumpToIf	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJumpToIf(LabelID _labelId)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId)
EthAssemblyAdapter::appendJumpsub	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJumpsub(LabelID, int, int)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID, int, int)
EthAssemblyAdapter::appendLabel	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendLabel(LabelID _labelId)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId)
EthAssemblyAdapter::appendLabelReference	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendLabelReference(LabelID _labelId)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId)
EthAssemblyAdapter::appendLinkerSymbol	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendLinkerSymbol(std::string const& _linkerSymbol)$/;"	f	class:EthAssemblyAdapter	signature:(std::string const& _linkerSymbol)
EthAssemblyAdapter::appendReturnsub	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendReturnsub(int, int)$/;"	f	class:EthAssemblyAdapter	signature:(int, int)
EthAssemblyAdapter::assemblyTagToIdentifier	libyul/backends/evm/AsmCodeGen.cpp	/^EthAssemblyAdapter::LabelID EthAssemblyAdapter::assemblyTagToIdentifier(eth::AssemblyItem const& _tag)$/;"	f	class:EthAssemblyAdapter	signature:(eth::AssemblyItem const& _tag)
EthAssemblyAdapter::createSubAssembly	libyul/backends/evm/AsmCodeGen.cpp	/^pair<shared_ptr<AbstractAssembly>, AbstractAssembly::SubID> EthAssemblyAdapter::createSubAssembly()$/;"	f	class:EthAssemblyAdapter	signature:()
EthAssemblyAdapter::namedLabel	libyul/backends/evm/AsmCodeGen.cpp	/^size_t EthAssemblyAdapter::namedLabel(std::string const& _name)$/;"	f	class:EthAssemblyAdapter	signature:(std::string const& _name)
EthAssemblyAdapter::newLabelId	libyul/backends/evm/AsmCodeGen.cpp	/^size_t EthAssemblyAdapter::newLabelId()$/;"	f	class:EthAssemblyAdapter	signature:()
EthAssemblyAdapter::setSourceLocation	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::setSourceLocation(SourceLocation const& _location)$/;"	f	class:EthAssemblyAdapter	signature:(SourceLocation const& _location)
EthAssemblyAdapter::stackHeight	libyul/backends/evm/AsmCodeGen.cpp	/^int EthAssemblyAdapter::stackHeight() const$/;"	f	class:EthAssemblyAdapter	signature:() const
Ether	libsolidity/ast/AST.h	/^		Ether = static_cast<int>(Token::SubEther),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
Event	libsolidity/ast/Types.h	/^		Event, \/\/\/< syntactic sugar for LOG*$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
EventDefinition	libsolidity/ast/AST.h	/^	EventDefinition($/;"	f	class:dev::solidity::EventDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, ASTPointer<ASTString> const& _documentation, ASTPointer<ParameterList> const& _parameters, bool _anonymous = false )
EventDefinition	libsolidity/ast/AST.h	/^class EventDefinition: public CallableDeclaration, public Documented$/;"	c	namespace:dev::solidity	inherits:CallableDeclaration,Documented
EventDefinition::annotation	libsolidity/ast/AST.cpp	/^EventDefinitionAnnotation& EventDefinition::annotation() const$/;"	f	class:EventDefinition	signature:() const
EventDefinition::functionType	libsolidity/ast/AST.cpp	/^FunctionTypePointer EventDefinition::functionType(bool _internal) const$/;"	f	class:EventDefinition	signature:(bool _internal) const
EventDefinition::type	libsolidity/ast/AST.cpp	/^TypePointer EventDefinition::type() const$/;"	f	class:EventDefinition	signature:() const
EventDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct EventDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
Exception	libdevcore/Exceptions.h	/^struct Exception: virtual std::exception, virtual boost::exception$/;"	s	namespace:dev	inherits:std::exception,boost::exception
Exception::lineInfo	libdevcore/Exceptions.cpp	/^string Exception::lineInfo() const$/;"	f	class:Exception	signature:() const
ExperimentalFeature	libsolidity/ast/ExperimentalFeatures.h	/^enum class ExperimentalFeature$/;"	c	namespace:dev::solidity
ExperimentalFeatureNames	libsolidity/ast/ExperimentalFeatures.h	/^static std::map<std::string, ExperimentalFeature> const ExperimentalFeatureNames =$/;"	m	class:dev::solidity::std
ExperimentalFeatureOnlyAnalysis	libsolidity/ast/ExperimentalFeatures.h	/^static std::map<ExperimentalFeature, bool> const ExperimentalFeatureOnlyAnalysis =$/;"	m	class:dev::solidity::std
Expression	libevmasm/ExpressionClasses.h	/^	struct Expression$/;"	s	class:dev::eth::ExpressionClasses	access:public
Expression	libsolidity/ast/AST.h	/^	explicit Expression(SourceLocation const& _location): ASTNode(_location) {}$/;"	f	class:dev::solidity::Expression	access:public	signature:(SourceLocation const& _location)
Expression	libsolidity/ast/AST.h	/^class Expression: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(Expression const&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression const&)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(Expression&&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression&&)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(bigint const& _number): Expression(_number.str(), Kind::Int) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(bigint const& _number)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(size_t _number): Expression(std::to_string(_number), Kind::Int) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(size_t _number)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, Expression _arg, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, Expression _arg, Kind _kind)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, Expression _arg1, Expression _arg2, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, Expression _arg1, Expression _arg2, Kind _kind)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, std::vector<Expression> _arguments, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, std::vector<Expression> _arguments, Kind _kind)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, std::vector<Expression> _arguments, SortPointer _sort):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, std::vector<Expression> _arguments, SortPointer _sort)
Expression	libsolidity/formal/SolverInterface.h	/^	Expression(u256 const& _number): Expression(_number.str(), Kind::Int) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(u256 const& _number)
Expression	libsolidity/formal/SolverInterface.h	/^	explicit Expression(bool _v): Expression(_v ? "true" : "false", Kind::Bool) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(bool _v)
Expression	libsolidity/formal/SolverInterface.h	/^	explicit Expression(std::string _name, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, Kind _kind)
Expression	libsolidity/formal/SolverInterface.h	/^class Expression$/;"	c	namespace:dev::solidity::smt
Expression::annotation	libsolidity/ast/AST.cpp	/^ExpressionAnnotation& Expression::annotation() const$/;"	f	class:Expression	signature:() const
ExpressionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ExpressionAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
ExpressionClasses	libevmasm/ExpressionClasses.h	/^class ExpressionClasses$/;"	c	namespace:dev::eth
ExpressionClasses::Expression::operator <	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::Expression::operator<(ExpressionClasses::Expression const& _other) const$/;"	f	class:ExpressionClasses::Expression	signature:(ExpressionClasses::Expression const& _other) const
ExpressionClasses::find	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::find($/;"	f	class:ExpressionClasses	signature:( AssemblyItem const& _item, Ids const& _arguments, bool _copyItem, unsigned _sequenceNumber )
ExpressionClasses::forceEqual	libevmasm/ExpressionClasses.cpp	/^void ExpressionClasses::forceEqual($/;"	f	class:ExpressionClasses	signature:( ExpressionClasses::Id _id, AssemblyItem const& _item, ExpressionClasses::Ids const& _arguments, bool _copyItem )
ExpressionClasses::fullDAGToString	libevmasm/ExpressionClasses.cpp	/^string ExpressionClasses::fullDAGToString(ExpressionClasses::Id _id) const$/;"	f	class:ExpressionClasses	signature:(ExpressionClasses::Id _id) const
ExpressionClasses::knownConstant	libevmasm/ExpressionClasses.cpp	/^u256 const* ExpressionClasses::knownConstant(Id _c)$/;"	f	class:ExpressionClasses	signature:(Id _c)
ExpressionClasses::knownNonZero	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownNonZero(Id _c)$/;"	f	class:ExpressionClasses	signature:(Id _c)
ExpressionClasses::knownToBeDifferent	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownToBeDifferent(ExpressionClasses::Id _a, ExpressionClasses::Id _b)$/;"	f	class:ExpressionClasses	signature:(ExpressionClasses::Id _a, ExpressionClasses::Id _b)
ExpressionClasses::knownToBeDifferentBy32	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownToBeDifferentBy32(ExpressionClasses::Id _a, ExpressionClasses::Id _b)$/;"	f	class:ExpressionClasses	signature:(ExpressionClasses::Id _a, ExpressionClasses::Id _b)
ExpressionClasses::knownZero	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownZero(Id _c)$/;"	f	class:ExpressionClasses	signature:(Id _c)
ExpressionClasses::newClass	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::newClass(SourceLocation const& _location)$/;"	f	class:ExpressionClasses	signature:(SourceLocation const& _location)
ExpressionClasses::rebuildExpression	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::rebuildExpression(ExpressionTemplate const& _template)$/;"	f	class:ExpressionClasses	signature:(ExpressionTemplate const& _template)
ExpressionClasses::storeItem	libevmasm/ExpressionClasses.cpp	/^AssemblyItem const* ExpressionClasses::storeItem(AssemblyItem const& _item)$/;"	f	class:ExpressionClasses	signature:(AssemblyItem const& _item)
ExpressionClasses::tryToSimplify	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::tryToSimplify(Expression const& _expr)$/;"	f	class:ExpressionClasses	signature:(Expression const& _expr)
ExpressionCompiler	libsolidity/codegen/ExpressionCompiler.h	/^	explicit ExpressionCompiler(CompilerContext& _compilerContext, bool _optimiseOrderLiterals):$/;"	f	class:dev::solidity::ExpressionCompiler	access:public	signature:(CompilerContext& _compilerContext, bool _optimiseOrderLiterals)
ExpressionCompiler	libsolidity/codegen/ExpressionCompiler.h	/^class ExpressionCompiler: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ExpressionCopier	libyul/optimiser/ASTCopier.h	/^class ExpressionCopier: public boost::static_visitor<Expression>$/;"	c	namespace:yul	inherits:boost::static_visitor
ExpressionInliner	libyul/optimiser/ExpressionInliner.h	/^	ExpressionInliner(Dialect const& _dialect, Block& _block):$/;"	f	class:yul::ExpressionInliner	access:public	signature:(Dialect const& _dialect, Block& _block)
ExpressionInliner	libyul/optimiser/ExpressionInliner.h	/^class ExpressionInliner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
ExpressionInliner::operator ()	libyul/optimiser/ExpressionInliner.cpp	/^void ExpressionInliner::operator()(FunctionDefinition& _fun)$/;"	f	class:ExpressionInliner	signature:(FunctionDefinition& _fun)
ExpressionInliner::run	libyul/optimiser/ExpressionInliner.cpp	/^void ExpressionInliner::run()$/;"	f	class:ExpressionInliner	signature:()
ExpressionInliner::visit	libyul/optimiser/ExpressionInliner.cpp	/^void ExpressionInliner::visit(Expression& _expression)$/;"	f	class:ExpressionInliner	signature:(Expression& _expression)
ExpressionJoiner	libyul/optimiser/ExpressionJoiner.cpp	/^ExpressionJoiner::ExpressionJoiner(Block& _ast)$/;"	f	class:ExpressionJoiner	signature:(Block& _ast)
ExpressionJoiner	libyul/optimiser/ExpressionJoiner.h	/^	explicit ExpressionJoiner(Block& _ast);$/;"	p	class:yul::ExpressionJoiner	access:private	signature:(Block& _ast)
ExpressionJoiner	libyul/optimiser/ExpressionJoiner.h	/^class ExpressionJoiner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
ExpressionJoiner::ExpressionJoiner	libyul/optimiser/ExpressionJoiner.cpp	/^ExpressionJoiner::ExpressionJoiner(Block& _ast)$/;"	f	class:ExpressionJoiner	signature:(Block& _ast)
ExpressionJoiner::decrementLatestStatementPointer	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::decrementLatestStatementPointer()$/;"	f	class:ExpressionJoiner	signature:()
ExpressionJoiner::handleArguments	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::handleArguments(vector<Expression>& _arguments)$/;"	f	class:ExpressionJoiner	signature:(vector<Expression>& _arguments)
ExpressionJoiner::isLatestStatementVarDeclJoinable	libyul/optimiser/ExpressionJoiner.cpp	/^bool ExpressionJoiner::isLatestStatementVarDeclJoinable(Identifier const& _identifier)$/;"	f	class:ExpressionJoiner	signature:(Identifier const& _identifier)
ExpressionJoiner::latestStatement	libyul/optimiser/ExpressionJoiner.cpp	/^Statement* ExpressionJoiner::latestStatement()$/;"	f	class:ExpressionJoiner	signature:()
ExpressionJoiner::operator ()	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::operator()(Block& _block)$/;"	f	class:ExpressionJoiner	signature:(Block& _block)
ExpressionJoiner::operator ()	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::operator()(FunctionCall& _funCall)$/;"	f	class:ExpressionJoiner	signature:(FunctionCall& _funCall)
ExpressionJoiner::operator ()	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::operator()(FunctionalInstruction& _instruction)$/;"	f	class:ExpressionJoiner	signature:(FunctionalInstruction& _instruction)
ExpressionJoiner::resetLatestStatementPointer	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::resetLatestStatementPointer()$/;"	f	class:ExpressionJoiner	signature:()
ExpressionJoiner::run	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::run(Block& _ast)$/;"	f	class:ExpressionJoiner	signature:(Block& _ast)
ExpressionJoiner::visit	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::visit(Expression& _e)$/;"	f	class:ExpressionJoiner	signature:(Expression& _e)
ExpressionSimplifier	libyul/optimiser/ExpressionSimplifier.h	/^	explicit ExpressionSimplifier(Dialect const& _dialect): DataFlowAnalyzer(_dialect) {}$/;"	f	class:yul::ExpressionSimplifier	access:private	signature:(Dialect const& _dialect)
ExpressionSimplifier	libyul/optimiser/ExpressionSimplifier.h	/^class ExpressionSimplifier: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
ExpressionSimplifier::run	libyul/optimiser/ExpressionSimplifier.cpp	/^void ExpressionSimplifier::run(Dialect const& _dialect, Block& _ast)$/;"	f	class:ExpressionSimplifier	signature:(Dialect const& _dialect, Block& _ast)
ExpressionSimplifier::visit	libyul/optimiser/ExpressionSimplifier.cpp	/^void ExpressionSimplifier::visit(Expression& _expression)$/;"	f	class:ExpressionSimplifier	signature:(Expression& _expression)
ExpressionSplitter	libyul/optimiser/ExpressionSplitter.h	/^	explicit ExpressionSplitter(Dialect const& _dialect, NameDispenser& _nameDispenser):$/;"	f	class:yul::ExpressionSplitter	access:public	signature:(Dialect const& _dialect, NameDispenser& _nameDispenser)
ExpressionSplitter	libyul/optimiser/ExpressionSplitter.h	/^class ExpressionSplitter: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
ExpressionSplitter::operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(Block& _block)$/;"	f	class:ExpressionSplitter	signature:(Block& _block)
ExpressionSplitter::operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(ForLoop& _loop)$/;"	f	class:ExpressionSplitter	signature:(ForLoop& _loop)
ExpressionSplitter::operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(FunctionCall& _funCall)$/;"	f	class:ExpressionSplitter	signature:(FunctionCall& _funCall)
ExpressionSplitter::operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(FunctionalInstruction& _instruction)$/;"	f	class:ExpressionSplitter	signature:(FunctionalInstruction& _instruction)
ExpressionSplitter::operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(If& _if)$/;"	f	class:ExpressionSplitter	signature:(If& _if)
ExpressionSplitter::operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(Switch& _switch)$/;"	f	class:ExpressionSplitter	signature:(Switch& _switch)
ExpressionSplitter::outlineExpression	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::outlineExpression(Expression& _expr)$/;"	f	class:ExpressionSplitter	signature:(Expression& _expr)
ExpressionStatement	libsolidity/ast/AST.h	/^	ExpressionStatement($/;"	f	class:dev::solidity::ExpressionStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> _expression )
ExpressionStatement	libsolidity/ast/AST.h	/^class ExpressionStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
ExpressionStatement	libyul/AsmData.h	/^struct ExpressionStatement { langutil::SourceLocation location; Expression expression; };$/;"	s	namespace:yul
ExpressionTemplate	libevmasm/SimplificationRules.cpp	/^ExpressionTemplate::ExpressionTemplate(Pattern const& _pattern, SourceLocation const& _location)$/;"	f	class:ExpressionTemplate	signature:(Pattern const& _pattern, SourceLocation const& _location)
ExpressionTemplate	libevmasm/SimplificationRules.h	/^struct ExpressionTemplate$/;"	s	namespace:dev::eth
ExpressionTemplate::ExpressionTemplate	libevmasm/SimplificationRules.cpp	/^ExpressionTemplate::ExpressionTemplate(Pattern const& _pattern, SourceLocation const& _location)$/;"	f	class:ExpressionTemplate	signature:(Pattern const& _pattern, SourceLocation const& _location)
ExpressionTemplate::toString	libevmasm/SimplificationRules.cpp	/^string ExpressionTemplate::toString() const$/;"	f	class:ExpressionTemplate	signature:() const
Ext	libevmasm/Instruction.h	/^	Ext,		\/\/ 20, Ext$/;"	m	class:dev::solidity::Instruction::Tier	access:private
ExtCode	libevmasm/Instruction.h	/^	ExtCode,	\/\/ 700, Extcode$/;"	m	class:dev::solidity::Instruction::Tier	access:private
External	libsolidity/ast/Types.h	/^		External, \/\/\/< external call using CALL$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ExternalIdentifierAccess	libyul/backends/evm/AbstractAssembly.h	/^struct ExternalIdentifierAccess$/;"	s	class:dev::solidity::Instruction	access:private
ExternalIdentifierInfo	libsolidity/ast/ASTAnnotations.h	/^	struct ExternalIdentifierInfo$/;"	s	struct:dev::solidity::InlineAssemblyAnnotation	access:public
FOR	libdevcore/Keccak256.cpp	117;"	d	file:
FOR5	libdevcore/Keccak256.cpp	73;"	d	file:
FailIfDifferent	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	e	enum:dev::FixedHash::ConstructFromHashType
FatalError	liblangutil/Exceptions.h	/^struct FatalError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
Finney	libsolidity/ast/AST.h	/^		Finney = static_cast<int>(Token::SubFinney),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
FixedBytes	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
FixedBytesType	libsolidity/ast/Types.cpp	/^FixedBytesType::FixedBytesType(unsigned _bytes): m_bytes(_bytes)$/;"	f	class:FixedBytesType	signature:(unsigned _bytes)
FixedBytesType	libsolidity/ast/Types.h	/^	explicit FixedBytesType(unsigned _bytes);$/;"	p	class:dev::solidity::FixedBytesType	access:public	signature:(unsigned _bytes)
FixedBytesType	libsolidity/ast/Types.h	/^class FixedBytesType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
FixedBytesType::FixedBytesType	libsolidity/ast/Types.cpp	/^FixedBytesType::FixedBytesType(unsigned _bytes): m_bytes(_bytes)$/;"	f	class:FixedBytesType	signature:(unsigned _bytes)
FixedBytesType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedBytesType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:FixedBytesType	signature:(Token _operator, TypePointer const& _other) const
FixedBytesType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedBytesType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedBytesType	signature:(Type const& _convertTo) const
FixedBytesType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedBytesType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedBytesType	signature:(Type const& _convertTo) const
FixedBytesType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap FixedBytesType::nativeMembers(ContractDefinition const*) const$/;"	f	class:FixedBytesType	signature:(ContractDefinition const*) const
FixedBytesType::operator ==	libsolidity/ast/Types.cpp	/^bool FixedBytesType::operator==(Type const& _other) const$/;"	f	class:FixedBytesType	signature:(Type const& _other) const
FixedBytesType::richIdentifier	libsolidity/ast/Types.cpp	/^string FixedBytesType::richIdentifier() const$/;"	f	class:FixedBytesType	signature:() const
FixedBytesType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedBytesType::unaryOperatorResult(Token _operator) const$/;"	f	class:FixedBytesType	signature:(Token _operator) const
FixedHash	libdevcore/FixedHash.h	/^	FixedHash(Arith const& _arith) { toBigEndian(_arith, m_data); }$/;"	f	class:dev::FixedHash	access:public	signature:(Arith const& _arith)
FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash() { m_data.fill(0); }$/;"	f	class:dev::FixedHash	access:public	signature:()
FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(bytes const& _b, ConstructFromHashType _t = FailIfDifferent) { if (_b.size() == N) memcpy(m_data.data(), _b.data(), std::min<unsigned>(_b.size(), N)); else { m_data.fill(0); if (_t != FailIfDifferent) { auto c = std::min<unsigned>(_b.size(), N); for (unsigned i = 0; i < c; ++i) m_data[_t == AlignRight ? N - 1 - i : i] = _b[_t == AlignRight ? _b.size() - 1 - i : i]; } } }$/;"	f	class:dev::FixedHash	access:public	signature:(bytes const& _b, ConstructFromHashType _t = FailIfDifferent)
FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(bytesConstRef _b, ConstructFromHashType _t = FailIfDifferent) { if (_b.size() == N) memcpy(m_data.data(), _b.data(), std::min<unsigned>(_b.size(), N)); else { m_data.fill(0); if (_t != FailIfDifferent) { auto c = std::min<unsigned>(_b.size(), N); for (unsigned i = 0; i < c; ++i) m_data[_t == AlignRight ? N - 1 - i : i] = _b[_t == AlignRight ? _b.size() - 1 - i : i]; } } }$/;"	f	class:dev::FixedHash	access:public	signature:(bytesConstRef _b, ConstructFromHashType _t = FailIfDifferent)
FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(std::string const& _s, ConstructFromStringType _t = FromHex, ConstructFromHashType _ht = FailIfDifferent): FixedHash(_t == FromHex ? fromHex(_s, WhenError::Throw) : dev::asBytes(_s), _ht) {}$/;"	f	class:dev::FixedHash	access:public	signature:(std::string const& _s, ConstructFromStringType _t = FromHex, ConstructFromHashType _ht = FailIfDifferent)
FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(unsigned _u) { toBigEndian(_u, m_data); }$/;"	f	class:dev::FixedHash	access:public	signature:(unsigned _u)
FixedHash	libdevcore/FixedHash.h	/^	template <unsigned M> explicit FixedHash(FixedHash<M> const& _h, ConstructFromHashType _t = AlignLeft) { m_data.fill(0); unsigned c = std::min(M, N); for (unsigned i = 0; i < c; ++i) m_data[_t == AlignRight ? N - 1 - i : i] = _h[_t == AlignRight ? M - 1 - i : i]; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash<M> const& _h, ConstructFromHashType _t = AlignLeft)
FixedHash	libdevcore/FixedHash.h	/^class FixedHash$/;"	c	namespace:dev
FixedPoint	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
FixedPointType	libsolidity/ast/Types.cpp	/^FixedPointType::FixedPointType(unsigned _totalBits, unsigned _fractionalDigits, FixedPointType::Modifier _modifier):$/;"	f	class:FixedPointType	signature:(unsigned _totalBits, unsigned _fractionalDigits, FixedPointType::Modifier _modifier)
FixedPointType	libsolidity/ast/Types.h	/^	explicit FixedPointType(unsigned _totalBits, unsigned _fractionalDigits, Modifier _modifier = Modifier::Unsigned);$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:(unsigned _totalBits, unsigned _fractionalDigits, Modifier _modifier = Modifier::Unsigned)
FixedPointType	libsolidity/ast/Types.h	/^class FixedPointType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
FixedPointType::FixedPointType	libsolidity/ast/Types.cpp	/^FixedPointType::FixedPointType(unsigned _totalBits, unsigned _fractionalDigits, FixedPointType::Modifier _modifier):$/;"	f	class:FixedPointType	signature:(unsigned _totalBits, unsigned _fractionalDigits, FixedPointType::Modifier _modifier)
FixedPointType::asIntegerType	libsolidity/ast/Types.cpp	/^std::shared_ptr<IntegerType> FixedPointType::asIntegerType() const$/;"	f	class:FixedPointType	signature:() const
FixedPointType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedPointType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:FixedPointType	signature:(Token _operator, TypePointer const& _other) const
FixedPointType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedPointType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedPointType	signature:(Type const& _convertTo) const
FixedPointType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedPointType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedPointType	signature:(Type const& _convertTo) const
FixedPointType::maxIntegerValue	libsolidity/ast/Types.cpp	/^bigint FixedPointType::maxIntegerValue() const$/;"	f	class:FixedPointType	signature:() const
FixedPointType::minIntegerValue	libsolidity/ast/Types.cpp	/^bigint FixedPointType::minIntegerValue() const$/;"	f	class:FixedPointType	signature:() const
FixedPointType::operator ==	libsolidity/ast/Types.cpp	/^bool FixedPointType::operator==(Type const& _other) const$/;"	f	class:FixedPointType	signature:(Type const& _other) const
FixedPointType::richIdentifier	libsolidity/ast/Types.cpp	/^string FixedPointType::richIdentifier() const$/;"	f	class:FixedPointType	signature:() const
FixedPointType::toString	libsolidity/ast/Types.cpp	/^string FixedPointType::toString(bool) const$/;"	f	class:FixedPointType	signature:(bool) const
FixedPointType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedPointType::unaryOperatorResult(Token _operator) const$/;"	f	class:FixedPointType	signature:(Token _operator) const
ForLoop	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	s	namespace:yul
ForLoopInitRewriter	libyul/optimiser/ForLoopInitRewriter.h	/^class ForLoopInitRewriter: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
ForLoopInitRewriter::operator ()	libyul/optimiser/ForLoopInitRewriter.cpp	/^void ForLoopInitRewriter::operator()(Block& _block)$/;"	f	class:ForLoopInitRewriter	signature:(Block& _block)
ForStatement	libsolidity/ast/AST.h	/^	ForStatement($/;"	f	class:dev::solidity::ForStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Statement> const& _initExpression, ASTPointer<Expression> const& _conditionExpression, ASTPointer<ExpressionStatement> const& _loopExpression, ASTPointer<Statement> const& _body )
ForStatement	libsolidity/ast/AST.h	/^class ForStatement: public BreakableStatement, public Scopable$/;"	c	namespace:dev::solidity	inherits:BreakableStatement,Scopable
FromBinary	libdevcore/FixedHash.h	/^	enum ConstructFromStringType { FromHex, FromBinary };$/;"	e	enum:dev::FixedHash::ConstructFromStringType
FromHex	libdevcore/FixedHash.h	/^	enum ConstructFromStringType { FromHex, FromBinary };$/;"	e	enum:dev::FixedHash::ConstructFromStringType
FullInliner	libyul/optimiser/FullInliner.cpp	/^FullInliner::FullInliner(Block& _ast, NameDispenser& _dispenser):$/;"	f	class:FullInliner	signature:(Block& _ast, NameDispenser& _dispenser)
FullInliner	libyul/optimiser/FullInliner.h	/^	explicit FullInliner(Block& _ast, NameDispenser& _dispenser);$/;"	p	class:yul::FullInliner	access:public	signature:(Block& _ast, NameDispenser& _dispenser)
FullInliner	libyul/optimiser/FullInliner.h	/^class FullInliner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
FullInliner::FullInliner	libyul/optimiser/FullInliner.cpp	/^FullInliner::FullInliner(Block& _ast, NameDispenser& _dispenser):$/;"	f	class:FullInliner	signature:(Block& _ast, NameDispenser& _dispenser)
FullInliner::handleBlock	libyul/optimiser/FullInliner.cpp	/^void FullInliner::handleBlock(YulString _currentFunctionName, Block& _block)$/;"	f	class:FullInliner	signature:(YulString _currentFunctionName, Block& _block)
FullInliner::run	libyul/optimiser/FullInliner.cpp	/^void FullInliner::run()$/;"	f	class:FullInliner	signature:()
FullInliner::shallInline	libyul/optimiser/FullInliner.cpp	/^bool FullInliner::shallInline(FunctionCall const& _funCall, YulString _callSite)$/;"	f	class:FullInliner	signature:(FunctionCall const& _funCall, YulString _callSite)
FullInliner::tentativelyUpdateCodeSize	libyul/optimiser/FullInliner.cpp	/^void FullInliner::tentativelyUpdateCodeSize(YulString _function, YulString _callSite)$/;"	f	class:FullInliner	signature:(YulString _function, YulString _callSite)
FullInliner::updateCodeSize	libyul/optimiser/FullInliner.cpp	/^void FullInliner::updateCodeSize(FunctionDefinition const& _fun)$/;"	f	class:FullInliner	signature:(FunctionDefinition const& _fun)
Function	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
Function	libsolidity/formal/SolverInterface.h	/^	Function,$/;"	m	class:dev::solidity::smt::Kind	access:private
Function	libyul/AsmScope.h	/^	struct Function$/;"	s	struct:yul::Scope	access:public
FunctionCall	libsolidity/ast/AST.h	/^	FunctionCall($/;"	f	class:dev::solidity::FunctionCall	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _expression, std::vector<ASTPointer<Expression>> const& _arguments, std::vector<ASTPointer<ASTString>> const& _names )
FunctionCall	libsolidity/ast/AST.h	/^class FunctionCall: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
FunctionCall	libsolidity/ast/ASTAnnotations.h	/^	FunctionCall,$/;"	m	class:dev::solidity::FunctionCallKind	access:private
FunctionCall	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	s	namespace:yul
FunctionCall::annotation	libsolidity/ast/AST.cpp	/^FunctionCallAnnotation& FunctionCall::annotation() const$/;"	f	class:FunctionCall	signature:() const
FunctionCallAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct FunctionCallAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
FunctionCallKind	libsolidity/ast/ASTAnnotations.h	/^enum class FunctionCallKind$/;"	c	namespace:dev::solidity
FunctionCompilationQueue	libsolidity/codegen/CompilerContext.h	/^	struct FunctionCompilationQueue$/;"	s	class:dev::solidity::CompilerContext	access:private
FunctionDefinition	libsolidity/ast/AST.h	/^	FunctionDefinition($/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, Declaration::Visibility _visibility, StateMutability _stateMutability, bool _isConstructor, ASTPointer<ASTString> const& _documentation, ASTPointer<ParameterList> const& _parameters, std::vector<ASTPointer<ModifierInvocation>> const& _modifiers, ASTPointer<ParameterList> const& _returnParameters, ASTPointer<Block> const& _body )
FunctionDefinition	libsolidity/ast/AST.h	/^class FunctionDefinition: public CallableDeclaration, public Documented, public ImplementationOptional$/;"	c	namespace:dev::solidity	inherits:CallableDeclaration,Documented,ImplementationOptional
FunctionDefinition	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	s	namespace:yul
FunctionDefinition::annotation	libsolidity/ast/AST.cpp	/^FunctionDefinitionAnnotation& FunctionDefinition::annotation() const$/;"	f	class:FunctionDefinition	signature:() const
FunctionDefinition::externalSignature	libsolidity/ast/AST.cpp	/^string FunctionDefinition::externalSignature() const$/;"	f	class:FunctionDefinition	signature:() const
FunctionDefinition::functionType	libsolidity/ast/AST.cpp	/^FunctionTypePointer FunctionDefinition::functionType(bool _internal) const$/;"	f	class:FunctionDefinition	signature:(bool _internal) const
FunctionDefinition::inContractKind	libsolidity/ast/AST.cpp	/^ContractDefinition::ContractKind FunctionDefinition::inContractKind() const$/;"	f	class:FunctionDefinition	signature:() const
FunctionDefinition::type	libsolidity/ast/AST.cpp	/^TypePointer FunctionDefinition::type() const$/;"	f	class:FunctionDefinition	signature:() const
FunctionDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct FunctionDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
FunctionFlow	libsolidity/analysis/ControlFlowGraph.h	/^struct FunctionFlow$/;"	s	namespace:dev::solidity
FunctionGrouper	libyul/optimiser/FunctionGrouper.h	/^class FunctionGrouper$/;"	c	namespace:yul
FunctionGrouper::alreadyGrouped	libyul/optimiser/FunctionGrouper.cpp	/^bool FunctionGrouper::alreadyGrouped(Block const& _block)$/;"	f	class:FunctionGrouper	signature:(Block const& _block)
FunctionGrouper::operator ()	libyul/optimiser/FunctionGrouper.cpp	/^void FunctionGrouper::operator()(Block& _block)$/;"	f	class:FunctionGrouper	signature:(Block& _block)
FunctionHeaderParserResult	libsolidity/parsing/Parser.h	/^	struct FunctionHeaderParserResult$/;"	s	class:dev::solidity::Parser	access:private
FunctionHoister	libyul/optimiser/FunctionHoister.h	/^class FunctionHoister: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
FunctionHoister::operator ()	libyul/optimiser/FunctionHoister.cpp	/^void FunctionHoister::operator()(Block& _block)$/;"	f	class:FunctionHoister	signature:(Block& _block)
FunctionSort	libsolidity/formal/SolverInterface.h	/^	FunctionSort(std::vector<SortPointer> _domain, SortPointer _codomain):$/;"	f	struct:dev::solidity::smt::FunctionSort	access:public	signature:(std::vector<SortPointer> _domain, SortPointer _codomain)
FunctionSort	libsolidity/formal/SolverInterface.h	/^struct FunctionSort: public Sort$/;"	s	namespace:dev::solidity::smt	inherits:Sort
FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(EventDefinition const& _event):$/;"	f	class:FunctionType	signature:(EventDefinition const& _event)
FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(FunctionDefinition const& _function, bool _isInternal):$/;"	f	class:FunctionType	signature:(FunctionDefinition const& _function, bool _isInternal)
FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(FunctionTypeName const& _typeName):$/;"	f	class:FunctionType	signature:(FunctionTypeName const& _typeName)
FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(VariableDeclaration const& _varDecl):$/;"	f	class:FunctionType	signature:(VariableDeclaration const& _varDecl)
FunctionType	libsolidity/ast/Types.h	/^	FunctionType($/;"	f	class:dev::solidity::FunctionType	access:public	signature:( TypePointers const& _parameterTypes, TypePointers const& _returnParameterTypes, strings _parameterNames = strings(), strings _returnParameterNames = strings(), Kind _kind = Kind::Internal, bool _arbitraryParameters = false, StateMutability _stateMutability = StateMutability::NonPayable, Declaration const* _declaration = nullptr, bool _gasSet = false, bool _valueSet = false, bool _bound = false )
FunctionType	libsolidity/ast/Types.h	/^	FunctionType($/;"	f	class:dev::solidity::FunctionType	access:public	signature:( strings const& _parameterTypes, strings const& _returnParameterTypes, Kind _kind = Kind::Internal, bool _arbitraryParameters = false, StateMutability _stateMutability = StateMutability::NonPayable )
FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(EventDefinition const& _event);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(EventDefinition const& _event)
FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(FunctionDefinition const& _function, bool _isInternal = true);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionDefinition const& _function, bool _isInternal = true)
FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(FunctionTypeName const& _typeName);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionTypeName const& _typeName)
FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(VariableDeclaration const& _varDecl)
FunctionType	libsolidity/ast/Types.h	/^class FunctionType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
FunctionType::FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(EventDefinition const& _event):$/;"	f	class:FunctionType	signature:(EventDefinition const& _event)
FunctionType::FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(FunctionDefinition const& _function, bool _isInternal):$/;"	f	class:FunctionType	signature:(FunctionDefinition const& _function, bool _isInternal)
FunctionType::FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(FunctionTypeName const& _typeName):$/;"	f	class:FunctionType	signature:(FunctionTypeName const& _typeName)
FunctionType::FunctionType	libsolidity/ast/Types.cpp	/^FunctionType::FunctionType(VariableDeclaration const& _varDecl):$/;"	f	class:FunctionType	signature:(VariableDeclaration const& _varDecl)
FunctionType::asCallableFunction	libsolidity/ast/Types.cpp	/^FunctionTypePointer FunctionType::asCallableFunction(bool _inLibrary, bool _bound) const$/;"	f	class:FunctionType	signature:(bool _inLibrary, bool _bound) const
FunctionType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FunctionType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:FunctionType	signature:(Token _operator, TypePointer const& _other) const
FunctionType::calldataEncodedSize	libsolidity/ast/Types.cpp	/^unsigned FunctionType::calldataEncodedSize(bool _padded) const$/;"	f	class:FunctionType	signature:(bool _padded) const
FunctionType::canTakeArguments	libsolidity/ast/Types.cpp	/^bool FunctionType::canTakeArguments(TypePointers const& _argumentTypes, TypePointer const& _selfType) const$/;"	f	class:FunctionType	signature:(TypePointers const& _argumentTypes, TypePointer const& _selfType) const
FunctionType::canonicalName	libsolidity/ast/Types.cpp	/^string FunctionType::canonicalName() const$/;"	f	class:FunctionType	signature:() const
FunctionType::copyAndSetGasOrValue	libsolidity/ast/Types.cpp	/^TypePointer FunctionType::copyAndSetGasOrValue(bool _setGas, bool _setValue) const$/;"	f	class:FunctionType	signature:(bool _setGas, bool _setValue) const
FunctionType::documentation	libsolidity/ast/Types.cpp	/^ASTPointer<ASTString> FunctionType::documentation() const$/;"	f	class:FunctionType	signature:() const
FunctionType::encodingType	libsolidity/ast/Types.cpp	/^TypePointer FunctionType::encodingType() const$/;"	f	class:FunctionType	signature:() const
FunctionType::equalExcludingStateMutability	libsolidity/ast/Types.cpp	/^bool FunctionType::equalExcludingStateMutability(FunctionType const& _other) const$/;"	f	class:FunctionType	signature:(FunctionType const& _other) const
FunctionType::externalIdentifier	libsolidity/ast/Types.cpp	/^u256 FunctionType::externalIdentifier() const$/;"	f	class:FunctionType	signature:() const
FunctionType::externalSignature	libsolidity/ast/Types.cpp	/^string FunctionType::externalSignature() const$/;"	f	class:FunctionType	signature:() const
FunctionType::hasEqualParameterTypes	libsolidity/ast/Types.cpp	/^bool FunctionType::hasEqualParameterTypes(FunctionType const& _other) const$/;"	f	class:FunctionType	signature:(FunctionType const& _other) const
FunctionType::hasEqualReturnTypes	libsolidity/ast/Types.cpp	/^bool FunctionType::hasEqualReturnTypes(FunctionType const& _other) const$/;"	f	class:FunctionType	signature:(FunctionType const& _other) const
FunctionType::interfaceFunctionType	libsolidity/ast/Types.cpp	/^FunctionTypePointer FunctionType::interfaceFunctionType() const$/;"	f	class:FunctionType	signature:() const
FunctionType::interfaceType	libsolidity/ast/Types.cpp	/^TypePointer FunctionType::interfaceType(bool \/*_inLibrary*\/) const$/;"	f	class:FunctionType	signature:(bool ) const
FunctionType::isBareCall	libsolidity/ast/Types.cpp	/^bool FunctionType::isBareCall() const$/;"	f	class:FunctionType	signature:() const
FunctionType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FunctionType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FunctionType	signature:(Type const& _convertTo) const
FunctionType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FunctionType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FunctionType	signature:(Type const& _convertTo) const
FunctionType::isPure	libsolidity/ast/Types.cpp	/^bool FunctionType::isPure() const$/;"	f	class:FunctionType	signature:() const
FunctionType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap FunctionType::nativeMembers(ContractDefinition const*) const$/;"	f	class:FunctionType	signature:(ContractDefinition const*) const
FunctionType::newExpressionType	libsolidity/ast/Types.cpp	/^FunctionTypePointer FunctionType::newExpressionType(ContractDefinition const& _contract)$/;"	f	class:FunctionType	signature:(ContractDefinition const& _contract)
FunctionType::operator ==	libsolidity/ast/Types.cpp	/^bool FunctionType::operator==(Type const& _other) const$/;"	f	class:FunctionType	signature:(Type const& _other) const
FunctionType::padArguments	libsolidity/ast/Types.cpp	/^bool FunctionType::padArguments() const$/;"	f	class:FunctionType	signature:() const
FunctionType::parameterNames	libsolidity/ast/Types.cpp	/^vector<string> FunctionType::parameterNames() const$/;"	f	class:FunctionType	signature:() const
FunctionType::parameterTypes	libsolidity/ast/Types.cpp	/^TypePointers FunctionType::parameterTypes() const$/;"	f	class:FunctionType	signature:() const
FunctionType::parseElementaryTypeVector	libsolidity/ast/Types.cpp	/^TypePointers FunctionType::parseElementaryTypeVector(strings const& _types)$/;"	f	class:FunctionType	signature:(strings const& _types)
FunctionType::returnParameterTypesWithoutDynamicTypes	libsolidity/ast/Types.cpp	/^TypePointers FunctionType::returnParameterTypesWithoutDynamicTypes() const$/;"	f	class:FunctionType	signature:() const
FunctionType::richIdentifier	libsolidity/ast/Types.cpp	/^string FunctionType::richIdentifier() const$/;"	f	class:FunctionType	signature:() const
FunctionType::selfType	libsolidity/ast/Types.cpp	/^TypePointer const& FunctionType::selfType() const$/;"	f	class:FunctionType	signature:() const
FunctionType::sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned FunctionType::sizeOnStack() const$/;"	f	class:FunctionType	signature:() const
FunctionType::storageBytes	libsolidity/ast/Types.cpp	/^unsigned FunctionType::storageBytes() const$/;"	f	class:FunctionType	signature:() const
FunctionType::storageSize	libsolidity/ast/Types.cpp	/^u256 FunctionType::storageSize() const$/;"	f	class:FunctionType	signature:() const
FunctionType::toString	libsolidity/ast/Types.cpp	/^string FunctionType::toString(bool _short) const$/;"	f	class:FunctionType	signature:(bool _short) const
FunctionType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FunctionType::unaryOperatorResult(Token _operator) const$/;"	f	class:FunctionType	signature:(Token _operator) const
FunctionTypeName	libsolidity/ast/AST.h	/^	FunctionTypeName($/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:( SourceLocation const& _location, ASTPointer<ParameterList> const& _parameterTypes, ASTPointer<ParameterList> const& _returnTypes, Declaration::Visibility _visibility, StateMutability _stateMutability )
FunctionTypeName	libsolidity/ast/AST.h	/^class FunctionTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
FunctionalInstruction	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	s	namespace:yul
Functionalizer	libevmasm/Assembly.cpp	/^	Functionalizer (ostream& _out, string const& _prefix, StringMap const& _sourceCodes):$/;"	f	class:__anon18::Functionalizer	access:public	signature:(ostream& _out, string const& _prefix, StringMap const& _sourceCodes)
Functionalizer	libevmasm/Assembly.cpp	/^class Functionalizer$/;"	c	namespace:__anon18	file:
GAS	libevmasm/Instruction.h	/^	GAS,				\/\/\/< get the amount of available gas$/;"	m	class:dev::solidity::Instruction	access:private
GASLIMIT	libevmasm/Instruction.h	/^	GASLIMIT,			\/\/\/< get the block's gas limit$/;"	m	class:dev::solidity::Instruction	access:private
GASPRICE	libevmasm/Instruction.h	/^	GASPRICE,			\/\/\/< get price of gas in current environment$/;"	m	class:dev::solidity::Instruction	access:private
GETLOCAL	libevmasm/Instruction.h	/^	GETLOCAL,           \/\/\/< push local variable to top of stack -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
GREEN	libdevcore/AnsiColorized.h	/^static constexpr char const* GREEN = "\\033[32m";$/;"	m	namespace:dev::formatting
GREEN_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* GREEN_BACKGROUND = "\\033[42m";$/;"	m	namespace:dev::formatting
GT	libevmasm/Instruction.h	/^	GT,					\/\/\/< greater-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
GasConsumption	libevmasm/GasMeter.h	/^		GasConsumption(u256 _value, bool _infinite = false): value(_value), isInfinite(_infinite) {}$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(u256 _value, bool _infinite = false)
GasConsumption	libevmasm/GasMeter.h	/^		GasConsumption(unsigned _value = 0, bool _infinite = false): value(_value), isInfinite(_infinite) {}$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(unsigned _value = 0, bool _infinite = false)
GasConsumption	libevmasm/GasMeter.h	/^	struct GasConsumption$/;"	s	class:dev::eth::GasMeter	access:public
GasCosts	libevmasm/GasMeter.h	/^namespace GasCosts$/;"	n	namespace:dev::eth
GasEstimator	libsolidity/interface/GasEstimator.h	/^	explicit GasEstimator(langutil::EVMVersion _evmVersion): m_evmVersion(_evmVersion) {}$/;"	f	struct:dev::solidity::GasEstimator	access:public	signature:(langutil::EVMVersion _evmVersion)
GasEstimator	libsolidity/interface/GasEstimator.h	/^struct GasEstimator$/;"	s	namespace:dev::solidity
GasEstimator::breakToStatementLevel	libsolidity/interface/GasEstimator.cpp	/^map<ASTNode const*, GasMeter::GasConsumption> GasEstimator::breakToStatementLevel($/;"	f	class:GasEstimator	signature:( ASTGasConsumptionSelfAccumulated const& _gasCosts, vector<ASTNode const*> const& _roots )
GasEstimator::finestNodesAtLocation	libsolidity/interface/GasEstimator.cpp	/^set<ASTNode const*> GasEstimator::finestNodesAtLocation($/;"	f	class:GasEstimator	signature:( vector<ASTNode const*> const& _roots )
GasEstimator::functionalEstimation	libsolidity/interface/GasEstimator.cpp	/^GasEstimator::GasConsumption GasEstimator::functionalEstimation($/;"	f	class:GasEstimator	signature:( AssemblyItems const& _items, size_t const& _offset, FunctionDefinition const& _function ) const
GasEstimator::functionalEstimation	libsolidity/interface/GasEstimator.cpp	/^GasEstimator::GasConsumption GasEstimator::functionalEstimation($/;"	f	class:GasEstimator	signature:( AssemblyItems const& _items, string const& _signature ) const
GasEstimator::structuralEstimation	libsolidity/interface/GasEstimator.cpp	/^GasEstimator::ASTGasConsumptionSelfAccumulated GasEstimator::structuralEstimation($/;"	f	class:GasEstimator	signature:( AssemblyItems const& _items, vector<ASTNode const*> const& _ast ) const
GasLeft	libsolidity/ast/Types.h	/^		GasLeft, \/\/\/< gasleft()$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
GasMeter	libevmasm/GasMeter.h	/^	GasMeter(std::shared_ptr<KnownState> const& _state, langutil::EVMVersion _evmVersion, u256 const& _largestMemoryAccess = 0):$/;"	f	class:dev::eth::GasMeter	access:public	signature:(std::shared_ptr<KnownState> const& _state, langutil::EVMVersion _evmVersion, u256 const& _largestMemoryAccess = 0)
GasMeter	libevmasm/GasMeter.h	/^class GasMeter$/;"	c	namespace:dev::eth
GasMeter::GasConsumption::operator +=	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption& GasMeter::GasConsumption::operator+=(GasConsumption const& _other)$/;"	f	class:GasMeter::GasConsumption	signature:(GasConsumption const& _other)
GasMeter::dataGas	libevmasm/GasMeter.cpp	/^u256 GasMeter::dataGas(bytes const& _data, bool _inCreation)$/;"	f	class:GasMeter	signature:(bytes const& _data, bool _inCreation)
GasMeter::estimateMax	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::estimateMax(AssemblyItem const& _item, bool _includeExternalCosts)$/;"	f	class:GasMeter	signature:(AssemblyItem const& _item, bool _includeExternalCosts)
GasMeter::memoryGas	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::memoryGas(ExpressionClasses::Id _position)$/;"	f	class:GasMeter	signature:(ExpressionClasses::Id _position)
GasMeter::memoryGas	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::memoryGas(int _stackPosOffset, int _stackPosSize)$/;"	f	class:GasMeter	signature:(int _stackPosOffset, int _stackPosSize)
GasMeter::runGas	libevmasm/GasMeter.cpp	/^unsigned GasMeter::runGas(Instruction _instruction)$/;"	f	class:GasMeter	signature:(Instruction _instruction)
GasMeter::wordGas	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::wordGas(u256 const& _multiplier, ExpressionClasses::Id _value)$/;"	f	class:GasMeter	signature:(u256 const& _multiplier, ExpressionClasses::Id _value)
GasPath	libevmasm/PathGasMeter.h	/^struct GasPath$/;"	s	namespace:dev::eth
GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^	explicit GenericFallbackReturnsVisitor($/;"	f	struct:dev::GenericFallbackReturnsVisitor	access:public	signature:( std::function<R(Visitable&)> _visitor, std::function<R(Others&)>... _otherVisitors )
GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^struct GenericFallbackReturnsVisitor<R, Visitable, Others...>: public GenericFallbackReturnsVisitor<R, Others...>$/;"	s	namespace:dev	inherits:GenericFallbackReturnsVisitor
GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^struct GenericFallbackReturnsVisitor<R>: public boost::static_visitor<R> {$/;"	s	namespace:dev	inherits:boost::static_visitor
GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^struct GenericFallbackReturnsVisitor{};$/;"	s	namespace:dev
GenericFallbackVisitor	libdevcore/Visitor.h	/^	explicit GenericFallbackVisitor($/;"	f	struct:dev::GenericFallbackVisitor	access:public	signature:( std::function<void(Visitable&)> _visitor, std::function<void(Others&)>... _otherVisitors )
GenericFallbackVisitor	libdevcore/Visitor.h	/^struct GenericFallbackVisitor<>: public boost::static_visitor<> {$/;"	s	namespace:dev	inherits:boost::static_visitor
GenericFallbackVisitor	libdevcore/Visitor.h	/^struct GenericFallbackVisitor<Visitable, Others...>: public GenericFallbackVisitor<Others...>$/;"	s	namespace:dev	inherits:GenericFallbackVisitor
GenericFallbackVisitor	libdevcore/Visitor.h	/^struct GenericFallbackVisitor{};$/;"	s	namespace:dev
GenericVisitor	libdevcore/Visitor.h	/^	explicit GenericVisitor($/;"	f	struct:dev::GenericVisitor	access:public	signature:( std::function<void(Visitable&)> _visitor, std::function<void(Others&)>... _otherVisitors )
GenericVisitor	libdevcore/Visitor.h	/^struct GenericVisitor<>: public boost::static_visitor<> {$/;"	s	namespace:dev	inherits:boost::static_visitor
GenericVisitor	libdevcore/Visitor.h	/^struct GenericVisitor<Visitable, Others...>: public GenericVisitor<Others...>$/;"	s	namespace:dev	inherits:GenericVisitor
GenericVisitor	libdevcore/Visitor.h	/^struct GenericVisitor{};$/;"	s	namespace:dev
GlobalContext	libsolidity/analysis/GlobalContext.cpp	/^GlobalContext::GlobalContext():$/;"	f	class:dev::solidity::GlobalContext	signature:()
GlobalContext	libsolidity/analysis/GlobalContext.h	/^	GlobalContext();$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:()
GlobalContext	libsolidity/analysis/GlobalContext.h	/^class GlobalContext: private boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
Handle	libyul/YulString.h	/^	struct Handle$/;"	s	class:yul::YulStringRepository	access:public
HexCase	libdevcore/CommonData.h	/^enum class HexCase$/;"	c	namespace:dev
HexPrefix	libdevcore/CommonData.h	/^enum class HexPrefix$/;"	c	namespace:dev
High	libevmasm/Instruction.h	/^	High,		\/\/ 10, Slow$/;"	m	class:dev::solidity::Instruction::Tier	access:private
Homestead	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
Hour	libsolidity/ast/AST.h	/^		Hour = static_cast<int>(Token::SubHour),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
IDDispenser	libsolidity/ast/AST.cpp	/^class IDDispenser$/;"	c	file:
IDDispenser::id	libsolidity/ast/AST.cpp	/^	size_t id = 0;$/;"	m	class:IDDispenser	file:	access:private
IDDispenser::instance	libsolidity/ast/AST.cpp	/^	static size_t& instance()$/;"	f	class:IDDispenser	file:	access:private	signature:()
IDDispenser::next	libsolidity/ast/AST.cpp	/^	static size_t next() { return ++instance(); }$/;"	f	class:IDDispenser	access:public	signature:()
IDDispenser::reset	libsolidity/ast/AST.cpp	/^	static void reset() { instance() = 0; }$/;"	f	class:IDDispenser	access:public	signature:()
IGNORE_TOKEN	liblangutil/Token.h	69;"	d
IN	liblangutil/UndefMacros.h	29;"	d
INVALID	libevmasm/Instruction.h	/^	INVALID = 0xfe,		\/\/\/< invalid instruction for expressing runtime errors (e.g., division-by-zero)$/;"	m	class:dev::solidity::Instruction	access:private
INVERSE	libdevcore/AnsiColorized.h	/^static constexpr char const* INVERSE = "\\033[7m";$/;"	m	namespace:dev::formatting
ISZERO	libevmasm/Instruction.h	/^	ISZERO,				\/\/\/< simple not operator$/;"	m	class:dev::solidity::Instruction	access:private
Identifier	libsolidity/ast/AST.h	/^	Identifier($/;"	f	class:dev::solidity::Identifier	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name )
Identifier	libsolidity/ast/AST.h	/^class Identifier: public PrimaryExpression$/;"	c	namespace:dev::solidity	inherits:PrimaryExpression
Identifier	libyul/AsmData.h	/^struct Identifier { langutil::SourceLocation location; YulString name; };$/;"	s	namespace:yul
Identifier::annotation	libsolidity/ast/AST.cpp	/^IdentifierAnnotation& Identifier::annotation() const$/;"	f	class:Identifier	signature:() const
IdentifierAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct IdentifierAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
IdentifierContext	libyul/backends/evm/AbstractAssembly.h	/^enum class IdentifierContext { LValue, RValue };$/;"	c	class:dev::solidity::Instruction	access:private
Identity	libevmasm/PeepholeOptimiser.cpp	/^struct Identity: SimplePeepholeOptimizerMethod<Identity, 1>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
If	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	s	namespace:yul
IfStatement	libsolidity/ast/AST.h	/^	IfStatement($/;"	f	class:dev::solidity::IfStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _condition, ASTPointer<Statement> const& _trueBody, ASTPointer<Statement> const& _falseBody )
IfStatement	libsolidity/ast/AST.h	/^class IfStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
IllegalCommentTerminator	liblangutil/Scanner.h	/^	IllegalCommentTerminator,$/;"	m	class:langutil::ScannerError	access:private
IllegalEscapeSequence	liblangutil/Scanner.h	/^	IllegalEscapeSequence,$/;"	m	class:langutil::ScannerError	access:private
IllegalExponent	liblangutil/Scanner.h	/^	IllegalExponent,$/;"	m	class:langutil::ScannerError	access:private
IllegalHexDigit	liblangutil/Scanner.h	/^	IllegalHexDigit,$/;"	m	class:langutil::ScannerError	access:private
IllegalHexString	liblangutil/Scanner.h	/^	IllegalHexString,$/;"	m	class:langutil::ScannerError	access:private
IllegalNumberEnd	liblangutil/Scanner.h	/^	IllegalNumberEnd,$/;"	m	class:langutil::ScannerError	access:private
IllegalNumberSeparator	liblangutil/Scanner.h	/^	IllegalNumberSeparator,$/;"	m	class:langutil::ScannerError	access:private
IllegalStringEndQuote	liblangutil/Scanner.h	/^	IllegalStringEndQuote,$/;"	m	class:langutil::ScannerError	access:private
IllegalToken	liblangutil/Scanner.h	/^	IllegalToken,$/;"	m	class:langutil::ScannerError	access:private
ImplementationOptional	libsolidity/ast/AST.h	/^	explicit ImplementationOptional(bool _implemented): m_implemented(_implemented) {}$/;"	f	class:dev::solidity::ImplementationOptional	access:public	signature:(bool _implemented)
ImplementationOptional	libsolidity/ast/AST.h	/^class ImplementationOptional$/;"	c	namespace:dev::solidity
ImportAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ImportAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
ImportDirective	libsolidity/ast/AST.h	/^	ImportDirective($/;"	f	class:dev::solidity::ImportDirective	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _path, ASTPointer<ASTString> const& _unitAlias, std::vector<std::pair<ASTPointer<Identifier>, ASTPointer<ASTString>>>&& _symbolAliases )
ImportDirective	libsolidity/ast/AST.h	/^class ImportDirective: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
ImportDirective::annotation	libsolidity/ast/AST.cpp	/^ImportAnnotation& ImportDirective::annotation() const$/;"	f	class:ImportDirective	signature:() const
ImportDirective::type	libsolidity/ast/AST.cpp	/^TypePointer ImportDirective::type() const$/;"	f	class:ImportDirective	signature:() const
InaccessibleDynamicType	libsolidity/ast/Types.h	/^class InaccessibleDynamicType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
IndentedWriter	libdevcore/IndentedWriter.h	/^class IndentedWriter$/;"	c	namespace:dev
IndentedWriter::add	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::add(string const& _str)$/;"	f	class:IndentedWriter	signature:(string const& _str)
IndentedWriter::addLine	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::addLine(string const& _line)$/;"	f	class:IndentedWriter	signature:(string const& _line)
IndentedWriter::format	libdevcore/IndentedWriter.cpp	/^string IndentedWriter::format() const$/;"	f	class:IndentedWriter	signature:() const
IndentedWriter::indent	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::indent()$/;"	f	class:IndentedWriter	signature:()
IndentedWriter::newLine	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::newLine()$/;"	f	class:IndentedWriter	signature:()
IndentedWriter::unindent	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::unindent()$/;"	f	class:IndentedWriter	signature:()
IndexAccess	libsolidity/ast/AST.h	/^	IndexAccess($/;"	f	class:dev::solidity::IndexAccess	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _base, ASTPointer<Expression> const& _index )
IndexAccess	libsolidity/ast/AST.h	/^class IndexAccess: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
IndexAccessStructure	libsolidity/parsing/Parser.h	/^		IndexAccessStructure, VariableDeclaration, Expression$/;"	m	class:dev::solidity::Parser::LookAheadInfo	access:private
IndexAccessedPath	libsolidity/parsing/Parser.h	/^	struct IndexAccessedPath$/;"	s	class:dev::solidity::Parser	access:private
InheritanceSpecifier	libsolidity/ast/AST.h	/^	InheritanceSpecifier($/;"	f	class:dev::solidity::InheritanceSpecifier	access:public	signature:( SourceLocation const& _location, ASTPointer<UserDefinedTypeName> const& _baseName, std::unique_ptr<std::vector<ASTPointer<Expression>>> _arguments )
InheritanceSpecifier	libsolidity/ast/AST.h	/^class InheritanceSpecifier: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
InlinableExpressionFunctionFinder	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^class InlinableExpressionFunctionFinder: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
InlinableExpressionFunctionFinder::operator ()	libyul/optimiser/InlinableExpressionFunctionFinder.cpp	/^void InlinableExpressionFunctionFinder::operator()(FunctionCall const& _funCall)$/;"	f	class:InlinableExpressionFunctionFinder	signature:(FunctionCall const& _funCall)
InlinableExpressionFunctionFinder::operator ()	libyul/optimiser/InlinableExpressionFunctionFinder.cpp	/^void InlinableExpressionFunctionFinder::operator()(FunctionDefinition const& _function)$/;"	f	class:InlinableExpressionFunctionFinder	signature:(FunctionDefinition const& _function)
InlinableExpressionFunctionFinder::operator ()	libyul/optimiser/InlinableExpressionFunctionFinder.cpp	/^void InlinableExpressionFunctionFinder::operator()(Identifier const& _identifier)$/;"	f	class:InlinableExpressionFunctionFinder	signature:(Identifier const& _identifier)
InlineAssembly	libsolidity/ast/AST.h	/^	InlineAssembly($/;"	f	class:dev::solidity::InlineAssembly	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, std::shared_ptr<yul::Block> const& _operations )
InlineAssembly	libsolidity/ast/AST.h	/^class InlineAssembly: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
InlineAssembly::annotation	libsolidity/ast/AST.cpp	/^InlineAssemblyAnnotation& InlineAssembly::annotation() const$/;"	f	class:InlineAssembly	signature:() const
InlineAssemblyAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct InlineAssemblyAnnotation: StatementAnnotation$/;"	s	namespace:dev::solidity	inherits:StatementAnnotation
InlineModifier	libyul/optimiser/FullInliner.h	/^	InlineModifier(FullInliner& _driver, NameDispenser& _nameDispenser, YulString _functionName):$/;"	f	class:yul::InlineModifier	access:public	signature:(FullInliner& _driver, NameDispenser& _nameDispenser, YulString _functionName)
InlineModifier	libyul/optimiser/FullInliner.h	/^class InlineModifier: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
InlineModifier::operator ()	libyul/optimiser/FullInliner.cpp	/^void InlineModifier::operator()(Block& _block)$/;"	f	class:InlineModifier	signature:(Block& _block)
InlineModifier::performInline	libyul/optimiser/FullInliner.cpp	/^vector<Statement> InlineModifier::performInline(Statement& _statement, FunctionCall& _funCall)$/;"	f	class:InlineModifier	signature:(Statement& _statement, FunctionCall& _funCall)
InlineModifier::tryInlineStatement	libyul/optimiser/FullInliner.cpp	/^boost::optional<vector<Statement>> InlineModifier::tryInlineStatement(Statement& _statement)$/;"	f	class:InlineModifier	signature:(Statement& _statement)
Instruction	libevmasm/Instruction.h	/^enum class Instruction: uint8_t$/;"	c	namespace:dev::solidity	inherits:uint8_t
Instruction	libyul/AsmData.h	/^struct Instruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; };$/;"	s	namespace:yul
Instruction	libyul/backends/evm/AbstractAssembly.h	/^enum class Instruction: uint8_t;$/;"	c	namespace:dev::solidity	inherits:uint8_t,yul
InstructionInfo	libevmasm/Instruction.h	/^struct InstructionInfo$/;"	s	class:dev::solidity::Instruction	access:private
Int	libsolidity/formal/SolverInterface.h	/^	Int,$/;"	m	class:dev::solidity::smt::Kind	access:private
Integer	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
IntegerType	libsolidity/ast/Types.cpp	/^IntegerType::IntegerType(unsigned _bits, IntegerType::Modifier _modifier):$/;"	f	class:IntegerType	signature:(unsigned _bits, IntegerType::Modifier _modifier)
IntegerType	libsolidity/ast/Types.h	/^	explicit IntegerType(unsigned _bits, Modifier _modifier = Modifier::Unsigned);$/;"	p	class:dev::solidity::IntegerType	access:public	signature:(unsigned _bits, Modifier _modifier = Modifier::Unsigned)
IntegerType	libsolidity/ast/Types.h	/^class IntegerType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
IntegerType::IntegerType	libsolidity/ast/Types.cpp	/^IntegerType::IntegerType(unsigned _bits, IntegerType::Modifier _modifier):$/;"	f	class:IntegerType	signature:(unsigned _bits, IntegerType::Modifier _modifier)
IntegerType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult IntegerType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:IntegerType	signature:(Token _operator, TypePointer const& _other) const
IntegerType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult IntegerType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:IntegerType	signature:(Type const& _convertTo) const
IntegerType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult IntegerType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:IntegerType	signature:(Type const& _convertTo) const
IntegerType::maxValue	libsolidity/ast/Types.cpp	/^bigint IntegerType::maxValue() const$/;"	f	class:IntegerType	signature:() const
IntegerType::minValue	libsolidity/ast/Types.cpp	/^bigint IntegerType::minValue() const$/;"	f	class:IntegerType	signature:() const
IntegerType::operator ==	libsolidity/ast/Types.cpp	/^bool IntegerType::operator==(Type const& _other) const$/;"	f	class:IntegerType	signature:(Type const& _other) const
IntegerType::richIdentifier	libsolidity/ast/Types.cpp	/^string IntegerType::richIdentifier() const$/;"	f	class:IntegerType	signature:() const
IntegerType::toString	libsolidity/ast/Types.cpp	/^string IntegerType::toString(bool) const$/;"	f	class:IntegerType	signature:(bool) const
IntegerType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult IntegerType::unaryOperatorResult(Token _operator) const$/;"	f	class:IntegerType	signature:(Token _operator) const
Interface	libsolidity/ast/AST.h	/^	enum class ContractKind { Interface, Contract, Library };$/;"	m	class:dev::solidity::ContractDefinition::ContractKind	access:private
Internal	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
Internal	libsolidity/ast/Types.h	/^		Internal, \/\/\/< stack-call using plain JUMP$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
InternalCompilerError	liblangutil/Exceptions.h	/^struct InternalCompilerError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
IntoFunction	libevmasm/AssemblyItem.h	/^	enum class JumpType { Ordinary, IntoFunction, OutOfFunction };$/;"	m	class:dev::eth::AssemblyItem::JumpType	access:private
Invalid	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	e	enum:dev::eth::KnownState::StoreOperation::Target
ItemNotAvailableException	libevmasm/Exceptions.h	/^struct ItemNotAvailableException: virtual OptimizerException {};$/;"	s	namespace:dev::eth	inherits:OptimizerException
JUMP	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	m	class:dev::eth::BasicBlock::EndType	access:private
JUMP	libevmasm/Instruction.h	/^	JUMP,				\/\/\/< alter the program counter$/;"	m	class:dev::solidity::Instruction	access:private
JUMPDEST	libevmasm/Instruction.h	/^	JUMPDEST,			\/\/\/< set a potential jump destination$/;"	m	class:dev::solidity::Instruction	access:private
JUMPI	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	m	class:dev::eth::BasicBlock::EndType	access:private
JUMPI	libevmasm/Instruction.h	/^	JUMPI,				\/\/\/< conditionally alter the program counter$/;"	m	class:dev::solidity::Instruction	access:private
JUMPIF	libevmasm/Instruction.h	/^	JUMPIF,             \/\/\/< conditionally alter the program counter -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
JUMPSUB	libevmasm/Instruction.h	/^	JUMPSUB,            \/\/\/< alter the program counter to a beginsub -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
JUMPSUBV	libevmasm/Instruction.h	/^	JUMPSUBV,           \/\/\/< alter the program counter to a beginsub -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
JUMPTO	libevmasm/Instruction.h	/^	JUMPTO = 0xb0,      \/\/\/< alter the program counter to a jumpdest -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
JUMPV	libevmasm/Instruction.h	/^	JUMPV,              \/\/\/< alter the program counter to a jumpdest -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
Json::CompilerStack::contractABI	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::contractABI(Contract const& _contract) const$/;"	f	class:Json::CompilerStack	signature:(Contract const& _contract) const
Json::CompilerStack::contractABI	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::contractABI(string const& _contractName) const$/;"	f	class:Json::CompilerStack	signature:(string const& _contractName) const
Json::CompilerStack::natspecDev	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecDev(Contract const& _contract) const$/;"	f	class:Json::CompilerStack	signature:(Contract const& _contract) const
Json::CompilerStack::natspecDev	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecDev(string const& _contractName) const$/;"	f	class:Json::CompilerStack	signature:(string const& _contractName) const
Json::CompilerStack::natspecUser	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecUser(Contract const& _contract) const$/;"	f	class:Json::CompilerStack	signature:(Contract const& _contract) const
Json::CompilerStack::natspecUser	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecUser(string const& _contractName) const$/;"	f	class:Json::CompilerStack	signature:(string const& _contractName) const
JumpToNext	libevmasm/PeepholeOptimiser.cpp	/^struct JumpToNext: SimplePeepholeOptimizerMethod<JumpToNext, 3>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
JumpType	libevmasm/AssemblyItem.h	/^	enum class JumpType { Ordinary, IntoFunction, OutOfFunction };$/;"	c	class:dev::eth::AssemblyItem	access:public
JumpdestRemover	libevmasm/JumpdestRemover.h	/^	explicit JumpdestRemover(AssemblyItems& _items): m_items(_items) {}$/;"	f	class:dev::eth::JumpdestRemover	access:public	signature:(AssemblyItems& _items)
JumpdestRemover	libevmasm/JumpdestRemover.h	/^class JumpdestRemover$/;"	c	namespace:dev::eth
JumpdestRemover::optimise	libevmasm/JumpdestRemover.cpp	/^bool JumpdestRemover::optimise(set<size_t> const& _tagsReferencedFromOutside)$/;"	f	class:JumpdestRemover	signature:(set<size_t> const& _tagsReferencedFromOutside)
JumpdestRemover::referencedTags	libevmasm/JumpdestRemover.cpp	/^set<size_t> JumpdestRemover::referencedTags(AssemblyItems const& _items, size_t _subId)$/;"	f	class:JumpdestRemover	signature:(AssemblyItems const& _items, size_t _subId)
KECCAK256	libevmasm/Instruction.h	/^	KECCAK256 = 0x20,		\/\/\/< compute KECCAK-256 hash$/;"	m	class:dev::solidity::Instruction	access:private
KECCAK256	libsolidity/ast/Types.h	/^		KECCAK256, \/\/\/< KECCAK256$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
KEYWORD	liblangutil/Token.cpp	144;"	d	file:
KEYWORD	liblangutil/Token.cpp	147;"	d	file:
Kind	libsolidity/analysis/ControlFlowGraph.h	/^	enum class Kind$/;"	c	class:dev::solidity::VariableOccurrence	access:public
Kind	libsolidity/ast/Types.h	/^	enum class Kind {$/;"	c	class:dev::solidity::MagicType	access:public
Kind	libsolidity/ast/Types.h	/^	enum class Kind$/;"	c	class:dev::solidity::FunctionType	access:public
Kind	libsolidity/formal/SolverInterface.h	/^enum class Kind$/;"	c	namespace:dev::solidity::smt
KnownState	libevmasm/KnownState.h	/^	explicit KnownState($/;"	f	class:dev::eth::KnownState	access:public	signature:( std::shared_ptr<ExpressionClasses> _expressionClasses = std::make_shared<ExpressionClasses>() )
KnownState	libevmasm/KnownState.h	/^class KnownState$/;"	c	namespace:dev::eth
KnownState::applyKeccak256	libevmasm/KnownState.cpp	/^KnownState::Id KnownState::applyKeccak256($/;"	f	class:KnownState	signature:( Id _start, Id _length, SourceLocation const& _location )
KnownState::clearTagUnions	libevmasm/KnownState.cpp	/^void KnownState::clearTagUnions()$/;"	f	class:KnownState	signature:()
KnownState::feedItem	libevmasm/KnownState.cpp	/^KnownState::StoreOperation KnownState::feedItem(AssemblyItem const& _item, bool _copyItem)$/;"	f	class:KnownState	signature:(AssemblyItem const& _item, bool _copyItem)
KnownState::loadFromMemory	libevmasm/KnownState.cpp	/^ExpressionClasses::Id KnownState::loadFromMemory(Id _slot, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(Id _slot, SourceLocation const& _location)
KnownState::loadFromStorage	libevmasm/KnownState.cpp	/^ExpressionClasses::Id KnownState::loadFromStorage(Id _slot, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(Id _slot, SourceLocation const& _location)
KnownState::operator ==	libevmasm/KnownState.cpp	/^bool KnownState::operator==(KnownState const& _other) const$/;"	f	class:KnownState	signature:(KnownState const& _other) const
KnownState::reduceToCommonKnowledge	libevmasm/KnownState.cpp	/^void KnownState::reduceToCommonKnowledge(KnownState const& _other, bool _combineSequenceNumbers)$/;"	f	class:KnownState	signature:(KnownState const& _other, bool _combineSequenceNumbers)
KnownState::relativeStackElement	libevmasm/KnownState.cpp	/^KnownState::Id KnownState::relativeStackElement(int _stackOffset, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(int _stackOffset, SourceLocation const& _location)
KnownState::setStackElement	libevmasm/KnownState.cpp	/^void KnownState::setStackElement(int _stackHeight, Id _class)$/;"	f	class:KnownState	signature:(int _stackHeight, Id _class)
KnownState::stackElement	libevmasm/KnownState.cpp	/^ExpressionClasses::Id KnownState::stackElement(int _stackHeight, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(int _stackHeight, SourceLocation const& _location)
KnownState::storeInMemory	libevmasm/KnownState.cpp	/^KnownState::StoreOperation KnownState::storeInMemory(Id _slot, Id _value, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(Id _slot, Id _value, SourceLocation const& _location)
KnownState::storeInStorage	libevmasm/KnownState.cpp	/^KnownState::StoreOperation KnownState::storeInStorage($/;"	f	class:KnownState	signature:( Id _slot, Id _value, SourceLocation const& _location)
KnownState::stream	libevmasm/KnownState.cpp	/^ostream& KnownState::stream(ostream& _out) const$/;"	f	class:KnownState	signature:(ostream& _out) const
KnownState::swapStackElements	libevmasm/KnownState.cpp	/^void KnownState::swapStackElements($/;"	f	class:KnownState	signature:( int _stackHeightA, int _stackHeightB, SourceLocation const& _location )
KnownState::tagUnion	libevmasm/KnownState.cpp	/^KnownState::Id KnownState::tagUnion(set<u256> _tags)$/;"	f	class:KnownState	signature:(set<u256> _tags)
KnownState::tagsInExpression	libevmasm/KnownState.cpp	/^set<u256> KnownState::tagsInExpression(KnownState::Id _expressionId)$/;"	f	class:KnownState	signature:(KnownState::Id _expressionId)
LITERAL_TYPE_COMMENT	liblangutil/Scanner.cpp	/^	LITERAL_TYPE_COMMENT$/;"	e	enum:langutil::LiteralType	file:
LITERAL_TYPE_NUMBER	liblangutil/Scanner.cpp	/^	LITERAL_TYPE_NUMBER, \/\/ not really different from string type in behaviour$/;"	e	enum:langutil::LiteralType	file:
LITERAL_TYPE_STRING	liblangutil/Scanner.cpp	/^	LITERAL_TYPE_STRING,$/;"	e	enum:langutil::LiteralType	file:
LOG0	libevmasm/Instruction.h	/^	LOG0 = 0xa0,		\/\/\/< Makes a log entry; no topics.$/;"	m	class:dev::solidity::Instruction	access:private
LOG1	libevmasm/Instruction.h	/^	LOG1,				\/\/\/< Makes a log entry; 1 topic.$/;"	m	class:dev::solidity::Instruction	access:private
LOG2	libevmasm/Instruction.h	/^	LOG2,				\/\/\/< Makes a log entry; 2 topics.$/;"	m	class:dev::solidity::Instruction	access:private
LOG3	libevmasm/Instruction.h	/^	LOG3,				\/\/\/< Makes a log entry; 3 topics.$/;"	m	class:dev::solidity::Instruction	access:private
LOG4	libevmasm/Instruction.h	/^	LOG4,				\/\/\/< Makes a log entry; 4 topics.$/;"	m	class:dev::solidity::Instruction	access:private
LT	libevmasm/Instruction.h	/^	LT = 0x10,			\/\/\/< less-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
LValue	libsolidity/codegen/LValue.h	/^	explicit LValue(CompilerContext& _compilerContext, Type const* _dataType = nullptr):$/;"	f	class:dev::solidity::LValue	access:protected	signature:(CompilerContext& _compilerContext, Type const* _dataType = nullptr)
LValue	libsolidity/codegen/LValue.h	/^class LValue$/;"	c	namespace:dev::solidity
LValue	libyul/backends/evm/AbstractAssembly.h	/^enum class IdentifierContext { LValue, RValue };$/;"	m	class:dev::solidity::Instruction::IdentifierContext	access:private
Label	libyul/AsmData.h	/^struct Label { langutil::SourceLocation location; YulString name; };$/;"	s	namespace:yul
Label	libyul/AsmScope.h	/^	struct Label { };$/;"	s	struct:yul::Scope	access:public
Language	libyul/AssemblyStack.h	/^	enum class Language { Yul, Assembly, StrictAssembly };$/;"	c	class:yul::AssemblyStack	access:public
Less	libyul/Utilities.h	/^struct Less$/;"	s	namespace:yul
Less	libyul/Utilities.h	/^struct Less<T*>$/;"	s	namespace:yul
Less::operator ()	libyul/Utilities.cpp	/^bool Less<Literal>::operator()(Literal const& _lhs, Literal const& _rhs) const$/;"	f	class:Less	signature:(Literal const& _lhs, Literal const& _rhs) const
Line	libdevcore/IndentedWriter.h	/^	struct Line$/;"	s	class:dev::IndentedWriter	access:private
LineColumn	liblangutil/SourceReferenceExtractor.h	/^	LineColumn() = default;$/;"	p	struct:langutil::LineColumn	access:public	signature:()
LineColumn	liblangutil/SourceReferenceExtractor.h	/^	LineColumn(std::tuple<int, int> const& _t): line{std::get<0>(_t)}, column{std::get<1>(_t)} {}$/;"	f	struct:langutil::LineColumn	access:public	signature:(std::tuple<int, int> const& _t)
LineColumn	liblangutil/SourceReferenceExtractor.h	/^struct LineColumn$/;"	s	namespace:langutil
LinkerObject	libevmasm/LinkerObject.h	/^struct LinkerObject$/;"	s	namespace:dev::eth
LinkerObject::append	libevmasm/LinkerObject.cpp	/^void LinkerObject::append(LinkerObject const& _other)$/;"	f	class:LinkerObject	signature:(LinkerObject const& _other)
LinkerObject::libraryPlaceholder	libevmasm/LinkerObject.cpp	/^string LinkerObject::libraryPlaceholder(string const& _libraryName)$/;"	f	class:LinkerObject	signature:(string const& _libraryName)
LinkerObject::link	libevmasm/LinkerObject.cpp	/^void LinkerObject::link(map<string, h160> const& _libraryAddresses)$/;"	f	class:LinkerObject	signature:(map<string, h160> const& _libraryAddresses)
LinkerObject::matchLibrary	libevmasm/LinkerObject.cpp	/^LinkerObject::matchLibrary($/;"	f	class:LinkerObject	signature:( string const& _linkRefName, map<string, h160> const& _libraryAddresses )
LinkerObject::toHex	libevmasm/LinkerObject.cpp	/^string LinkerObject::toHex() const$/;"	f	class:LinkerObject	signature:() const
Literal	libsolidity/ast/AST.h	/^	Literal($/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:( SourceLocation const& _location, Token _token, ASTPointer<ASTString> const& _value, SubDenomination _sub = SubDenomination::None )
Literal	libsolidity/ast/AST.h	/^class Literal: public PrimaryExpression$/;"	c	namespace:dev::solidity	inherits:PrimaryExpression
Literal	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	s	namespace:yul
Literal::getChecksummedAddress	libsolidity/ast/AST.cpp	/^string Literal::getChecksummedAddress() const$/;"	f	class:Literal	signature:() const
Literal::isHexNumber	libsolidity/ast/AST.cpp	/^bool Literal::isHexNumber() const$/;"	f	class:Literal	signature:() const
Literal::looksLikeAddress	libsolidity/ast/AST.cpp	/^bool Literal::looksLikeAddress() const$/;"	f	class:Literal	signature:() const
Literal::passesAddressChecksum	libsolidity/ast/AST.cpp	/^bool Literal::passesAddressChecksum() const$/;"	f	class:Literal	signature:() const
Literal::valueWithoutUnderscores	libsolidity/ast/AST.cpp	/^ASTString Literal::valueWithoutUnderscores() const$/;"	f	class:Literal	signature:() const
LiteralKind	libyul/AsmData.h	/^enum class LiteralKind { Number, Boolean, String };$/;"	c	namespace:yul
LiteralMethod	libevmasm/ConstantOptimiser.h	/^	explicit LiteralMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::LiteralMethod	access:public	signature:(Params const& _params, u256 const& _value)
LiteralMethod	libevmasm/ConstantOptimiser.h	/^class LiteralMethod: public ConstantOptimisationMethod$/;"	c	namespace:dev::eth	inherits:ConstantOptimisationMethod
LiteralMethod::gasNeeded	libevmasm/ConstantOptimiser.cpp	/^bigint LiteralMethod::gasNeeded() const$/;"	f	class:LiteralMethod	signature:() const
LiteralScope	liblangutil/Scanner.cpp	/^	explicit LiteralScope(Scanner* _self, enum LiteralType _type): m_type(_type)$/;"	f	class:langutil::LiteralScope	access:public	signature:(Scanner* _self, enum LiteralType _type)
LiteralScope	liblangutil/Scanner.cpp	/^class LiteralScope$/;"	c	namespace:langutil	file:
LiteralType	liblangutil/Scanner.cpp	/^enum LiteralType {$/;"	g	namespace:langutil	file:
Location	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	g	class:dev::solidity::VariableDeclaration	access:public
LocationExtractor	libyul/AsmData.h	/^struct LocationExtractor: boost::static_visitor<langutil::SourceLocation>$/;"	s	namespace:yul	inherits:boost::static_visitor
LocationSetter	libsolidity/codegen/CompilerContext.h	/^		LocationSetter(CompilerContext& _compilerContext, ASTNode const& _node):$/;"	f	class:dev::solidity::CompilerContext::LocationSetter	access:public	signature:(CompilerContext& _compilerContext, ASTNode const& _node)
LocationSetter	libsolidity/codegen/CompilerContext.h	/^	class LocationSetter: public ScopeGuard$/;"	c	class:dev::solidity::CompilerContext	inherits:ScopeGuard	access:public
Log0	libsolidity/ast/Types.h	/^		Log0,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Log1	libsolidity/ast/Types.h	/^		Log1,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Log2	libsolidity/ast/Types.h	/^		Log2,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Log3	libsolidity/ast/Types.h	/^		Log3,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Log4	libsolidity/ast/Types.h	/^		Log4,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
LookAheadInfo	libsolidity/parsing/Parser.h	/^	enum class LookAheadInfo$/;"	c	class:dev::solidity::Parser	access:private
Loose	libyul/Dialect.h	/^	Loose,  \/\/ no types, EVM instructions as function, jumps and direct stack manipulations$/;"	m	class:yul::AsmFlavour	access:private
Low	libevmasm/Instruction.h	/^	Low,		\/\/ 5, Fast$/;"	m	class:dev::solidity::Instruction::Tier	access:private
Lower	libdevcore/CommonData.h	/^	Lower = 0,$/;"	m	class:dev::HexCase	access:private
MAGENTA	libdevcore/AnsiColorized.h	/^static constexpr char const* MAGENTA = "\\033[35m";$/;"	m	namespace:dev::formatting
MAGENTA_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* MAGENTA_BACKGROUND = "\\033[45m";$/;"	m	namespace:dev::formatting
MECHANISM_H	solse/mechanism.h	2;"	d
MLOAD	libevmasm/Instruction.h	/^	MLOAD,				\/\/\/< load word from memory$/;"	m	class:dev::solidity::Instruction	access:private
MOD	libevmasm/Instruction.h	/^	MOD,				\/\/\/< modulo remainder operation$/;"	m	class:dev::solidity::Instruction	access:private
MSIZE	libevmasm/Instruction.h	/^	MSIZE,				\/\/\/< get the size of active memory$/;"	m	class:dev::solidity::Instruction	access:private
MSTORE	libevmasm/Instruction.h	/^	MSTORE,				\/\/\/< save word to memory$/;"	m	class:dev::solidity::Instruction	access:private
MSTORE8	libevmasm/Instruction.h	/^	MSTORE8,			\/\/\/< save byte to memory$/;"	m	class:dev::solidity::Instruction	access:private
MUL	libevmasm/Instruction.h	/^	MUL,				\/\/\/< multiplication operation$/;"	m	class:dev::solidity::Instruction	access:private
MULMOD	libevmasm/Instruction.h	/^	MULMOD,				\/\/\/< unsigned modular multiplication$/;"	m	class:dev::solidity::Instruction	access:private
Machine	libyul/AssemblyStack.h	/^	enum class Machine { EVM, EVM15, eWasm };$/;"	c	class:yul::AssemblyStack	access:public
MachineAssemblyObject	libyul/AssemblyStack.h	/^struct MachineAssemblyObject$/;"	s	namespace:yul
Magic	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
MagicType	libsolidity/ast/Types.h	/^	explicit MagicType(Kind _kind): m_kind(_kind) {}$/;"	f	class:dev::solidity::MagicType	access:public	signature:(Kind _kind)
MagicType	libsolidity/ast/Types.h	/^class MagicType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
MagicType::metaType	libsolidity/ast/Types.cpp	/^shared_ptr<MagicType> MagicType::metaType(TypePointer _type)$/;"	f	class:MagicType	signature:(TypePointer _type)
MagicType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap MagicType::nativeMembers(ContractDefinition const*) const$/;"	f	class:MagicType	signature:(ContractDefinition const*) const
MagicType::operator ==	libsolidity/ast/Types.cpp	/^bool MagicType::operator==(Type const& _other) const$/;"	f	class:MagicType	signature:(Type const& _other) const
MagicType::richIdentifier	libsolidity/ast/Types.cpp	/^string MagicType::richIdentifier() const$/;"	f	class:MagicType	signature:() const
MagicType::toString	libsolidity/ast/Types.cpp	/^string MagicType::toString(bool _short) const$/;"	f	class:MagicType	signature:(bool _short) const
MagicType::typeArgument	libsolidity/ast/Types.cpp	/^TypePointer MagicType::typeArgument() const$/;"	f	class:MagicType	signature:() const
MagicVariableDeclaration	libsolidity/ast/AST.h	/^	MagicVariableDeclaration(ASTString const& _name, std::shared_ptr<Type const> const& _type):$/;"	f	class:dev::solidity::MagicVariableDeclaration	access:public	signature:(ASTString const& _name, std::shared_ptr<Type const> const& _type)
MagicVariableDeclaration	libsolidity/ast/AST.h	/^class MagicVariableDeclaration: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
MainFunction	libyul/optimiser/MainFunction.h	/^class MainFunction$/;"	c	namespace:yul
MainFunction::operator ()	libyul/optimiser/MainFunction.cpp	/^void MainFunction::operator()(Block& _block)$/;"	f	class:MainFunction	signature:(Block& _block)
Mapping	libsolidity/ast/AST.h	/^	Mapping($/;"	f	class:dev::solidity::Mapping	access:public	signature:( SourceLocation const& _location, ASTPointer<ElementaryTypeName> const& _keyType, ASTPointer<TypeName> const& _valueType )
Mapping	libsolidity/ast/AST.h	/^class Mapping: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
Mapping	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
MappingType	libsolidity/ast/Types.h	/^	MappingType(TypePointer const& _keyType, TypePointer const& _valueType):$/;"	f	class:dev::solidity::MappingType	access:public	signature:(TypePointer const& _keyType, TypePointer const& _valueType)
MappingType	libsolidity/ast/Types.h	/^class MappingType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
MappingType::canonicalName	libsolidity/ast/Types.cpp	/^string MappingType::canonicalName() const$/;"	f	class:MappingType	signature:() const
MappingType::operator ==	libsolidity/ast/Types.cpp	/^bool MappingType::operator==(Type const& _other) const$/;"	f	class:MappingType	signature:(Type const& _other) const
MappingType::richIdentifier	libsolidity/ast/Types.cpp	/^string MappingType::richIdentifier() const$/;"	f	class:MappingType	signature:() const
MappingType::toString	libsolidity/ast/Types.cpp	/^string MappingType::toString(bool _short) const$/;"	f	class:MappingType	signature:(bool _short) const
MatchComponent	libsolidity/analysis/SemVerHandler.h	/^	struct MatchComponent$/;"	s	struct:dev::solidity::SemVerMatchExpression	access:public
Mechanism	solse/mechanism.h	/^    Mechanism():preCond((*Mechanism::p_z3_ctx).bool_val(1)),model_type((*Mechanism::p_z3_ctx).int_val(-1)),allocation((*Mechanism::p_z3_ctx)),price((*Mechanism::p_z3_ctx).int_val(0)){$/;"	f	class:Mechanism	access:public	signature:()
Mechanism	solse/mechanism.h	/^class Mechanism{$/;"	c
Mechanism::Mechanism	solse/mechanism.h	/^    Mechanism():preCond((*Mechanism::p_z3_ctx).bool_val(1)),model_type((*Mechanism::p_z3_ctx).int_val(-1)),allocation((*Mechanism::p_z3_ctx)),price((*Mechanism::p_z3_ctx).int_val(0)){$/;"	f	class:Mechanism	access:public	signature:()
Mechanism::allocation	solse/mechanism.h	/^		z3::expr allocation;$/;"	m	class:Mechanism	access:public
Mechanism::assumptions	solse/mechanism.h	/^		std::vector<z3::expr> assumptions; $/;"	m	class:Mechanism	access:public
Mechanism::bidders	solse/mechanism.h	/^		std::vector<std::vector<z3::expr> > bidders;$/;"	m	class:Mechanism	access:public
Mechanism::check	solse/mechanism.cpp	/^bool Mechanism::check(){$/;"	f	class:Mechanism	signature:()
Mechanism::check	solse/mechanism.h	/^    bool check();$/;"	p	class:Mechanism	access:public	signature:()
Mechanism::check_1stPrice	solse/mechanism.cpp	/^bool Mechanism::check_1stPrice(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_1stPrice	solse/mechanism.h	/^    bool check_1stPrice(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_2ndPrice	solse/mechanism.cpp	/^bool Mechanism::check_2ndPrice(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_2ndPrice	solse/mechanism.h	/^    bool check_2ndPrice(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_TopBidder	solse/mechanism.cpp	/^bool Mechanism::check_TopBidder(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_TopBidder	solse/mechanism.h	/^    bool check_TopBidder(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_collusionfreeness	solse/mechanism.cpp	/^bool Mechanism::check_collusionfreeness(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_collusionfreeness	solse/mechanism.h	/^    bool check_collusionfreeness(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_efficiency	solse/mechanism.cpp	/^bool Mechanism::check_efficiency(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_efficiency	solse/mechanism.h	/^    bool check_efficiency(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_invariant	solse/mechanism.cpp	/^bool Mechanism::check_invariant(){$/;"	f	class:Mechanism	signature:()
Mechanism::check_invariant	solse/mechanism.h	/^    bool check_invariant();$/;"	p	class:Mechanism	access:public	signature:()
Mechanism::check_optimality	solse/mechanism.cpp	/^bool Mechanism::check_optimality(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_optimality	solse/mechanism.h	/^    bool check_optimality(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_property	solse/mechanism.cpp	/^bool Mechanism::check_property(){$/;"	f	class:Mechanism	signature:()
Mechanism::check_property	solse/mechanism.h	/^    bool check_property();$/;"	p	class:Mechanism	access:public	signature:()
Mechanism::check_truthfulness	solse/mechanism.cpp	/^bool Mechanism::check_truthfulness(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
Mechanism::check_truthfulness	solse/mechanism.h	/^    bool check_truthfulness(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
Mechanism::check_types	solse/mechanism.h	/^		std::vector<z3::expr> check_types;$/;"	m	class:Mechanism	access:public
Mechanism::invariant_types	solse/mechanism.h	/^		std::vector<z3::expr> invariant_types;$/;"	m	class:Mechanism	access:public
Mechanism::model_type	solse/mechanism.h	/^		z3::expr model_type;$/;"	m	class:Mechanism	access:public
Mechanism::operator =	solse/mechanism.h	/^    Mechanism& operator=(const Mechanism& other) {$/;"	f	class:Mechanism	access:public	signature:(const Mechanism& other)
Mechanism::p_z3_ctx	solse/mechanism.cpp	/^z3::context* Mechanism::p_z3_ctx=new z3::context();$/;"	m	class:Mechanism	file:
Mechanism::p_z3_ctx	solse/mechanism.h	/^		static z3::context* p_z3_ctx;$/;"	m	class:Mechanism	access:public
Mechanism::preCond	solse/mechanism.h	/^		z3::expr preCond;$/;"	m	class:Mechanism	access:public
Mechanism::price	solse/mechanism.h	/^		z3::expr price;$/;"	m	class:Mechanism	access:public
Mechanism::print_model	solse/mechanism.h	/^    void print_model(z3::model& model, std::string desc){$/;"	f	class:Mechanism	access:public	signature:(z3::model& model, std::string desc)
Mechanism::size	solse/mechanism.h	/^		unsigned size=0;$/;"	m	class:Mechanism	access:public
Mechanism::utilities	solse/mechanism.h	/^		std::vector<std::vector<z3::expr> > utilities; $/;"	m	class:Mechanism	access:public
Mechanism::variables	solse/mechanism.h	/^  	std::vector<z3::expr> variables;$/;"	m	class:Mechanism	access:public
Mechanism::variables_smt	solse/mechanism.h	/^    std::vector<z3::expr> variables_smt;$/;"	m	class:Mechanism	access:public
Mechanism::variables_smt_str	solse/mechanism.h	/^    std::vector<std::string> variables_smt_str;$/;"	m	class:Mechanism	access:public
Mechanism::variables_str	solse/mechanism.h	/^    std::vector<std::string> variables_str;$/;"	m	class:Mechanism	access:public
Member	libsolidity/ast/Types.h	/^		Member(std::string const& _name, TypePointer const& _type, Declaration const* _declaration = nullptr):$/;"	f	struct:dev::solidity::MemberList::Member	access:public	signature:(std::string const& _name, TypePointer const& _type, Declaration const* _declaration = nullptr)
Member	libsolidity/ast/Types.h	/^	struct Member$/;"	s	class:dev::solidity::MemberList	access:public
MemberAccess	libsolidity/ast/AST.h	/^	MemberAccess($/;"	f	class:dev::solidity::MemberAccess	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> _expression, ASTPointer<ASTString> const& _memberName )
MemberAccess	libsolidity/ast/AST.h	/^class MemberAccess: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
MemberAccess::annotation	libsolidity/ast/AST.cpp	/^MemberAccessAnnotation& MemberAccess::annotation() const$/;"	f	class:MemberAccess	signature:() const
MemberAccessAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct MemberAccessAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
MemberList	libsolidity/ast/Types.h	/^	explicit MemberList(MemberMap const& _members): m_memberTypes(_members) {}$/;"	f	class:dev::solidity::MemberList	access:public	signature:(MemberMap const& _members)
MemberList	libsolidity/ast/Types.h	/^class MemberList$/;"	c	namespace:dev::solidity
MemberList::combine	libsolidity/ast/Types.cpp	/^void MemberList::combine(MemberList const & _other)$/;"	f	class:MemberList	signature:(MemberList const & _other)
MemberList::memberStorageOffset	libsolidity/ast/Types.cpp	/^pair<u256, unsigned> const* MemberList::memberStorageOffset(string const& _name) const$/;"	f	class:MemberList	signature:(string const& _name) const
MemberList::storageSize	libsolidity/ast/Types.cpp	/^u256 const& MemberList::storageSize() const$/;"	f	class:MemberList	signature:() const
Memory	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	e	enum:dev::eth::KnownState::StoreOperation::Target
Memory	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
MemoryItem	libsolidity/codegen/LValue.cpp	/^MemoryItem::MemoryItem(CompilerContext& _compilerContext, Type const& _type, bool _padded):$/;"	f	class:MemoryItem	signature:(CompilerContext& _compilerContext, Type const& _type, bool _padded)
MemoryItem	libsolidity/codegen/LValue.h	/^	MemoryItem(CompilerContext& _compilerContext, Type const& _type, bool _padded = true);$/;"	p	class:dev::solidity::MemoryItem	access:public	signature:(CompilerContext& _compilerContext, Type const& _type, bool _padded = true)
MemoryItem	libsolidity/codegen/LValue.h	/^class MemoryItem: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
MemoryItem::MemoryItem	libsolidity/codegen/LValue.cpp	/^MemoryItem::MemoryItem(CompilerContext& _compilerContext, Type const& _type, bool _padded):$/;"	f	class:MemoryItem	signature:(CompilerContext& _compilerContext, Type const& _type, bool _padded)
MemoryItem::retrieveValue	libsolidity/codegen/LValue.cpp	/^void MemoryItem::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:MemoryItem	signature:(SourceLocation const&, bool _remove) const
MemoryItem::setToZero	libsolidity/codegen/LValue.cpp	/^void MemoryItem::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:MemoryItem	signature:(SourceLocation const&, bool _removeReference) const
MemoryItem::storeValue	libsolidity/codegen/LValue.cpp	/^void MemoryItem::storeValue(Type const& _sourceType, SourceLocation const&, bool _move) const$/;"	f	class:MemoryItem	signature:(Type const& _sourceType, SourceLocation const&, bool _move) const
Message	liblangutil/SourceReferenceExtractor.h	/^	struct Message$/;"	s	namespace:langutil::SourceReferenceExtractor
Message	libsolidity/ast/Types.h	/^		Message, \/\/\/< "msg"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
MessageOnly	liblangutil/SourceReferenceExtractor.h	/^	static SourceReference MessageOnly(std::string _msg)$/;"	f	struct:langutil::SourceReference	access:public	signature:(std::string _msg)
Mid	libevmasm/Instruction.h	/^	Mid,		\/\/ 8, Mid$/;"	m	class:dev::solidity::Instruction::Tier	access:private
Minute	libsolidity/ast/AST.h	/^		Minute = static_cast<int>(Token::SubMinute),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
Mixed	libdevcore/CommonData.h	/^	Mixed = 2,$/;"	m	class:dev::HexCase	access:private
Modifier	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
Modifier	libsolidity/ast/Types.h	/^	enum class Modifier$/;"	c	class:dev::solidity::FixedPointType	access:public
Modifier	libsolidity/ast/Types.h	/^	enum class Modifier$/;"	c	class:dev::solidity::IntegerType	access:public
ModifierDefinition	libsolidity/ast/AST.h	/^	ModifierDefinition($/;"	f	class:dev::solidity::ModifierDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, ASTPointer<ASTString> const& _documentation, ASTPointer<ParameterList> const& _parameters, ASTPointer<Block> const& _body )
ModifierDefinition	libsolidity/ast/AST.h	/^class ModifierDefinition: public CallableDeclaration, public Documented$/;"	c	namespace:dev::solidity	inherits:CallableDeclaration,Documented
ModifierDefinition::annotation	libsolidity/ast/AST.cpp	/^ModifierDefinitionAnnotation& ModifierDefinition::annotation() const$/;"	f	class:ModifierDefinition	signature:() const
ModifierDefinition::type	libsolidity/ast/AST.cpp	/^TypePointer ModifierDefinition::type() const$/;"	f	class:ModifierDefinition	signature:() const
ModifierDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ModifierDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
ModifierInvocation	libsolidity/ast/AST.h	/^	ModifierInvocation($/;"	f	class:dev::solidity::ModifierInvocation	access:public	signature:( SourceLocation const& _location, ASTPointer<Identifier> const& _name, std::unique_ptr<std::vector<ASTPointer<Expression>>> _arguments )
ModifierInvocation	libsolidity/ast/AST.h	/^class ModifierInvocation: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
ModifierType	libsolidity/ast/Types.cpp	/^ModifierType::ModifierType(ModifierDefinition const& _modifier)$/;"	f	class:ModifierType	signature:(ModifierDefinition const& _modifier)
ModifierType	libsolidity/ast/Types.h	/^	explicit ModifierType(ModifierDefinition const& _modifier);$/;"	p	class:dev::solidity::ModifierType	access:public	signature:(ModifierDefinition const& _modifier)
ModifierType	libsolidity/ast/Types.h	/^class ModifierType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
ModifierType::ModifierType	libsolidity/ast/Types.cpp	/^ModifierType::ModifierType(ModifierDefinition const& _modifier)$/;"	f	class:ModifierType	signature:(ModifierDefinition const& _modifier)
ModifierType::operator ==	libsolidity/ast/Types.cpp	/^bool ModifierType::operator==(Type const& _other) const$/;"	f	class:ModifierType	signature:(Type const& _other) const
ModifierType::richIdentifier	libsolidity/ast/Types.cpp	/^string ModifierType::richIdentifier() const$/;"	f	class:ModifierType	signature:() const
ModifierType::storageSize	libsolidity/ast/Types.cpp	/^u256 ModifierType::storageSize() const$/;"	f	class:ModifierType	signature:() const
ModifierType::toString	libsolidity/ast/Types.cpp	/^string ModifierType::toString(bool _short) const$/;"	f	class:ModifierType	signature:(bool _short) const
Module	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
ModuleType	libsolidity/ast/Types.h	/^	explicit ModuleType(SourceUnit const& _source): m_sourceUnit(_source) {}$/;"	f	class:dev::solidity::ModuleType	access:public	signature:(SourceUnit const& _source)
ModuleType	libsolidity/ast/Types.h	/^class ModuleType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
ModuleType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap ModuleType::nativeMembers(ContractDefinition const*) const$/;"	f	class:ModuleType	signature:(ContractDefinition const*) const
ModuleType::operator ==	libsolidity/ast/Types.cpp	/^bool ModuleType::operator==(Type const& _other) const$/;"	f	class:ModuleType	signature:(Type const& _other) const
ModuleType::richIdentifier	libsolidity/ast/Types.cpp	/^string ModuleType::richIdentifier() const$/;"	f	class:ModuleType	signature:() const
ModuleType::toString	libsolidity/ast/Types.cpp	/^string ModuleType::toString(bool) const$/;"	f	class:ModuleType	signature:(bool) const
MovableChecker	libyul/optimiser/Semantics.cpp	/^MovableChecker::MovableChecker(Dialect const& _dialect):$/;"	f	class:MovableChecker	signature:(Dialect const& _dialect)
MovableChecker	libyul/optimiser/Semantics.cpp	/^MovableChecker::MovableChecker(Dialect const& _dialect, Expression const& _expression):$/;"	f	class:MovableChecker	signature:(Dialect const& _dialect, Expression const& _expression)
MovableChecker	libyul/optimiser/Semantics.h	/^	MovableChecker(Dialect const& _dialect, Expression const& _expression);$/;"	p	class:yul::MovableChecker	access:public	signature:(Dialect const& _dialect, Expression const& _expression)
MovableChecker	libyul/optimiser/Semantics.h	/^	explicit MovableChecker(Dialect const& _dialect);$/;"	p	class:yul::MovableChecker	access:public	signature:(Dialect const& _dialect)
MovableChecker	libyul/optimiser/Semantics.h	/^class MovableChecker: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
MovableChecker::MovableChecker	libyul/optimiser/Semantics.cpp	/^MovableChecker::MovableChecker(Dialect const& _dialect):$/;"	f	class:MovableChecker	signature:(Dialect const& _dialect)
MovableChecker::MovableChecker	libyul/optimiser/Semantics.cpp	/^MovableChecker::MovableChecker(Dialect const& _dialect, Expression const& _expression):$/;"	f	class:MovableChecker	signature:(Dialect const& _dialect, Expression const& _expression)
MovableChecker::operator ()	libyul/optimiser/Semantics.cpp	/^void MovableChecker::operator()(FunctionCall const& _functionCall)$/;"	f	class:MovableChecker	signature:(FunctionCall const& _functionCall)
MovableChecker::operator ()	libyul/optimiser/Semantics.cpp	/^void MovableChecker::operator()(FunctionalInstruction const& _instr)$/;"	f	class:MovableChecker	signature:(FunctionalInstruction const& _instr)
MovableChecker::operator ()	libyul/optimiser/Semantics.cpp	/^void MovableChecker::operator()(Identifier const& _identifier)$/;"	f	class:MovableChecker	signature:(Identifier const& _identifier)
MovableChecker::visit	libyul/optimiser/Semantics.cpp	/^void MovableChecker::visit(Statement const&)$/;"	f	class:MovableChecker	signature:(Statement const&)
MulMod	libsolidity/ast/Types.h	/^		MulMod, \/\/\/< MULMOD$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
MutabilityAndLocation	libsolidity/analysis/ViewPureChecker.h	/^	struct MutabilityAndLocation$/;"	s	class:dev::solidity::ViewPureChecker	access:private
NONE	solse/SolidityExprTranslator.h	/^enum TerminationCode { NONE, RETURN, CONTINUE, BREAK, THROW };$/;"	e	enum:TerminationCode
NOT	libevmasm/Instruction.h	/^	NOT,				\/\/\/< bitwise NOT operation$/;"	m	class:dev::solidity::Instruction	access:private
NUMBER	libevmasm/Instruction.h	/^	NUMBER,				\/\/\/< get the block's number$/;"	m	class:dev::solidity::Instruction	access:private
NameAndTypeResolver	libsolidity/analysis/NameAndTypeResolver.cpp	/^NameAndTypeResolver::NameAndTypeResolver($/;"	f	class:dev::solidity::NameAndTypeResolver	signature:( vector<Declaration const*> const& _globals, map<ASTNode const*, shared_ptr<DeclarationContainer>>& _scopes, ErrorReporter& _errorReporter )
NameAndTypeResolver	libsolidity/analysis/NameAndTypeResolver.h	/^	NameAndTypeResolver($/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:( std::vector<Declaration const*> const& _globals, std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& _scopes, langutil::ErrorReporter& _errorReporter )
NameAndTypeResolver	libsolidity/analysis/NameAndTypeResolver.h	/^class NameAndTypeResolver: private boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
NameCollector	libyul/optimiser/NameCollector.h	/^	explicit NameCollector(Block const& _block)$/;"	f	class:yul::NameCollector	access:public	signature:(Block const& _block)
NameCollector	libyul/optimiser/NameCollector.h	/^class NameCollector: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
NameCollector::operator ()	libyul/optimiser/NameCollector.cpp	/^void NameCollector::operator ()(FunctionDefinition const& _funDef)$/;"	f	class:NameCollector	signature:(FunctionDefinition const& _funDef)
NameCollector::operator ()	libyul/optimiser/NameCollector.cpp	/^void NameCollector::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:NameCollector	signature:(VariableDeclaration const& _varDecl)
NameDispenser	libyul/optimiser/NameDispenser.cpp	/^NameDispenser::NameDispenser(Dialect const& _dialect, Block const& _ast):$/;"	f	class:NameDispenser	signature:(Dialect const& _dialect, Block const& _ast)
NameDispenser	libyul/optimiser/NameDispenser.cpp	/^NameDispenser::NameDispenser(Dialect const& _dialect, set<YulString> _usedNames):$/;"	f	class:NameDispenser	signature:(Dialect const& _dialect, set<YulString> _usedNames)
NameDispenser	libyul/optimiser/NameDispenser.h	/^	explicit NameDispenser(Dialect const& _dialect, Block const& _ast);$/;"	p	class:yul::NameDispenser	access:public	signature:(Dialect const& _dialect, Block const& _ast)
NameDispenser	libyul/optimiser/NameDispenser.h	/^	explicit NameDispenser(Dialect const& _dialect, std::set<YulString> _usedNames);$/;"	p	class:yul::NameDispenser	access:public	signature:(Dialect const& _dialect, std::set<YulString> _usedNames)
NameDispenser	libyul/optimiser/NameDispenser.h	/^class NameDispenser$/;"	c	namespace:yul
NameDispenser::NameDispenser	libyul/optimiser/NameDispenser.cpp	/^NameDispenser::NameDispenser(Dialect const& _dialect, Block const& _ast):$/;"	f	class:NameDispenser	signature:(Dialect const& _dialect, Block const& _ast)
NameDispenser::NameDispenser	libyul/optimiser/NameDispenser.cpp	/^NameDispenser::NameDispenser(Dialect const& _dialect, set<YulString> _usedNames):$/;"	f	class:NameDispenser	signature:(Dialect const& _dialect, set<YulString> _usedNames)
NameDispenser::newName	libyul/optimiser/NameDispenser.cpp	/^YulString NameDispenser::newName(YulString _nameHint)$/;"	f	class:NameDispenser	signature:(YulString _nameHint)
Natspec	libsolidity/interface/Natspec.h	/^class Natspec$/;"	c	namespace:dev::solidity
Natspec::devDocumentation	libsolidity/interface/Natspec.cpp	/^Json::Value Natspec::devDocumentation(ContractDefinition const& _contractDef)$/;"	f	class:Natspec	signature:(ContractDefinition const& _contractDef)
Natspec::devDocumentation	libsolidity/interface/Natspec.cpp	/^Json::Value Natspec::devDocumentation(std::multimap<std::string, DocTag> const& _tags)$/;"	f	class:Natspec	signature:(std::multimap<std::string, DocTag> const& _tags)
Natspec::extractDoc	libsolidity/interface/Natspec.cpp	/^string Natspec::extractDoc(multimap<string, DocTag> const& _tags, string const& _name)$/;"	f	class:Natspec	signature:(multimap<string, DocTag> const& _tags, string const& _name)
Natspec::userDocumentation	libsolidity/interface/Natspec.cpp	/^Json::Value Natspec::userDocumentation(ContractDefinition const& _contractDef)$/;"	f	class:Natspec	signature:(ContractDefinition const& _contractDef)
NewExpression	libsolidity/ast/AST.h	/^	NewExpression($/;"	f	class:dev::solidity::NewExpression	access:public	signature:( SourceLocation const& _location, ASTPointer<TypeName> const& _typeName )
NewExpression	libsolidity/ast/AST.h	/^class NewExpression: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
NoError	liblangutil/Scanner.h	/^	NoError,$/;"	m	class:langutil::ScannerError	access:private
NoOutputAssembly	libyul/backends/evm/NoOutputAssembly.h	/^	explicit NoOutputAssembly(bool _evm15 = false): m_evm15(_evm15) { }$/;"	f	class:yul::NoOutputAssembly	access:public	signature:(bool _evm15 = false)
NoOutputAssembly	libyul/backends/evm/NoOutputAssembly.h	/^class NoOutputAssembly: public AbstractAssembly$/;"	c	namespace:yul	inherits:AbstractAssembly
NoOutputAssembly::appendAssemblySize	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendAssemblySize()$/;"	f	class:NoOutputAssembly	signature:()
NoOutputAssembly::appendBeginsub	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendBeginsub(LabelID, int _arguments)$/;"	f	class:NoOutputAssembly	signature:(LabelID, int _arguments)
NoOutputAssembly::appendConstant	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendConstant(u256 const&)$/;"	f	class:NoOutputAssembly	signature:(u256 const&)
NoOutputAssembly::appendData	libyul/backends/evm/NoOutputAssembly.cpp	/^AbstractAssembly::SubID NoOutputAssembly::appendData(bytes const&)$/;"	f	class:NoOutputAssembly	signature:(bytes const&)
NoOutputAssembly::appendDataOffset	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendDataOffset(AbstractAssembly::SubID)$/;"	f	class:NoOutputAssembly	signature:(AbstractAssembly::SubID)
NoOutputAssembly::appendDataSize	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendDataSize(AbstractAssembly::SubID)$/;"	f	class:NoOutputAssembly	signature:(AbstractAssembly::SubID)
NoOutputAssembly::appendInstruction	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendInstruction(solidity::Instruction _instr)$/;"	f	class:NoOutputAssembly	signature:(solidity::Instruction _instr)
NoOutputAssembly::appendJump	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJump(int _stackDiffAfter)$/;"	f	class:NoOutputAssembly	signature:(int _stackDiffAfter)
NoOutputAssembly::appendJumpTo	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJumpTo(LabelID _labelId, int _stackDiffAfter)$/;"	f	class:NoOutputAssembly	signature:(LabelID _labelId, int _stackDiffAfter)
NoOutputAssembly::appendJumpToIf	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJumpToIf(LabelID _labelId)$/;"	f	class:NoOutputAssembly	signature:(LabelID _labelId)
NoOutputAssembly::appendJumpsub	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJumpsub(LabelID, int _arguments, int _returns)$/;"	f	class:NoOutputAssembly	signature:(LabelID, int _arguments, int _returns)
NoOutputAssembly::appendLabel	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendLabel(LabelID)$/;"	f	class:NoOutputAssembly	signature:(LabelID)
NoOutputAssembly::appendLabelReference	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendLabelReference(LabelID)$/;"	f	class:NoOutputAssembly	signature:(LabelID)
NoOutputAssembly::appendLinkerSymbol	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendLinkerSymbol(string const&)$/;"	f	class:NoOutputAssembly	signature:(string const&)
NoOutputAssembly::appendReturnsub	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendReturnsub(int _returns, int _stackDiffAfter)$/;"	f	class:NoOutputAssembly	signature:(int _returns, int _stackDiffAfter)
NoOutputAssembly::createSubAssembly	libyul/backends/evm/NoOutputAssembly.cpp	/^pair<shared_ptr<AbstractAssembly>, AbstractAssembly::SubID> NoOutputAssembly::createSubAssembly()$/;"	f	class:NoOutputAssembly	signature:()
NoOutputAssembly::namedLabel	libyul/backends/evm/NoOutputAssembly.cpp	/^AbstractAssembly::LabelID NoOutputAssembly::namedLabel(string const&)$/;"	f	class:NoOutputAssembly	signature:(string const&)
NoOutputAssembly::newLabelId	libyul/backends/evm/NoOutputAssembly.cpp	/^NoOutputAssembly::LabelID NoOutputAssembly::newLabelId()$/;"	f	class:NoOutputAssembly	signature:()
NoOutputEVMDialect	libyul/backends/evm/NoOutputAssembly.cpp	/^NoOutputEVMDialect::NoOutputEVMDialect(shared_ptr<EVMDialect> const& _copyFrom):$/;"	f	class:NoOutputEVMDialect	signature:(shared_ptr<EVMDialect> const& _copyFrom)
NoOutputEVMDialect	libyul/backends/evm/NoOutputAssembly.h	/^	explicit NoOutputEVMDialect(std::shared_ptr<EVMDialect> const& _copyFrom);$/;"	p	struct:yul::NoOutputEVMDialect	access:public	signature:(std::shared_ptr<EVMDialect> const& _copyFrom)
NoOutputEVMDialect	libyul/backends/evm/NoOutputAssembly.h	/^struct NoOutputEVMDialect: public EVMDialect$/;"	s	namespace:yul	inherits:EVMDialect
NoOutputEVMDialect::NoOutputEVMDialect	libyul/backends/evm/NoOutputAssembly.cpp	/^NoOutputEVMDialect::NoOutputEVMDialect(shared_ptr<EVMDialect> const& _copyFrom):$/;"	f	class:NoOutputEVMDialect	signature:(shared_ptr<EVMDialect> const& _copyFrom)
NodeContainer	libsolidity/analysis/ControlFlowGraph.h	/^	class NodeContainer$/;"	c	class:dev::solidity::CFG	access:public
NonPayable	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	m	class:dev::solidity::StateMutability	access:private
None	libsolidity/ast/AST.h	/^		None = static_cast<int>(Token::Illegal),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
Number	libyul/AsmData.h	/^enum class LiteralKind { Number, Boolean, String };$/;"	m	class:yul::LiteralKind	access:private
OR	libevmasm/Instruction.h	/^	OR,					\/\/\/< bitwise OR operation$/;"	m	class:dev::solidity::Instruction	access:private
ORANGE_BACKGROUND_256	libdevcore/AnsiColorized.h	/^static constexpr char const* ORANGE_BACKGROUND_256 = "\\033[48;5;166m";$/;"	m	namespace:dev::formatting
ORIGIN	libevmasm/Instruction.h	/^	ORIGIN,				\/\/\/< get execution origination address$/;"	m	class:dev::solidity::Instruction	access:private
Object	libyul/Object.h	/^struct Object: ObjectNode$/;"	s	namespace:yul	inherits:ObjectNode
Object::toString	libyul/Object.cpp	/^string Object::toString(bool _yul) const$/;"	f	class:Object	signature:(bool _yul) const
ObjectCreation	libsolidity/ast/Types.h	/^		ObjectCreation, \/\/\/< array creation using new$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
ObjectNode	libyul/Object.h	/^struct ObjectNode$/;"	s	namespace:yul
ObjectParser	libyul/ObjectParser.h	/^	explicit ObjectParser($/;"	f	class:yul::ObjectParser	access:public	signature:( langutil::ErrorReporter& _errorReporter, std::shared_ptr<Dialect> _dialect )
ObjectParser	libyul/ObjectParser.h	/^class ObjectParser: public langutil::ParserBase$/;"	c	namespace:yul	inherits:langutil::ParserBase
ObjectParser::addNamedSubObject	libyul/ObjectParser.cpp	/^void ObjectParser::addNamedSubObject(Object& _container, YulString _name, shared_ptr<ObjectNode> _subObject)$/;"	f	class:ObjectParser	signature:(Object& _container, YulString _name, shared_ptr<ObjectNode> _subObject)
ObjectParser::parse	libyul/ObjectParser.cpp	/^shared_ptr<Object> ObjectParser::parse(shared_ptr<Scanner> const& _scanner, bool _reuseScanner)$/;"	f	class:ObjectParser	signature:(shared_ptr<Scanner> const& _scanner, bool _reuseScanner)
ObjectParser::parseBlock	libyul/ObjectParser.cpp	/^shared_ptr<Block> ObjectParser::parseBlock()$/;"	f	class:ObjectParser	signature:()
ObjectParser::parseCode	libyul/ObjectParser.cpp	/^shared_ptr<Block> ObjectParser::parseCode()$/;"	f	class:ObjectParser	signature:()
ObjectParser::parseData	libyul/ObjectParser.cpp	/^void ObjectParser::parseData(Object& _containingObject)$/;"	f	class:ObjectParser	signature:(Object& _containingObject)
ObjectParser::parseObject	libyul/ObjectParser.cpp	/^shared_ptr<Object> ObjectParser::parseObject(Object* _containingObject)$/;"	f	class:ObjectParser	signature:(Object* _containingObject)
ObjectParser::parseUniqueName	libyul/ObjectParser.cpp	/^YulString ObjectParser::parseUniqueName(Object const* _containingObject)$/;"	f	class:ObjectParser	signature:(Object const* _containingObject)
OctalNotAllowed	liblangutil/Scanner.h	/^	OctalNotAllowed,$/;"	m	class:langutil::ScannerError	access:private
OpPop	libevmasm/PeepholeOptimiser.cpp	/^struct OpPop: SimplePeepholeOptimizerMethod<OpPop, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
Operation	libevmasm/AssemblyItem.h	/^	Operation,$/;"	e	enum:dev::eth::AssemblyItemType
Operation	libyul/optimiser/SimplificationRules.h	/^	Operation,$/;"	m	class:yul::PatternKind	access:private
OptimiserSettings	libevmasm/Assembly.h	/^	struct OptimiserSettings$/;"	s	class:dev::eth::Assembly	access:public
OptimiserSettings	libsolidity/interface/OptimiserSettings.h	/^struct OptimiserSettings$/;"	s	namespace:dev::solidity
OptimiserState	libevmasm/PeepholeOptimiser.cpp	/^struct OptimiserState$/;"	s	namespace:__anon19	file:
OptimiserSuite	libyul/optimiser/Suite.h	/^class OptimiserSuite$/;"	c	namespace:yul
OptimiserSuite::run	libyul/optimiser/Suite.cpp	/^void OptimiserSuite::run($/;"	f	class:OptimiserSuite	signature:( shared_ptr<Dialect> const& _dialect, Block& _ast, AsmAnalysisInfo const& _analysisInfo, set<YulString> const& _externallyUsedIdentifiers )
OptimizerException	libevmasm/Exceptions.h	/^struct OptimizerException: virtual AssemblyException {};$/;"	s	namespace:dev::eth	inherits:AssemblyException
OptimizerException	libyul/Exceptions.h	/^struct OptimizerException: virtual YulException {};$/;"	s	namespace:yul	inherits:YulException
Ordinary	libevmasm/AssemblyItem.h	/^	enum class JumpType { Ordinary, IntoFunction, OutOfFunction };$/;"	m	class:dev::eth::AssemblyItem::JumpType	access:private
Ordinary	libsolidity/ast/Types.h	/^	enum class ArrayKind { Ordinary, Bytes, String };$/;"	m	class:dev::solidity::ArrayType::ArrayKind	access:private
Overflow	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	m	class:dev::solidity::SMTChecker::OverflowTarget::Type	access:private
OverflowTarget	libsolidity/formal/SMTChecker.h	/^		OverflowTarget(Type _type, TypePointer _intType, smt::Expression _value, smt::Expression _path, langutil::SourceLocation const& _location):$/;"	f	struct:dev::solidity::SMTChecker::OverflowTarget	access:public	signature:(Type _type, TypePointer _intType, smt::Expression _value, smt::Expression _path, langutil::SourceLocation const& _location)
OverflowTarget	libsolidity/formal/SMTChecker.h	/^	struct OverflowTarget$/;"	s	class:dev::solidity::SMTChecker	access:private
P	libdevcore/Keccak256.cpp	135;"	d	file:
PC	libevmasm/Instruction.h	/^	PC,					\/\/\/< get the program counter$/;"	m	class:dev::solidity::Instruction	access:private
POP	libevmasm/Instruction.h	/^	POP = 0x50,			\/\/\/< remove item from stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH1	libevmasm/Instruction.h	/^	PUSH1 = 0x60,		\/\/\/< place 1 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH10	libevmasm/Instruction.h	/^	PUSH10,				\/\/\/< place 10 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH11	libevmasm/Instruction.h	/^	PUSH11,				\/\/\/< place 11 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH12	libevmasm/Instruction.h	/^	PUSH12,				\/\/\/< place 12 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH13	libevmasm/Instruction.h	/^	PUSH13,				\/\/\/< place 13 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH14	libevmasm/Instruction.h	/^	PUSH14,				\/\/\/< place 14 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH15	libevmasm/Instruction.h	/^	PUSH15,				\/\/\/< place 15 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH16	libevmasm/Instruction.h	/^	PUSH16,				\/\/\/< place 16 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH17	libevmasm/Instruction.h	/^	PUSH17,				\/\/\/< place 17 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH18	libevmasm/Instruction.h	/^	PUSH18,				\/\/\/< place 18 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH19	libevmasm/Instruction.h	/^	PUSH19,				\/\/\/< place 19 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH2	libevmasm/Instruction.h	/^	PUSH2,				\/\/\/< place 2 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH20	libevmasm/Instruction.h	/^	PUSH20,				\/\/\/< place 20 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH21	libevmasm/Instruction.h	/^	PUSH21,				\/\/\/< place 21 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH22	libevmasm/Instruction.h	/^	PUSH22,				\/\/\/< place 22 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH23	libevmasm/Instruction.h	/^	PUSH23,				\/\/\/< place 23 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH24	libevmasm/Instruction.h	/^	PUSH24,				\/\/\/< place 24 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH25	libevmasm/Instruction.h	/^	PUSH25,				\/\/\/< place 25 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH26	libevmasm/Instruction.h	/^	PUSH26,				\/\/\/< place 26 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH27	libevmasm/Instruction.h	/^	PUSH27,				\/\/\/< place 27 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH28	libevmasm/Instruction.h	/^	PUSH28,				\/\/\/< place 28 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH29	libevmasm/Instruction.h	/^	PUSH29,				\/\/\/< place 29 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH3	libevmasm/Instruction.h	/^	PUSH3,				\/\/\/< place 3 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH30	libevmasm/Instruction.h	/^	PUSH30,				\/\/\/< place 30 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH31	libevmasm/Instruction.h	/^	PUSH31,				\/\/\/< place 31 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH32	libevmasm/Instruction.h	/^	PUSH32,				\/\/\/< place 32 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH4	libevmasm/Instruction.h	/^	PUSH4,				\/\/\/< place 4 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH5	libevmasm/Instruction.h	/^	PUSH5,				\/\/\/< place 5 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH6	libevmasm/Instruction.h	/^	PUSH6,				\/\/\/< place 6 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH7	libevmasm/Instruction.h	/^	PUSH7,				\/\/\/< place 7 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH8	libevmasm/Instruction.h	/^	PUSH8,				\/\/\/< place 8 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUSH9	libevmasm/Instruction.h	/^	PUSH9,				\/\/\/< place 9 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
PUTLOCAL	libevmasm/Instruction.h	/^	PUTLOCAL,           \/\/\/< pop top of stack to local variable -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
ParameterList	libsolidity/ast/AST.h	/^	ParameterList($/;"	f	class:dev::solidity::ParameterList	access:public	signature:( SourceLocation const& _location, std::vector<ASTPointer<VariableDeclaration>> const& _parameters )
ParameterList	libsolidity/ast/AST.h	/^class ParameterList: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
Params	libevmasm/ConstantOptimiser.h	/^	struct Params$/;"	s	class:dev::eth::ConstantOptimisationMethod	access:protected
Parser	libsolidity/parsing/Parser.h	/^	explicit Parser(langutil::ErrorReporter& _errorReporter): ParserBase(_errorReporter) {}$/;"	f	class:dev::solidity::Parser	access:public	signature:(langutil::ErrorReporter& _errorReporter)
Parser	libsolidity/parsing/Parser.h	/^class Parser: public langutil::ParserBase$/;"	c	namespace:dev::solidity	inherits:langutil::ParserBase
Parser	libyul/AsmParser.h	/^	explicit Parser(langutil::ErrorReporter& _errorReporter, std::shared_ptr<Dialect> _dialect):$/;"	f	class:yul::Parser	access:public	signature:(langutil::ErrorReporter& _errorReporter, std::shared_ptr<Dialect> _dialect)
Parser	libyul/AsmParser.h	/^class Parser: public langutil::ParserBase$/;"	c	namespace:yul	inherits:langutil::ParserBase
Parser::expectAsmIdentifier	libyul/AsmParser.cpp	/^YulString Parser::expectAsmIdentifier()$/;"	f	class:Parser	signature:()
Parser::isValidNumberLiteral	libyul/AsmParser.cpp	/^bool Parser::isValidNumberLiteral(string const& _literal)$/;"	f	class:Parser	signature:(string const& _literal)
Parser::parse	libyul/AsmParser.cpp	/^shared_ptr<Block> Parser::parse(std::shared_ptr<Scanner> const& _scanner, bool _reuseScanner)$/;"	f	class:Parser	signature:(std::shared_ptr<Scanner> const& _scanner, bool _reuseScanner)
Parser::parseBlock	libyul/AsmParser.cpp	/^Block Parser::parseBlock()$/;"	f	class:Parser	signature:()
Parser::parseCall	libyul/AsmParser.cpp	/^Expression Parser::parseCall(Parser::ElementaryOperation&& _initialOp)$/;"	f	class:Parser	signature:(Parser::ElementaryOperation&& _initialOp)
Parser::parseCase	libyul/AsmParser.cpp	/^Case Parser::parseCase()$/;"	f	class:Parser	signature:()
Parser::parseElementaryOperation	libyul/AsmParser.cpp	/^Parser::ElementaryOperation Parser::parseElementaryOperation()$/;"	f	class:Parser	signature:()
Parser::parseExpression	libyul/AsmParser.cpp	/^Expression Parser::parseExpression()$/;"	f	class:Parser	signature:()
Parser::parseForLoop	libyul/AsmParser.cpp	/^ForLoop Parser::parseForLoop()$/;"	f	class:Parser	signature:()
Parser::parseFunctionDefinition	libyul/AsmParser.cpp	/^FunctionDefinition Parser::parseFunctionDefinition()$/;"	f	class:Parser	signature:()
Parser::parseStatement	libyul/AsmParser.cpp	/^Statement Parser::parseStatement()$/;"	f	class:Parser	signature:()
Parser::parseTypedName	libyul/AsmParser.cpp	/^TypedName Parser::parseTypedName()$/;"	f	class:Parser	signature:()
Parser::parseVariableDeclaration	libyul/AsmParser.cpp	/^VariableDeclaration Parser::parseVariableDeclaration()$/;"	f	class:Parser	signature:()
ParserBase	liblangutil/ParserBase.h	/^	explicit ParserBase(ErrorReporter& errorReporter): m_errorReporter(errorReporter) {}$/;"	f	class:langutil::ParserBase	access:public	signature:(ErrorReporter& errorReporter)
ParserBase	liblangutil/ParserBase.h	/^class ParserBase$/;"	c	namespace:langutil
ParserBase::advance	liblangutil/ParserBase.cpp	/^Token ParserBase::advance()$/;"	f	class:ParserBase	signature:()
ParserBase::currentLiteral	liblangutil/ParserBase.cpp	/^std::string ParserBase::currentLiteral() const$/;"	f	class:ParserBase	signature:() const
ParserBase::currentToken	liblangutil/ParserBase.cpp	/^Token ParserBase::currentToken() const$/;"	f	class:ParserBase	signature:() const
ParserBase::decreaseRecursionDepth	liblangutil/ParserBase.cpp	/^void ParserBase::decreaseRecursionDepth()$/;"	f	class:ParserBase	signature:()
ParserBase::endPosition	liblangutil/ParserBase.cpp	/^int ParserBase::endPosition() const$/;"	f	class:ParserBase	signature:() const
ParserBase::expectToken	liblangutil/ParserBase.cpp	/^void ParserBase::expectToken(Token _value, bool _advance)$/;"	f	class:ParserBase	signature:(Token _value, bool _advance)
ParserBase::fatalParserError	liblangutil/ParserBase.cpp	/^void ParserBase::fatalParserError(string const& _description)$/;"	f	class:ParserBase	signature:(string const& _description)
ParserBase::increaseRecursionDepth	liblangutil/ParserBase.cpp	/^void ParserBase::increaseRecursionDepth()$/;"	f	class:ParserBase	signature:()
ParserBase::parserError	liblangutil/ParserBase.cpp	/^void ParserBase::parserError(string const& _description)$/;"	f	class:ParserBase	signature:(string const& _description)
ParserBase::peekNextToken	liblangutil/ParserBase.cpp	/^Token ParserBase::peekNextToken() const$/;"	f	class:ParserBase	signature:() const
ParserBase::position	liblangutil/ParserBase.cpp	/^int ParserBase::position() const$/;"	f	class:ParserBase	signature:() const
ParserError	liblangutil/Exceptions.h	/^		ParserError,$/;"	m	class:langutil::Error::Type	access:private
ParsingSuccessful	libsolidity/interface/CompilerStack.h	/^		ParsingSuccessful,$/;"	e	enum:dev::solidity::CompilerStack::State
PathGasMeter	libevmasm/PathGasMeter.cpp	/^PathGasMeter::PathGasMeter(AssemblyItems const& _items, langutil::EVMVersion _evmVersion):$/;"	f	class:PathGasMeter	signature:(AssemblyItems const& _items, langutil::EVMVersion _evmVersion)
PathGasMeter	libevmasm/PathGasMeter.h	/^	explicit PathGasMeter(AssemblyItems const& _items, langutil::EVMVersion _evmVersion);$/;"	p	class:dev::eth::PathGasMeter	access:public	signature:(AssemblyItems const& _items, langutil::EVMVersion _evmVersion)
PathGasMeter	libevmasm/PathGasMeter.h	/^class PathGasMeter$/;"	c	namespace:dev::eth
PathGasMeter::PathGasMeter	libevmasm/PathGasMeter.cpp	/^PathGasMeter::PathGasMeter(AssemblyItems const& _items, langutil::EVMVersion _evmVersion):$/;"	f	class:PathGasMeter	signature:(AssemblyItems const& _items, langutil::EVMVersion _evmVersion)
PathGasMeter::estimateMax	libevmasm/PathGasMeter.cpp	/^GasMeter::GasConsumption PathGasMeter::estimateMax($/;"	f	class:PathGasMeter	signature:( size_t _startIndex, shared_ptr<KnownState> const& _state )
PathGasMeter::handleQueueItem	libevmasm/PathGasMeter.cpp	/^GasMeter::GasConsumption PathGasMeter::handleQueueItem()$/;"	f	class:PathGasMeter	signature:()
PathGasMeter::queue	libevmasm/PathGasMeter.cpp	/^void PathGasMeter::queue(std::unique_ptr<GasPath>&& _newPath)$/;"	f	class:PathGasMeter	signature:(std::unique_ptr<GasPath>&& _newPath)
Pattern	libevmasm/SimplificationRules.cpp	/^Pattern::Pattern(Instruction _instruction, std::vector<Pattern> const& _arguments):$/;"	f	class:Pattern	signature:(Instruction _instruction, std::vector<Pattern> const& _arguments)
Pattern	libevmasm/SimplificationRules.h	/^	Pattern(AssemblyItemType _type = UndefinedItem): m_type(_type) {}$/;"	f	class:dev::eth::Pattern	access:public	signature:(AssemblyItemType _type = UndefinedItem)
Pattern	libevmasm/SimplificationRules.h	/^	Pattern(Instruction _instruction, std::vector<Pattern> const& _arguments = {});$/;"	p	class:dev::eth::Pattern	access:public	signature:(Instruction _instruction, std::vector<Pattern> const& _arguments = {})
Pattern	libevmasm/SimplificationRules.h	/^	Pattern(u256 const& _value): m_type(Push), m_requireDataMatch(true), m_data(std::make_shared<u256>(_value)) {}$/;"	f	class:dev::eth::Pattern	access:public	signature:(u256 const& _value)
Pattern	libevmasm/SimplificationRules.h	/^	Pattern(unsigned _value): Pattern(u256(_value)) {}$/;"	f	class:dev::eth::Pattern	access:public	signature:(unsigned _value)
Pattern	libevmasm/SimplificationRules.h	/^class Pattern$/;"	c	namespace:dev::eth
Pattern	libyul/optimiser/SimplificationRules.cpp	/^Pattern::Pattern(solidity::Instruction _instruction, vector<Pattern> const& _arguments):$/;"	f	class:Pattern	signature:(solidity::Instruction _instruction, vector<Pattern> const& _arguments)
Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(PatternKind _kind = PatternKind::Any): m_kind(_kind) {}$/;"	f	class:yul::Pattern	access:public	signature:(PatternKind _kind = PatternKind::Any)
Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(dev::solidity::Instruction _instruction, std::vector<Pattern> const& _arguments = {});$/;"	p	class:yul::Pattern	access:public	signature:(dev::solidity::Instruction _instruction, std::vector<Pattern> const& _arguments = {})
Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(dev::u256 const& _value): m_kind(PatternKind::Constant), m_data(std::make_shared<dev::u256>(_value)) {}$/;"	f	class:yul::Pattern	access:public	signature:(dev::u256 const& _value)
Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(unsigned _value): Pattern(dev::u256(_value)) {}$/;"	f	class:yul::Pattern	access:public	signature:(unsigned _value)
Pattern	libyul/optimiser/SimplificationRules.h	/^class Pattern$/;"	c	namespace:yul
Pattern::Pattern	libevmasm/SimplificationRules.cpp	/^Pattern::Pattern(Instruction _instruction, std::vector<Pattern> const& _arguments):$/;"	f	class:Pattern	signature:(Instruction _instruction, std::vector<Pattern> const& _arguments)
Pattern::Pattern	libyul/optimiser/SimplificationRules.cpp	/^Pattern::Pattern(solidity::Instruction _instruction, vector<Pattern> const& _arguments):$/;"	f	class:Pattern	signature:(solidity::Instruction _instruction, vector<Pattern> const& _arguments)
Pattern::Pattern::matchGroupValue	libevmasm/SimplificationRules.cpp	/^Pattern::Expression const& Pattern::matchGroupValue() const$/;"	f	class:Pattern::Pattern	signature:() const
Pattern::d	libyul/optimiser/SimplificationRules.cpp	/^u256 Pattern::d() const$/;"	f	class:Pattern	signature:() const
Pattern::data	libevmasm/SimplificationRules.cpp	/^u256 const& Pattern::data() const$/;"	f	class:Pattern	signature:() const
Pattern::instruction	libyul/optimiser/SimplificationRules.cpp	/^solidity::Instruction Pattern::instruction() const$/;"	f	class:Pattern	signature:() const
Pattern::matchGroupValue	libyul/optimiser/SimplificationRules.cpp	/^Expression const& Pattern::matchGroupValue() const$/;"	f	class:Pattern	signature:() const
Pattern::matches	libevmasm/SimplificationRules.cpp	/^bool Pattern::matches(Expression const& _expr, ExpressionClasses const& _classes) const$/;"	f	class:Pattern	signature:(Expression const& _expr, ExpressionClasses const& _classes) const
Pattern::matches	libyul/optimiser/SimplificationRules.cpp	/^bool Pattern::matches($/;"	f	class:Pattern	signature:( Expression const& _expr, Dialect const& _dialect, map<YulString, Expression const*> const& _ssaValues ) const
Pattern::matchesBaseItem	libevmasm/SimplificationRules.cpp	/^bool Pattern::matchesBaseItem(AssemblyItem const* _item) const$/;"	f	class:Pattern	signature:(AssemblyItem const* _item) const
Pattern::setMatchGroup	libevmasm/SimplificationRules.cpp	/^void Pattern::setMatchGroup(unsigned _group, map<unsigned, Expression const*>& _matchGroups)$/;"	f	class:Pattern	signature:(unsigned _group, map<unsigned, Expression const*>& _matchGroups)
Pattern::setMatchGroup	libyul/optimiser/SimplificationRules.cpp	/^void Pattern::setMatchGroup(unsigned _group, map<unsigned, Expression const*>& _matchGroups)$/;"	f	class:Pattern	signature:(unsigned _group, map<unsigned, Expression const*>& _matchGroups)
Pattern::toAssemblyItem	libevmasm/SimplificationRules.cpp	/^AssemblyItem Pattern::toAssemblyItem(SourceLocation const& _location) const$/;"	f	class:Pattern	signature:(SourceLocation const& _location) const
Pattern::toExpression	libyul/optimiser/SimplificationRules.cpp	/^Expression Pattern::toExpression(SourceLocation const& _location) const$/;"	f	class:Pattern	signature:(SourceLocation const& _location) const
Pattern::toString	libevmasm/SimplificationRules.cpp	/^string Pattern::toString() const$/;"	f	class:Pattern	signature:() const
PatternKind	libyul/optimiser/SimplificationRules.h	/^enum class PatternKind$/;"	c	namespace:yul
PeepholeOptimisationMethod	libevmasm/PeepholeOptimiser.h	/^class PeepholeOptimisationMethod$/;"	c	namespace:dev::eth
PeepholeOptimiser	libevmasm/PeepholeOptimiser.h	/^	explicit PeepholeOptimiser(AssemblyItems& _items): m_items(_items) {}$/;"	f	class:dev::eth::PeepholeOptimiser	access:public	signature:(AssemblyItems& _items)
PeepholeOptimiser	libevmasm/PeepholeOptimiser.h	/^class PeepholeOptimiser$/;"	c	namespace:dev::eth
PeepholeOptimiser::optimise	libevmasm/PeepholeOptimiser.cpp	/^bool PeepholeOptimiser::optimise()$/;"	f	class:PeepholeOptimiser	signature:()
PlaceholderStatement	libsolidity/ast/AST.h	/^	explicit PlaceholderStatement($/;"	f	class:dev::solidity::PlaceholderStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString )
PlaceholderStatement	libsolidity/ast/AST.h	/^class PlaceholderStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
Plen	libdevcore/Keccak256.cpp	136;"	d	file:
PostTypeChecker	libsolidity/analysis/PostTypeChecker.h	/^	PostTypeChecker(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::PostTypeChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter)
PostTypeChecker	libsolidity/analysis/PostTypeChecker.h	/^class PostTypeChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
PostTypeChecker::check	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::check(ASTNode const& _astRoot)$/;"	f	class:PostTypeChecker	signature:(ASTNode const& _astRoot)
PostTypeChecker::endVisit	libsolidity/analysis/PostTypeChecker.cpp	/^void PostTypeChecker::endVisit(ContractDefinition const&)$/;"	f	class:PostTypeChecker	signature:(ContractDefinition const&)
PostTypeChecker::endVisit	libsolidity/analysis/PostTypeChecker.cpp	/^void PostTypeChecker::endVisit(VariableDeclaration const& _variable)$/;"	f	class:PostTypeChecker	signature:(VariableDeclaration const& _variable)
PostTypeChecker::findCycle	libsolidity/analysis/PostTypeChecker.cpp	/^VariableDeclaration const* PostTypeChecker::findCycle(VariableDeclaration const& _startingFrom)$/;"	f	class:PostTypeChecker	signature:(VariableDeclaration const& _startingFrom)
PostTypeChecker::visit	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::visit(ContractDefinition const&)$/;"	f	class:PostTypeChecker	signature:(ContractDefinition const&)
PostTypeChecker::visit	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::visit(Identifier const& _identifier)$/;"	f	class:PostTypeChecker	signature:(Identifier const& _identifier)
PostTypeChecker::visit	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::visit(VariableDeclaration const& _variable)$/;"	f	class:PostTypeChecker	signature:(VariableDeclaration const& _variable)
PragmaDirective	libsolidity/ast/AST.h	/^	PragmaDirective($/;"	f	class:dev::solidity::PragmaDirective	access:public	signature:( SourceLocation const& _location, std::vector<Token> const& _tokens, std::vector<ASTString> const& _literals )
PragmaDirective	libsolidity/ast/AST.h	/^class PragmaDirective: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
PrimaryExpression	libsolidity/ast/AST.h	/^	PrimaryExpression(SourceLocation const& _location): Expression(_location) {}$/;"	f	class:dev::solidity::PrimaryExpression	access:public	signature:(SourceLocation const& _location)
PrimaryExpression	libsolidity/ast/AST.h	/^class PrimaryExpression: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
Private	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
Public	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
Pure	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	m	class:dev::solidity::StateMutability	access:private
Push	libevmasm/AssemblyItem.h	/^	Push,$/;"	e	enum:dev::eth::AssemblyItemType
PushData	libevmasm/AssemblyItem.h	/^	PushData,$/;"	e	enum:dev::eth::AssemblyItemType
PushDeployTimeAddress	libevmasm/AssemblyItem.h	/^	PushDeployTimeAddress \/\/\/< Push an address to be filled at deploy time. Should not be touched by the optimizer.$/;"	e	enum:dev::eth::AssemblyItemType
PushLibraryAddress	libevmasm/AssemblyItem.h	/^	PushLibraryAddress, \/\/\/< Push a currently unknown address of another (library) contract.$/;"	e	enum:dev::eth::AssemblyItemType
PushPop	libevmasm/PeepholeOptimiser.cpp	/^struct PushPop: SimplePeepholeOptimizerMethod<PushPop, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
PushProgramSize	libevmasm/AssemblyItem.h	/^	PushProgramSize,$/;"	e	enum:dev::eth::AssemblyItemType
PushString	libevmasm/AssemblyItem.h	/^	PushString,$/;"	e	enum:dev::eth::AssemblyItemType
PushSub	libevmasm/AssemblyItem.h	/^	PushSub,$/;"	e	enum:dev::eth::AssemblyItemType
PushSubSize	libevmasm/AssemblyItem.h	/^	PushSubSize,$/;"	e	enum:dev::eth::AssemblyItemType
PushTag	libevmasm/AssemblyItem.h	/^	PushTag,$/;"	e	enum:dev::eth::AssemblyItemType
RC	libdevcore/Keccak256.cpp	/^static uint64_t const RC[24] = \\$/;"	m	namespace:dev::__anon23	file:
RED	libdevcore/AnsiColorized.h	/^static constexpr char const* RED = "\\033[31m";$/;"	m	namespace:dev::formatting
RED_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* RED_BACKGROUND = "\\033[41m";$/;"	m	namespace:dev::formatting
RED_BACKGROUND_256	libdevcore/AnsiColorized.h	/^static constexpr char const* RED_BACKGROUND_256 = "\\033[48;5;160m";$/;"	m	namespace:dev::formatting
REPEAT24	libdevcore/Keccak256.cpp	71;"	d	file:
REPEAT5	libdevcore/Keccak256.cpp	72;"	d	file:
REPEAT6	libdevcore/Keccak256.cpp	70;"	d	file:
RESET	libdevcore/AnsiColorized.h	/^static constexpr char const* RESET = "\\033[0m";$/;"	m	namespace:dev::formatting
RETURN	libevmasm/Instruction.h	/^	RETURN,				\/\/\/< halt execution returning output data$/;"	m	class:dev::solidity::Instruction	access:private
RETURN	solse/SolidityExprTranslator.h	/^enum TerminationCode { NONE, RETURN, CONTINUE, BREAK, THROW };$/;"	e	enum:TerminationCode
RETURNDATACOPY	libevmasm/Instruction.h	/^	RETURNDATACOPY = 0x3e,	\/\/\/< copy return data in current environment to memory$/;"	m	class:dev::solidity::Instruction	access:private
RETURNDATASIZE	libevmasm/Instruction.h	/^	RETURNDATASIZE = 0x3d,	\/\/\/< get size of return data buffer$/;"	m	class:dev::solidity::Instruction	access:private
RETURNSUB	libevmasm/Instruction.h	/^	RETURNSUB,          \/\/\/< return to subroutine jumped from -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
REVERT	libevmasm/Instruction.h	/^	REVERT = 0xfd,		\/\/\/< halt execution, revert state and return output data$/;"	m	class:dev::solidity::Instruction	access:private
RIPEMD160	libsolidity/ast/Types.h	/^		RIPEMD160, \/\/\/< CALL to special contract for ripemd160$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
RationalNumber	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
RationalNumberType	libsolidity/ast/Types.h	/^	explicit RationalNumberType(rational const& _value, TypePointer const& _compatibleBytesType = TypePointer()):$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:(rational const& _value, TypePointer const& _compatibleBytesType = TypePointer())
RationalNumberType	libsolidity/ast/Types.h	/^class RationalNumberType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
RationalNumberType::bigintToReadableString	libsolidity/ast/Types.cpp	/^string RationalNumberType::bigintToReadableString(dev::bigint const& _num)$/;"	f	class:RationalNumberType	signature:(dev::bigint const& _num)
RationalNumberType::binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult RationalNumberType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:RationalNumberType	signature:(Token _operator, TypePointer const& _other) const
RationalNumberType::fixedPointType	libsolidity/ast/Types.cpp	/^shared_ptr<FixedPointType const> RationalNumberType::fixedPointType() const$/;"	f	class:RationalNumberType	signature:() const
RationalNumberType::forLiteral	libsolidity/ast/Types.cpp	/^TypePointer RationalNumberType::forLiteral(Literal const& _literal)$/;"	f	class:RationalNumberType	signature:(Literal const& _literal)
RationalNumberType::integerType	libsolidity/ast/Types.cpp	/^shared_ptr<IntegerType const> RationalNumberType::integerType() const$/;"	f	class:RationalNumberType	signature:() const
RationalNumberType::isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult RationalNumberType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:RationalNumberType	signature:(Type const& _convertTo) const
RationalNumberType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult RationalNumberType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:RationalNumberType	signature:(Type const& _convertTo) const
RationalNumberType::isValidLiteral	libsolidity/ast/Types.cpp	/^tuple<bool, rational> RationalNumberType::isValidLiteral(Literal const& _literal)$/;"	f	class:RationalNumberType	signature:(Literal const& _literal)
RationalNumberType::literalValue	libsolidity/ast/Types.cpp	/^u256 RationalNumberType::literalValue(Literal const*) const$/;"	f	class:RationalNumberType	signature:(Literal const*) const
RationalNumberType::mobileType	libsolidity/ast/Types.cpp	/^TypePointer RationalNumberType::mobileType() const$/;"	f	class:RationalNumberType	signature:() const
RationalNumberType::operator ==	libsolidity/ast/Types.cpp	/^bool RationalNumberType::operator==(Type const& _other) const$/;"	f	class:RationalNumberType	signature:(Type const& _other) const
RationalNumberType::parseRational	libsolidity/ast/Types.cpp	/^tuple<bool, rational> RationalNumberType::parseRational(string const& _value)$/;"	f	class:RationalNumberType	signature:(string const& _value)
RationalNumberType::richIdentifier	libsolidity/ast/Types.cpp	/^string RationalNumberType::richIdentifier() const$/;"	f	class:RationalNumberType	signature:() const
RationalNumberType::toString	libsolidity/ast/Types.cpp	/^string RationalNumberType::toString(bool) const$/;"	f	class:RationalNumberType	signature:(bool) const
RationalNumberType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult RationalNumberType::unaryOperatorResult(Token _operator) const$/;"	f	class:RationalNumberType	signature:(Token _operator) const
ReadCallback	libsolidity/interface/ReadFile.h	/^class ReadCallback: boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
RecursionGuard	liblangutil/ParserBase.h	/^		explicit RecursionGuard(ParserBase& _parser): m_parser(_parser)$/;"	f	class:langutil::ParserBase::RecursionGuard	access:public	signature:(ParserBase& _parser)
RecursionGuard	liblangutil/ParserBase.h	/^	class RecursionGuard$/;"	c	class:langutil::ParserBase	access:protected
RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator() = default;$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:()
RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator(RedundantAssignEliminator const&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator const&)
RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator(RedundantAssignEliminator&&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator&&)
RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	explicit RedundantAssignEliminator(Dialect const& _dialect): m_dialect(&_dialect) {}$/;"	f	class:yul::RedundantAssignEliminator	access:public	signature:(Dialect const& _dialect)
RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^class RedundantAssignEliminator: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
RedundantAssignEliminator::changeUndecidedTo	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::changeUndecidedTo(YulString _variable, RedundantAssignEliminator::State _newState)$/;"	f	class:RedundantAssignEliminator	signature:(YulString _variable, RedundantAssignEliminator::State _newState)
RedundantAssignEliminator::finalize	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::finalize(YulString _variable)$/;"	f	class:RedundantAssignEliminator	signature:(YulString _variable)
RedundantAssignEliminator::join	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::join(RedundantAssignEliminator& _other)$/;"	f	class:RedundantAssignEliminator	signature:(RedundantAssignEliminator& _other)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Assignment const& _assignment)$/;"	f	class:RedundantAssignEliminator	signature:(Assignment const& _assignment)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Block const& _block)$/;"	f	class:RedundantAssignEliminator	signature:(Block const& _block)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(ForLoop const& _forLoop)$/;"	f	class:RedundantAssignEliminator	signature:(ForLoop const& _forLoop)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(FunctionDefinition const& _functionDefinition)$/;"	f	class:RedundantAssignEliminator	signature:(FunctionDefinition const& _functionDefinition)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Identifier const& _identifier)$/;"	f	class:RedundantAssignEliminator	signature:(Identifier const& _identifier)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(If const& _if)$/;"	f	class:RedundantAssignEliminator	signature:(If const& _if)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Switch const& _switch)$/;"	f	class:RedundantAssignEliminator	signature:(Switch const& _switch)
RedundantAssignEliminator::operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(VariableDeclaration const& _variableDeclaration)$/;"	f	class:RedundantAssignEliminator	signature:(VariableDeclaration const& _variableDeclaration)
RedundantAssignEliminator::run	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::run(Dialect const& _dialect, Block& _ast)$/;"	f	class:RedundantAssignEliminator	signature:(Dialect const& _dialect, Block& _ast)
ReferenceType	libsolidity/ast/Types.h	/^	explicit ReferenceType(DataLocation _location): m_location(_location) {}$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:(DataLocation _location)
ReferenceType	libsolidity/ast/Types.h	/^class ReferenceType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
ReferenceType::copyForLocationIfReference	libsolidity/ast/Types.cpp	/^TypePointer ReferenceType::copyForLocationIfReference(DataLocation _location, TypePointer const& _type)$/;"	f	class:ReferenceType	signature:(DataLocation _location, TypePointer const& _type)
ReferenceType::copyForLocationIfReference	libsolidity/ast/Types.cpp	/^TypePointer ReferenceType::copyForLocationIfReference(TypePointer const& _type) const$/;"	f	class:ReferenceType	signature:(TypePointer const& _type) const
ReferenceType::identifierLocationSuffix	libsolidity/ast/Types.cpp	/^string ReferenceType::identifierLocationSuffix() const$/;"	f	class:ReferenceType	signature:() const
ReferenceType::stringForReferencePart	libsolidity/ast/Types.cpp	/^string ReferenceType::stringForReferencePart() const$/;"	f	class:ReferenceType	signature:() const
ReferenceType::unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult ReferenceType::unaryOperatorResult(Token _operator) const$/;"	f	class:ReferenceType	signature:(Token _operator) const
ReferencesCounter	libyul/optimiser/NameCollector.h	/^class ReferencesCounter: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
ReferencesCounter::countReferences	libyul/optimiser/NameCollector.cpp	/^map<YulString, size_t> ReferencesCounter::countReferences(Block const& _block)$/;"	f	class:ReferencesCounter	signature:(Block const& _block)
ReferencesCounter::countReferences	libyul/optimiser/NameCollector.cpp	/^map<YulString, size_t> ReferencesCounter::countReferences(Expression const& _expression)$/;"	f	class:ReferencesCounter	signature:(Expression const& _expression)
ReferencesCounter::countReferences	libyul/optimiser/NameCollector.cpp	/^map<YulString, size_t> ReferencesCounter::countReferences(FunctionDefinition const& _function)$/;"	f	class:ReferencesCounter	signature:(FunctionDefinition const& _function)
ReferencesCounter::operator ()	libyul/optimiser/NameCollector.cpp	/^void ReferencesCounter::operator()(FunctionCall const& _funCall)$/;"	f	class:ReferencesCounter	signature:(FunctionCall const& _funCall)
ReferencesCounter::operator ()	libyul/optimiser/NameCollector.cpp	/^void ReferencesCounter::operator()(Identifier const& _identifier)$/;"	f	class:ReferencesCounter	signature:(Identifier const& _identifier)
ReferencesResolver	libsolidity/analysis/ReferencesResolver.h	/^	ReferencesResolver($/;"	f	class:dev::solidity::ReferencesResolver	access:public	signature:( langutil::ErrorReporter& _errorReporter, NameAndTypeResolver& _resolver, bool _resolveInsideCode = false )
ReferencesResolver	libsolidity/analysis/ReferencesResolver.h	/^class ReferencesResolver: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
Remapping	libsolidity/interface/CompilerStack.h	/^	struct Remapping$/;"	s	class:dev::solidity::CompilerStack	access:public
Rematerialiser	libyul/optimiser/Rematerialiser.cpp	/^Rematerialiser::Rematerialiser($/;"	f	class:Rematerialiser	signature:( Dialect const& _dialect, Block& _ast, set<YulString> _varsToAlwaysRematerialize )
Rematerialiser	libyul/optimiser/Rematerialiser.cpp	/^Rematerialiser::Rematerialiser($/;"	f	class:Rematerialiser	signature:( Dialect const& _dialect, FunctionDefinition& _function, set<YulString> _varsToAlwaysRematerialize )
Rematerialiser	libyul/optimiser/Rematerialiser.h	/^	Rematerialiser($/;"	p	class:yul::Rematerialiser	access:protected	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> _varsToAlwaysRematerialize = {} )
Rematerialiser	libyul/optimiser/Rematerialiser.h	/^	Rematerialiser($/;"	p	class:yul::Rematerialiser	access:protected	signature:( Dialect const& _dialect, FunctionDefinition& _function, std::set<YulString> _varsToAlwaysRematerialize = {} )
Rematerialiser	libyul/optimiser/Rematerialiser.h	/^class Rematerialiser: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
Rematerialiser::Rematerialiser	libyul/optimiser/Rematerialiser.cpp	/^Rematerialiser::Rematerialiser($/;"	f	class:Rematerialiser	signature:( Dialect const& _dialect, Block& _ast, set<YulString> _varsToAlwaysRematerialize )
Rematerialiser::Rematerialiser	libyul/optimiser/Rematerialiser.cpp	/^Rematerialiser::Rematerialiser($/;"	f	class:Rematerialiser	signature:( Dialect const& _dialect, FunctionDefinition& _function, set<YulString> _varsToAlwaysRematerialize )
Rematerialiser::run	libyul/optimiser/Rematerialiser.cpp	/^void Rematerialiser::run($/;"	f	class:Rematerialiser	signature:( Dialect const& _dialect, FunctionDefinition& _function, set<YulString> _varsToAlwaysRematerialize )
Rematerialiser::run	libyul/optimiser/Rematerialiser.cpp	/^void Rematerialiser::run(Dialect const& _dialect, Block& _ast, set<YulString> _varsToAlwaysRematerialize)$/;"	f	class:Rematerialiser	signature:(Dialect const& _dialect, Block& _ast, set<YulString> _varsToAlwaysRematerialize)
Rematerialiser::visit	libyul/optimiser/Rematerialiser.cpp	/^void Rematerialiser::visit(Expression& _e)$/;"	f	class:Rematerialiser	signature:(Expression& _e)
Require	libsolidity/ast/Types.h	/^		Require, \/\/\/< require()$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
Result	libdevcore/Result.h	/^	Result(ResultType _value): Result(_value, std::string{}) {}$/;"	f	class:dev::Result	access:public	signature:(ResultType _value)
Result	libdevcore/Result.h	/^	Result(std::string _message): Result(ResultType{}, std::move(_message)) {}$/;"	f	class:dev::Result	access:public	signature:(std::string _message)
Result	libdevcore/Result.h	/^	explicit Result(ResultType _value, std::string _message):$/;"	f	class:dev::Result	access:private	signature:(ResultType _value, std::string _message)
Result	libdevcore/Result.h	/^class Result$/;"	c	namespace:dev
Result	libsolidity/interface/ReadFile.h	/^	struct Result$/;"	s	class:dev::solidity::ReadCallback	access:public
Return	libsolidity/analysis/ControlFlowGraph.h	/^		Return,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
Return	libsolidity/ast/AST.h	/^	Return($/;"	f	class:dev::solidity::Return	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> _expression )
Return	libsolidity/ast/AST.h	/^class Return: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
Return::annotation	libsolidity/ast/AST.cpp	/^ReturnAnnotation& Return::annotation() const$/;"	f	class:Return	signature:() const
ReturnAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ReturnAnnotation: StatementAnnotation$/;"	s	namespace:dev::solidity	inherits:StatementAnnotation
Revert	libsolidity/ast/Types.h	/^		Revert, \/\/\/< REVERT$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
RoughHeuristic	libyul/optimiser/EquivalentFunctionDetector.h	/^		RoughHeuristic(FunctionDefinition const& _fun): m_fun(_fun) {}$/;"	f	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:public	signature:(FunctionDefinition const& _fun)
RoughHeuristic	libyul/optimiser/EquivalentFunctionDetector.h	/^	class RoughHeuristic$/;"	c	class:yul::EquivalentFunctionDetector	access:private
Rules	libevmasm/SimplificationRules.cpp	/^Rules::Rules()$/;"	f	class:Rules	signature:()
Rules	libevmasm/SimplificationRules.h	/^class Rules: public boost::noncopyable$/;"	c	namespace:dev::eth	inherits:boost::noncopyable
Rules::Rules	libevmasm/SimplificationRules.cpp	/^Rules::Rules()$/;"	f	class:Rules	signature:()
Rules::addRule	libevmasm/SimplificationRules.cpp	/^void Rules::addRule(SimplificationRule<Pattern> const& _rule)$/;"	f	class:Rules	signature:(SimplificationRule<Pattern> const& _rule)
Rules::addRules	libevmasm/SimplificationRules.cpp	/^void Rules::addRules(std::vector<SimplificationRule<Pattern>> const& _rules)$/;"	f	class:Rules	signature:(std::vector<SimplificationRule<Pattern>> const& _rules)
Rules::findFirstMatch	libevmasm/SimplificationRules.cpp	/^SimplificationRule<Pattern> const* Rules::findFirstMatch($/;"	f	class:Rules	signature:( Expression const& _expr, ExpressionClasses const& _classes )
Rules::isInitialized	libevmasm/SimplificationRules.cpp	/^bool Rules::isInitialized() const$/;"	f	class:Rules	signature:() const
SAR	libevmasm/Instruction.h	/^	SAR,				\/\/\/< bitwise SAR operation$/;"	m	class:dev::solidity::Instruction	access:private
SATISFIABLE	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
SDIV	libevmasm/Instruction.h	/^	SDIV,				\/\/\/< signed integer division operation$/;"	m	class:dev::solidity::Instruction	access:private
SELFDESTRUCT	libevmasm/Instruction.h	/^	SELFDESTRUCT = 0xff	\/\/\/< halt execution and register account for later deletion$/;"	m	class:dev::solidity::Instruction	access:private
SGT	libevmasm/Instruction.h	/^	SGT,				\/\/\/< signed greater-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
SHA256	libsolidity/ast/Types.h	/^		SHA256, \/\/\/< CALL to special contract for sha256$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
SHL	libevmasm/Instruction.h	/^	SHL,				\/\/\/< bitwise SHL operation$/;"	m	class:dev::solidity::Instruction	access:private
SHR	libevmasm/Instruction.h	/^	SHR,				\/\/\/< bitwise SHR operation$/;"	m	class:dev::solidity::Instruction	access:private
SIGNEXTEND	libevmasm/Instruction.h	/^	SIGNEXTEND,			\/\/\/< extend length of signed integer$/;"	m	class:dev::solidity::Instruction	access:private
SLOAD	libevmasm/Instruction.h	/^	SLOAD,				\/\/\/< load word from storage$/;"	m	class:dev::solidity::Instruction	access:private
SLT	libevmasm/Instruction.h	/^	SLT,				\/\/\/< signed less-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
SMOD	libevmasm/Instruction.h	/^	SMOD,				\/\/\/< signed modulo remainder operation$/;"	m	class:dev::solidity::Instruction	access:private
SMTChecker	libsolidity/ast/ExperimentalFeatures.h	/^	SMTChecker,$/;"	m	class:dev::solidity::ExperimentalFeature	access:private
SMTChecker	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::SMTChecker(ErrorReporter& _errorReporter, map<h256, string> const& _smtlib2Responses):$/;"	f	class:SMTChecker	signature:(ErrorReporter& _errorReporter, map<h256, string> const& _smtlib2Responses)
SMTChecker	libsolidity/formal/SMTChecker.h	/^	SMTChecker(langutil::ErrorReporter& _errorReporter, std::map<h256, std::string> const& _smtlib2Responses);$/;"	p	class:dev::solidity::SMTChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter, std::map<h256, std::string> const& _smtlib2Responses)
SMTChecker	libsolidity/formal/SMTChecker.h	/^class SMTChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
SMTChecker::SMTChecker	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::SMTChecker(ErrorReporter& _errorReporter, map<h256, string> const& _smtlib2Responses):$/;"	f	class:SMTChecker	signature:(ErrorReporter& _errorReporter, map<h256, string> const& _smtlib2Responses)
SMTChecker::abstractFunctionCall	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::abstractFunctionCall(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::addOverflowTarget	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::addOverflowTarget($/;"	f	class:SMTChecker	signature:( OverflowTarget::Type _type, TypePointer _intType, smt::Expression _value, SourceLocation const& _location )
SMTChecker::addPathConjoinedExpression	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::addPathConjoinedExpression(smt::Expression const& _e)$/;"	f	class:SMTChecker	signature:(smt::Expression const& _e)
SMTChecker::addPathImpliedExpression	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::addPathImpliedExpression(smt::Expression const& _e)$/;"	f	class:SMTChecker	signature:(smt::Expression const& _e)
SMTChecker::analyze	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::analyze(SourceUnit const& _source, shared_ptr<Scanner> const& _scanner)$/;"	f	class:SMTChecker	signature:(SourceUnit const& _source, shared_ptr<Scanner> const& _scanner)
SMTChecker::arithmeticOperation	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::arithmeticOperation(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
SMTChecker::arrayAssignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::arrayAssignment()$/;"	f	class:SMTChecker	signature:()
SMTChecker::arrayIndexAssignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::arrayIndexAssignment(Assignment const& _assignment)$/;"	f	class:SMTChecker	signature:(Assignment const& _assignment)
SMTChecker::assignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::assignment(VariableDeclaration const& _variable, Expression const& _value, SourceLocation const& _location)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _variable, Expression const& _value, SourceLocation const& _location)
SMTChecker::assignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::assignment(VariableDeclaration const& _variable, smt::Expression const& _value, SourceLocation const& _location)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _variable, smt::Expression const& _value, SourceLocation const& _location)
SMTChecker::booleanOperation	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::booleanOperation(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
SMTChecker::checkBooleanNotConstant	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkBooleanNotConstant(Expression const& _condition, string const& _description)$/;"	f	class:SMTChecker	signature:(Expression const& _condition, string const& _description)
SMTChecker::checkCondition	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkCondition($/;"	f	class:SMTChecker	signature:( smt::Expression _condition, SourceLocation const& _location, string const& _description, string const& _additionalValueName, smt::Expression* _additionalValue )
SMTChecker::checkOverflow	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkOverflow(OverflowTarget& _target)$/;"	f	class:SMTChecker	signature:(OverflowTarget& _target)
SMTChecker::checkSatisfiable	libsolidity/formal/SMTChecker.cpp	/^smt::CheckResult SMTChecker::checkSatisfiable()$/;"	f	class:SMTChecker	signature:()
SMTChecker::checkSatisfiableAndGenerateModel	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::checkSatisfiableAndGenerateModel(vector<smt::Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTChecker	signature:(vector<smt::Expression> const& _expressionsToEvaluate)
SMTChecker::checkUnderOverflow	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkUnderOverflow()$/;"	f	class:SMTChecker	signature:()
SMTChecker::checkUnderflow	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkUnderflow(OverflowTarget& _target)$/;"	f	class:SMTChecker	signature:(OverflowTarget& _target)
SMTChecker::compareOperation	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::compareOperation(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
SMTChecker::copyVariableIndices	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::VariableIndices SMTChecker::copyVariableIndices()$/;"	f	class:SMTChecker	signature:()
SMTChecker::createExpr	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::createExpr(Expression const& _e)$/;"	f	class:SMTChecker	signature:(Expression const& _e)
SMTChecker::createVariable	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::createVariable(VariableDeclaration const& _varDecl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _varDecl)
SMTChecker::currentPathConditions	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::currentPathConditions()$/;"	f	class:SMTChecker	signature:()
SMTChecker::currentValue	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::currentValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
SMTChecker::defineExpr	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::defineExpr(Expression const& _e, smt::Expression _value)$/;"	f	class:SMTChecker	signature:(Expression const& _e, smt::Expression _value)
SMTChecker::defineGlobalFunction	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::defineGlobalFunction(string const& _name, Expression const& _expr)$/;"	f	class:SMTChecker	signature:(string const& _name, Expression const& _expr)
SMTChecker::defineGlobalVariable	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::defineGlobalVariable(string const& _name, Expression const& _expr, bool _increaseIndex)$/;"	f	class:SMTChecker	signature:(string const& _name, Expression const& _expr, bool _increaseIndex)
SMTChecker::division	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::division(smt::Expression _left, smt::Expression _right, IntegerType const& _type)$/;"	f	class:SMTChecker	signature:(smt::Expression _left, smt::Expression _right, IntegerType const& _type)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Assignment const& _assignment)$/;"	f	class:SMTChecker	signature:(Assignment const& _assignment)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(ContractDefinition const&)$/;"	f	class:SMTChecker	signature:(ContractDefinition const&)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(FunctionDefinition const&)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const&)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Identifier const& _identifier)$/;"	f	class:SMTChecker	signature:(Identifier const& _identifier)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(IndexAccess const& _indexAccess)$/;"	f	class:SMTChecker	signature:(IndexAccess const& _indexAccess)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Literal const& _literal)$/;"	f	class:SMTChecker	signature:(Literal const& _literal)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Return const& _return)$/;"	f	class:SMTChecker	signature:(Return const& _return)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(TupleExpression const& _tuple)$/;"	f	class:SMTChecker	signature:(TupleExpression const& _tuple)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(UnaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(UnaryOperation const& _op)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(VariableDeclaration const& _varDecl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _varDecl)
SMTChecker::endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(VariableDeclarationStatement const& _varDecl)$/;"	f	class:SMTChecker	signature:(VariableDeclarationStatement const& _varDecl)
SMTChecker::eraseArrayKnowledge	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::eraseArrayKnowledge()$/;"	f	class:SMTChecker	signature:()
SMTChecker::expr	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::expr(Expression const& _e)$/;"	f	class:SMTChecker	signature:(Expression const& _e)
SMTChecker::initializeFunctionCallParameters	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::initializeFunctionCallParameters(FunctionDefinition const& _function, vector<smt::Expression> const& _callArgs)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const& _function, vector<smt::Expression> const& _callArgs)
SMTChecker::initializeLocalVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::initializeLocalVariables(FunctionDefinition const& _function)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const& _function)
SMTChecker::inlineFunctionCall	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::inlineFunctionCall(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::isRootFunction	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::isRootFunction()$/;"	f	class:SMTChecker	signature:()
SMTChecker::knownExpr	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::knownExpr(Expression const& _e) const$/;"	f	class:SMTChecker	signature:(Expression const& _e) const
SMTChecker::knownGlobalSymbol	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::knownGlobalSymbol(string const& _var) const$/;"	f	class:SMTChecker	signature:(string const& _var) const
SMTChecker::knownVariable	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::knownVariable(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
SMTChecker::mergeVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::mergeVariables(vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse)$/;"	f	class:SMTChecker	signature:(vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse)
SMTChecker::newValue	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::newValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
SMTChecker::popPathCondition	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::popPathCondition()$/;"	f	class:SMTChecker	signature:()
SMTChecker::pushPathCondition	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::pushPathCondition(smt::Expression const& _e)$/;"	f	class:SMTChecker	signature:(smt::Expression const& _e)
SMTChecker::removeLocalVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::removeLocalVariables()$/;"	f	class:SMTChecker	signature:()
SMTChecker::resetStateVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetStateVariables()$/;"	f	class:SMTChecker	signature:()
SMTChecker::resetStorageReferences	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetStorageReferences()$/;"	f	class:SMTChecker	signature:()
SMTChecker::resetVariable	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariable(VariableDeclaration const& _variable)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _variable)
SMTChecker::resetVariableIndices	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariableIndices(VariableIndices const& _indices)$/;"	f	class:SMTChecker	signature:(VariableIndices const& _indices)
SMTChecker::resetVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariables(function<bool(VariableDeclaration const&)> const& _filter)$/;"	f	class:SMTChecker	signature:(function<bool(VariableDeclaration const&)> const& _filter)
SMTChecker::resetVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariables(vector<VariableDeclaration const*> _variables)$/;"	f	class:SMTChecker	signature:(vector<VariableDeclaration const*> _variables)
SMTChecker::setUnknownValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setUnknownValue(SymbolicVariable& _variable)$/;"	f	class:SMTChecker	signature:(SymbolicVariable& _variable)
SMTChecker::setUnknownValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setUnknownValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
SMTChecker::setZeroValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setZeroValue(SymbolicVariable& _variable)$/;"	f	class:SMTChecker	signature:(SymbolicVariable& _variable)
SMTChecker::setZeroValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setZeroValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
SMTChecker::valueAtIndex	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::valueAtIndex(VariableDeclaration const& _decl, int _index)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl, int _index)
SMTChecker::visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(ContractDefinition const& _contract)$/;"	f	class:SMTChecker	signature:(ContractDefinition const& _contract)
SMTChecker::visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(ForStatement const& _node)$/;"	f	class:SMTChecker	signature:(ForStatement const& _node)
SMTChecker::visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(FunctionDefinition const& _function)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const& _function)
SMTChecker::visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(IfStatement const& _node)$/;"	f	class:SMTChecker	signature:(IfStatement const& _node)
SMTChecker::visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(MemberAccess const& _memberAccess)$/;"	f	class:SMTChecker	signature:(MemberAccess const& _memberAccess)
SMTChecker::visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(WhileStatement const& _node)$/;"	f	class:SMTChecker	signature:(WhileStatement const& _node)
SMTChecker::visitAssert	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitAssert(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::visitBranch	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::VariableIndices SMTChecker::visitBranch(Statement const& _statement, smt::Expression _condition)$/;"	f	class:SMTChecker	signature:(Statement const& _statement, smt::Expression _condition)
SMTChecker::visitBranch	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::VariableIndices SMTChecker::visitBranch(Statement const& _statement, smt::Expression const* _condition)$/;"	f	class:SMTChecker	signature:(Statement const& _statement, smt::Expression const* _condition)
SMTChecker::visitFunctionIdentifier	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitFunctionIdentifier(Identifier const& _identifier)$/;"	f	class:SMTChecker	signature:(Identifier const& _identifier)
SMTChecker::visitGasLeft	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitGasLeft(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::visitRequire	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitRequire(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::visitTypeConversion	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitTypeConversion(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
SMTChecker::visitedFunction	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visitedFunction(FunctionDefinition const* _funDef)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const* _funDef)
SMTLib2Interface	libsolidity/formal/SMTLib2Interface.cpp	/^SMTLib2Interface::SMTLib2Interface(map<h256, string> const& _queryResponses):$/;"	f	class:SMTLib2Interface	signature:(map<h256, string> const& _queryResponses)
SMTLib2Interface	libsolidity/formal/SMTLib2Interface.h	/^	explicit SMTLib2Interface(std::map<h256, std::string> const& _queryResponses);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:public	signature:(std::map<h256, std::string> const& _queryResponses)
SMTLib2Interface	libsolidity/formal/SMTLib2Interface.h	/^class SMTLib2Interface: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
SMTLib2Interface::SMTLib2Interface	libsolidity/formal/SMTLib2Interface.cpp	/^SMTLib2Interface::SMTLib2Interface(map<h256, string> const& _queryResponses):$/;"	f	class:SMTLib2Interface	signature:(map<h256, string> const& _queryResponses)
SMTLib2Interface::addAssertion	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::addAssertion(Expression const& _expr)$/;"	f	class:SMTLib2Interface	signature:(Expression const& _expr)
SMTLib2Interface::check	libsolidity/formal/SMTLib2Interface.cpp	/^pair<CheckResult, vector<string>> SMTLib2Interface::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTLib2Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
SMTLib2Interface::checkSatAndGetValuesCommand	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::checkSatAndGetValuesCommand(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTLib2Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
SMTLib2Interface::declareFunction	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::declareFunction(string const& _name, Sort const& _sort)$/;"	f	class:SMTLib2Interface	signature:(string const& _name, Sort const& _sort)
SMTLib2Interface::declareVariable	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:SMTLib2Interface	signature:(string const& _name, Sort const& _sort)
SMTLib2Interface::parseValues	libsolidity/formal/SMTLib2Interface.cpp	/^vector<string> SMTLib2Interface::parseValues(string::const_iterator _start, string::const_iterator _end)$/;"	f	class:SMTLib2Interface	signature:(string::const_iterator _start, string::const_iterator _end)
SMTLib2Interface::pop	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::pop()$/;"	f	class:SMTLib2Interface	signature:()
SMTLib2Interface::push	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::push()$/;"	f	class:SMTLib2Interface	signature:()
SMTLib2Interface::querySolver	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::querySolver(string const& _input)$/;"	f	class:SMTLib2Interface	signature:(string const& _input)
SMTLib2Interface::reset	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::reset()$/;"	f	class:SMTLib2Interface	signature:()
SMTLib2Interface::toSExpr	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::toSExpr(Expression const& _expr)$/;"	f	class:SMTLib2Interface	signature:(Expression const& _expr)
SMTLib2Interface::toSmtLibSort	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::toSmtLibSort(Sort const& _sort)$/;"	f	class:SMTLib2Interface	signature:(Sort const& _sort)
SMTLib2Interface::toSmtLibSort	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::toSmtLibSort(vector<SortPointer> const& _sorts)$/;"	f	class:SMTLib2Interface	signature:(vector<SortPointer> const& _sorts)
SMTLib2Interface::write	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::write(string _data)$/;"	f	class:SMTLib2Interface	signature:(string _data)
SMTPortfolio	libsolidity/formal/SMTPortfolio.cpp	/^SMTPortfolio::SMTPortfolio(map<h256, string> const& _smtlib2Responses)$/;"	f	class:SMTPortfolio	signature:(map<h256, string> const& _smtlib2Responses)
SMTPortfolio	libsolidity/formal/SMTPortfolio.h	/^	SMTPortfolio(std::map<h256, std::string> const& _smtlib2Responses);$/;"	p	class:dev::solidity::smt::SMTPortfolio	access:public	signature:(std::map<h256, std::string> const& _smtlib2Responses)
SMTPortfolio	libsolidity/formal/SMTPortfolio.h	/^class SMTPortfolio: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
SMTPortfolio::SMTPortfolio	libsolidity/formal/SMTPortfolio.cpp	/^SMTPortfolio::SMTPortfolio(map<h256, string> const& _smtlib2Responses)$/;"	f	class:SMTPortfolio	signature:(map<h256, string> const& _smtlib2Responses)
SMTPortfolio::addAssertion	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::addAssertion(Expression const& _expr)$/;"	f	class:SMTPortfolio	signature:(Expression const& _expr)
SMTPortfolio::check	libsolidity/formal/SMTPortfolio.cpp	/^pair<CheckResult, vector<string>> SMTPortfolio::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTPortfolio	signature:(vector<Expression> const& _expressionsToEvaluate)
SMTPortfolio::declareVariable	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:SMTPortfolio	signature:(string const& _name, Sort const& _sort)
SMTPortfolio::pop	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::pop()$/;"	f	class:SMTPortfolio	signature:()
SMTPortfolio::push	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::push()$/;"	f	class:SMTPortfolio	signature:()
SMTPortfolio::reset	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::reset()$/;"	f	class:SMTPortfolio	signature:()
SMTPortfolio::solverAnswered	libsolidity/formal/SMTPortfolio.cpp	/^bool SMTPortfolio::solverAnswered(CheckResult result)$/;"	f	class:SMTPortfolio	signature:(CheckResult result)
SMTPortfolio::unhandledQueries	libsolidity/formal/SMTPortfolio.cpp	/^vector<string> SMTPortfolio::unhandledQueries()$/;"	f	class:SMTPortfolio	signature:()
SOL_COMMIT_HASH	solidity/BuildInfo.h	4;"	d
SOL_OUTPUT_ASM	libsolidity/codegen/CompilerContext.cpp	48;"	d	file:
SOL_VERSION_BUILDINFO	solidity/BuildInfo.h	10;"	d
SOL_VERSION_COMMIT	solidity/BuildInfo.h	11;"	d
SOL_VERSION_PLATFORM	solidity/BuildInfo.h	12;"	d
SOL_VERSION_PRERELEASE	solidity/BuildInfo.h	9;"	d
SSAReverser	libyul/optimiser/SSAReverser.h	/^	SSAReverser(AssignmentCounter const& _assignmentCounter): m_assignmentCounter(_assignmentCounter) {}$/;"	f	class:yul::SSAReverser	access:private	signature:(AssignmentCounter const& _assignmentCounter)
SSAReverser	libyul/optimiser/SSAReverser.h	/^class SSAReverser: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
SSAReverser::operator ()	libyul/optimiser/SSAReverser.cpp	/^void SSAReverser::operator()(Block& _block)$/;"	f	class:SSAReverser	signature:(Block& _block)
SSAReverser::run	libyul/optimiser/SSAReverser.cpp	/^void SSAReverser::run(Block& _block)$/;"	f	class:SSAReverser	signature:(Block& _block)
SSATransform	libyul/optimiser/SSATransform.h	/^	explicit SSATransform(NameDispenser& _nameDispenser, std::set<YulString> const& _variablesToReplace):$/;"	f	class:yul::SSATransform	access:private	signature:(NameDispenser& _nameDispenser, std::set<YulString> const& _variablesToReplace)
SSATransform	libyul/optimiser/SSATransform.h	/^class SSATransform: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
SSATransform::operator ()	libyul/optimiser/SSATransform.cpp	/^void SSATransform::operator()(Block& _block)$/;"	f	class:SSATransform	signature:(Block& _block)
SSATransform::operator ()	libyul/optimiser/SSATransform.cpp	/^void SSATransform::operator()(ForLoop& _for)$/;"	f	class:SSATransform	signature:(ForLoop& _for)
SSATransform::operator ()	libyul/optimiser/SSATransform.cpp	/^void SSATransform::operator()(Identifier& _identifier)$/;"	f	class:SSATransform	signature:(Identifier& _identifier)
SSATransform::run	libyul/optimiser/SSATransform.cpp	/^void SSATransform::run(Block& _ast, NameDispenser& _nameDispenser)$/;"	f	class:SSATransform	signature:(Block& _ast, NameDispenser& _nameDispenser)
SSAValueTracker	libyul/optimiser/SSAValueTracker.h	/^class SSAValueTracker: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
SSAValueTracker::operator ()	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::operator()(Assignment const& _assignment)$/;"	f	class:SSAValueTracker	signature:(Assignment const& _assignment)
SSAValueTracker::operator ()	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::operator()(FunctionDefinition const& _funDef)$/;"	f	class:SSAValueTracker	signature:(FunctionDefinition const& _funDef)
SSAValueTracker::operator ()	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:SSAValueTracker	signature:(VariableDeclaration const& _varDecl)
SSAValueTracker::setValue	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::setValue(YulString _name, Expression const* _value)$/;"	f	class:SSAValueTracker	signature:(YulString _name, Expression const* _value)
SSAVariable	libsolidity/formal/SSAVariable.cpp	/^SSAVariable::SSAVariable()$/;"	f	class:SSAVariable	signature:()
SSAVariable	libsolidity/formal/SSAVariable.h	/^	SSAVariable();$/;"	p	class:dev::solidity::SSAVariable	access:public	signature:()
SSAVariable	libsolidity/formal/SSAVariable.h	/^class SSAVariable$/;"	c	namespace:dev::solidity
SSAVariable::SSAVariable	libsolidity/formal/SSAVariable.cpp	/^SSAVariable::SSAVariable()$/;"	f	class:SSAVariable	signature:()
SSAVariable::resetIndex	libsolidity/formal/SSAVariable.cpp	/^void SSAVariable::resetIndex()$/;"	f	class:SSAVariable	signature:()
SSTORE	libevmasm/Instruction.h	/^	SSTORE,				\/\/\/< save word to storage$/;"	m	class:dev::solidity::Instruction	access:private
STATICCALL	libevmasm/Instruction.h	/^	STATICCALL = 0xfa,	\/\/\/< like CALL but disallow state modifications$/;"	m	class:dev::solidity::Instruction	access:private
STDERR_FILENO	solse/CommandLineInterface.cpp	71;"	d	file:
STOP	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	m	class:dev::eth::BasicBlock::EndType	access:private
STOP	libevmasm/Instruction.h	/^	STOP = 0x00,		\/\/\/< halts execution$/;"	m	class:dev::solidity::Instruction	access:private
SUB	libevmasm/Instruction.h	/^	SUB,				\/\/\/< subtraction operation$/;"	m	class:dev::solidity::Instruction	access:private
SWAP1	libevmasm/Instruction.h	/^	SWAP1 = 0x90,		\/\/\/< swaps the highest and second highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP10	libevmasm/Instruction.h	/^	SWAP10,				\/\/\/< swaps the highest and 11th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP11	libevmasm/Instruction.h	/^	SWAP11,				\/\/\/< swaps the highest and 12th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP12	libevmasm/Instruction.h	/^	SWAP12,				\/\/\/< swaps the highest and 13th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP13	libevmasm/Instruction.h	/^	SWAP13,				\/\/\/< swaps the highest and 14th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP14	libevmasm/Instruction.h	/^	SWAP14,				\/\/\/< swaps the highest and 15th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP15	libevmasm/Instruction.h	/^	SWAP15,				\/\/\/< swaps the highest and 16th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP16	libevmasm/Instruction.h	/^	SWAP16,				\/\/\/< swaps the highest and 17th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP2	libevmasm/Instruction.h	/^	SWAP2,				\/\/\/< swaps the highest and third highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP3	libevmasm/Instruction.h	/^	SWAP3,				\/\/\/< swaps the highest and 4th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP4	libevmasm/Instruction.h	/^	SWAP4,				\/\/\/< swaps the highest and 5th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP5	libevmasm/Instruction.h	/^	SWAP5,				\/\/\/< swaps the highest and 6th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP6	libevmasm/Instruction.h	/^	SWAP6,				\/\/\/< swaps the highest and 7th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP7	libevmasm/Instruction.h	/^	SWAP7,				\/\/\/< swaps the highest and 8th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP8	libevmasm/Instruction.h	/^	SWAP8,				\/\/\/< swaps the highest and 9th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
SWAP9	libevmasm/Instruction.h	/^	SWAP9,				\/\/\/< swaps the highest and 10th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
Scanner	liblangutil/Scanner.h	/^	explicit Scanner(CharStream _source = CharStream()) { reset(std::move(_source)); }$/;"	f	class:langutil::Scanner	access:public	signature:(CharStream _source = CharStream())
Scanner	liblangutil/Scanner.h	/^	explicit Scanner(std::shared_ptr<CharStream> _source) { reset(std::move(_source)); }$/;"	f	class:langutil::Scanner	access:public	signature:(std::shared_ptr<CharStream> _source)
Scanner	liblangutil/Scanner.h	/^class Scanner$/;"	c	namespace:langutil
ScannerError	liblangutil/Scanner.h	/^enum class ScannerError$/;"	c	namespace:langutil
Scopable	libsolidity/ast/AST.h	/^class Scopable$/;"	c	namespace:dev::solidity
Scopable::sourceUnit	libsolidity/ast/AST.cpp	/^SourceUnit const& Scopable::sourceUnit() const$/;"	f	class:Scopable	signature:() const
Scopable::sourceUnitName	libsolidity/ast/AST.cpp	/^string Scopable::sourceUnitName() const$/;"	f	class:Scopable	signature:() const
Scope	libyul/AsmScope.h	/^struct Scope$/;"	s	namespace:yul
Scope	libyul/optimiser/DataFlowAnalyzer.h	/^		explicit Scope(bool _isFunction): isFunction(_isFunction) {}$/;"	f	struct:yul::DataFlowAnalyzer::Scope	access:public	signature:(bool _isFunction)
Scope	libyul/optimiser/DataFlowAnalyzer.h	/^	struct Scope$/;"	s	class:yul::DataFlowAnalyzer	access:protected
Scope::exists	libyul/AsmScope.cpp	/^bool Scope::exists(YulString _name) const$/;"	f	class:Scope	signature:(YulString _name) const
Scope::insideFunction	libyul/AsmScope.cpp	/^bool Scope::insideFunction() const$/;"	f	class:Scope	signature:() const
Scope::lookup	libyul/AsmScope.cpp	/^Scope::Identifier* Scope::lookup(YulString _name)$/;"	f	class:Scope	signature:(YulString _name)
Scope::numberOfVariables	libyul/AsmScope.cpp	/^size_t Scope::numberOfVariables() const$/;"	f	class:Scope	signature:() const
Scope::registerFunction	libyul/AsmScope.cpp	/^bool Scope::registerFunction(YulString _name, std::vector<YulType> const& _arguments, std::vector<YulType> const& _returns)$/;"	f	class:Scope	signature:(YulString _name, std::vector<YulType> const& _arguments, std::vector<YulType> const& _returns)
Scope::registerLabel	libyul/AsmScope.cpp	/^bool Scope::registerLabel(YulString _name)$/;"	f	class:Scope	signature:(YulString _name)
Scope::registerVariable	libyul/AsmScope.cpp	/^bool Scope::registerVariable(YulString _name, YulType const& _type)$/;"	f	class:Scope	signature:(YulString _name, YulType const& _type)
ScopeFiller	libyul/AsmScopeFiller.cpp	/^ScopeFiller::ScopeFiller(AsmAnalysisInfo& _info, ErrorReporter& _errorReporter):$/;"	f	class:ScopeFiller	signature:(AsmAnalysisInfo& _info, ErrorReporter& _errorReporter)
ScopeFiller	libyul/AsmScopeFiller.h	/^	ScopeFiller(AsmAnalysisInfo& _info, langutil::ErrorReporter& _errorReporter);$/;"	p	class:yul::ScopeFiller	access:public	signature:(AsmAnalysisInfo& _info, langutil::ErrorReporter& _errorReporter)
ScopeFiller	libyul/AsmScopeFiller.h	/^class ScopeFiller: public boost::static_visitor<bool>$/;"	c	namespace:yul	inherits:boost::static_visitor
ScopeFiller::ScopeFiller	libyul/AsmScopeFiller.cpp	/^ScopeFiller::ScopeFiller(AsmAnalysisInfo& _info, ErrorReporter& _errorReporter):$/;"	f	class:ScopeFiller	signature:(AsmAnalysisInfo& _info, ErrorReporter& _errorReporter)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(Block const& _block)$/;"	f	class:ScopeFiller	signature:(Block const& _block)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(ExpressionStatement const& _expr)$/;"	f	class:ScopeFiller	signature:(ExpressionStatement const& _expr)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(ForLoop const& _forLoop)$/;"	f	class:ScopeFiller	signature:(ForLoop const& _forLoop)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(FunctionDefinition const& _funDef)$/;"	f	class:ScopeFiller	signature:(FunctionDefinition const& _funDef)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(If const& _if)$/;"	f	class:ScopeFiller	signature:(If const& _if)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(Label const& _item)$/;"	f	class:ScopeFiller	signature:(Label const& _item)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(Switch const& _switch)$/;"	f	class:ScopeFiller	signature:(Switch const& _switch)
ScopeFiller::operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:ScopeFiller	signature:(VariableDeclaration const& _varDecl)
ScopeFiller::registerVariable	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::registerVariable(TypedName const& _name, SourceLocation const& _location, Scope& _scope)$/;"	f	class:ScopeFiller	signature:(TypedName const& _name, SourceLocation const& _location, Scope& _scope)
ScopeFiller::scope	libyul/AsmScopeFiller.cpp	/^Scope& ScopeFiller::scope(Block const* _block)$/;"	f	class:ScopeFiller	signature:(Block const* _block)
ScopeGuard	libdevcore/Common.h	/^	explicit ScopeGuard(std::function<void(void)> _f): m_f(_f) {}$/;"	f	class:dev::ScopeGuard	access:public	signature:(std::function<void(void)> _f)
ScopeGuard	libdevcore/Common.h	/^class ScopeGuard$/;"	c	namespace:dev
Second	libsolidity/ast/AST.h	/^		Second = static_cast<int>(Token::SubSecond),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
SecondarySourceLocation	liblangutil/Exceptions.h	/^class SecondarySourceLocation$/;"	c	namespace:langutil
Selfdestruct	libsolidity/ast/Types.h	/^		Selfdestruct, \/\/\/< SELFDESTRUCT$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
SemVerError	libsolidity/analysis/SemVerHandler.h	/^class SemVerError: dev::Exception$/;"	c	namespace:dev::solidity	inherits:dev::Exception
SemVerMatchExpression	libsolidity/analysis/SemVerHandler.h	/^struct SemVerMatchExpression$/;"	s	namespace:dev::solidity
SemVerMatchExpression::Conjunction::matches	libsolidity/analysis/SemVerHandler.cpp	/^bool SemVerMatchExpression::Conjunction::matches(SemVerVersion const& _version) const$/;"	f	class:SemVerMatchExpression::Conjunction	signature:(SemVerVersion const& _version) const
SemVerMatchExpression::MatchComponent::matches	libsolidity/analysis/SemVerHandler.cpp	/^bool SemVerMatchExpression::MatchComponent::matches(SemVerVersion const& _version) const$/;"	f	class:SemVerMatchExpression::MatchComponent	signature:(SemVerVersion const& _version) const
SemVerMatchExpression::matches	libsolidity/analysis/SemVerHandler.cpp	/^bool SemVerMatchExpression::matches(SemVerVersion const& _version) const$/;"	f	class:SemVerMatchExpression	signature:(SemVerVersion const& _version) const
SemVerMatchExpressionParser	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpressionParser(std::vector<Token> const& _tokens, std::vector<std::string> const& _literals):$/;"	f	class:dev::solidity::SemVerMatchExpressionParser	access:public	signature:(std::vector<Token> const& _tokens, std::vector<std::string> const& _literals)
SemVerMatchExpressionParser	libsolidity/analysis/SemVerHandler.h	/^class SemVerMatchExpressionParser$/;"	c	namespace:dev::solidity
SemVerMatchExpressionParser::currentChar	libsolidity/analysis/SemVerHandler.cpp	/^char SemVerMatchExpressionParser::currentChar() const$/;"	f	class:SemVerMatchExpressionParser	signature:() const
SemVerMatchExpressionParser::currentToken	libsolidity/analysis/SemVerHandler.cpp	/^Token SemVerMatchExpressionParser::currentToken() const$/;"	f	class:SemVerMatchExpressionParser	signature:() const
SemVerMatchExpressionParser::nextChar	libsolidity/analysis/SemVerHandler.cpp	/^char SemVerMatchExpressionParser::nextChar()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerMatchExpressionParser::nextToken	libsolidity/analysis/SemVerHandler.cpp	/^void SemVerMatchExpressionParser::nextToken()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerMatchExpressionParser::parse	libsolidity/analysis/SemVerHandler.cpp	/^SemVerMatchExpression SemVerMatchExpressionParser::parse()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerMatchExpressionParser::parseMatchComponent	libsolidity/analysis/SemVerHandler.cpp	/^SemVerMatchExpression::MatchComponent SemVerMatchExpressionParser::parseMatchComponent()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerMatchExpressionParser::parseMatchExpression	libsolidity/analysis/SemVerHandler.cpp	/^void SemVerMatchExpressionParser::parseMatchExpression()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerMatchExpressionParser::parseVersionPart	libsolidity/analysis/SemVerHandler.cpp	/^unsigned SemVerMatchExpressionParser::parseVersionPart()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerMatchExpressionParser::reset	libsolidity/analysis/SemVerHandler.cpp	/^void SemVerMatchExpressionParser::reset()$/;"	f	class:SemVerMatchExpressionParser	signature:()
SemVerVersion	libsolidity/analysis/SemVerHandler.cpp	/^SemVerVersion::SemVerVersion(string const& _versionString)$/;"	f	class:SemVerVersion	signature:(string const& _versionString)
SemVerVersion	libsolidity/analysis/SemVerHandler.h	/^	explicit SemVerVersion(std::string const& _versionString = "0.0.0");$/;"	p	struct:dev::solidity::SemVerVersion	access:public	signature:(std::string const& _versionString = )
SemVerVersion	libsolidity/analysis/SemVerHandler.h	/^struct SemVerVersion$/;"	s	namespace:dev::solidity
SemVerVersion::SemVerVersion	libsolidity/analysis/SemVerHandler.cpp	/^SemVerVersion::SemVerVersion(string const& _versionString)$/;"	f	class:SemVerVersion	signature:(string const& _versionString)
SemanticInformation	libevmasm/SemanticInformation.h	/^struct SemanticInformation$/;"	s	namespace:dev::eth
SemanticInformation::altersControlFlow	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::altersControlFlow(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
SemanticInformation::breaksCSEAnalysisBlock	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::breaksCSEAnalysisBlock(AssemblyItem const& _item, bool _msizeImportant)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item, bool _msizeImportant)
SemanticInformation::invalidInPureFunctions	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidInPureFunctions(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
SemanticInformation::invalidInViewFunctions	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidInViewFunctions(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
SemanticInformation::invalidatesMemory	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidatesMemory(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
SemanticInformation::invalidatesStorage	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidatesStorage(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
SemanticInformation::isCommutativeOperation	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isCommutativeOperation(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
SemanticInformation::isDeterministic	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isDeterministic(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
SemanticInformation::isDupInstruction	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isDupInstruction(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
SemanticInformation::isJumpInstruction	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isJumpInstruction(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
SemanticInformation::isSwapInstruction	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isSwapInstruction(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
SemanticInformation::movable	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::movable(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
Send	libsolidity/ast/Types.h	/^		Send, \/\/\/< CALL, but without data and gas$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
SetGas	libsolidity/ast/Types.h	/^		SetGas, \/\/\/< modify the default gas value for the function call$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
SetValue	libsolidity/ast/Types.h	/^		SetValue, \/\/\/< modify the default value transfer for the function call$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
SimpleASTVisitor	libsolidity/ast/ASTVisitor.h	/^	SimpleASTVisitor($/;"	f	class:dev::solidity::SimpleASTVisitor	access:public	signature:( std::function<bool(ASTNode const&)> _onVisit, std::function<void(ASTNode const&)> _onEndVisit )
SimpleASTVisitor	libsolidity/ast/ASTVisitor.h	/^class SimpleASTVisitor: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
SimplePeepholeOptimizerMethod	libevmasm/PeepholeOptimiser.cpp	/^struct SimplePeepholeOptimizerMethod$/;"	s	namespace:__anon19	file:
SimplificationRule	libevmasm/SimplificationRule.h	/^struct SimplificationRule$/;"	s	namespace:dev::solidity
SimplificationRules	libyul/optimiser/SimplificationRules.cpp	/^SimplificationRules::SimplificationRules()$/;"	f	class:SimplificationRules	signature:()
SimplificationRules	libyul/optimiser/SimplificationRules.h	/^	SimplificationRules();$/;"	p	class:yul::SimplificationRules	access:public	signature:()
SimplificationRules	libyul/optimiser/SimplificationRules.h	/^class SimplificationRules: public boost::noncopyable$/;"	c	namespace:yul	inherits:boost::noncopyable
SimplificationRules::SimplificationRules	libyul/optimiser/SimplificationRules.cpp	/^SimplificationRules::SimplificationRules()$/;"	f	class:SimplificationRules	signature:()
SimplificationRules::addRule	libyul/optimiser/SimplificationRules.cpp	/^void SimplificationRules::addRule(SimplificationRule<Pattern> const& _rule)$/;"	f	class:SimplificationRules	signature:(SimplificationRule<Pattern> const& _rule)
SimplificationRules::addRules	libyul/optimiser/SimplificationRules.cpp	/^void SimplificationRules::addRules(vector<SimplificationRule<Pattern>> const& _rules)$/;"	f	class:SimplificationRules	signature:(vector<SimplificationRule<Pattern>> const& _rules)
SimplificationRules::findFirstMatch	libyul/optimiser/SimplificationRules.cpp	/^SimplificationRule<Pattern> const* SimplificationRules::findFirstMatch($/;"	f	class:SimplificationRules	signature:( Expression const& _expr, Dialect const& _dialect, map<YulString, Expression const*> const& _ssaValues )
SimplificationRules::isInitialized	libyul/optimiser/SimplificationRules.cpp	/^bool SimplificationRules::isInitialized() const$/;"	f	class:SimplificationRules	signature:() const
SolidityExprTranslator	solse/SolidityExprTranslator.cpp	/^SolidityExprTranslator(z3::context& ctx, SymExecEngine* engine): z3_ctx(ctx){$/;"	f	class:SolidityExprTranslator	signature:(z3::context& ctx, SymExecEngine* engine)
SolidityExprTranslator	solse/SolidityExprTranslator.h	/^    SolidityExprTranslator(z3::context& ctx, SymExecEngine* engine);$/;"	p	class:SolidityExprTranslator	access:public	signature:(z3::context& ctx, SymExecEngine* engine)
SolidityExprTranslator	solse/SolidityExprTranslator.h	/^class SolidityExprTranslator {$/;"	c
SolidityExprTranslator::SolidityExprTranslator	solse/SolidityExprTranslator.cpp	/^SolidityExprTranslator(z3::context& ctx, SymExecEngine* engine): z3_ctx(ctx){$/;"	f	class:SolidityExprTranslator	signature:(z3::context& ctx, SymExecEngine* engine)
SolidityExprTranslator::SolidityExprTranslator	solse/SolidityExprTranslator.h	/^    SolidityExprTranslator(z3::context& ctx, SymExecEngine* engine);$/;"	p	class:SolidityExprTranslator	access:public	signature:(z3::context& ctx, SymExecEngine* engine)
SolidityExprTranslator::debugMode	solse/SolidityExprTranslator.h	/^    bool debugMode;$/;"	m	class:SolidityExprTranslator	access:private
SolidityExprTranslator::setDebugMode	solse/SolidityExprTranslator.cpp	/^setDebugMode(bool mode) {$/;"	f	class:SolidityExprTranslator	signature:(bool mode)
SolidityExprTranslator::setDebugMode	solse/SolidityExprTranslator.h	/^    void setDebugMode(bool mode);$/;"	p	class:SolidityExprTranslator	access:public	signature:(bool mode)
SolidityExprTranslator::symExecEngine	solse/SolidityExprTranslator.h	/^    SymExecEngine* symExecEngine;$/;"	m	class:SolidityExprTranslator	access:private
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(BinaryOperation const* binaryExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(BinaryOperation const* binaryExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(Expression const* aExpr, ContextInfo& ctxInfo){$/;"	f	class:SolidityExprTranslator	signature:(Expression const* aExpr, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(FunctionCall const* functioncallExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(FunctionCall const* functioncallExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(Identifier const* idExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(Identifier const* idExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(IndexAccess const* indexAccessExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(IndexAccess const* indexAccessExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(Literal const* litExpr, ContextInfo& ctxInfo){$/;"	f	class:SolidityExprTranslator	signature:(Literal const* litExpr, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(MemberAccess const* memAccExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(MemberAccess const* memAccExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(TupleExpression const* tupleExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(TupleExpression const* tupleExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.cpp	/^translate(UnaryOperation const* unaryExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(UnaryOperation const* unaryExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::BinaryOperation const* binaryExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::BinaryOperation const* binaryExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::FunctionCall const* functioncallExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::FunctionCall const* functioncallExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::Identifier const* idExpr, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::Identifier const* idExpr, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::IndexAccess const* indexAccessExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::IndexAccess const* indexAccessExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::Literal const* litExpr, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::Literal const* litExpr, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::MemberAccess const* memAccExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::MemberAccess const* memAccExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::TupleExpression const* tupleExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::TupleExpression const* tupleExp, ContextInfo& ctxInfo)
SolidityExprTranslator::translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::UnaryOperation const* unaryExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::UnaryOperation const* unaryExp, ContextInfo& ctxInfo)
SolidityExprTranslator::z3_ctx	solse/SolidityExprTranslator.h	/^    z3::context& z3_ctx;$/;"	m	class:SolidityExprTranslator	access:private
SolverInterface	libsolidity/formal/SolverInterface.h	/^class SolverInterface$/;"	c	namespace:dev::solidity::smt
Sort	libsolidity/formal/SolverInterface.h	/^	Sort(Kind _kind):$/;"	f	struct:dev::solidity::smt::Sort	access:public	signature:(Kind _kind)
Sort	libsolidity/formal/SolverInterface.h	/^struct Sort$/;"	s	namespace:dev::solidity::smt
Source	libsolidity/interface/CompilerStack.h	/^	struct Source$/;"	s	class:dev::solidity::CompilerStack	access:private
SourceLocation	liblangutil/SourceLocation.h	/^struct SourceLocation$/;"	s	namespace:langutil
SourceReference	liblangutil/SourceReferenceExtractor.h	/^struct SourceReference$/;"	s	namespace:langutil
SourceReferenceExtractor	liblangutil/SourceReferenceExtractor.h	/^namespace SourceReferenceExtractor$/;"	n	namespace:langutil
SourceReferenceExtractor::extract	liblangutil/SourceReferenceExtractor.cpp	/^SourceReference SourceReferenceExtractor::extract(SourceLocation const* _location, std::string message)$/;"	f	class:SourceReferenceExtractor	signature:(SourceLocation const* _location, std::string message)
SourceReferenceExtractor::extract	liblangutil/SourceReferenceExtractor.cpp	/^SourceReferenceExtractor::Message SourceReferenceExtractor::extract(Exception const& _exception, string _category)$/;"	f	class:SourceReferenceExtractor	signature:(Exception const& _exception, string _category)
SourceReferenceFormatter	liblangutil/SourceReferenceFormatter.h	/^	explicit SourceReferenceFormatter(std::ostream& _stream):$/;"	f	class:langutil::SourceReferenceFormatter	access:public	signature:(std::ostream& _stream)
SourceReferenceFormatter	liblangutil/SourceReferenceFormatter.h	/^class SourceReferenceFormatter$/;"	c	namespace:langutil
SourceReferenceFormatter::printExceptionInformation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printExceptionInformation(SourceReferenceExtractor::Message const& _msg)$/;"	f	class:SourceReferenceFormatter	signature:(SourceReferenceExtractor::Message const& _msg)
SourceReferenceFormatter::printExceptionInformation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printExceptionInformation(dev::Exception const& _error, std::string const& _category)$/;"	f	class:SourceReferenceFormatter	signature:(dev::Exception const& _error, std::string const& _category)
SourceReferenceFormatter::printSourceLocation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printSourceLocation(SourceLocation const* _location)$/;"	f	class:SourceReferenceFormatter	signature:(SourceLocation const* _location)
SourceReferenceFormatter::printSourceLocation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printSourceLocation(SourceReference const& _ref)$/;"	f	class:SourceReferenceFormatter	signature:(SourceReference const& _ref)
SourceReferenceFormatter::printSourceName	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printSourceName(SourceReference const& _ref)$/;"	f	class:SourceReferenceFormatter	signature:(SourceReference const& _ref)
SourceReferenceFormatterHuman	liblangutil/SourceReferenceFormatterHuman.h	/^	SourceReferenceFormatterHuman(std::ostream& _stream, bool colored):$/;"	f	class:langutil::SourceReferenceFormatterHuman	access:public	signature:(std::ostream& _stream, bool colored)
SourceReferenceFormatterHuman	liblangutil/SourceReferenceFormatterHuman.h	/^class SourceReferenceFormatterHuman: public SourceReferenceFormatter$/;"	c	namespace:langutil	inherits:SourceReferenceFormatter
SourceReferenceFormatterHuman::diagColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::diagColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceReferenceFormatterHuman::errorColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::errorColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceReferenceFormatterHuman::frameColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::frameColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceReferenceFormatterHuman::highlightColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::highlightColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceReferenceFormatterHuman::messageColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::messageColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceReferenceFormatterHuman::normalColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::normalColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceReferenceFormatterHuman::printExceptionInformation	liblangutil/SourceReferenceFormatterHuman.cpp	/^void SourceReferenceFormatterHuman::printExceptionInformation(SourceReferenceExtractor::Message const& _msg)$/;"	f	class:SourceReferenceFormatterHuman	signature:(SourceReferenceExtractor::Message const& _msg)
SourceReferenceFormatterHuman::printSourceLocation	liblangutil/SourceReferenceFormatterHuman.cpp	/^void SourceReferenceFormatterHuman::printSourceLocation(SourceReference const& _ref)$/;"	f	class:SourceReferenceFormatterHuman	signature:(SourceReference const& _ref)
SourceReferenceFormatterHuman::secondaryColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::secondaryColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
SourceUnit	libsolidity/ast/AST.h	/^	SourceUnit(SourceLocation const& _location, std::vector<ASTPointer<ASTNode>> const& _nodes):$/;"	f	class:dev::solidity::SourceUnit	access:public	signature:(SourceLocation const& _location, std::vector<ASTPointer<ASTNode>> const& _nodes)
SourceUnit	libsolidity/ast/AST.h	/^class SourceUnit: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
SourceUnit::annotation	libsolidity/ast/AST.cpp	/^SourceUnitAnnotation& SourceUnit::annotation() const$/;"	f	class:SourceUnit	signature:() const
SourceUnit::referencedSourceUnits	libsolidity/ast/AST.cpp	/^set<SourceUnit const*> SourceUnit::referencedSourceUnits(bool _recurse, set<SourceUnit const*> _skipList) const$/;"	f	class:SourceUnit	signature:(bool _recurse, set<SourceUnit const*> _skipList) const
SourceUnitAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct SourceUnitAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
SourcesSet	libsolidity/interface/CompilerStack.h	/^		SourcesSet,$/;"	e	enum:dev::solidity::CompilerStack::State
Special	libevmasm/Instruction.h	/^	Special,	\/\/ multiparam or otherwise special$/;"	m	class:dev::solidity::Instruction::Tier	access:private
SpuriousDragon	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
StackAssignment	libyul/AsmData.h	/^struct StackAssignment { langutil::SourceLocation location; Identifier variableName; };$/;"	s	namespace:yul
StackCompressor	libyul/optimiser/StackCompressor.h	/^class StackCompressor$/;"	c	namespace:yul
StackCompressor::run	libyul/optimiser/StackCompressor.cpp	/^bool StackCompressor::run(shared_ptr<Dialect> const& _dialect, Block& _ast)$/;"	f	class:StackCompressor	signature:(shared_ptr<Dialect> const& _dialect, Block& _ast)
StackHeightChecker	libsolidity/codegen/ContractCompiler.cpp	/^	explicit StackHeightChecker(CompilerContext const& _context):$/;"	f	class:__anon12::StackHeightChecker	access:public	signature:(CompilerContext const& _context)
StackHeightChecker	libsolidity/codegen/ContractCompiler.cpp	/^class StackHeightChecker$/;"	c	namespace:__anon12	file:
StackTooDeepError	libyul/backends/evm/EVMCodeTransform.h	/^	StackTooDeepError(YulString _functionName, YulString _variable, int _depth):$/;"	f	struct:yul::StackTooDeepError	access:public	signature:(YulString _functionName, YulString _variable, int _depth)
StackTooDeepError	libyul/backends/evm/EVMCodeTransform.h	/^	StackTooDeepError(YulString _variable, int _depth): variable(_variable), depth(_depth) {}$/;"	f	struct:yul::StackTooDeepError	access:public	signature:(YulString _variable, int _depth)
StackTooDeepError	libyul/backends/evm/EVMCodeTransform.h	/^struct StackTooDeepError: virtual YulException$/;"	s	namespace:yul	inherits:YulException
StackTooDeepException	libevmasm/Exceptions.h	/^struct StackTooDeepException: virtual OptimizerException {};$/;"	s	namespace:dev::eth	inherits:OptimizerException
StackVariable	libsolidity/codegen/LValue.cpp	/^StackVariable::StackVariable(CompilerContext& _compilerContext, VariableDeclaration const& _declaration):$/;"	f	class:StackVariable	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
StackVariable	libsolidity/codegen/LValue.h	/^	StackVariable(CompilerContext& _compilerContext, VariableDeclaration const& _declaration);$/;"	p	class:dev::solidity::StackVariable	access:public	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
StackVariable	libsolidity/codegen/LValue.h	/^class StackVariable: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
StackVariable::StackVariable	libsolidity/codegen/LValue.cpp	/^StackVariable::StackVariable(CompilerContext& _compilerContext, VariableDeclaration const& _declaration):$/;"	f	class:StackVariable	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
StackVariable::retrieveValue	libsolidity/codegen/LValue.cpp	/^void StackVariable::retrieveValue(SourceLocation const& _location, bool) const$/;"	f	class:StackVariable	signature:(SourceLocation const& _location, bool) const
StackVariable::setToZero	libsolidity/codegen/LValue.cpp	/^void StackVariable::setToZero(SourceLocation const& _location, bool) const$/;"	f	class:StackVariable	signature:(SourceLocation const& _location, bool) const
StackVariable::storeValue	libsolidity/codegen/LValue.cpp	/^void StackVariable::storeValue(Type const&, SourceLocation const& _location, bool _move) const$/;"	f	class:StackVariable	signature:(Type const&, SourceLocation const& _location, bool _move) const
StandardCompiler	libsolidity/interface/StandardCompiler.h	/^	explicit StandardCompiler(ReadCallback::Callback const& _readFile = ReadCallback::Callback())$/;"	f	class:dev::solidity::StandardCompiler	access:public	signature:(ReadCallback::Callback const& _readFile = ReadCallback::Callback())
StandardCompiler	libsolidity/interface/StandardCompiler.h	/^class StandardCompiler: boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
StandardCompiler::compileInternal	libsolidity/interface/StandardCompiler.cpp	/^Json::Value StandardCompiler::compileInternal(Json::Value const& _input)$/;"	f	class:StandardCompiler	signature:(Json::Value const& _input)
StandardCompiler::parseOptimizerSettings	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> StandardCompiler::parseOptimizerSettings(Json::Value const& _jsonInput)$/;"	f	class:StandardCompiler	signature:(Json::Value const& _jsonInput)
State	libsolidity/interface/CompilerStack.h	/^	enum State {$/;"	g	class:dev::solidity::CompilerStack	access:public
State	libyul/optimiser/RedundantAssignEliminator.h	/^		State(Value _value = Undecided): m_value(_value) {}$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(Value _value = Undecided)
State	libyul/optimiser/RedundantAssignEliminator.h	/^	class State$/;"	c	class:yul::RedundantAssignEliminator	access:private
StateMutability	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	c	namespace:dev::solidity
Statement	libsolidity/ast/AST.h	/^	explicit Statement($/;"	f	class:dev::solidity::Statement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString )
Statement	libsolidity/ast/AST.h	/^class Statement: public ASTNode, public Documented$/;"	c	namespace:dev::solidity	inherits:ASTNode,Documented
Statement::annotation	libsolidity/ast/AST.cpp	/^StatementAnnotation& Statement::annotation() const$/;"	f	class:Statement	signature:() const
StatementAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct StatementAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
StatementCopier	libyul/optimiser/ASTCopier.h	/^class StatementCopier: public boost::static_visitor<Statement>$/;"	c	namespace:yul	inherits:boost::static_visitor
StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.cpp	/^StaticAnalyzer::StaticAnalyzer(ErrorReporter& _errorReporter):$/;"	f	class:StaticAnalyzer	signature:(ErrorReporter& _errorReporter)
StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.h	/^	explicit StaticAnalyzer(langutil::ErrorReporter& _errorReporter);$/;"	p	class:dev::solidity::StaticAnalyzer	access:public	signature:(langutil::ErrorReporter& _errorReporter)
StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.h	/^class StaticAnalyzer: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
StaticAnalyzer::StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.cpp	/^StaticAnalyzer::StaticAnalyzer(ErrorReporter& _errorReporter):$/;"	f	class:StaticAnalyzer	signature:(ErrorReporter& _errorReporter)
StaticAnalyzer::analyze	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::analyze(SourceUnit const& _sourceUnit)$/;"	f	class:StaticAnalyzer	signature:(SourceUnit const& _sourceUnit)
StaticAnalyzer::endVisit	libsolidity/analysis/StaticAnalyzer.cpp	/^void StaticAnalyzer::endVisit(ContractDefinition const&)$/;"	f	class:StaticAnalyzer	signature:(ContractDefinition const&)
StaticAnalyzer::endVisit	libsolidity/analysis/StaticAnalyzer.cpp	/^void StaticAnalyzer::endVisit(FunctionDefinition const&)$/;"	f	class:StaticAnalyzer	signature:(FunctionDefinition const&)
StaticAnalyzer::structureSizeEstimate	libsolidity/analysis/StaticAnalyzer.cpp	/^bigint StaticAnalyzer::structureSizeEstimate(Type const& _type, set<StructDefinition const*>& _structsSeen)$/;"	f	class:StaticAnalyzer	signature:(Type const& _type, set<StructDefinition const*>& _structsSeen)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(BinaryOperation const& _operation)$/;"	f	class:StaticAnalyzer	signature:(BinaryOperation const& _operation)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(ContractDefinition const& _contract)$/;"	f	class:StaticAnalyzer	signature:(ContractDefinition const& _contract)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(ExpressionStatement const& _statement)$/;"	f	class:StaticAnalyzer	signature:(ExpressionStatement const& _statement)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(FunctionCall const& _functionCall)$/;"	f	class:StaticAnalyzer	signature:(FunctionCall const& _functionCall)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(FunctionDefinition const& _function)$/;"	f	class:StaticAnalyzer	signature:(FunctionDefinition const& _function)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(Identifier const& _identifier)$/;"	f	class:StaticAnalyzer	signature:(Identifier const& _identifier)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:StaticAnalyzer	signature:(InlineAssembly const& _inlineAssembly)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(MemberAccess const& _memberAccess)$/;"	f	class:StaticAnalyzer	signature:(MemberAccess const& _memberAccess)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(Return const& _return)$/;"	f	class:StaticAnalyzer	signature:(Return const& _return)
StaticAnalyzer::visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(VariableDeclaration const& _variable)$/;"	f	class:StaticAnalyzer	signature:(VariableDeclaration const& _variable)
StaticAnalyzer::~StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.cpp	/^StaticAnalyzer::~StaticAnalyzer()$/;"	f	class:StaticAnalyzer	signature:()
Storage	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	e	enum:dev::eth::KnownState::StoreOperation::Target
Storage	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
Storage	libsolidity/ast/Types.h	/^enum class DataLocation { Storage, CallData, Memory };$/;"	m	class:dev::solidity::DataLocation	access:private
StorageArrayLength	libsolidity/codegen/LValue.cpp	/^StorageArrayLength::StorageArrayLength(CompilerContext& _compilerContext, ArrayType const& _arrayType):$/;"	f	class:StorageArrayLength	signature:(CompilerContext& _compilerContext, ArrayType const& _arrayType)
StorageArrayLength	libsolidity/codegen/LValue.h	/^	StorageArrayLength(CompilerContext& _compilerContext, ArrayType const& _arrayType);$/;"	p	class:dev::solidity::StorageArrayLength	access:public	signature:(CompilerContext& _compilerContext, ArrayType const& _arrayType)
StorageArrayLength	libsolidity/codegen/LValue.h	/^class StorageArrayLength: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
StorageArrayLength::StorageArrayLength	libsolidity/codegen/LValue.cpp	/^StorageArrayLength::StorageArrayLength(CompilerContext& _compilerContext, ArrayType const& _arrayType):$/;"	f	class:StorageArrayLength	signature:(CompilerContext& _compilerContext, ArrayType const& _arrayType)
StorageArrayLength::retrieveValue	libsolidity/codegen/LValue.cpp	/^void StorageArrayLength::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:StorageArrayLength	signature:(SourceLocation const&, bool _remove) const
StorageArrayLength::setToZero	libsolidity/codegen/LValue.cpp	/^void StorageArrayLength::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:StorageArrayLength	signature:(SourceLocation const&, bool _removeReference) const
StorageArrayLength::storeValue	libsolidity/codegen/LValue.cpp	/^void StorageArrayLength::storeValue(Type const&, SourceLocation const&, bool _move) const$/;"	f	class:StorageArrayLength	signature:(Type const&, SourceLocation const&, bool _move) const
StorageByteArrayElement	libsolidity/codegen/LValue.cpp	/^StorageByteArrayElement::StorageByteArrayElement(CompilerContext& _compilerContext):$/;"	f	class:StorageByteArrayElement	signature:(CompilerContext& _compilerContext)
StorageByteArrayElement	libsolidity/codegen/LValue.h	/^	StorageByteArrayElement(CompilerContext& _compilerContext);$/;"	p	class:dev::solidity::StorageByteArrayElement	access:public	signature:(CompilerContext& _compilerContext)
StorageByteArrayElement	libsolidity/codegen/LValue.h	/^class StorageByteArrayElement: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
StorageByteArrayElement::StorageByteArrayElement	libsolidity/codegen/LValue.cpp	/^StorageByteArrayElement::StorageByteArrayElement(CompilerContext& _compilerContext):$/;"	f	class:StorageByteArrayElement	signature:(CompilerContext& _compilerContext)
StorageByteArrayElement::retrieveValue	libsolidity/codegen/LValue.cpp	/^void StorageByteArrayElement::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:StorageByteArrayElement	signature:(SourceLocation const&, bool _remove) const
StorageByteArrayElement::setToZero	libsolidity/codegen/LValue.cpp	/^void StorageByteArrayElement::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:StorageByteArrayElement	signature:(SourceLocation const&, bool _removeReference) const
StorageByteArrayElement::storeValue	libsolidity/codegen/LValue.cpp	/^void StorageByteArrayElement::storeValue(Type const&, SourceLocation const&, bool _move) const$/;"	f	class:StorageByteArrayElement	signature:(Type const&, SourceLocation const&, bool _move) const
StorageItem	libsolidity/codegen/LValue.cpp	/^StorageItem::StorageItem(CompilerContext& _compilerContext, Type const& _type):$/;"	f	class:StorageItem	signature:(CompilerContext& _compilerContext, Type const& _type)
StorageItem	libsolidity/codegen/LValue.cpp	/^StorageItem::StorageItem(CompilerContext& _compilerContext, VariableDeclaration const& _declaration):$/;"	f	class:StorageItem	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
StorageItem	libsolidity/codegen/LValue.h	/^	StorageItem(CompilerContext& _compilerContext, Type const& _type);$/;"	p	class:dev::solidity::StorageItem	access:public	signature:(CompilerContext& _compilerContext, Type const& _type)
StorageItem	libsolidity/codegen/LValue.h	/^	StorageItem(CompilerContext& _compilerContext, VariableDeclaration const& _declaration);$/;"	p	class:dev::solidity::StorageItem	access:public	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
StorageItem	libsolidity/codegen/LValue.h	/^class StorageItem: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
StorageItem::StorageItem	libsolidity/codegen/LValue.cpp	/^StorageItem::StorageItem(CompilerContext& _compilerContext, Type const& _type):$/;"	f	class:StorageItem	signature:(CompilerContext& _compilerContext, Type const& _type)
StorageItem::StorageItem	libsolidity/codegen/LValue.cpp	/^StorageItem::StorageItem(CompilerContext& _compilerContext, VariableDeclaration const& _declaration):$/;"	f	class:StorageItem	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
StorageItem::retrieveValue	libsolidity/codegen/LValue.cpp	/^void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:StorageItem	signature:(SourceLocation const&, bool _remove) const
StorageItem::setToZero	libsolidity/codegen/LValue.cpp	/^void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:StorageItem	signature:(SourceLocation const&, bool _removeReference) const
StorageItem::storeValue	libsolidity/codegen/LValue.cpp	/^void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _location, bool _move) const$/;"	f	class:StorageItem	signature:(Type const& _sourceType, SourceLocation const& _location, bool _move) const
StorageOffsets	libsolidity/ast/Types.h	/^class StorageOffsets$/;"	c	namespace:dev::solidity
StorageOffsets::computeOffsets	libsolidity/ast/Types.cpp	/^void StorageOffsets::computeOffsets(TypePointers const& _types)$/;"	f	class:StorageOffsets	signature:(TypePointers const& _types)
StorageOffsets::offset	libsolidity/ast/Types.cpp	/^pair<u256, unsigned> const* StorageOffsets::offset(size_t _index) const$/;"	f	class:StorageOffsets	signature:(size_t _index) const
StoreOperation	libevmasm/KnownState.h	/^	struct StoreOperation$/;"	s	class:dev::eth::KnownState	access:public
StreamWriterBuilder	libdevcore/JSON.cpp	/^	explicit StreamWriterBuilder(map<string, string> const& _settings)$/;"	f	class:dev::__anon25::StreamWriterBuilder	access:public	signature:(map<string, string> const& _settings)
StreamWriterBuilder	libdevcore/JSON.cpp	/^class StreamWriterBuilder: public Json::StreamWriterBuilder$/;"	c	namespace:dev::__anon25	file:	inherits:Json::StreamWriterBuilder
Strict	libyul/Dialect.h	/^	Strict, \/\/ no types, EVM instructions as functions, but no jumps and no direct stack manipulations$/;"	m	class:yul::AsmFlavour	access:private
StrictModeCharReaderBuilder	libdevcore/JSON.cpp	/^	StrictModeCharReaderBuilder()$/;"	f	class:dev::__anon25::StrictModeCharReaderBuilder	access:public	signature:()
StrictModeCharReaderBuilder	libdevcore/JSON.cpp	/^class StrictModeCharReaderBuilder: public Json::CharReaderBuilder$/;"	c	namespace:dev::__anon25	file:	inherits:Json::CharReaderBuilder
StringLiteral	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
StringLiteralType	libsolidity/ast/Types.cpp	/^StringLiteralType::StringLiteralType(Literal const& _literal):$/;"	f	class:StringLiteralType	signature:(Literal const& _literal)
StringLiteralType	libsolidity/ast/Types.h	/^	explicit StringLiteralType(Literal const& _literal);$/;"	p	class:dev::solidity::StringLiteralType	access:public	signature:(Literal const& _literal)
StringLiteralType	libsolidity/ast/Types.h	/^class StringLiteralType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
StringLiteralType::StringLiteralType	libsolidity/ast/Types.cpp	/^StringLiteralType::StringLiteralType(Literal const& _literal):$/;"	f	class:StringLiteralType	signature:(Literal const& _literal)
StringLiteralType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult StringLiteralType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:StringLiteralType	signature:(Type const& _convertTo) const
StringLiteralType::isValidUTF8	libsolidity/ast/Types.cpp	/^bool StringLiteralType::isValidUTF8() const$/;"	f	class:StringLiteralType	signature:() const
StringLiteralType::mobileType	libsolidity/ast/Types.cpp	/^TypePointer StringLiteralType::mobileType() const$/;"	f	class:StringLiteralType	signature:() const
StringLiteralType::operator ==	libsolidity/ast/Types.cpp	/^bool StringLiteralType::operator==(Type const& _other) const$/;"	f	class:StringLiteralType	signature:(Type const& _other) const
StringLiteralType::richIdentifier	libsolidity/ast/Types.cpp	/^string StringLiteralType::richIdentifier() const$/;"	f	class:StringLiteralType	signature:() const
StringLiteralType::toString	libsolidity/ast/Types.cpp	/^std::string StringLiteralType::toString(bool) const$/;"	f	class:StringLiteralType	signature:(bool) const
Struct	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
StructDefinition	libsolidity/ast/AST.h	/^	StructDefinition($/;"	f	class:dev::solidity::StructDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, std::vector<ASTPointer<VariableDeclaration>> const& _members )
StructDefinition	libsolidity/ast/AST.h	/^class StructDefinition: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
StructDefinition::annotation	libsolidity/ast/AST.cpp	/^TypeDeclarationAnnotation& StructDefinition::annotation() const$/;"	f	class:StructDefinition	signature:() const
StructDefinition::type	libsolidity/ast/AST.cpp	/^TypePointer StructDefinition::type() const$/;"	f	class:StructDefinition	signature:() const
StructInfo	solse/SymExecEngine.h	/^class StructInfo{$/;"	c
StructInfo::fieldNames	solse/SymExecEngine.h	/^    std::vector<std::string> fieldNames;$/;"	m	class:StructInfo	access:public
StructInfo::fieldSorts	solse/SymExecEngine.h	/^    std::vector<z3::sort> fieldSorts;$/;"	m	class:StructInfo	access:public
StructInfo::getProjIndex	solse/SymExecEngine.h	/^    int getProjIndex(std::string fName){$/;"	f	class:StructInfo	access:public	signature:(std::string fName)
StructInfo::operator =	solse/SymExecEngine.h	/^    StructInfo& operator=(const StructInfo& other){$/;"	f	class:StructInfo	access:public	signature:(const StructInfo& other)
StructInfo::projectors	solse/SymExecEngine.h	/^    std::vector<z3::func_decl_vector> projectors;$/;"	m	class:StructInfo	access:public
StructInfo::structConstructor	solse/SymExecEngine.h	/^    std::vector<z3::func_decl> structConstructor;    \/\/ always has one element$/;"	m	class:StructInfo	access:public
StructInfo::structName	solse/SymExecEngine.h	/^    std::string structName;$/;"	m	class:StructInfo	access:public
StructInfo::structSort	solse/SymExecEngine.h	/^    std::vector<z3::sort> structSort;           \/\/ always has one element$/;"	m	class:StructInfo	access:public
StructInfo::toString	solse/SymExecEngine.h	/^    std::string toString(){$/;"	f	class:StructInfo	access:public	signature:()
StructType	libsolidity/ast/Types.h	/^	explicit StructType(StructDefinition const& _struct, DataLocation _location = DataLocation::Storage):$/;"	f	class:dev::solidity::StructType	access:public	signature:(StructDefinition const& _struct, DataLocation _location = DataLocation::Storage)
StructType	libsolidity/ast/Types.h	/^class StructType: public ReferenceType$/;"	c	namespace:dev::solidity	inherits:ReferenceType
StructType::calldataEncodedSize	libsolidity/ast/Types.cpp	/^unsigned StructType::calldataEncodedSize(bool) const$/;"	f	class:StructType	signature:(bool) const
StructType::calldataOffsetOfMember	libsolidity/ast/Types.cpp	/^unsigned StructType::calldataOffsetOfMember(std::string const& _member) const$/;"	f	class:StructType	signature:(std::string const& _member) const
StructType::canBeUsedExternally	libsolidity/ast/Types.cpp	/^bool StructType::canBeUsedExternally(bool _inLibrary) const$/;"	f	class:StructType	signature:(bool _inLibrary) const
StructType::canonicalName	libsolidity/ast/Types.cpp	/^string StructType::canonicalName() const$/;"	f	class:StructType	signature:() const
StructType::constructorType	libsolidity/ast/Types.cpp	/^FunctionTypePointer StructType::constructorType() const$/;"	f	class:StructType	signature:() const
StructType::copyForLocation	libsolidity/ast/Types.cpp	/^TypePointer StructType::copyForLocation(DataLocation _location, bool _isPointer) const$/;"	f	class:StructType	signature:(DataLocation _location, bool _isPointer) const
StructType::interfaceType	libsolidity/ast/Types.cpp	/^TypePointer StructType::interfaceType(bool _inLibrary) const$/;"	f	class:StructType	signature:(bool _inLibrary) const
StructType::isDynamicallyEncoded	libsolidity/ast/Types.cpp	/^bool StructType::isDynamicallyEncoded() const$/;"	f	class:StructType	signature:() const
StructType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult StructType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:StructType	signature:(Type const& _convertTo) const
StructType::membersMissingInMemory	libsolidity/ast/Types.cpp	/^set<string> StructType::membersMissingInMemory() const$/;"	f	class:StructType	signature:() const
StructType::memoryMemberTypes	libsolidity/ast/Types.cpp	/^TypePointers StructType::memoryMemberTypes() const$/;"	f	class:StructType	signature:() const
StructType::memoryOffsetOfMember	libsolidity/ast/Types.cpp	/^u256 StructType::memoryOffsetOfMember(string const& _name) const$/;"	f	class:StructType	signature:(string const& _name) const
StructType::memorySize	libsolidity/ast/Types.cpp	/^u256 StructType::memorySize() const$/;"	f	class:StructType	signature:() const
StructType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap StructType::nativeMembers(ContractDefinition const*) const$/;"	f	class:StructType	signature:(ContractDefinition const*) const
StructType::operator ==	libsolidity/ast/Types.cpp	/^bool StructType::operator==(Type const& _other) const$/;"	f	class:StructType	signature:(Type const& _other) const
StructType::recursive	libsolidity/ast/Types.cpp	/^bool StructType::recursive() const$/;"	f	class:StructType	signature:() const
StructType::richIdentifier	libsolidity/ast/Types.cpp	/^string StructType::richIdentifier() const$/;"	f	class:StructType	signature:() const
StructType::signatureInExternalFunction	libsolidity/ast/Types.cpp	/^string StructType::signatureInExternalFunction(bool _structsByName) const$/;"	f	class:StructType	signature:(bool _structsByName) const
StructType::storageOffsetsOfMember	libsolidity/ast/Types.cpp	/^pair<u256, unsigned> const& StructType::storageOffsetsOfMember(string const& _name) const$/;"	f	class:StructType	signature:(string const& _name) const
StructType::storageSize	libsolidity/ast/Types.cpp	/^u256 StructType::storageSize() const$/;"	f	class:StructType	signature:() const
StructType::toString	libsolidity/ast/Types.cpp	/^string StructType::toString(bool _short) const$/;"	f	class:StructType	signature:(bool _short) const
StructuralSimplifier	libyul/optimiser/StructuralSimplifier.h	/^	explicit StructuralSimplifier(Dialect const& _dialect): DataFlowAnalyzer(_dialect) {}$/;"	f	class:yul::StructuralSimplifier	access:public	signature:(Dialect const& _dialect)
StructuralSimplifier	libyul/optimiser/StructuralSimplifier.h	/^class StructuralSimplifier: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
StructuralSimplifier::expressionAlwaysFalse	libyul/optimiser/StructuralSimplifier.cpp	/^bool StructuralSimplifier::expressionAlwaysFalse(Expression const& _expression)$/;"	f	class:StructuralSimplifier	signature:(Expression const& _expression)
StructuralSimplifier::expressionAlwaysTrue	libyul/optimiser/StructuralSimplifier.cpp	/^bool StructuralSimplifier::expressionAlwaysTrue(Expression const& _expression)$/;"	f	class:StructuralSimplifier	signature:(Expression const& _expression)
StructuralSimplifier::hasLiteralValue	libyul/optimiser/StructuralSimplifier.cpp	/^boost::optional<dev::u256> StructuralSimplifier::hasLiteralValue(Expression const& _expression) const$/;"	f	class:StructuralSimplifier	signature:(Expression const& _expression) const
StructuralSimplifier::operator ()	libyul/optimiser/StructuralSimplifier.cpp	/^void StructuralSimplifier::operator()(Block& _block)$/;"	f	class:StructuralSimplifier	signature:(Block& _block)
StructuralSimplifier::simplify	libyul/optimiser/StructuralSimplifier.cpp	/^void StructuralSimplifier::simplify(std::vector<yul::Statement>& _statements)$/;"	f	class:StructuralSimplifier	signature:(std::vector<yul::Statement>& _statements)
SubDenomination	libsolidity/ast/AST.h	/^	enum class SubDenomination$/;"	c	class:dev::solidity::Literal	access:public
Substitution	libyul/optimiser/Substitution.h	/^	Substitution(std::map<YulString, Expression const*> const& _substitutions):$/;"	f	class:yul::Substitution	access:public	signature:(std::map<YulString, Expression const*> const& _substitutions)
Substitution	libyul/optimiser/Substitution.h	/^class Substitution: public ASTCopier$/;"	c	namespace:yul	inherits:ASTCopier
Substitution::translate	libyul/optimiser/Substitution.cpp	/^Expression Substitution::translate(Expression const& _expression)$/;"	f	class:Substitution	signature:(Expression const& _expression)
SwapComparison	libevmasm/PeepholeOptimiser.cpp	/^struct SwapComparison: SimplePeepholeOptimizerMethod<SwapComparison, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
Switch	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	s	namespace:yul
SymContract	solse/SymExecObject.h	/^class SymContract{$/;"	c
SymExecEngine	solse/SymExecEngine.cpp	/^SymExecEngine:: SymExecEngine(std::string _source, ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx):$/;"	f	class:SymExecEngine	signature:(std::string _source, ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx)
SymExecEngine	solse/SymExecEngine.h	/^    SymExecEngine(std::string source, dev::solidity::ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx);$/;"	p	class:SymExecEngine	access:public	signature:(std::string source, dev::solidity::ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx)
SymExecEngine	solse/SymExecEngine.h	/^class SymExecEngine: public dev::solidity::ASTConstVisitor {$/;"	c	inherits:dev::solidity::ASTConstVisitor
SymExecEngine::SymExecEngine	solse/SymExecEngine.cpp	/^SymExecEngine:: SymExecEngine(std::string _source, ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx):$/;"	f	class:SymExecEngine	signature:(std::string _source, ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx)
SymExecEngine::SymExecEngine	solse/SymExecEngine.h	/^    SymExecEngine(std::string source, dev::solidity::ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx);$/;"	p	class:SymExecEngine	access:public	signature:(std::string source, dev::solidity::ASTNode const& _node, bool mode, bool onlyExeMain, z3::context& _z3_ctx)
SymExecEngine::astNodeVisitMap	solse/SymExecEngine.h	/^    std::unordered_map<size_t, int> astNodeVisitMap;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::checkSatisfiability	solse/SymExecEngine.cpp	/^checkSatisfiability(z3::expr property, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(z3::expr property, ContextInfo& ctxInfo)
SymExecEngine::checkSatisfiability	solse/SymExecEngine.h	/^    bool checkSatisfiability(z3::expr property, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(z3::expr property, ContextInfo& ctxInfo)
SymExecEngine::checkValidity	solse/SymExecEngine.cpp	/^checkValidity(z3::expr property, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(z3::expr property, ContextInfo& ctxInfo)
SymExecEngine::checkValidity	solse/SymExecEngine.h	/^    bool checkValidity(z3::expr property, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(z3::expr property, ContextInfo& ctxInfo)
SymExecEngine::debugMode	solse/SymExecEngine.h	/^    bool debugMode;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::dev::solidity::currentFuncDef	solse/SymExecEngine.h	/^    dev::solidity::FunctionDefinition const* currentFuncDef;$/;"	m	class:SymExecEngine::dev::solidity	access:private
SymExecEngine::dev::solidity::getFuncDefinition	solse/SymExecEngine.h	/^    dev::solidity::FunctionDefinition const* getFuncDefinition(std::string funcName);$/;"	p	class:SymExecEngine::dev::solidity	access:protected	signature:(std::string funcName)
SymExecEngine::dev::solidity::root	solse/SymExecEngine.h	/^    dev::solidity::ASTNode const& root;$/;"	m	class:SymExecEngine::dev::solidity	access:private
SymExecEngine::endVisit	solse/SymExecEngine.cpp	/^endVisit(StructDefinition const&) {$/;"	f	class:SymExecEngine	signature:(StructDefinition const&)
SymExecEngine::endVisit	solse/SymExecEngine.cpp	/^endVisit(dev::solidity::FunctionDefinition const&){$/;"	f	class:SymExecEngine	signature:(dev::solidity::FunctionDefinition const&)
SymExecEngine::endVisit	solse/SymExecEngine.cpp	/^void SymExecEngine::endVisit(ContractDefinition const& _node){$/;"	f	class:SymExecEngine	signature:(ContractDefinition const& _node)
SymExecEngine::funcVec	solse/SymExecEngine.h	/^    std::vector<dev::solidity::FunctionDefinition const*> funcVec;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::getArrayName	solse/SymExecEngine.cpp	/^getArrayName(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo)
SymExecEngine::getArrayName	solse/SymExecEngine.h	/^    std::string getArrayName(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo)
SymExecEngine::getFuncDefinition	solse/SymExecEngine.cpp	/^getFuncDefinition(std::string funcName){$/;"	f	class:SymExecEngine	signature:(std::string funcName)
SymExecEngine::getRealFuncCallName	solse/SymExecEngine.cpp	/^getRealFuncCallName(Expression const* funcCall) {$/;"	f	class:SymExecEngine	signature:(Expression const* funcCall)
SymExecEngine::getRealFuncCallName	solse/SymExecEngine.h	/^    std::string getRealFuncCallName(dev::solidity::Expression const* funcCall);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Expression const* funcCall)
SymExecEngine::getVarFullName	solse/SymExecEngine.cpp	/^getVarFullName(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo)
SymExecEngine::getVarFullName	solse/SymExecEngine.cpp	/^getVarFullName(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo)
SymExecEngine::getVarFullName	solse/SymExecEngine.h	/^    std::string getVarFullName(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo)
SymExecEngine::getVarFullName	solse/SymExecEngine.h	/^    std::string getVarFullName(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo)
SymExecEngine::initSuffix	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::initSuffix = "_0_";$/;"	m	class:SymExecEngine	file:
SymExecEngine::initSuffix	solse/SymExecEngine.h	/^    static const std::string initSuffix;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::isInStructDefinition	solse/SymExecEngine.h	/^    bool isInStructDefinition;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::localVarValuesZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> localVarValuesZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::localVarZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> localVarZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::m_source	solse/SymExecEngine.h	/^    std::string m_source;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::mainFuncName	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::mainFuncName = "_Main_";$/;"	m	class:SymExecEngine	file:
SymExecEngine::mainFuncName	solse/SymExecEngine.h	/^    static const std::string mainFuncName;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::nameSeparator	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::nameSeparator = "@";$/;"	m	class:SymExecEngine	file:
SymExecEngine::nameSeparator	solse/SymExecEngine.h	/^    static const std::string nameSeparator;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::onlyExecuteMain	solse/SymExecEngine.h	/^    bool onlyExecuteMain;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::BinaryOperation const& _node) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::ContractDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::FunctionDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::Literal const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::StructDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::VariableDeclaration const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    void endVisit(dev::solidity::ContractDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    void endVisit(dev::solidity::FunctionDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::override	solse/SymExecEngine.h	/^    void endVisit(dev::solidity::StructDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
SymExecEngine::print_model	solse/SymExecEngine.cpp	/^void SymExecEngine::print_model (z3::model z3_model, ContextInfo& current_ctx, std::string title){$/;"	f	class:SymExecEngine	signature:(z3::model z3_model, ContextInfo& current_ctx, std::string title)
SymExecEngine::print_model	solse/SymExecEngine.h	/^    void print_model(z3::model, ContextInfo&,  std::string);$/;"	p	class:SymExecEngine	access:public	signature:(z3::model, ContextInfo&, std::string)
SymExecEngine::scopeSpecifier	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::scopeSpecifier = "$";$/;"	m	class:SymExecEngine	file:
SymExecEngine::scopeSpecifier	solse/SymExecEngine.h	/^    static const std::string scopeSpecifier;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::solExprTranslator	solse/SymExecEngine.h	/^    SolidityExprTranslator* solExprTranslator;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::stateVarValuesZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> stateVarValuesZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::stateVarZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> stateVarZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Assignment const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Assignment const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Block const *stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Block const *stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Break const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Break const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Continue const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Continue const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(ExpressionStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(ExpressionStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(ForStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(ForStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(FunctionCall const* funCall, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(FunctionCall const* funCall, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(FunctionDefinition const* funcDef, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(FunctionDefinition const* funcDef, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(IfStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(IfStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Return const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Return const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Statement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Statement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Statement const* stmt, std::vector<ContextInfo> preCondVec) {$/;"	f	class:SymExecEngine	signature:(Statement const* stmt, std::vector<ContextInfo> preCondVec)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Throw const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Throw const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(UnaryOperation const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(UnaryOperation const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(VariableDeclarationStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(VariableDeclarationStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(WhileStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(WhileStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Assignment const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Assignment const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Block const *stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Block const *stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Break const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Break const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Continue const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Continue const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::ExpressionStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::ExpressionStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::ForStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::ForStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::FunctionCall const* funCall, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::FunctionCall const* funCall, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::FunctionDefinition const* funcDef, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::FunctionDefinition const* funcDef, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::IfStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::IfStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Return const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Return const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Statement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Statement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Statement const* stmt, std::vector<ContextInfo>);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Statement const* stmt, std::vector<ContextInfo>)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Throw const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Throw const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::UnaryOperation const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::UnaryOperation const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::VariableDeclarationStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::VariableDeclarationStatement const* stmt, ContextInfo& preCond)
SymExecEngine::strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::WhileStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::WhileStatement const* stmt, ContextInfo& preCond)
SymExecEngine::structsMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, std::shared_ptr<StructInfo>> structsMap;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::symbolicExecution	solse/SymExecEngine.cpp	/^symbolicExecution() {$/;"	f	class:SymExecEngine	signature:()
SymExecEngine::symbolicExecution	solse/SymExecEngine.h	/^    void symbolicExecution();$/;"	p	class:SymExecEngine	access:public	signature:()
SymExecEngine::synthesis	solse/SymExecEngine.cpp	/^void SymExecEngine::synthesis(std::vector<ContextInfo>& contexts ){$/;"	f	class:SymExecEngine	signature:(std::vector<ContextInfo>& contexts )
SymExecEngine::synthesis	solse/SymExecEngine.h	/^    void synthesis(std::vector<ContextInfo>& contexts);$/;"	p	class:SymExecEngine	access:public	signature:(std::vector<ContextInfo>& contexts)
SymExecEngine::typeSortInZ3	solse/SymExecEngine.cpp	/^typeSortInZ3(TypePointer const typePtr){$/;"	f	class:SymExecEngine	signature:(TypePointer const typePtr)
SymExecEngine::typeSortInZ3	solse/SymExecEngine.h	/^    z3::sort typeSortInZ3(dev::solidity::TypePointer const typePtr);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::TypePointer const typePtr)
SymExecEngine::updateContextInfo	solse/SymExecEngine.cpp	/^updateContextInfo(Expression const* exp, z3::expr rightExpr, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Expression const* exp, z3::expr rightExpr, ContextInfo& preCond)
SymExecEngine::updateContextInfo	solse/SymExecEngine.h	/^    void updateContextInfo(dev::solidity::Expression const* exp, z3::expr rightExpr, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Expression const* exp, z3::expr rightExpr, ContextInfo& preCond)
SymExecEngine::visit	solse/SymExecEngine.cpp	/^bool SymExecEngine::visit(ContractDefinition const& _node){$/;"	f	class:SymExecEngine	signature:(ContractDefinition const& _node)
SymExecEngine::visit	solse/SymExecEngine.cpp	/^visit(BinaryOperation const& _node) {$/;"	f	class:SymExecEngine	signature:(BinaryOperation const& _node)
SymExecEngine::visit	solse/SymExecEngine.cpp	/^visit(FunctionDefinition const& _node) {$/;"	f	class:SymExecEngine	signature:(FunctionDefinition const& _node)
SymExecEngine::visit	solse/SymExecEngine.cpp	/^visit(Literal const& _node) {$/;"	f	class:SymExecEngine	signature:(Literal const& _node)
SymExecEngine::visit	solse/SymExecEngine.cpp	/^visit(StructDefinition const& _node) {$/;"	f	class:SymExecEngine	signature:(StructDefinition const& _node)
SymExecEngine::visit	solse/SymExecEngine.cpp	/^visit(VariableDeclaration const& _node) {$/;"	f	class:SymExecEngine	signature:(VariableDeclaration const& _node)
SymExecEngine::visitNumber	solse/SymExecEngine.h	/^    unsigned int visitNumber;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::z3_ctx	solse/SymExecEngine.h	/^    z3::context& z3_ctx;$/;"	m	class:SymExecEngine	access:private
SymExecEngine::~SymExecEngine	solse/SymExecEngine.cpp	/^~SymExecEngine(){$/;"	f	class:SymExecEngine	signature:()
SymExecEngine::~SymExecEngine	solse/SymExecEngine.h	/^    ~SymExecEngine();$/;"	p	class:SymExecEngine	access:public	signature:()
SymFunction	solse/SymExecObject.h	/^class SymFunction{$/;"	c
SymbolicAddressVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicAddressVariable::SymbolicAddressVariable($/;"	f	class:SymbolicAddressVariable	signature:( string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicAddressVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicAddressVariable($/;"	p	class:dev::solidity::SymbolicAddressVariable	access:public	signature:( std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicAddressVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicAddressVariable: public SymbolicIntVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicIntVariable
SymbolicAddressVariable::SymbolicAddressVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicAddressVariable::SymbolicAddressVariable($/;"	f	class:SymbolicAddressVariable	signature:( string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicBoolVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicBoolVariable::SymbolicBoolVariable($/;"	f	class:SymbolicBoolVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicBoolVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicBoolVariable($/;"	p	class:dev::solidity::SymbolicBoolVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicBoolVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicBoolVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
SymbolicBoolVariable::SymbolicBoolVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicBoolVariable::SymbolicBoolVariable($/;"	f	class:SymbolicBoolVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFixedBytesVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicFixedBytesVariable::SymbolicFixedBytesVariable($/;"	f	class:SymbolicFixedBytesVariable	signature:( unsigned _numBytes, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFixedBytesVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicFixedBytesVariable($/;"	p	class:dev::solidity::SymbolicFixedBytesVariable	access:public	signature:( unsigned _numBytes, std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFixedBytesVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicFixedBytesVariable: public SymbolicIntVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicIntVariable
SymbolicFixedBytesVariable::SymbolicFixedBytesVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicFixedBytesVariable::SymbolicFixedBytesVariable($/;"	f	class:SymbolicFixedBytesVariable	signature:( unsigned _numBytes, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFunctionVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicFunctionVariable::SymbolicFunctionVariable($/;"	f	class:SymbolicFunctionVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFunctionVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicFunctionVariable($/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFunctionVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicFunctionVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
SymbolicFunctionVariable::SymbolicFunctionVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicFunctionVariable::SymbolicFunctionVariable($/;"	f	class:SymbolicFunctionVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicFunctionVariable::increaseIndex	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicFunctionVariable::increaseIndex()$/;"	f	class:SymbolicFunctionVariable	signature:()
SymbolicFunctionVariable::operator ()	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicFunctionVariable::operator()(vector<smt::Expression> _arguments) const$/;"	f	class:SymbolicFunctionVariable	signature:(vector<smt::Expression> _arguments) const
SymbolicFunctionVariable::resetDeclaration	libsolidity/formal/SymbolicVariables.cpp	/^void SymbolicFunctionVariable::resetDeclaration()$/;"	f	class:SymbolicFunctionVariable	signature:()
SymbolicIntVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicIntVariable::SymbolicIntVariable($/;"	f	class:SymbolicIntVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicIntVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicIntVariable($/;"	p	class:dev::solidity::SymbolicIntVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicIntVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicIntVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
SymbolicIntVariable::SymbolicIntVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicIntVariable::SymbolicIntVariable($/;"	f	class:SymbolicIntVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicMappingVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicMappingVariable::SymbolicMappingVariable($/;"	f	class:SymbolicMappingVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicMappingVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicMappingVariable($/;"	p	class:dev::solidity::SymbolicMappingVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicMappingVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicMappingVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
SymbolicMappingVariable::SymbolicMappingVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicMappingVariable::SymbolicMappingVariable($/;"	f	class:SymbolicMappingVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicVariable::SymbolicVariable($/;"	f	class:SymbolicVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicVariable($/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicVariable$/;"	c	namespace:dev::solidity
SymbolicVariable::SymbolicVariable	libsolidity/formal/SymbolicVariables.cpp	/^SymbolicVariable::SymbolicVariable($/;"	f	class:SymbolicVariable	signature:( TypePointer _type, string const& _uniqueName, smt::SolverInterface& _interface )
SymbolicVariable::currentName	libsolidity/formal/SymbolicVariables.cpp	/^string SymbolicVariable::currentName() const$/;"	f	class:SymbolicVariable	signature:() const
SymbolicVariable::currentValue	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicVariable::currentValue() const$/;"	f	class:SymbolicVariable	signature:() const
SymbolicVariable::increaseIndex	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicVariable::increaseIndex()$/;"	f	class:SymbolicVariable	signature:()
SymbolicVariable::uniqueSymbol	libsolidity/formal/SymbolicVariables.cpp	/^string SymbolicVariable::uniqueSymbol(unsigned _index) const$/;"	f	class:SymbolicVariable	signature:(unsigned _index) const
SymbolicVariable::valueAtIndex	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicVariable::valueAtIndex(int _index) const$/;"	f	class:SymbolicVariable	signature:(int _index) const
SyntacticallyEqual	libyul/optimiser/SyntacticalEquality.h	/^class SyntacticallyEqual$/;"	c	namespace:yul
SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(FunctionCall const& _lhs, FunctionCall const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(FunctionCall const& _lhs, FunctionCall const& _rhs)
SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs)
SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(Identifier const& _lhs, Identifier const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Identifier const& _lhs, Identifier const& _rhs)
SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(Literal const& _lhs, Literal const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Literal const& _lhs, Literal const& _rhs)
SyntacticallyEqual::operator ()	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::operator()(Expression const& _lhs, Expression const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Expression const& _lhs, Expression const& _rhs)
SyntacticallyEqual::operator ()	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::operator()(Statement const& _lhs, Statement const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Statement const& _lhs, Statement const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Assignment const& _lhs, Assignment const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Assignment const& _lhs, Assignment const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Block const& _lhs, Block const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Block const& _lhs, Block const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(ForLoop const& _lhs, ForLoop const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(ForLoop const& _lhs, ForLoop const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(If const& _lhs, If const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(If const& _lhs, If const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Instruction const&, Instruction const&)$/;"	f	class:SyntacticallyEqual	signature:(Instruction const&, Instruction const&)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Label const&, Label const&)$/;"	f	class:SyntacticallyEqual	signature:(Label const&, Label const&)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(StackAssignment const&, StackAssignment const&)$/;"	f	class:SyntacticallyEqual	signature:(StackAssignment const&, StackAssignment const&)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Switch const& _lhs, Switch const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Switch const& _lhs, Switch const& _rhs)
SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs)
SyntacticallyEqual::switchCaseEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::switchCaseEqual(Case const& _lhs, Case const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Case const& _lhs, Case const& _rhs)
SyntacticallyEqual::visitDeclaration	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::visitDeclaration(TypedName const& _lhs, TypedName const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(TypedName const& _lhs, TypedName const& _rhs)
SyntaxChecker	libsolidity/analysis/SyntaxChecker.h	/^	SyntaxChecker(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::SyntaxChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter)
SyntaxChecker	libsolidity/analysis/SyntaxChecker.h	/^class SyntaxChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
SyntaxChecker::checkSingleStatementVariableDeclaration	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::checkSingleStatementVariableDeclaration(ASTNode const& _statement)$/;"	f	class:SyntaxChecker	signature:(ASTNode const& _statement)
SyntaxChecker::checkSyntax	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::checkSyntax(ASTNode const& _astRoot)$/;"	f	class:SyntaxChecker	signature:(ASTNode const& _astRoot)
SyntaxChecker::endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(ForStatement const&)$/;"	f	class:SyntaxChecker	signature:(ForStatement const&)
SyntaxChecker::endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(ModifierDefinition const& _modifier)$/;"	f	class:SyntaxChecker	signature:(ModifierDefinition const& _modifier)
SyntaxChecker::endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(SourceUnit const& _sourceUnit)$/;"	f	class:SyntaxChecker	signature:(SourceUnit const& _sourceUnit)
SyntaxChecker::endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(WhileStatement const&)$/;"	f	class:SyntaxChecker	signature:(WhileStatement const&)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Break const& _breakStatement)$/;"	f	class:SyntaxChecker	signature:(Break const& _breakStatement)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Continue const& _continueStatement)$/;"	f	class:SyntaxChecker	signature:(Continue const& _continueStatement)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(ContractDefinition const& _contract)$/;"	f	class:SyntaxChecker	signature:(ContractDefinition const& _contract)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(ForStatement const& _forStatement)$/;"	f	class:SyntaxChecker	signature:(ForStatement const& _forStatement)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(FunctionDefinition const& _function)$/;"	f	class:SyntaxChecker	signature:(FunctionDefinition const& _function)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(FunctionTypeName const& _node)$/;"	f	class:SyntaxChecker	signature:(FunctionTypeName const& _node)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(IfStatement const& _ifStatement)$/;"	f	class:SyntaxChecker	signature:(IfStatement const& _ifStatement)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Literal const& _literal)$/;"	f	class:SyntaxChecker	signature:(Literal const& _literal)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(ModifierDefinition const&)$/;"	f	class:SyntaxChecker	signature:(ModifierDefinition const&)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(PlaceholderStatement const&)$/;"	f	class:SyntaxChecker	signature:(PlaceholderStatement const&)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(PragmaDirective const& _pragma)$/;"	f	class:SyntaxChecker	signature:(PragmaDirective const& _pragma)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(SourceUnit const& _sourceUnit)$/;"	f	class:SyntaxChecker	signature:(SourceUnit const& _sourceUnit)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(StructDefinition const& _struct)$/;"	f	class:SyntaxChecker	signature:(StructDefinition const& _struct)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Throw const& _throwStatement)$/;"	f	class:SyntaxChecker	signature:(Throw const& _throwStatement)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(UnaryOperation const& _operation)$/;"	f	class:SyntaxChecker	signature:(UnaryOperation const& _operation)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(VariableDeclarationStatement const& _statement)$/;"	f	class:SyntaxChecker	signature:(VariableDeclarationStatement const& _statement)
SyntaxChecker::visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(WhileStatement const& _whileStatement)$/;"	f	class:SyntaxChecker	signature:(WhileStatement const& _whileStatement)
SyntaxError	liblangutil/Exceptions.h	/^		SyntaxError,$/;"	m	class:langutil::Error::Type	access:private
Szabo	libsolidity/ast/AST.h	/^		Szabo = static_cast<int>(Token::SubSzabo),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
T	liblangutil/Token.cpp	116;"	d	file:
T	liblangutil/Token.cpp	125;"	d	file:
T	liblangutil/Token.cpp	87;"	d	file:
T	liblangutil/Token.cpp	89;"	d	file:
T	liblangutil/Token.cpp	97;"	d	file:
T	liblangutil/Token.cpp	99;"	d	file:
T	liblangutil/Token.h	277;"	d
T	liblangutil/Token.h	280;"	d
THIS	liblangutil/UndefMacros.h	31;"	d
THROW	solse/SolidityExprTranslator.h	/^enum TerminationCode { NONE, RETURN, CONTINUE, BREAK, THROW };$/;"	e	enum:TerminationCode
TIMESTAMP	libevmasm/Instruction.h	/^	TIMESTAMP,			\/\/\/< get the block's timestamp$/;"	m	class:dev::solidity::Instruction	access:private
TOKEN	liblangutil/Token.cpp	145;"	d	file:
TOKEN	liblangutil/Token.cpp	148;"	d	file:
TOKEN_LIST	liblangutil/Token.h	71;"	d
Tag	libevmasm/AssemblyItem.h	/^	Tag,$/;"	e	enum:dev::eth::AssemblyItemType
TagConjunctions	libevmasm/PeepholeOptimiser.cpp	/^struct TagConjunctions: SimplePeepholeOptimizerMethod<TagConjunctions, 3>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
TangerineWhistle	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
Target	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	g	struct:dev::eth::KnownState::StoreOperation	access:public
TerminationCode	solse/SolidityExprTranslator.h	/^enum TerminationCode { NONE, RETURN, CONTINUE, BREAK, THROW };$/;"	g
Test	libsolidity/ast/ExperimentalFeatures.h	/^	Test,$/;"	m	class:dev::solidity::ExperimentalFeature	access:private
Throw	libdevcore/CommonData.h	/^	Throw = 1,$/;"	m	class:dev::WhenError	access:private
Throw	libsolidity/ast/AST.h	/^	explicit Throw(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):$/;"	f	class:dev::solidity::Throw	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _docString)
Throw	libsolidity/ast/AST.h	/^class Throw: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
Tier	libevmasm/Instruction.h	/^enum class Tier : unsigned$/;"	c	class:dev::solidity::Instruction	access:private
Token	liblangutil/Token.h	/^enum class Token : unsigned int {$/;"	c	namespace:langutil
TokenDesc	liblangutil/Scanner.h	/^	struct TokenDesc$/;"	s	class:langutil::Scanner	access:private
TokenTraits	liblangutil/Token.cpp	/^namespace TokenTraits$/;"	n	namespace:langutil	file:
TokenTraits	liblangutil/Token.h	/^namespace TokenTraits$/;"	n	namespace:langutil
Transaction	libsolidity/ast/Types.h	/^		Transaction, \/\/\/< "tx"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
Transfer	libsolidity/ast/Types.h	/^		Transfer, \/\/\/< CALL, but without data and throws on error$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
TruthyAnd	libevmasm/PeepholeOptimiser.cpp	/^struct TruthyAnd: SimplePeepholeOptimizerMethod<TruthyAnd, 3>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
Tuple	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
TupleExpression	libsolidity/ast/AST.h	/^	TupleExpression($/;"	f	class:dev::solidity::TupleExpression	access:public	signature:( SourceLocation const& _location, std::vector<ASTPointer<Expression>> const& _components, bool _isArray )
TupleExpression	libsolidity/ast/AST.h	/^class TupleExpression: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
TupleObject	libsolidity/codegen/LValue.cpp	/^TupleObject::TupleObject($/;"	f	class:TupleObject	signature:( CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues )
TupleObject	libsolidity/codegen/LValue.h	/^	TupleObject(CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues);$/;"	p	class:dev::solidity::TupleObject	access:public	signature:(CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues)
TupleObject	libsolidity/codegen/LValue.h	/^class TupleObject: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
TupleObject::TupleObject	libsolidity/codegen/LValue.cpp	/^TupleObject::TupleObject($/;"	f	class:TupleObject	signature:( CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues )
TupleObject::retrieveValue	libsolidity/codegen/LValue.cpp	/^void TupleObject::retrieveValue(SourceLocation const&, bool) const$/;"	f	class:TupleObject	signature:(SourceLocation const&, bool) const
TupleObject::setToZero	libsolidity/codegen/LValue.cpp	/^void TupleObject::setToZero(SourceLocation const&, bool) const$/;"	f	class:TupleObject	signature:(SourceLocation const&, bool) const
TupleObject::sizeOnStack	libsolidity/codegen/LValue.cpp	/^unsigned TupleObject::sizeOnStack() const$/;"	f	class:TupleObject	signature:() const
TupleObject::storeValue	libsolidity/codegen/LValue.cpp	/^void TupleObject::storeValue(Type const& _sourceType, SourceLocation const& _location, bool) const$/;"	f	class:TupleObject	signature:(Type const& _sourceType, SourceLocation const& _location, bool) const
TupleType	libsolidity/ast/Types.h	/^	explicit TupleType(std::vector<TypePointer> const& _types = std::vector<TypePointer>()): m_components(_types) {}$/;"	f	class:dev::solidity::TupleType	access:public	signature:(std::vector<TypePointer> const& _types = std::vector<TypePointer>())
TupleType	libsolidity/ast/Types.h	/^class TupleType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
TupleType::closestTemporaryType	libsolidity/ast/Types.cpp	/^TypePointer TupleType::closestTemporaryType(TypePointer const& _targetType) const$/;"	f	class:TupleType	signature:(TypePointer const& _targetType) const
TupleType::isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult TupleType::isImplicitlyConvertibleTo(Type const& _other) const$/;"	f	class:TupleType	signature:(Type const& _other) const
TupleType::mobileType	libsolidity/ast/Types.cpp	/^TypePointer TupleType::mobileType() const$/;"	f	class:TupleType	signature:() const
TupleType::operator ==	libsolidity/ast/Types.cpp	/^bool TupleType::operator==(Type const& _other) const$/;"	f	class:TupleType	signature:(Type const& _other) const
TupleType::richIdentifier	libsolidity/ast/Types.cpp	/^string TupleType::richIdentifier() const$/;"	f	class:TupleType	signature:() const
TupleType::sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned TupleType::sizeOnStack() const$/;"	f	class:TupleType	signature:() const
TupleType::storageSize	libsolidity/ast/Types.cpp	/^u256 TupleType::storageSize() const$/;"	f	class:TupleType	signature:() const
TupleType::toString	libsolidity/ast/Types.cpp	/^string TupleType::toString(bool _short) const$/;"	f	class:TupleType	signature:(bool _short) const
Type	liblangutil/Exceptions.h	/^	enum class Type$/;"	c	class:langutil::Error	access:public
Type	libsolidity/ast/Types.h	/^class Type: private boost::noncopyable, public std::enable_shared_from_this<Type>$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable,std::enable_shared_from_this
Type	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	c	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
Type::boundFunctions	libsolidity/ast/Types.cpp	/^MemberList::MemberMap Type::boundFunctions(Type const& _type, ContractDefinition const& _scope)$/;"	f	class:Type	signature:(Type const& _type, ContractDefinition const& _scope)
Type::commonType	libsolidity/ast/Types.cpp	/^TypePointer Type::commonType(TypePointer const& _a, TypePointer const& _b)$/;"	f	class:Type	signature:(TypePointer const& _a, TypePointer const& _b)
Type::escapeIdentifier	libsolidity/ast/Types.cpp	/^string Type::escapeIdentifier(string const& _identifier)$/;"	f	class:Type	signature:(string const& _identifier)
Type::forLiteral	libsolidity/ast/Types.cpp	/^TypePointer Type::forLiteral(Literal const& _literal)$/;"	f	class:Type	signature:(Literal const& _literal)
Type::fromElementaryTypeName	libsolidity/ast/Types.cpp	/^TypePointer Type::fromElementaryTypeName(ElementaryTypeNameToken const& _type)$/;"	f	class:Type	signature:(ElementaryTypeNameToken const& _type)
Type::fromElementaryTypeName	libsolidity/ast/Types.cpp	/^TypePointer Type::fromElementaryTypeName(string const& _name)$/;"	f	class:Type	signature:(string const& _name)
Type::fullEncodingType	libsolidity/ast/Types.cpp	/^TypePointer Type::fullEncodingType(bool _inLibraryCall, bool _encoderV2, bool) const$/;"	f	class:Type	signature:(bool _inLibraryCall, bool _encoderV2, bool) const
Type::identifier	libsolidity/ast/Types.cpp	/^string Type::identifier() const$/;"	f	class:Type	signature:() const
Type::members	libsolidity/ast/Types.cpp	/^MemberList const& Type::members(ContractDefinition const* _currentScope) const$/;"	f	class:Type	signature:(ContractDefinition const* _currentScope) const
TypeChecker	libsolidity/analysis/TypeChecker.h	/^	TypeChecker(langutil::EVMVersion _evmVersion, langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::TypeChecker	access:public	signature:(langutil::EVMVersion _evmVersion, langutil::ErrorReporter& _errorReporter)
TypeChecker	libsolidity/analysis/TypeChecker.h	/^class TypeChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
TypeChecker::checkDoubleStorageAssignment	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::checkDoubleStorageAssignment(Assignment const& _assignment)$/;"	f	class:TypeChecker	signature:(Assignment const& _assignment)
TypeChecker::checkExpressionAssignment	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::checkExpressionAssignment(Type const& _type, Expression const& _expression)$/;"	f	class:TypeChecker	signature:(Type const& _type, Expression const& _expression)
TypeChecker::checkTypeRequirements	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::checkTypeRequirements(ASTNode const& _contract)$/;"	f	class:TypeChecker	signature:(ASTNode const& _contract)
TypeChecker::contractDependenciesAreCyclic	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::contractDependenciesAreCyclic($/;"	f	class:TypeChecker	signature:( ContractDefinition const& _contract, std::set<ContractDefinition const*> const& _seenContracts ) const
TypeChecker::dereference	libsolidity/analysis/TypeChecker.cpp	/^Declaration const& TypeChecker::dereference(Identifier const& _identifier) const$/;"	f	class:TypeChecker	signature:(Identifier const& _identifier) const
TypeChecker::dereference	libsolidity/analysis/TypeChecker.cpp	/^Declaration const& TypeChecker::dereference(UserDefinedTypeName const& _typeName) const$/;"	f	class:TypeChecker	signature:(UserDefinedTypeName const& _typeName) const
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(BinaryOperation const& _operation)$/;"	f	class:TypeChecker	signature:(BinaryOperation const& _operation)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(ElementaryTypeNameExpression const& _expr)$/;"	f	class:TypeChecker	signature:(ElementaryTypeNameExpression const& _expr)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(EmitStatement const& _emit)$/;"	f	class:TypeChecker	signature:(EmitStatement const& _emit)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(ExpressionStatement const& _statement)$/;"	f	class:TypeChecker	signature:(ExpressionStatement const& _statement)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(FunctionTypeName const& _funType)$/;"	f	class:TypeChecker	signature:(FunctionTypeName const& _funType)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(InheritanceSpecifier const& _inheritance)$/;"	f	class:TypeChecker	signature:(InheritanceSpecifier const& _inheritance)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(Literal const& _literal)$/;"	f	class:TypeChecker	signature:(Literal const& _literal)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(NewExpression const& _newExpression)$/;"	f	class:TypeChecker	signature:(NewExpression const& _newExpression)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(Return const& _return)$/;"	f	class:TypeChecker	signature:(Return const& _return)
TypeChecker::endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(UsingForDirective const& _usingFor)$/;"	f	class:TypeChecker	signature:(UsingForDirective const& _usingFor)
TypeChecker::expectType	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::expectType(Expression const& _expression, Type const& _expectedType)$/;"	f	class:TypeChecker	signature:(Expression const& _expression, Type const& _expectedType)
TypeChecker::requireLValue	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::requireLValue(Expression const& _expression)$/;"	f	class:TypeChecker	signature:(Expression const& _expression)
TypeChecker::type	libsolidity/analysis/TypeChecker.cpp	/^TypePointer const& TypeChecker::type(Expression const& _expression) const$/;"	f	class:TypeChecker	signature:(Expression const& _expression) const
TypeChecker::type	libsolidity/analysis/TypeChecker.cpp	/^TypePointer const& TypeChecker::type(VariableDeclaration const& _variable) const$/;"	f	class:TypeChecker	signature:(VariableDeclaration const& _variable) const
TypeChecker::typeCheckABIDecodeAndRetrieveReturnType	libsolidity/analysis/TypeChecker.cpp	/^TypePointers TypeChecker::typeCheckABIDecodeAndRetrieveReturnType(FunctionCall const& _functionCall, bool _abiEncoderV2)$/;"	f	class:TypeChecker	signature:(FunctionCall const& _functionCall, bool _abiEncoderV2)
TypeChecker::typeCheckABIEncodeFunctions	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::typeCheckABIEncodeFunctions($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
TypeChecker::typeCheckFunctionCall	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::typeCheckFunctionCall($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
TypeChecker::typeCheckFunctionGeneralChecks	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::typeCheckFunctionGeneralChecks($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
TypeChecker::typeCheckMetaTypeFunctionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.cpp	/^TypePointers TypeChecker::typeCheckMetaTypeFunctionAndRetrieveReturnType(FunctionCall const& _functionCall)$/;"	f	class:TypeChecker	signature:(FunctionCall const& _functionCall)
TypeChecker::typeCheckTypeConversionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.cpp	/^TypePointer TypeChecker::typeCheckTypeConversionAndRetrieveReturnType($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall )
TypeChecker::typeSupportedByOldABIEncoder	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::typeSupportedByOldABIEncoder(Type const& _type, bool _isLibraryCall)$/;"	f	class:TypeChecker	signature:(Type const& _type, bool _isLibraryCall)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(Assignment const& _assignment)$/;"	f	class:TypeChecker	signature:(Assignment const& _assignment)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(Conditional const& _conditional)$/;"	f	class:TypeChecker	signature:(Conditional const& _conditional)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(ContractDefinition const& _contract)$/;"	f	class:TypeChecker	signature:(ContractDefinition const& _contract)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(EventDefinition const& _eventDef)$/;"	f	class:TypeChecker	signature:(EventDefinition const& _eventDef)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(ForStatement const& _forStatement)$/;"	f	class:TypeChecker	signature:(ForStatement const& _forStatement)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(FunctionCall const& _functionCall)$/;"	f	class:TypeChecker	signature:(FunctionCall const& _functionCall)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(FunctionDefinition const& _function)$/;"	f	class:TypeChecker	signature:(FunctionDefinition const& _function)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(Identifier const& _identifier)$/;"	f	class:TypeChecker	signature:(Identifier const& _identifier)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(IfStatement const& _ifStatement)$/;"	f	class:TypeChecker	signature:(IfStatement const& _ifStatement)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(IndexAccess const& _access)$/;"	f	class:TypeChecker	signature:(IndexAccess const& _access)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:TypeChecker	signature:(InlineAssembly const& _inlineAssembly)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(MemberAccess const& _memberAccess)$/;"	f	class:TypeChecker	signature:(MemberAccess const& _memberAccess)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(StructDefinition const& _struct)$/;"	f	class:TypeChecker	signature:(StructDefinition const& _struct)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(TupleExpression const& _tuple)$/;"	f	class:TypeChecker	signature:(TupleExpression const& _tuple)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(UnaryOperation const& _operation)$/;"	f	class:TypeChecker	signature:(UnaryOperation const& _operation)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(VariableDeclaration const& _variable)$/;"	f	class:TypeChecker	signature:(VariableDeclaration const& _variable)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(VariableDeclarationStatement const& _statement)$/;"	f	class:TypeChecker	signature:(VariableDeclarationStatement const& _statement)
TypeChecker::visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(WhileStatement const& _whileStatement)$/;"	f	class:TypeChecker	signature:(WhileStatement const& _whileStatement)
TypeChecker::visitManually	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::visitManually($/;"	f	class:TypeChecker	signature:( ModifierInvocation const& _modifier, vector<ContractDefinition const*> const& _bases )
TypeConversion	libsolidity/ast/ASTAnnotations.h	/^	TypeConversion,$/;"	m	class:dev::solidity::FunctionCallKind	access:private
TypeDeclarationAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct TypeDeclarationAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
TypeError	liblangutil/Exceptions.h	/^		TypeError,$/;"	m	class:langutil::Error::Type	access:private
TypeName	libsolidity/ast/AST.h	/^	explicit TypeName(SourceLocation const& _location): ASTNode(_location) {}$/;"	f	class:dev::solidity::TypeName	access:protected	signature:(SourceLocation const& _location)
TypeName	libsolidity/ast/AST.h	/^class TypeName: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
TypeName::annotation	libsolidity/ast/AST.cpp	/^TypeNameAnnotation& TypeName::annotation() const$/;"	f	class:TypeName	signature:() const
TypeNameAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct TypeNameAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
TypeType	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
TypeType	libsolidity/ast/Types.h	/^	explicit TypeType(TypePointer const& _actualType): m_actualType(_actualType) {}$/;"	f	class:dev::solidity::TypeType	access:public	signature:(TypePointer const& _actualType)
TypeType	libsolidity/ast/Types.h	/^class TypeType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
TypeType::nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap TypeType::nativeMembers(ContractDefinition const* _currentScope) const$/;"	f	class:TypeType	signature:(ContractDefinition const* _currentScope) const
TypeType::operator ==	libsolidity/ast/Types.cpp	/^bool TypeType::operator==(Type const& _other) const$/;"	f	class:TypeType	signature:(Type const& _other) const
TypeType::richIdentifier	libsolidity/ast/Types.cpp	/^string TypeType::richIdentifier() const$/;"	f	class:TypeType	signature:() const
TypeType::sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned TypeType::sizeOnStack() const$/;"	f	class:TypeType	signature:() const
TypeType::storageSize	libsolidity/ast/Types.cpp	/^u256 TypeType::storageSize() const$/;"	f	class:TypeType	signature:() const
TypedName	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	s	namespace:yul
UNKNOWN	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
UNSATISFIABLE	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
UnaryOperation	libsolidity/ast/AST.h	/^	UnaryOperation($/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:( SourceLocation const& _location, Token _operator, ASTPointer<Expression> const& _subExpression, bool _isPrefix )
UnaryOperation	libsolidity/ast/AST.h	/^class UnaryOperation: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
Undecided	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	e	enum:yul::RedundantAssignEliminator::State::Value
UndefinedItem	libevmasm/AssemblyItem.h	/^	UndefinedItem,$/;"	e	enum:dev::eth::AssemblyItemType
Underflow	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	m	class:dev::solidity::SMTChecker::OverflowTarget::Type	access:private
UnimplementedFeatureError	liblangutil/Exceptions.h	/^struct UnimplementedFeatureError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
UnreachableCode	libevmasm/PeepholeOptimiser.cpp	/^struct UnreachableCode$/;"	s	namespace:__anon19	file:
Unset	libsolidity/ast/ASTAnnotations.h	/^	Unset,$/;"	m	class:dev::solidity::FunctionCallKind	access:private
Unsigned	libsolidity/ast/Types.h	/^		Unsigned, Signed$/;"	m	class:dev::solidity::FixedPointType::Modifier	access:private
Unsigned	libsolidity/ast/Types.h	/^		Unsigned, Signed$/;"	m	class:dev::solidity::IntegerType::Modifier	access:private
Unspecified	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
Unused	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	e	enum:yul::RedundantAssignEliminator::State::Value
UnusedPruner	libyul/optimiser/UnusedPruner.cpp	/^UnusedPruner::UnusedPruner(Dialect const& _dialect, Block& _ast, set<YulString> const& _externallyUsedFunctions):$/;"	f	class:UnusedPruner	signature:(Dialect const& _dialect, Block& _ast, set<YulString> const& _externallyUsedFunctions)
UnusedPruner	libyul/optimiser/UnusedPruner.cpp	/^UnusedPruner::UnusedPruner(Dialect const& _dialect, FunctionDefinition& _function, set<YulString> const& _externallyUsedFunctions):$/;"	f	class:UnusedPruner	signature:(Dialect const& _dialect, FunctionDefinition& _function, set<YulString> const& _externallyUsedFunctions)
UnusedPruner	libyul/optimiser/UnusedPruner.h	/^	UnusedPruner($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> const& _externallyUsedFunctions = {} )
UnusedPruner	libyul/optimiser/UnusedPruner.h	/^	UnusedPruner($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, FunctionDefinition& _function, std::set<YulString> const& _externallyUsedFunctions = {} )
UnusedPruner	libyul/optimiser/UnusedPruner.h	/^class UnusedPruner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
UnusedPruner::UnusedPruner	libyul/optimiser/UnusedPruner.cpp	/^UnusedPruner::UnusedPruner(Dialect const& _dialect, Block& _ast, set<YulString> const& _externallyUsedFunctions):$/;"	f	class:UnusedPruner	signature:(Dialect const& _dialect, Block& _ast, set<YulString> const& _externallyUsedFunctions)
UnusedPruner::UnusedPruner	libyul/optimiser/UnusedPruner.cpp	/^UnusedPruner::UnusedPruner(Dialect const& _dialect, FunctionDefinition& _function, set<YulString> const& _externallyUsedFunctions):$/;"	f	class:UnusedPruner	signature:(Dialect const& _dialect, FunctionDefinition& _function, set<YulString> const& _externallyUsedFunctions)
UnusedPruner::operator ()	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::operator()(Block& _block)$/;"	f	class:UnusedPruner	signature:(Block& _block)
UnusedPruner::runUntilStabilised	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::runUntilStabilised($/;"	f	class:UnusedPruner	signature:( Dialect const& _dialect, Block& _ast, set<YulString> const& _externallyUsedFunctions )
UnusedPruner::runUntilStabilised	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::runUntilStabilised($/;"	f	class:UnusedPruner	signature:( Dialect const& _dialect, FunctionDefinition& _function, set<YulString> const& _externallyUsedFunctions )
UnusedPruner::subtractReferences	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::subtractReferences(map<YulString, size_t> const& _subtrahend)$/;"	f	class:UnusedPruner	signature:(map<YulString, size_t> const& _subtrahend)
UnusedPruner::used	libyul/optimiser/UnusedPruner.cpp	/^bool UnusedPruner::used(YulString _name) const$/;"	f	class:UnusedPruner	signature:(YulString _name) const
Upper	libdevcore/CommonData.h	/^	Upper = 1,$/;"	m	class:dev::HexCase	access:private
Used	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	e	enum:yul::RedundantAssignEliminator::State::Value
UserDefinedTypeName	libsolidity/ast/AST.h	/^	UserDefinedTypeName(SourceLocation const& _location, std::vector<ASTString> const& _namePath):$/;"	f	class:dev::solidity::UserDefinedTypeName	access:public	signature:(SourceLocation const& _location, std::vector<ASTString> const& _namePath)
UserDefinedTypeName	libsolidity/ast/AST.h	/^class UserDefinedTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
UserDefinedTypeName::annotation	libsolidity/ast/AST.cpp	/^UserDefinedTypeNameAnnotation& UserDefinedTypeName::annotation() const$/;"	f	class:UserDefinedTypeName	signature:() const
UserDefinedTypeNameAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct UserDefinedTypeNameAnnotation: TypeNameAnnotation$/;"	s	namespace:dev::solidity	inherits:TypeNameAnnotation
UsingForDirective	libsolidity/ast/AST.h	/^	UsingForDirective($/;"	f	class:dev::solidity::UsingForDirective	access:public	signature:( SourceLocation const& _location, ASTPointer<UserDefinedTypeName> const& _libraryName, ASTPointer<TypeName> const& _typeName )
UsingForDirective	libsolidity/ast/AST.h	/^class UsingForDirective: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
VOID	liblangutil/UndefMacros.h	30;"	d
Value	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	g	class:yul::RedundantAssignEliminator::State	access:public
VarDeclInitializer	libyul/optimiser/VarDeclInitializer.h	/^class VarDeclInitializer: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
VarDeclInitializer::operator ()	libyul/optimiser/VarDeclInitializer.cpp	/^void VarDeclInitializer::operator()(Block& _block)$/;"	f	class:VarDeclInitializer	signature:(Block& _block)
VarDeclParserOptions	libsolidity/parsing/Parser.h	/^		VarDeclParserOptions() {}$/;"	f	struct:dev::solidity::Parser::VarDeclParserOptions	access:public	signature:()
VarDeclParserOptions	libsolidity/parsing/Parser.h	/^	struct VarDeclParserOptions$/;"	s	class:dev::solidity::Parser	access:private
VarNameCleaner	libyul/optimiser/VarNameCleaner.cpp	/^VarNameCleaner::VarNameCleaner($/;"	f	class:VarNameCleaner	signature:( Block const& _ast, Dialect const& _dialect, set<YulString> _blacklist )
VarNameCleaner	libyul/optimiser/VarNameCleaner.h	/^	VarNameCleaner($/;"	p	class:yul::VarNameCleaner	access:public	signature:( Block const& _ast, Dialect const& _dialect, std::set<YulString> _blacklist = {} )
VarNameCleaner	libyul/optimiser/VarNameCleaner.h	/^class VarNameCleaner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
VarNameCleaner::VarNameCleaner	libyul/optimiser/VarNameCleaner.cpp	/^VarNameCleaner::VarNameCleaner($/;"	f	class:VarNameCleaner	signature:( Block const& _ast, Dialect const& _dialect, set<YulString> _blacklist )
VarNameCleaner::findCleanName	libyul/optimiser/VarNameCleaner.cpp	/^YulString VarNameCleaner::findCleanName(YulString const& _name) const$/;"	f	class:VarNameCleaner	signature:(YulString const& _name) const
VarNameCleaner::isUsedName	libyul/optimiser/VarNameCleaner.cpp	/^bool VarNameCleaner::isUsedName(YulString const& _name) const$/;"	f	class:VarNameCleaner	signature:(YulString const& _name) const
VarNameCleaner::operator ()	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::operator()(FunctionDefinition& _funDef)$/;"	f	class:VarNameCleaner	signature:(FunctionDefinition& _funDef)
VarNameCleaner::operator ()	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::operator()(Identifier& _identifier)$/;"	f	class:VarNameCleaner	signature:(Identifier& _identifier)
VarNameCleaner::operator ()	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::operator()(VariableDeclaration& _varDecl)$/;"	f	class:VarNameCleaner	signature:(VariableDeclaration& _varDecl)
VarNameCleaner::renameVariables	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::renameVariables(vector<TypedName>& _variables)$/;"	f	class:VarNameCleaner	signature:(vector<TypedName>& _variables)
VarNameCleaner::stripSuffix	libyul/optimiser/VarNameCleaner.cpp	/^YulString VarNameCleaner::stripSuffix(YulString const& _name) const$/;"	f	class:VarNameCleaner	signature:(YulString const& _name) const
Variable	libyul/AsmScope.h	/^	struct Variable { YulType type; };$/;"	s	struct:yul::Scope	access:public
VariableDeclaration	libsolidity/ast/AST.h	/^	VariableDeclaration($/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:( SourceLocation const& _sourceLocation, ASTPointer<TypeName> const& _type, ASTPointer<ASTString> const& _name, ASTPointer<Expression> _value, Visibility _visibility, bool _isStateVar = false, bool _isIndexed = false, bool _isConstant = false, Location _referenceLocation = Location::Unspecified )
VariableDeclaration	libsolidity/ast/AST.h	/^class VariableDeclaration: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
VariableDeclaration	libsolidity/parsing/Parser.h	/^		IndexAccessStructure, VariableDeclaration, Expression$/;"	m	class:dev::solidity::Parser::LookAheadInfo	access:private
VariableDeclaration	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	s	namespace:yul
VariableDeclaration::allowedDataLocations	libsolidity/ast/AST.cpp	/^set<VariableDeclaration::Location> VariableDeclaration::allowedDataLocations() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::annotation	libsolidity/ast/AST.cpp	/^VariableDeclarationAnnotation& VariableDeclaration::annotation() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::functionType	libsolidity/ast/AST.cpp	/^FunctionTypePointer VariableDeclaration::functionType(bool _internal) const$/;"	f	class:VariableDeclaration	signature:(bool _internal) const
VariableDeclaration::hasReferenceOrMappingType	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::hasReferenceOrMappingType() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isCallableParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isCallableParameter() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isEventParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isEventParameter() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isExternalCallableParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isExternalCallableParameter() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isInternalCallableParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isInternalCallableParameter() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isLValue	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLValue() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isLibraryFunctionParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLibraryFunctionParameter() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isLocalOrReturn	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLocalOrReturn() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isLocalVariable	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLocalVariable() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::isReturnParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isReturnParameter() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclaration::type	libsolidity/ast/AST.cpp	/^TypePointer VariableDeclaration::type() const$/;"	f	class:VariableDeclaration	signature:() const
VariableDeclarationAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct VariableDeclarationAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
VariableDeclarationStatement	libsolidity/ast/AST.h	/^	VariableDeclarationStatement($/;"	f	class:dev::solidity::VariableDeclarationStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, std::vector<ASTPointer<VariableDeclaration>> const& _variables, ASTPointer<Expression> const& _initialValue )
VariableDeclarationStatement	libsolidity/ast/AST.h	/^class VariableDeclarationStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
VariableOccurrence	libsolidity/analysis/ControlFlowGraph.h	/^	VariableOccurrence(VariableDeclaration const& _declaration, Kind _kind, ASTNode const* _occurrence):$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:(VariableDeclaration const& _declaration, Kind _kind, ASTNode const* _occurrence)
VariableOccurrence	libsolidity/analysis/ControlFlowGraph.h	/^class VariableOccurrence$/;"	c	namespace:dev::solidity
VariableReferenceCounter	libyul/backends/evm/EVMCodeTransform.h	/^	explicit VariableReferenceCounter($/;"	f	class:yul::VariableReferenceCounter	access:public	signature:( CodeTransformContext& _context, AsmAnalysisInfo const& _assemblyInfo )
VariableReferenceCounter	libyul/backends/evm/EVMCodeTransform.h	/^class VariableReferenceCounter: public yul::ASTWalker$/;"	c	namespace:yul	inherits:yul::ASTWalker
VariableReferenceCounter::increaseRefIfFound	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::increaseRefIfFound(YulString _variableName)$/;"	f	class:VariableReferenceCounter	signature:(YulString _variableName)
VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(Block const& _block)$/;"	f	class:VariableReferenceCounter	signature:(Block const& _block)
VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(ForLoop const& _forLoop)$/;"	f	class:VariableReferenceCounter	signature:(ForLoop const& _forLoop)
VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(FunctionDefinition const& _function)$/;"	f	class:VariableReferenceCounter	signature:(FunctionDefinition const& _function)
VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(Identifier const& _identifier)$/;"	f	class:VariableReferenceCounter	signature:(Identifier const& _identifier)
VariableScope	libsolidity/ast/AST.h	/^class VariableScope$/;"	c	namespace:dev::solidity
VariableUsage	libsolidity/formal/VariableUsage.cpp	/^VariableUsage::VariableUsage(ASTNode const& _node)$/;"	f	class:VariableUsage	signature:(ASTNode const& _node)
VariableUsage	libsolidity/formal/VariableUsage.h	/^	explicit VariableUsage(ASTNode const& _node);$/;"	p	class:dev::solidity::VariableUsage	access:public	signature:(ASTNode const& _node)
VariableUsage	libsolidity/formal/VariableUsage.h	/^class VariableUsage$/;"	c	namespace:dev::solidity
VariableUsage::VariableUsage	libsolidity/formal/VariableUsage.cpp	/^VariableUsage::VariableUsage(ASTNode const& _node)$/;"	f	class:VariableUsage	signature:(ASTNode const& _node)
VariableUsage::touchedVariables	libsolidity/formal/VariableUsage.cpp	/^vector<VariableDeclaration const*> VariableUsage::touchedVariables(ASTNode const& _node) const$/;"	f	class:VariableUsage	signature:(ASTNode const& _node) const
Version	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	c	class:langutil::EVMVersion	access:private
VersionNumber	libsolidity/interface/Version.cpp	/^char const* dev::solidity::VersionNumber = ETH_PROJECT_VERSION;$/;"	m	class:dev::solidity	file:
VersionString	libsolidity/interface/Version.cpp	/^string const dev::solidity::VersionString =$/;"	m	class:dev::solidity	file:
VersionStringStrict	libsolidity/interface/Version.cpp	/^string const dev::solidity::VersionStringStrict =$/;"	m	class:dev::solidity	file:
VeryLow	libevmasm/Instruction.h	/^	VeryLow,	\/\/ 3, Fastest$/;"	m	class:dev::solidity::Instruction::Tier	access:private
View	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	m	class:dev::solidity::StateMutability	access:private
ViewPureChecker	libsolidity/analysis/ViewPureChecker.h	/^	ViewPureChecker(std::vector<std::shared_ptr<ASTNode>> const& _ast, langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::ViewPureChecker	access:public	signature:(std::vector<std::shared_ptr<ASTNode>> const& _ast, langutil::ErrorReporter& _errorReporter)
ViewPureChecker	libsolidity/analysis/ViewPureChecker.h	/^class ViewPureChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
ViewPureChecker::check	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::check()$/;"	f	class:ViewPureChecker	signature:()
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(FunctionCall const& _functionCall)$/;"	f	class:ViewPureChecker	signature:(FunctionCall const& _functionCall)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(FunctionDefinition const& _funDef)$/;"	f	class:ViewPureChecker	signature:(FunctionDefinition const& _funDef)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(Identifier const& _identifier)$/;"	f	class:ViewPureChecker	signature:(Identifier const& _identifier)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(IndexAccess const& _indexAccess)$/;"	f	class:ViewPureChecker	signature:(IndexAccess const& _indexAccess)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(InlineAssembly const& _inlineAssembly)$/;"	f	class:ViewPureChecker	signature:(InlineAssembly const& _inlineAssembly)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(MemberAccess const& _memberAccess)$/;"	f	class:ViewPureChecker	signature:(MemberAccess const& _memberAccess)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(ModifierDefinition const& _modifierDef)$/;"	f	class:ViewPureChecker	signature:(ModifierDefinition const& _modifierDef)
ViewPureChecker::endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(ModifierInvocation const& _modifier)$/;"	f	class:ViewPureChecker	signature:(ModifierInvocation const& _modifier)
ViewPureChecker::reportMutability	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::reportMutability($/;"	f	class:ViewPureChecker	signature:( StateMutability _mutability, SourceLocation const& _location, boost::optional<SourceLocation> const& _nestedLocation )
ViewPureChecker::visit	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::visit(FunctionDefinition const& _funDef)$/;"	f	class:ViewPureChecker	signature:(FunctionDefinition const& _funDef)
ViewPureChecker::visit	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::visit(MemberAccess const& _memberAccess)$/;"	f	class:ViewPureChecker	signature:(MemberAccess const& _memberAccess)
ViewPureChecker::visit	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::visit(ModifierDefinition const& _modifier)$/;"	f	class:ViewPureChecker	signature:(ModifierDefinition const& _modifier)
Visibility	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	c	class:dev::solidity::Declaration	access:public
WHITE	libdevcore/AnsiColorized.h	/^static constexpr char const* WHITE = "\\033[37m";$/;"	m	namespace:dev::formatting
WHITE_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* WHITE_BACKGROUND = "\\033[47m";$/;"	m	namespace:dev::formatting
Week	libsolidity/ast/AST.h	/^		Week = static_cast<int>(Token::SubWeek),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
Wei	libsolidity/ast/AST.h	/^		Wei = static_cast<int>(Token::SubWei),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
WhenError	libdevcore/CommonData.h	/^enum class WhenError$/;"	c	namespace:dev
WhileStatement	libsolidity/ast/AST.h	/^	WhileStatement($/;"	f	class:dev::solidity::WhileStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _condition, ASTPointer<Statement> const& _body, bool _isDoWhile )
WhileStatement	libsolidity/ast/AST.h	/^class WhileStatement: public BreakableStatement$/;"	c	namespace:dev::solidity	inherits:BreakableStatement
Whiskers	libdevcore/Whiskers.cpp	/^Whiskers::Whiskers(string const& _template):$/;"	f	class:Whiskers	signature:(string const& _template)
Whiskers	libdevcore/Whiskers.h	/^class Whiskers$/;"	c	namespace:dev
Whiskers::Whiskers	libdevcore/Whiskers.cpp	/^Whiskers::Whiskers(string const& _template):$/;"	f	class:Whiskers	signature:(string const& _template)
Whiskers::joinMaps	libdevcore/Whiskers.cpp	/^Whiskers::StringMap Whiskers::joinMaps($/;"	f	class:Whiskers	signature:( Whiskers::StringMap const& _a, Whiskers::StringMap const& _b )
Whiskers::operator ()	libdevcore/Whiskers.cpp	/^Whiskers& Whiskers::operator ()($/;"	f	class:Whiskers	signature:( string const& _listParameter, vector<map<string, string>> const& _values )
Whiskers::operator ()	libdevcore/Whiskers.cpp	/^Whiskers& Whiskers::operator ()(string const& _parameter, string const& _value)$/;"	f	class:Whiskers	signature:(string const& _parameter, string const& _value)
Whiskers::render	libdevcore/Whiskers.cpp	/^string Whiskers::render() const$/;"	f	class:Whiskers	signature:() const
Whiskers::replace	libdevcore/Whiskers.cpp	/^string Whiskers::replace($/;"	f	class:Whiskers	signature:( string const& _template, StringMap const& _parameters, map<string, vector<StringMap>> const& _listParameters )
XOR	libevmasm/Instruction.h	/^	XOR,				\/\/\/< bitwise XOR operation$/;"	m	class:dev::solidity::Instruction	access:private
YELLOW	libdevcore/AnsiColorized.h	/^static constexpr char const* YELLOW = "\\033[33m";$/;"	m	namespace:dev::formatting
YELLOW_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* YELLOW_BACKGROUND = "\\033[43m";$/;"	m	namespace:dev::formatting
Year	libsolidity/ast/AST.h	/^		Year = static_cast<int>(Token::SubYear)$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
Yul	libyul/AssemblyStack.h	/^	enum class Language { Yul, Assembly, StrictAssembly };$/;"	m	class:yul::AssemblyStack::Language	access:private
YulAssertion	libyul/Exceptions.h	/^struct YulAssertion: virtual YulException {};$/;"	s	namespace:yul	inherits:YulException
YulException	libyul/Exceptions.h	/^struct YulException: virtual dev::Exception {};$/;"	s	namespace:yul	inherits:dev::Exception
YulString	libyul/YulString.h	/^	YulString() = default;$/;"	p	class:yul::YulString	access:public	signature:()
YulString	libyul/YulString.h	/^	YulString(YulString const&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString const&)
YulString	libyul/YulString.h	/^	YulString(YulString&&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString&&)
YulString	libyul/YulString.h	/^	explicit YulString(std::string const& _s): m_handle(YulStringRepository::instance().stringToHandle(_s)) {}$/;"	f	class:yul::YulString	access:public	signature:(std::string const& _s)
YulString	libyul/YulString.h	/^class YulString$/;"	c	namespace:yul
YulStringRepository	libyul/YulString.h	/^	YulStringRepository() = default;$/;"	p	class:yul::YulStringRepository	access:public	signature:()
YulStringRepository	libyul/YulString.h	/^class YulStringRepository: boost::noncopyable$/;"	c	namespace:yul	inherits:boost::noncopyable
Z3Interface	libsolidity/formal/Z3Interface.cpp	/^Z3Interface::Z3Interface():$/;"	f	class:Z3Interface	signature:()
Z3Interface	libsolidity/formal/Z3Interface.h	/^	Z3Interface();$/;"	p	class:dev::solidity::smt::Z3Interface	access:public	signature:()
Z3Interface	libsolidity/formal/Z3Interface.h	/^class Z3Interface: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
Z3Interface::Z3Interface	libsolidity/formal/Z3Interface.cpp	/^Z3Interface::Z3Interface():$/;"	f	class:Z3Interface	signature:()
Z3Interface::addAssertion	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::addAssertion(Expression const& _expr)$/;"	f	class:Z3Interface	signature:(Expression const& _expr)
Z3Interface::check	libsolidity/formal/Z3Interface.cpp	/^pair<CheckResult, vector<string>> Z3Interface::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:Z3Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
Z3Interface::declareFunction	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::declareFunction(string const& _name, Sort const& _sort)$/;"	f	class:Z3Interface	signature:(string const& _name, Sort const& _sort)
Z3Interface::declareVariable	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:Z3Interface	signature:(string const& _name, Sort const& _sort)
Z3Interface::pop	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::pop()$/;"	f	class:Z3Interface	signature:()
Z3Interface::push	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::push()$/;"	f	class:Z3Interface	signature:()
Z3Interface::reset	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::reset()$/;"	f	class:Z3Interface	signature:()
Z3Interface::toZ3Expr	libsolidity/formal/Z3Interface.cpp	/^z3::expr Z3Interface::toZ3Expr(Expression const& _expr)$/;"	f	class:Z3Interface	signature:(Expression const& _expr)
Z3Interface::z3Sort	libsolidity/formal/Z3Interface.cpp	/^z3::sort Z3Interface::z3Sort(Sort const& _sort)$/;"	f	class:Z3Interface	signature:(Sort const& _sort)
Z3Interface::z3Sort	libsolidity/formal/Z3Interface.cpp	/^z3::sort_vector Z3Interface::z3Sort(vector<SortPointer> const& _sorts)$/;"	f	class:Z3Interface	signature:(vector<SortPointer> const& _sorts)
Zero	libevmasm/Instruction.h	/^	Zero = 0,	\/\/ 0, Zero$/;"	m	class:dev::solidity::Instruction::Tier	access:private
_	libdevcore/Keccak256.cpp	116;"	d	file:
_ALLOW_KEYWORD_MACROS	libdevcore/Common.h	32;"	d
_GLIBCXX_PERMIT_BACKWARD_HASH	libsolidity/formal/CVC4Interface.h	27;"	d
_GLIBCXX_PERMIT_BACKWARD_HASH	libsolidity/formal/CVC4Interface.h	33;"	d
__anon10::createTupleDecl	libsolidity/analysis/TypeChecker.cpp	/^string createTupleDecl(vector<ASTPointer<VariableDeclaration>> const& _decls)$/;"	f	namespace:__anon10	signature:(vector<ASTPointer<VariableDeclaration>> const& _decls)
__anon10::typeCanBeExpressed	libsolidity/analysis/TypeChecker.cpp	/^bool typeCanBeExpressed(vector<ASTPointer<VariableDeclaration>> const& decls)$/;"	f	namespace:__anon10	signature:(vector<ASTPointer<VariableDeclaration>> const& decls)
__anon11::AssemblyViewPureChecker	libsolidity/analysis/ViewPureChecker.cpp	/^class AssemblyViewPureChecker: public boost::static_visitor<void>$/;"	c	namespace:__anon11	file:	inherits:boost::static_visitor
__anon11::AssemblyViewPureChecker::AssemblyViewPureChecker	libsolidity/analysis/ViewPureChecker.cpp	/^	explicit AssemblyViewPureChecker(std::function<void(StateMutability, SourceLocation const&)> _reportMutability):$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(std::function<void(StateMutability, SourceLocation const&)> _reportMutability)
__anon11::AssemblyViewPureChecker::checkInstruction	libsolidity/analysis/ViewPureChecker.cpp	/^	void checkInstruction(SourceLocation _location, solidity::Instruction _instruction)$/;"	f	class:__anon11::AssemblyViewPureChecker	file:	access:private	signature:(SourceLocation _location, solidity::Instruction _instruction)
__anon11::AssemblyViewPureChecker::m_reportMutability	libsolidity/analysis/ViewPureChecker.cpp	/^	std::function<void(StateMutability, SourceLocation const&)> m_reportMutability;$/;"	m	class:__anon11::AssemblyViewPureChecker	file:	access:private
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Assignment const& _assignment)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Assignment const& _assignment)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Block const& _block)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Block const& _block)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::ExpressionStatement const& _expr)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::ExpressionStatement const& _expr)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::ForLoop const& _for)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::ForLoop const& _for)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::FunctionCall const& _funCall)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::FunctionCall const& _funCall)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::FunctionDefinition const& _funDef)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::FunctionDefinition const& _funDef)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::FunctionalInstruction const& _instr)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::FunctionalInstruction const& _instr)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Identifier const&) {}$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Identifier const&)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::If const& _if)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::If const& _if)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Instruction const& _instruction)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Instruction const& _instruction)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Label const&) { }$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Label const&)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Literal const&) {}$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Literal const&)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::StackAssignment const&) {}$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::StackAssignment const&)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Switch const& _switch)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Switch const& _switch)
__anon11::AssemblyViewPureChecker::operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::VariableDeclaration const& _varDecl)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::VariableDeclaration const& _varDecl)
__anon12::StackHeightChecker	libsolidity/codegen/ContractCompiler.cpp	/^class StackHeightChecker$/;"	c	namespace:__anon12	file:
__anon12::StackHeightChecker::StackHeightChecker	libsolidity/codegen/ContractCompiler.cpp	/^	explicit StackHeightChecker(CompilerContext const& _context):$/;"	f	class:__anon12::StackHeightChecker	access:public	signature:(CompilerContext const& _context)
__anon12::StackHeightChecker::check	libsolidity/codegen/ContractCompiler.cpp	/^	void check() { solAssert(m_context.stackHeight() == stackHeight, std::string("I sense a disturbance in the stack: ") + to_string(m_context.stackHeight()) + " vs " + to_string(stackHeight)); }$/;"	f	class:__anon12::StackHeightChecker	access:public	signature:()
__anon12::StackHeightChecker::m_context	libsolidity/codegen/ContractCompiler.cpp	/^	CompilerContext const& m_context;$/;"	m	class:__anon12::StackHeightChecker	file:	access:private
__anon12::StackHeightChecker::stackHeight	libsolidity/codegen/ContractCompiler.cpp	/^	unsigned stackHeight;$/;"	m	class:__anon12::StackHeightChecker	file:	access:private
__anon13::hasPayableFunctions	libsolidity/codegen/ContractCompiler.cpp	/^bool hasPayableFunctions(ContractDefinition const& _contract)$/;"	f	namespace:__anon13	signature:(ContractDefinition const& _contract)
__anon14::firstSpaceOrTab	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator firstSpaceOrTab($/;"	f	namespace:__anon14	signature:( string::const_iterator _pos, string::const_iterator _end )
__anon14::firstWhitespaceOrNewline	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator firstWhitespaceOrNewline($/;"	f	namespace:__anon14	signature:( string::const_iterator _pos, string::const_iterator _end )
__anon14::skipLineOrEOS	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator skipLineOrEOS($/;"	f	namespace:__anon14	signature:( string::const_iterator _nlPos, string::const_iterator _end )
__anon14::skipWhitespace	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator skipWhitespace($/;"	f	namespace:__anon14	signature:( string::const_iterator _pos, string::const_iterator _end )
__anon15::onlySafeExperimentalFeaturesActivated	libsolidity/interface/CompilerStack.cpp	/^bool onlySafeExperimentalFeaturesActivated(set<ExperimentalFeature> const& features)$/;"	f	namespace:__anon15	signature:(set<ExperimentalFeature> const& features)
__anon16::gasToJson	libsolidity/interface/CompilerStack.cpp	/^Json::Value gasToJson(GasEstimator::GasConsumption const& _gas)$/;"	f	namespace:__anon16	signature:(GasEstimator::GasConsumption const& _gas)
__anon17::checkAuxiliaryInputKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkAuxiliaryInputKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::checkKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkKeys(Json::Value const& _input, set<string> const& _keys, string const& _name)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input, set<string> const& _keys, string const& _name)
__anon17::checkMetadataKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkMetadataKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::checkOptimizerDetail	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOptimizerDetail(Json::Value const& _details, std::string const& _name, bool& _setting)$/;"	f	namespace:__anon17	signature:(Json::Value const& _details, std::string const& _name, bool& _setting)
__anon17::checkOptimizerDetailsKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOptimizerDetailsKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::checkOptimizerKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOptimizerKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::checkOutputSelection	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOutputSelection(Json::Value const& _outputSelection)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection)
__anon17::checkRootKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkRootKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::checkSettingsKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkSettingsKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::checkSourceKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkSourceKeys(Json::Value const& _input, string const& _name)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input, string const& _name)
__anon17::collectEVMObject	libsolidity/interface/StandardCompiler.cpp	/^Json::Value collectEVMObject(eth::LinkerObject const& _object, string const* _sourceMap)$/;"	f	namespace:__anon17	signature:(eth::LinkerObject const& _object, string const* _sourceMap)
__anon17::createSourceList	libsolidity/interface/StandardCompiler.cpp	/^StringMap createSourceList(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
__anon17::formatError	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatError($/;"	f	namespace:__anon17	signature:( bool _warning, string const& _type, string const& _component, string const& _message, string const& _formattedMessage = , Json::Value const& _sourceLocation = Json::Value() )
__anon17::formatErrorWithException	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatErrorWithException($/;"	f	namespace:__anon17	signature:( Exception const& _exception, bool const& _warning, string const& _type, string const& _component, string const& _message )
__anon17::formatFatalError	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatFatalError(string const& _type, string const& _message)$/;"	f	namespace:__anon17	signature:(string const& _type, string const& _message)
__anon17::formatLinkReferences	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatLinkReferences(std::map<size_t, std::string> const& linkReferences)$/;"	f	namespace:__anon17	signature:(std::map<size_t, std::string> const& linkReferences)
__anon17::hashMatchesContent	libsolidity/interface/StandardCompiler.cpp	/^bool hashMatchesContent(string const& _hash, string const& _content)$/;"	f	namespace:__anon17	signature:(string const& _hash, string const& _content)
__anon17::isArtifactRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isArtifactRequested(Json::Value const& _outputSelection, string const& _artifact)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection, string const& _artifact)
__anon17::isArtifactRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isArtifactRequested(Json::Value const& _outputSelection, string const& _file, string const& _contract, string const& _artifact)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection, string const& _file, string const& _contract, string const& _artifact)
__anon17::isArtifactRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isArtifactRequested(Json::Value const& _outputSelection, string const& _file, string const& _contract, vector<string> const& _artifacts)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection, string const& _file, string const& _contract, vector<string> const& _artifacts)
__anon17::isBinaryRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isBinaryRequested(Json::Value const& _outputSelection)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection)
__anon17::requestedContractNames	libsolidity/interface/StandardCompiler.cpp	/^set<string> requestedContractNames(Json::Value const& _outputSelection)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection)
__anon18::Functionalizer	libevmasm/Assembly.cpp	/^class Functionalizer$/;"	c	namespace:__anon18	file:
__anon18::Functionalizer::Functionalizer	libevmasm/Assembly.cpp	/^	Functionalizer (ostream& _out, string const& _prefix, StringMap const& _sourceCodes):$/;"	f	class:__anon18::Functionalizer	access:public	signature:(ostream& _out, string const& _prefix, StringMap const& _sourceCodes)
__anon18::Functionalizer::feed	libevmasm/Assembly.cpp	/^	void feed(AssemblyItem const& _item)$/;"	f	class:__anon18::Functionalizer	access:public	signature:(AssemblyItem const& _item)
__anon18::Functionalizer::flush	libevmasm/Assembly.cpp	/^	void flush()$/;"	f	class:__anon18::Functionalizer	access:public	signature:()
__anon18::Functionalizer::m_location	libevmasm/Assembly.cpp	/^	SourceLocation m_location;$/;"	m	class:__anon18::Functionalizer	file:	access:private
__anon18::Functionalizer::m_out	libevmasm/Assembly.cpp	/^	ostream& m_out;$/;"	m	class:__anon18::Functionalizer	file:	access:private
__anon18::Functionalizer::m_pending	libevmasm/Assembly.cpp	/^	strings m_pending;$/;"	m	class:__anon18::Functionalizer	file:	access:private
__anon18::Functionalizer::m_prefix	libevmasm/Assembly.cpp	/^	string const& m_prefix;$/;"	m	class:__anon18::Functionalizer	file:	access:private
__anon18::Functionalizer::m_sourceCodes	libevmasm/Assembly.cpp	/^	StringMap const& m_sourceCodes;$/;"	m	class:__anon18::Functionalizer	file:	access:private
__anon18::Functionalizer::printLocation	libevmasm/Assembly.cpp	/^	void printLocation()$/;"	f	class:__anon18::Functionalizer	access:public	signature:()
__anon18::locationFromSources	libevmasm/Assembly.cpp	/^string locationFromSources(StringMap const& _sourceCodes, SourceLocation const& _location)$/;"	f	namespace:__anon18	signature:(StringMap const& _sourceCodes, SourceLocation const& _location)
__anon19::ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule$/;"	s	namespace:__anon19	file:
__anon19::ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule<Method, 1>$/;"	s	namespace:__anon19	file:
__anon19::ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule<Method, 2>$/;"	s	namespace:__anon19	file:
__anon19::ApplyRule	libevmasm/PeepholeOptimiser.cpp	/^struct ApplyRule<Method, 3>$/;"	s	namespace:__anon19	file:
__anon19::ApplyRule::applyRule	libevmasm/PeepholeOptimiser.cpp	/^	static bool applyRule(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::ApplyRule	access:public	signature:(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out)
__anon19::CommutativeSwap	libevmasm/PeepholeOptimiser.cpp	/^struct CommutativeSwap: SimplePeepholeOptimizerMethod<CommutativeSwap, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::CommutativeSwap::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::CommutativeSwap	access:public	signature:(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)
__anon19::DoublePush	libevmasm/PeepholeOptimiser.cpp	/^struct DoublePush: SimplePeepholeOptimizerMethod<DoublePush, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::DoublePush::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _push1, AssemblyItem const& _push2, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::DoublePush	access:public	signature:(AssemblyItem const& _push1, AssemblyItem const& _push2, std::back_insert_iterator<AssemblyItems> _out)
__anon19::DoubleSwap	libevmasm/PeepholeOptimiser.cpp	/^struct DoubleSwap: SimplePeepholeOptimizerMethod<DoubleSwap, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::DoubleSwap::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static size_t applySimple(AssemblyItem const& _s1, AssemblyItem const& _s2, std::back_insert_iterator<AssemblyItems>)$/;"	f	struct:__anon19::DoubleSwap	access:public	signature:(AssemblyItem const& _s1, AssemblyItem const& _s2, std::back_insert_iterator<AssemblyItems>)
__anon19::Identity	libevmasm/PeepholeOptimiser.cpp	/^struct Identity: SimplePeepholeOptimizerMethod<Identity, 1>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::Identity::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _item, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::Identity	access:public	signature:(AssemblyItem const& _item, std::back_insert_iterator<AssemblyItems> _out)
__anon19::JumpToNext	libevmasm/PeepholeOptimiser.cpp	/^struct JumpToNext: SimplePeepholeOptimizerMethod<JumpToNext, 3>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::JumpToNext::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static size_t applySimple($/;"	f	struct:__anon19::JumpToNext	access:public	signature:( AssemblyItem const& _pushTag, AssemblyItem const& _jump, AssemblyItem const& _tag, std::back_insert_iterator<AssemblyItems> _out )
__anon19::OpPop	libevmasm/PeepholeOptimiser.cpp	/^struct OpPop: SimplePeepholeOptimizerMethod<OpPop, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::OpPop::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple($/;"	f	struct:__anon19::OpPop	access:public	signature:( AssemblyItem const& _op, AssemblyItem const& _pop, std::back_insert_iterator<AssemblyItems> _out )
__anon19::OptimiserState	libevmasm/PeepholeOptimiser.cpp	/^struct OptimiserState$/;"	s	namespace:__anon19	file:
__anon19::OptimiserState::i	libevmasm/PeepholeOptimiser.cpp	/^	size_t i;$/;"	m	struct:__anon19::OptimiserState	file:	access:public
__anon19::OptimiserState::items	libevmasm/PeepholeOptimiser.cpp	/^	AssemblyItems const& items;$/;"	m	struct:__anon19::OptimiserState	file:	access:public
__anon19::OptimiserState::out	libevmasm/PeepholeOptimiser.cpp	/^	std::back_insert_iterator<AssemblyItems> out;$/;"	m	struct:__anon19::OptimiserState	file:	access:public
__anon19::PushPop	libevmasm/PeepholeOptimiser.cpp	/^struct PushPop: SimplePeepholeOptimizerMethod<PushPop, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::PushPop::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _push, AssemblyItem const& _pop, std::back_insert_iterator<AssemblyItems>)$/;"	f	struct:__anon19::PushPop	access:public	signature:(AssemblyItem const& _push, AssemblyItem const& _pop, std::back_insert_iterator<AssemblyItems>)
__anon19::SimplePeepholeOptimizerMethod	libevmasm/PeepholeOptimiser.cpp	/^struct SimplePeepholeOptimizerMethod$/;"	s	namespace:__anon19	file:
__anon19::SimplePeepholeOptimizerMethod::apply	libevmasm/PeepholeOptimiser.cpp	/^	static bool apply(OptimiserState& _state)$/;"	f	struct:__anon19::SimplePeepholeOptimizerMethod	access:public	signature:(OptimiserState& _state)
__anon19::SwapComparison	libevmasm/PeepholeOptimiser.cpp	/^struct SwapComparison: SimplePeepholeOptimizerMethod<SwapComparison, 2>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::SwapComparison::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::SwapComparison	access:public	signature:(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)
__anon19::TagConjunctions	libevmasm/PeepholeOptimiser.cpp	/^struct TagConjunctions: SimplePeepholeOptimizerMethod<TagConjunctions, 3>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::TagConjunctions::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple($/;"	f	struct:__anon19::TagConjunctions	access:public	signature:( AssemblyItem const& _pushTag, AssemblyItem const& _pushConstant, AssemblyItem const& _and, std::back_insert_iterator<AssemblyItems> _out )
__anon19::TruthyAnd	libevmasm/PeepholeOptimiser.cpp	/^struct TruthyAnd: SimplePeepholeOptimizerMethod<TruthyAnd, 3>$/;"	s	namespace:__anon19	file:	inherits:SimplePeepholeOptimizerMethod
__anon19::TruthyAnd::applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple($/;"	f	struct:__anon19::TruthyAnd	access:public	signature:( AssemblyItem const& _push, AssemblyItem const& _not, AssemblyItem const& _and, std::back_insert_iterator<AssemblyItems> )
__anon19::UnreachableCode	libevmasm/PeepholeOptimiser.cpp	/^struct UnreachableCode$/;"	s	namespace:__anon19	file:
__anon19::UnreachableCode::apply	libevmasm/PeepholeOptimiser.cpp	/^	static bool apply(OptimiserState& _state)$/;"	f	struct:__anon19::UnreachableCode	access:public	signature:(OptimiserState& _state)
__anon19::applyMethods	libevmasm/PeepholeOptimiser.cpp	/^void applyMethods(OptimiserState& _state, Method, OtherMethods... _other)$/;"	f	namespace:__anon19	signature:(OptimiserState& _state, Method, OtherMethods... _other)
__anon19::applyMethods	libevmasm/PeepholeOptimiser.cpp	/^void applyMethods(OptimiserState&)$/;"	f	namespace:__anon19	signature:(OptimiserState&)
__anon19::numberOfPops	libevmasm/PeepholeOptimiser.cpp	/^size_t numberOfPops(AssemblyItems const& _items)$/;"	f	namespace:__anon19	signature:(AssemblyItems const& _items)
__anon1::languageToDialect	libyul/AssemblyStack.cpp	/^shared_ptr<Dialect> languageToDialect(AssemblyStack::Language _language, EVMVersion _version)$/;"	f	namespace:__anon1	signature:(AssemblyStack::Language _language, EVMVersion _version)
__anon22::swarmHashIntermediate	libdevcore/SwarmHash.cpp	/^h256 swarmHashIntermediate(string const& _input, size_t _offset, size_t _length)$/;"	f	namespace:__anon22	signature:(string const& _input, size_t _offset, size_t _length)
__anon22::swarmHashSimple	libdevcore/SwarmHash.cpp	/^h256 swarmHashSimple(bytesConstRef _data, size_t _size)$/;"	f	namespace:__anon22	signature:(bytesConstRef _data, size_t _size)
__anon22::toLittleEndian	libdevcore/SwarmHash.cpp	/^bytes toLittleEndian(size_t _size)$/;"	f	namespace:__anon22	signature:(size_t _size)
__anon24::readFile	libdevcore/CommonIO.cpp	/^inline _T readFile(std::string const& _file)$/;"	f	namespace:__anon24	signature:(std::string const& _file)
__anon3::indent	libyul/Object.cpp	/^string indent(std::string const& _input)$/;"	f	namespace:__anon3	signature:(std::string const& _input)
__anon4::assemblySizeReferenceSize	libyul/backends/evm/EVMAssembly.cpp	/^size_t constexpr assemblySizeReferenceSize = 4;$/;"	m	namespace:__anon4	file:
__anon4::labelReferenceSize	libyul/backends/evm/EVMAssembly.cpp	/^size_t constexpr labelReferenceSize = 4;$/;"	m	namespace:__anon4	file:
__anon5::makePopExpressionStatement	libyul/optimiser/StructuralSimplifier.cpp	/^ExpressionStatement makePopExpressionStatement(langutil::SourceLocation const& _location, Expression&& _expression)$/;"	f	namespace:__anon5	signature:(langutil::SourceLocation const& _location, Expression&& _expression)
__anon6::eliminateVariables	libyul/optimiser/StackCompressor.cpp	/^void eliminateVariables(shared_ptr<Dialect> const& _dialect, ASTNode& _node, size_t _numVariables)$/;"	f	namespace:__anon6	signature:(shared_ptr<Dialect> const& _dialect, ASTNode& _node, size_t _numVariables)
__anon7::fitsIntegerType	libsolidity/ast/Types.cpp	/^bool fitsIntegerType(bigint const& _value, IntegerType const& _type)$/;"	f	namespace:__anon7	signature:(bigint const& _value, IntegerType const& _type)
__anon7::fitsIntoBits	libsolidity/ast/Types.cpp	/^bool fitsIntoBits(bigint const& _value, unsigned _bits, bool _signed)$/;"	f	namespace:__anon7	signature:(bigint const& _value, unsigned _bits, bool _signed)
__anon7::fitsPrecisionBase10	libsolidity/ast/Types.cpp	/^bool fitsPrecisionBase10(bigint const& _mantissa, uint32_t _expBase10)$/;"	f	namespace:__anon7	signature:(bigint const& _mantissa, uint32_t _expBase10)
__anon7::fitsPrecisionBase2	libsolidity/ast/Types.cpp	/^bool fitsPrecisionBase2(bigint const& _mantissa, uint32_t _expBase2)$/;"	f	namespace:__anon7	signature:(bigint const& _mantissa, uint32_t _expBase2)
__anon7::fitsPrecisionBaseX	libsolidity/ast/Types.cpp	/^bool fitsPrecisionBaseX($/;"	f	namespace:__anon7	signature:( bigint const& _mantissa, double _log2OfBase, uint32_t _exp )
__anon7::fitsPrecisionExp	libsolidity/ast/Types.cpp	/^bool fitsPrecisionExp(bigint const& _base, bigint const& _exp)$/;"	f	namespace:__anon7	signature:(bigint const& _base, bigint const& _exp)
__anon7::mostSignificantBit	libsolidity/ast/Types.cpp	/^unsigned int mostSignificantBit(bigint const& _number)$/;"	f	namespace:__anon7	signature:(bigint const& _number)
__anon8::identifierList	libsolidity/ast/Types.cpp	/^string identifierList(Range const&& _list)$/;"	f	namespace:__anon8	signature:(Range const&& _list)
__anon8::identifierList	libsolidity/ast/Types.cpp	/^string identifierList(TypePointer const& _type)$/;"	f	namespace:__anon8	signature:(TypePointer const& _type)
__anon8::identifierList	libsolidity/ast/Types.cpp	/^string identifierList(TypePointer const& _type1, TypePointer const& _type2)$/;"	f	namespace:__anon8	signature:(TypePointer const& _type1, TypePointer const& _type2)
__anon8::identifierList	libsolidity/ast/Types.cpp	/^string identifierList(vector<TypePointer> const& _list)$/;"	f	namespace:__anon8	signature:(vector<TypePointer> const& _list)
__anon8::parenthesizeIdentifier	libsolidity/ast/Types.cpp	/^string parenthesizeIdentifier(string const& _internal)$/;"	f	namespace:__anon8	signature:(string const& _internal)
__anon8::parenthesizeUserIdentifier	libsolidity/ast/Types.cpp	/^string parenthesizeUserIdentifier(string const& _internal)$/;"	f	namespace:__anon8	signature:(string const& _internal)
__anon8::richIdentifier	libsolidity/ast/Types.cpp	/^string richIdentifier(TypePointer const& _type)$/;"	f	namespace:__anon8	signature:(TypePointer const& _type)
__anon9::isValidShiftAndAmountType	libsolidity/ast/Types.cpp	/^bool isValidShiftAndAmountType(Token _operator, Type const& _shiftAmountType)$/;"	f	namespace:__anon9	signature:(Token _operator, Type const& _shiftAmountType)
_objectAccess	libyul/backends/evm/EVMDialect.cpp	/^	Dialect{_flavour}, m_objectAccess(_objectAccess), m_evmVersion(_evmVersion)$/;"	v
_yulstring	libyul/YulString.h	/^inline YulString operator "" _yulstring(char const* _string, std::size_t _size)$/;"	f	namespace:yul	signature:(char const* _string, std::size_t _size)
abi	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<Json::Value const> abi;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
abiDecode	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::abiDecode(TypePointers const& _typeParameters, bool _fromMemory)$/;"	f	class:dev::solidity::CompilerUtils	signature:(TypePointers const& _typeParameters, bool _fromMemory)
abiDecode	libsolidity/codegen/CompilerUtils.h	/^	void abiDecode(TypePointers const& _typeParameters, bool _fromMemory = false);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(TypePointers const& _typeParameters, bool _fromMemory = false)
abiDecodeV2	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::abiDecodeV2(TypePointers const& _parameterTypes, bool _fromMemory)$/;"	f	class:dev::solidity::CompilerUtils	signature:(TypePointers const& _parameterTypes, bool _fromMemory)
abiDecodeV2	libsolidity/codegen/CompilerUtils.h	/^	void abiDecodeV2(TypePointers const& _parameterTypes, bool _fromMemory = false);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(TypePointers const& _parameterTypes, bool _fromMemory = false)
abiDecodingFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunction(Type const& _type, bool _fromMemory, bool _forUseOnStack)$/;"	f	class:ABIFunctions	signature:(Type const& _type, bool _fromMemory, bool _forUseOnStack)
abiDecodingFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunction($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _Type, bool _fromMemory, bool _forUseOnStack )
abiDecodingFunctionArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionArray(ArrayType const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type, bool _fromMemory)
abiDecodingFunctionArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionArray(ArrayType const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type, bool _fromMemory)
abiDecodingFunctionByteArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionByteArray(ArrayType const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type, bool _fromMemory)
abiDecodingFunctionByteArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionByteArray(ArrayType const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type, bool _fromMemory)
abiDecodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionCalldataArray(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
abiDecodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionCalldataArray(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
abiDecodingFunctionCalldataStruct	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionCalldataStruct(StructType const& _type)$/;"	f	class:ABIFunctions	signature:(StructType const& _type)
abiDecodingFunctionCalldataStruct	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionCalldataStruct(StructType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(StructType const& _type)
abiDecodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionFunctionType(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack)$/;"	f	class:ABIFunctions	signature:(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack)
abiDecodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionFunctionType(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack)
abiDecodingFunctionStruct	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionStruct(StructType const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(StructType const& _type, bool _fromMemory)
abiDecodingFunctionStruct	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionStruct(StructType const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(StructType const& _type, bool _fromMemory)
abiDecodingFunctionValueType	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiDecodingFunctionValueType(Type const& _type, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(Type const& _type, bool _fromMemory)
abiDecodingFunctionValueType	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionValueType(Type const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _type, bool _fromMemory)
abiEncode	libsolidity/codegen/CompilerUtils.h	/^	void abiEncode($/;"	f	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false )
abiEncodeAndReturnUpdatedPosFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodeAndReturnUpdatedPosFunction($/;"	f	class:ABIFunctions	signature:( Type const& _givenType, Type const& _targetType, ABIFunctions::EncodingOptions const& _options )
abiEncodeAndReturnUpdatedPosFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodeAndReturnUpdatedPosFunction($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
abiEncodeV2	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::abiEncodeV2($/;"	f	class:dev::solidity::CompilerUtils	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes, bool _padToWordBoundaries )
abiEncodeV2	libsolidity/codegen/CompilerUtils.h	/^	void abiEncodeV2($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false, bool _padToWordBoundaries = true )
abiEncodingFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunction($/;"	f	class:ABIFunctions	signature:( Type const& _from, Type const& _to, EncodingOptions const& _options )
abiEncodingFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunction($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
abiEncodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionCalldataArray($/;"	f	class:ABIFunctions	signature:( Type const& _from, Type const& _to, EncodingOptions const& _options )
abiEncodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionCalldataArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
abiEncodingFunctionCompactStorageArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionCompactStorageArray($/;"	f	class:ABIFunctions	signature:( ArrayType const& _from, ArrayType const& _to, EncodingOptions const& _options )
abiEncodingFunctionCompactStorageArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionCompactStorageArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( ArrayType const& _givenType, ArrayType const& _targetType, EncodingOptions const& _options )
abiEncodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionFunctionType($/;"	f	class:ABIFunctions	signature:( FunctionType const& _from, Type const& _to, EncodingOptions const& _options )
abiEncodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionFunctionType($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( FunctionType const& _from, Type const& _to, EncodingOptions const& _options )
abiEncodingFunctionMemoryByteArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionMemoryByteArray($/;"	f	class:ABIFunctions	signature:( ArrayType const& _from, ArrayType const& _to, EncodingOptions const& _options )
abiEncodingFunctionMemoryByteArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionMemoryByteArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( ArrayType const& _givenType, ArrayType const& _targetType, EncodingOptions const& _options )
abiEncodingFunctionSimpleArray	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionSimpleArray($/;"	f	class:ABIFunctions	signature:( ArrayType const& _from, ArrayType const& _to, EncodingOptions const& _options )
abiEncodingFunctionSimpleArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionSimpleArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( ArrayType const& _givenType, ArrayType const& _targetType, EncodingOptions const& _options )
abiEncodingFunctionStringLiteral	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionStringLiteral($/;"	f	class:ABIFunctions	signature:( Type const& _from, Type const& _to, EncodingOptions const& _options )
abiEncodingFunctionStringLiteral	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionStringLiteral($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
abiEncodingFunctionStruct	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::abiEncodingFunctionStruct($/;"	f	class:ABIFunctions	signature:( StructType const& _from, StructType const& _to, EncodingOptions const& _options )
abiEncodingFunctionStruct	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionStruct($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( StructType const& _givenType, StructType const& _targetType, EncodingOptions const& _options )
abiFunctions	libsolidity/codegen/CompilerContext.h	/^	ABIFunctions& abiFunctions() { return m_abiFunctions; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
abnormalTerminationCode	solse/SolidityExprTranslator.h	/^    TerminationCode  abnormalTerminationCode = NONE;$/;"	m	class:ContextInfo	access:public
absolutePath	libdevcore/CommonIO.cpp	/^string dev::absolutePath(string const& _path, string const& _reference)$/;"	f	class:dev	signature:(string const& _path, string const& _reference)
absolutePath	libdevcore/CommonIO.h	/^std::string absolutePath(std::string const& _path, std::string const& _reference);$/;"	p	namespace:dev	signature:(std::string const& _path, std::string const& _reference)
absolutePath	libsolidity/ast/ASTAnnotations.h	/^	std::string absolutePath;$/;"	m	struct:dev::solidity::ImportAnnotation	access:public
abstractFunctionCall	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::abstractFunctionCall(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
abstractFunctionCall	libsolidity/formal/SMTChecker.h	/^	void abstractFunctionCall(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
accept	libsolidity/analysis/ControlFlowGraph.cpp	/^void CFG::accept(CFGConstVisitor& _visitor) const$/;"	f	class:CFG	signature:(CFGConstVisitor& _visitor) const
accept	libsolidity/analysis/ControlFlowGraph.h	/^  void accept(CFGConstVisitor& _visitor) const;$/;"	p	class:dev::solidity::CFG	access:public	signature:(CFGConstVisitor& _visitor) const
accept	libsolidity/ast/AST.h	/^	virtual void accept(ASTConstVisitor& _visitor) const = 0;$/;"	p	class:dev::solidity::ASTNode	access:public	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST.h	/^	virtual void accept(ASTVisitor& _visitor) = 0;$/;"	p	class:dev::solidity::ASTNode	access:public	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ArrayTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ArrayTypeName	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ArrayTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ArrayTypeName	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Assignment::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Assignment	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Assignment::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Assignment	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void BinaryOperation::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::BinaryOperation	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void BinaryOperation::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::BinaryOperation	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Block::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Block	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Block::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Block	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Break::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Break	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Break::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Break	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Conditional::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Conditional	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Conditional::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Conditional	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Continue::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Continue	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Continue::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Continue	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ContractDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ContractDefinition	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ContractDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ContractDefinition	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ElementaryTypeName	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ElementaryTypeName	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeNameExpression::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeNameExpression::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void EmitStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EmitStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void EmitStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EmitStatement	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void EnumDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EnumDefinition	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void EnumDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EnumDefinition	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void EnumValue::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EnumValue	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void EnumValue::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EnumValue	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void EventDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EventDefinition	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void EventDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EventDefinition	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ExpressionStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ExpressionStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ExpressionStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ExpressionStatement	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ForStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ForStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ForStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ForStatement	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void FunctionCall::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::FunctionCall	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void FunctionCall::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::FunctionCall	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void FunctionDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::FunctionDefinition	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void FunctionDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::FunctionDefinition	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void FunctionTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::FunctionTypeName	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void FunctionTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::FunctionTypeName	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Identifier::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Identifier	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Identifier::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Identifier	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void IfStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::IfStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void IfStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::IfStatement	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ImportDirective::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ImportDirective	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ImportDirective::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ImportDirective	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void IndexAccess::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::IndexAccess	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void IndexAccess::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::IndexAccess	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void InheritanceSpecifier::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::InheritanceSpecifier	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void InheritanceSpecifier::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::InheritanceSpecifier	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void InlineAssembly::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::InlineAssembly	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void InlineAssembly::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::InlineAssembly	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Literal::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Literal	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Literal::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Literal	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Mapping::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Mapping	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Mapping::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Mapping	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void MemberAccess::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::MemberAccess	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void MemberAccess::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::MemberAccess	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ModifierDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ModifierDefinition	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ModifierDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ModifierDefinition	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ModifierInvocation::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ModifierInvocation	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ModifierInvocation::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ModifierInvocation	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void NewExpression::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::NewExpression	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void NewExpression::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::NewExpression	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void ParameterList::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ParameterList	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void ParameterList::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ParameterList	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void PlaceholderStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::PlaceholderStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void PlaceholderStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::PlaceholderStatement	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void PragmaDirective::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::PragmaDirective	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void PragmaDirective::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::PragmaDirective	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Return::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Return	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Return::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Return	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void SourceUnit::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::SourceUnit	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void SourceUnit::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::SourceUnit	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void StructDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::StructDefinition	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void StructDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::StructDefinition	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void Throw::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Throw	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void Throw::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Throw	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void TupleExpression::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::TupleExpression	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void TupleExpression::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::TupleExpression	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void UnaryOperation::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::UnaryOperation	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void UnaryOperation::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::UnaryOperation	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void UserDefinedTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::UserDefinedTypeName	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void UserDefinedTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::UserDefinedTypeName	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void UsingForDirective::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::UsingForDirective	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void UsingForDirective::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::UsingForDirective	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void VariableDeclaration::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::VariableDeclaration	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void VariableDeclaration::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::VariableDeclaration	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void VariableDeclarationStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::VariableDeclarationStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void VariableDeclarationStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::VariableDeclarationStatement	signature:(ASTVisitor& _visitor)
accept	libsolidity/ast/AST_accept.h	/^void WhileStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::WhileStatement	signature:(ASTConstVisitor& _visitor) const
accept	libsolidity/ast/AST_accept.h	/^void WhileStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::WhileStatement	signature:(ASTVisitor& _visitor)
accessIndex	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _arrayType, bool _doBoundsCheck) const
accessIndex	libsolidity/codegen/ArrayUtils.h	/^	void accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck = true) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, bool _doBoundsCheck = true) const
actOnInput	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::actOnInput()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
actOnInput	solse/CommandLineInterface.h	/^	bool actOnInput();$/;"	p	class:dev::solidity::DocumentationType	access:public	signature:()
action	libevmasm/SimplificationRule.h	/^	std::function<Pattern()> action;$/;"	m	struct:dev::solidity::SimplificationRule	access:public
activateVariable	libsolidity/analysis/DeclarationContainer.cpp	/^void DeclarationContainer::activateVariable(ASTString const& _name)$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name)
activateVariable	libsolidity/analysis/DeclarationContainer.h	/^	void activateVariable(ASTString const& _name);$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name)
activateVariable	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::activateVariable(string const& _name)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(string const& _name)
activateVariable	libsolidity/analysis/NameAndTypeResolver.h	/^	void activateVariable(std::string const& _name);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(std::string const& _name)
actualType	libsolidity/ast/Types.h	/^	TypePointer const& actualType() const { return m_actualType; }$/;"	f	class:dev::solidity::TypeType	access:public	signature:() const
add	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::add(string const& _str)$/;"	f	class:IndentedWriter	signature:(string const& _str)
add	libdevcore/IndentedWriter.h	/^	void add(std::string const& _str);$/;"	p	class:dev::IndentedWriter	access:public	signature:(std::string const& _str)
addAssertion	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::addAssertion(Expression const& _expr)$/;"	f	class:CVC4Interface	signature:(Expression const& _expr)
addAssertion	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::addAssertion(Expression const& _expr)$/;"	f	class:SMTLib2Interface	signature:(Expression const& _expr)
addAssertion	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::addAssertion(Expression const& _expr)$/;"	f	class:SMTPortfolio	signature:(Expression const& _expr)
addAssertion	libsolidity/formal/SolverInterface.h	/^	virtual void addAssertion(Expression const& _expr) = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:(Expression const& _expr)
addAssertion	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::addAssertion(Expression const& _expr)$/;"	f	class:Z3Interface	signature:(Expression const& _expr)
addCommentLiteralChar	liblangutil/Scanner.h	/^	inline void addCommentLiteralChar(char c) { m_nextSkippedComment.literal.push_back(c); }$/;"	f	class:langutil::Scanner	access:private	signature:(char c)
addDependencies	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::addDependencies(Id _c)$/;"	f	class:CSECodeGenerator	signature:(Id _c)
addDependencies	libevmasm/CommonSubexpressionEliminator.h	/^	void addDependencies(Id _c);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _c)
addFunction	libyul/backends/evm/EVMDialect.cpp	/^void EVMDialect::addFunction($/;"	f	class:EVMDialect	signature:( string _name, size_t _params, size_t _returns, bool _movable, bool _literalArguments, std::function<void(FunctionCall const&, AbstractAssembly&, std::function<void()>)> _generateCode )
addFunction	libyul/backends/evm/EVMDialect.h	/^	void addFunction($/;"	p	struct:yul::EVMDialect	access:protected	signature:( std::string _name, size_t _params, size_t _returns, bool _movable, bool _literalArguments, std::function<void(FunctionCall const&, AbstractAssembly&, std::function<void()>)> _generateCode )
addLine	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::addLine(string const& _line)$/;"	f	class:IndentedWriter	signature:(string const& _line)
addLine	libdevcore/IndentedWriter.h	/^	void addLine(std::string const& _line);$/;"	p	class:dev::IndentedWriter	access:public	signature:(std::string const& _line)
addLiteralChar	liblangutil/Scanner.h	/^	inline void addLiteralChar(char c) { m_nextToken.literal.push_back(c); }$/;"	f	class:langutil::Scanner	access:private	signature:(char c)
addLiteralCharAndAdvance	liblangutil/Scanner.h	/^	inline void addLiteralCharAndAdvance() { addLiteralChar(m_char); advance(); }$/;"	f	class:langutil::Scanner	access:private	signature:()
addLocalVariable	libsolidity/ast/AST.h	/^	void addLocalVariable(VariableDeclaration const& _localVariable) { m_localVariables.push_back(&_localVariable); }$/;"	f	class:dev::solidity::VariableScope	access:public	signature:(VariableDeclaration const& _localVariable)
addNamedSubObject	libyul/ObjectParser.cpp	/^void ObjectParser::addNamedSubObject(Object& _container, YulString _name, shared_ptr<ObjectNode> _subObject)$/;"	f	class:ObjectParser	signature:(Object& _container, YulString _name, shared_ptr<ObjectNode> _subObject)
addNamedSubObject	libyul/ObjectParser.h	/^	void addNamedSubObject(Object& _container, YulString _name, std::shared_ptr<ObjectNode> _subObject);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object& _container, YulString _name, std::shared_ptr<ObjectNode> _subObject)
addOverflowTarget	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::addOverflowTarget($/;"	f	class:SMTChecker	signature:( OverflowTarget::Type _type, TypePointer _intType, smt::Expression _value, SourceLocation const& _location )
addOverflowTarget	libsolidity/formal/SMTChecker.h	/^	void addOverflowTarget(OverflowTarget::Type _type, TypePointer _intType, smt::Expression _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(OverflowTarget::Type _type, TypePointer _intType, smt::Expression _value, langutil::SourceLocation const& _location)
addPathConjoinedExpression	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::addPathConjoinedExpression(smt::Expression const& _e)$/;"	f	class:SMTChecker	signature:(smt::Expression const& _e)
addPathConjoinedExpression	libsolidity/formal/SMTChecker.h	/^	void addPathConjoinedExpression(smt::Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression const& _e)
addPathImpliedExpression	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::addPathImpliedExpression(smt::Expression const& _e)$/;"	f	class:SMTChecker	signature:(smt::Expression const& _e)
addPathImpliedExpression	libsolidity/formal/SMTChecker.h	/^	void addPathImpliedExpression(smt::Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression const& _e)
addRule	libevmasm/SimplificationRules.cpp	/^void Rules::addRule(SimplificationRule<Pattern> const& _rule)$/;"	f	class:Rules	signature:(SimplificationRule<Pattern> const& _rule)
addRule	libevmasm/SimplificationRules.h	/^	void addRule(SimplificationRule<Pattern> const& _rule);$/;"	p	class:dev::eth::Rules	access:private	signature:(SimplificationRule<Pattern> const& _rule)
addRule	libyul/optimiser/SimplificationRules.cpp	/^void SimplificationRules::addRule(SimplificationRule<Pattern> const& _rule)$/;"	f	class:SimplificationRules	signature:(SimplificationRule<Pattern> const& _rule)
addRule	libyul/optimiser/SimplificationRules.h	/^	void addRule(SimplificationRule<Pattern> const& _rule);$/;"	p	class:yul::SimplificationRules	access:private	signature:(SimplificationRule<Pattern> const& _rule)
addRules	libevmasm/SimplificationRules.cpp	/^void Rules::addRules(std::vector<SimplificationRule<Pattern>> const& _rules)$/;"	f	class:Rules	signature:(std::vector<SimplificationRule<Pattern>> const& _rules)
addRules	libevmasm/SimplificationRules.h	/^	void addRules(std::vector<SimplificationRule<Pattern>> const& _rules);$/;"	p	class:dev::eth::Rules	access:private	signature:(std::vector<SimplificationRule<Pattern>> const& _rules)
addRules	libyul/optimiser/SimplificationRules.cpp	/^void SimplificationRules::addRules(vector<SimplificationRule<Pattern>> const& _rules)$/;"	f	class:SimplificationRules	signature:(vector<SimplificationRule<Pattern>> const& _rules)
addRules	libyul/optimiser/SimplificationRules.h	/^	void addRules(std::vector<SimplificationRule<Pattern>> const& _rules);$/;"	p	class:yul::SimplificationRules	access:private	signature:(std::vector<SimplificationRule<Pattern>> const& _rules)
addSMTLib2Response	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::addSMTLib2Response(h256 const& _hash, string const& _response)$/;"	f	class:CompilerStack	signature:(h256 const& _hash, string const& _response)
addSMTLib2Response	libsolidity/interface/CompilerStack.h	/^	void addSMTLib2Response(h256 const& _hash, std::string const& _response);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(h256 const& _hash, std::string const& _response)
addSource	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::addSource(string const& _name, string const& _content, bool _isLibrary)$/;"	f	class:CompilerStack	signature:(string const& _name, string const& _content, bool _isLibrary)
addSource	libsolidity/interface/CompilerStack.h	/^	bool addSource(std::string const& _name, std::string const& _content, bool _isLibrary = false);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _name, std::string const& _content, bool _isLibrary = false)
addStateVariable	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::addStateVariable($/;"	f	class:dev::solidity::CompilerContext	signature:( VariableDeclaration const& _declaration, u256 const& _storageOffset, unsigned _byteOffset )
addStateVariable	libsolidity/codegen/CompilerContext.h	/^	void addStateVariable(VariableDeclaration const& _declaration, u256 const& _storageOffset, unsigned _byteOffset);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(VariableDeclaration const& _declaration, u256 const& _storageOffset, unsigned _byteOffset)
addSubroutine	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem addSubroutine(eth::AssemblyPointer const& _assembly) { return m_asm->appendSubroutine(_assembly); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyPointer const& _assembly)
addUnicodeAsUTF8	liblangutil/Scanner.cpp	/^void Scanner::addUnicodeAsUTF8(unsigned codepoint)$/;"	f	class:langutil::Scanner	signature:(unsigned codepoint)
addUnicodeAsUTF8	liblangutil/Scanner.h	/^	void addUnicodeAsUTF8(unsigned codepoint);$/;"	p	class:langutil::Scanner	access:private	signature:(unsigned codepoint)
addVariable	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::addVariable($/;"	f	class:dev::solidity::CompilerContext	signature:( VariableDeclaration const& _declaration, unsigned _offsetToCurrent )
addVariable	libsolidity/codegen/CompilerContext.h	/^	void addVariable(VariableDeclaration const& _declaration, unsigned _offsetToCurrent = 0);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(VariableDeclaration const& _declaration, unsigned _offsetToCurrent = 0)
additional	libevmasm/Instruction.h	/^	int additional;		\/\/\/< Additional items required in memory for this instructions (only for PUSH).$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
address	libsolidity/ast/Types.h	/^	static AddressType& address() { static std::shared_ptr<AddressType> addr(std::make_shared<AddressType>(StateMutability::NonPayable)); return *addr; }$/;"	f	class:dev::solidity::AddressType	access:public	signature:()
addressPayable	libsolidity/ast/Types.h	/^	static AddressType& addressPayable() { static std::shared_ptr<AddressType> addr(std::make_shared<AddressType>(StateMutability::Payable)); return *addr; }$/;"	f	class:dev::solidity::AddressType	access:public	signature:()
adjustDeposit	libevmasm/Assembly.h	/^	void adjustDeposit(int _adjustment) { m_deposit += _adjustment; assertThrow(m_deposit >= 0, InvalidDeposit, ""); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(int _adjustment)
adjustStackOffset	libsolidity/codegen/CompilerContext.h	/^	void adjustStackOffset(int _adjustment) { m_asm->adjustDeposit(_adjustment); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(int _adjustment)
advance	liblangutil/ParserBase.cpp	/^Token ParserBase::advance()$/;"	f	class:ParserBase	signature:()
advance	liblangutil/ParserBase.h	/^	Token advance();$/;"	p	class:langutil::ParserBase	access:protected	signature:()
advance	liblangutil/Scanner.h	/^	bool advance() { m_char = m_source->advanceAndGet(); return !m_source->isPastEndOfInput(); }$/;"	f	class:langutil::Scanner	access:private	signature:()
advanceAndGet	liblangutil/CharStream.cpp	/^char CharStream::advanceAndGet(size_t _chars)$/;"	f	class:CharStream	signature:(size_t _chars)
advanceAndGet	liblangutil/CharStream.h	/^	char advanceAndGet(size_t _chars = 1);$/;"	p	class:langutil::CharStream	access:public	signature:(size_t _chars = 1)
allocateMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::allocateMemory()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
allocateMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::allocateMemory(u256 const& size)$/;"	f	class:dev::solidity::CompilerUtils	signature:(u256 const& size)
allocateMemory	libsolidity/codegen/CompilerUtils.h	/^	void allocateMemory();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
allocateMemory	libsolidity/codegen/CompilerUtils.h	/^	void allocateMemory(u256 const& size);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(u256 const& size)
allocation	solse/mechanism.h	/^		z3::expr allocation;$/;"	m	class:Mechanism	access:public
allocationFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::allocationFunction()$/;"	f	class:ABIFunctions	signature:()
allocationFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string allocationFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
allowEmptyName	libsolidity/parsing/Parser.h	/^		bool allowEmptyName = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
allowIndexed	libsolidity/parsing/Parser.h	/^		bool allowIndexed = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
allowInitialValue	libsolidity/parsing/Parser.h	/^		bool allowInitialValue = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
allowLocationSpecifier	libsolidity/parsing/Parser.h	/^		bool allowLocationSpecifier = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
allowVar	libsolidity/parsing/Parser.h	/^		bool allowVar = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
allowedDataLocations	libsolidity/ast/AST.cpp	/^set<VariableDeclaration::Location> VariableDeclaration::allowedDataLocations() const$/;"	f	class:VariableDeclaration	signature:() const
allowedDataLocations	libsolidity/ast/AST.h	/^	std::set<Location> allowedDataLocations() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
alreadyGrouped	libyul/optimiser/FunctionGrouper.cpp	/^bool FunctionGrouper::alreadyGrouped(Block const& _block)$/;"	f	class:FunctionGrouper	signature:(Block const& _block)
alreadyGrouped	libyul/optimiser/FunctionGrouper.h	/^	bool alreadyGrouped(Block const& _block);$/;"	p	class:yul::FunctionGrouper	access:private	signature:(Block const& _block)
altersControlFlow	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::altersControlFlow(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
altersControlFlow	libevmasm/SemanticInformation.h	/^	static bool altersControlFlow(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
analyseDocStrings	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::analyseDocStrings(SourceUnit const& _sourceUnit)$/;"	f	class:DocStringAnalyser	signature:(SourceUnit const& _sourceUnit)
analyseDocStrings	libsolidity/analysis/DocStringAnalyser.h	/^	bool analyseDocStrings(SourceUnit const& _sourceUnit);$/;"	p	class:dev::solidity::DocStringAnalyser	access:public	signature:(SourceUnit const& _sourceUnit)
analysisInfo	libsolidity/ast/ASTAnnotations.h	/^	std::shared_ptr<yul::AsmAnalysisInfo> analysisInfo;$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation	access:public
analysisInfo	libyul/Object.h	/^	std::shared_ptr<yul::AsmAnalysisInfo> analysisInfo;$/;"	m	struct:yul::Object	access:public
analyze	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^bool ControlFlowAnalyzer::analyze(ASTNode const& _astRoot)$/;"	f	class:ControlFlowAnalyzer	signature:(ASTNode const& _astRoot)
analyze	libsolidity/analysis/ControlFlowAnalyzer.h	/^	bool analyze(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::ControlFlowAnalyzer	access:public	signature:(ASTNode const& _astRoot)
analyze	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::analyze(SourceUnit const& _sourceUnit)$/;"	f	class:StaticAnalyzer	signature:(SourceUnit const& _sourceUnit)
analyze	libsolidity/analysis/StaticAnalyzer.h	/^	bool analyze(SourceUnit const& _sourceUnit);$/;"	p	class:dev::solidity::StaticAnalyzer	access:public	signature:(SourceUnit const& _sourceUnit)
analyze	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::analyze(SourceUnit const& _source, shared_ptr<Scanner> const& _scanner)$/;"	f	class:SMTChecker	signature:(SourceUnit const& _source, shared_ptr<Scanner> const& _scanner)
analyze	libsolidity/formal/SMTChecker.h	/^	void analyze(SourceUnit const& _sources, std::shared_ptr<langutil::Scanner> const& _scanner);$/;"	p	class:dev::solidity::SMTChecker	access:public	signature:(SourceUnit const& _sources, std::shared_ptr<langutil::Scanner> const& _scanner)
analyze	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::analyze()$/;"	f	class:CompilerStack	signature:()
analyze	libsolidity/interface/CompilerStack.h	/^	bool analyze();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
analyze	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::analyze(Block const& _block)$/;"	f	class:AsmAnalyzer	signature:(Block const& _block)
analyze	libyul/AsmAnalysis.h	/^	bool analyze(Block const& _block);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Block const& _block)
analyzeParsed	libyul/AssemblyStack.cpp	/^bool AssemblyStack::analyzeParsed()$/;"	f	class:AssemblyStack	signature:()
analyzeParsed	libyul/AssemblyStack.cpp	/^bool AssemblyStack::analyzeParsed(Object& _object)$/;"	f	class:AssemblyStack	signature:(Object& _object)
analyzeParsed	libyul/AssemblyStack.h	/^	bool analyzeParsed();$/;"	p	class:yul::AssemblyStack	access:private	signature:()
analyzeParsed	libyul/AssemblyStack.h	/^	bool analyzeParsed(yul::Object& _object);$/;"	p	class:yul::AssemblyStack	access:private	signature:(yul::Object& _object)
analyzeStrictAssertCorrect	libyul/AsmAnalysis.cpp	/^AsmAnalysisInfo AsmAnalyzer::analyzeStrictAssertCorrect($/;"	f	class:AsmAnalyzer	signature:( shared_ptr<Dialect> _dialect, Block const& _ast )
analyzeStrictAssertCorrect	libyul/AsmAnalysis.h	/^	static AsmAnalysisInfo analyzeStrictAssertCorrect($/;"	p	class:yul::AsmAnalyzer	access:public	signature:( std::shared_ptr<Dialect> _dialect, Block const& _ast )
annotateBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::annotateBaseConstructorArguments($/;"	f	class:ContractLevelChecker	signature:( ContractDefinition const& _currentContract, FunctionDefinition const* _baseConstructor, ASTNode const* _argumentNode )
annotateBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.h	/^	void annotateBaseConstructorArguments($/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:( ContractDefinition const& _currentContract, FunctionDefinition const* _baseConstructor, ASTNode const* _argumentNode )
annotation	libsolidity/ast/AST.cpp	/^ASTAnnotation& ASTNode::annotation() const$/;"	f	class:ASTNode	signature:() const
annotation	libsolidity/ast/AST.cpp	/^BinaryOperationAnnotation& BinaryOperation::annotation() const$/;"	f	class:BinaryOperation	signature:() const
annotation	libsolidity/ast/AST.cpp	/^ContractDefinitionAnnotation& ContractDefinition::annotation() const$/;"	f	class:ContractDefinition	signature:() const
annotation	libsolidity/ast/AST.cpp	/^EventDefinitionAnnotation& EventDefinition::annotation() const$/;"	f	class:EventDefinition	signature:() const
annotation	libsolidity/ast/AST.cpp	/^ExpressionAnnotation& Expression::annotation() const$/;"	f	class:Expression	signature:() const
annotation	libsolidity/ast/AST.cpp	/^FunctionCallAnnotation& FunctionCall::annotation() const$/;"	f	class:FunctionCall	signature:() const
annotation	libsolidity/ast/AST.cpp	/^FunctionDefinitionAnnotation& FunctionDefinition::annotation() const$/;"	f	class:FunctionDefinition	signature:() const
annotation	libsolidity/ast/AST.cpp	/^IdentifierAnnotation& Identifier::annotation() const$/;"	f	class:Identifier	signature:() const
annotation	libsolidity/ast/AST.cpp	/^ImportAnnotation& ImportDirective::annotation() const$/;"	f	class:ImportDirective	signature:() const
annotation	libsolidity/ast/AST.cpp	/^InlineAssemblyAnnotation& InlineAssembly::annotation() const$/;"	f	class:InlineAssembly	signature:() const
annotation	libsolidity/ast/AST.cpp	/^MemberAccessAnnotation& MemberAccess::annotation() const$/;"	f	class:MemberAccess	signature:() const
annotation	libsolidity/ast/AST.cpp	/^ModifierDefinitionAnnotation& ModifierDefinition::annotation() const$/;"	f	class:ModifierDefinition	signature:() const
annotation	libsolidity/ast/AST.cpp	/^ReturnAnnotation& Return::annotation() const$/;"	f	class:Return	signature:() const
annotation	libsolidity/ast/AST.cpp	/^SourceUnitAnnotation& SourceUnit::annotation() const$/;"	f	class:SourceUnit	signature:() const
annotation	libsolidity/ast/AST.cpp	/^StatementAnnotation& Statement::annotation() const$/;"	f	class:Statement	signature:() const
annotation	libsolidity/ast/AST.cpp	/^TypeDeclarationAnnotation& EnumDefinition::annotation() const$/;"	f	class:EnumDefinition	signature:() const
annotation	libsolidity/ast/AST.cpp	/^TypeDeclarationAnnotation& StructDefinition::annotation() const$/;"	f	class:StructDefinition	signature:() const
annotation	libsolidity/ast/AST.cpp	/^TypeNameAnnotation& TypeName::annotation() const$/;"	f	class:TypeName	signature:() const
annotation	libsolidity/ast/AST.cpp	/^UserDefinedTypeNameAnnotation& UserDefinedTypeName::annotation() const$/;"	f	class:UserDefinedTypeName	signature:() const
annotation	libsolidity/ast/AST.cpp	/^VariableDeclarationAnnotation& VariableDeclaration::annotation() const$/;"	f	class:VariableDeclaration	signature:() const
annotation	libsolidity/ast/AST.h	/^	virtual ASTAnnotation& annotation() const;$/;"	p	class:dev::solidity::ASTNode	access:public	signature:() const
append	libevmasm/Assembly.cpp	/^AssemblyItem const& Assembly::append(AssemblyItem const& _i)$/;"	f	class:Assembly	signature:(AssemblyItem const& _i)
append	libevmasm/Assembly.cpp	/^void Assembly::append(Assembly const& _a)$/;"	f	class:Assembly	signature:(Assembly const& _a)
append	libevmasm/Assembly.cpp	/^void Assembly::append(Assembly const& _a, int _deposit)$/;"	f	class:Assembly	signature:(Assembly const& _a, int _deposit)
append	libevmasm/Assembly.h	/^	AssemblyItem const& append(AssemblyItem const& _i);$/;"	p	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _i)
append	libevmasm/Assembly.h	/^	AssemblyItem const& append(bytes const& _data) { return append(newData(_data)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(bytes const& _data)
append	libevmasm/Assembly.h	/^	AssemblyItem const& append(std::string const& _data) { return append(newPushString(_data)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(std::string const& _data)
append	libevmasm/Assembly.h	/^	void append(Assembly const& _a);$/;"	p	class:dev::eth::Assembly	access:public	signature:(Assembly const& _a)
append	libevmasm/Assembly.h	/^	void append(Assembly const& _a, int _deposit);$/;"	p	class:dev::eth::Assembly	access:public	signature:(Assembly const& _a, int _deposit)
append	libevmasm/LinkerObject.cpp	/^void LinkerObject::append(LinkerObject const& _other)$/;"	f	class:LinkerObject	signature:(LinkerObject const& _other)
append	libevmasm/LinkerObject.h	/^	void append(LinkerObject const& _other);$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:(LinkerObject const& _other)
append	liblangutil/ErrorReporter.h	/^	void append(ErrorList const& _errorList)$/;"	f	class:langutil::ErrorReporter	access:public	signature:(ErrorList const& _errorList)
append	liblangutil/Exceptions.h	/^	SecondarySourceLocation& append(std::string const& _errMsg, SourceLocation const& _sourceLocation)$/;"	f	class:langutil::SecondarySourceLocation	access:public	signature:(std::string const& _errMsg, SourceLocation const& _sourceLocation)
appendAndOrOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendAndOrOperatorCode(BinaryOperation const& _binaryOperation)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(BinaryOperation const& _binaryOperation)
appendAndOrOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendAndOrOperatorCode(BinaryOperation const& _binaryOperation);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(BinaryOperation const& _binaryOperation)
appendArithmeticOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendArithmeticOperatorCode(Token _operator, Type const& _type)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _type)
appendArithmeticOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendArithmeticOperatorCode(Token _operator, Type const& _type);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _type)
appendAssemblySize	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendAssemblySize() = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:()
appendAssemblySize	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendAssemblySize()$/;"	f	class:EthAssemblyAdapter	signature:()
appendAssemblySize	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendAssemblySize()$/;"	f	class:EVMAssembly	signature:()
appendAssemblySize	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendAssemblySize()$/;"	f	class:NoOutputAssembly	signature:()
appendAuxiliaryData	libsolidity/codegen/CompilerContext.h	/^	void appendAuxiliaryData(bytes const& _data) { m_asm->appendAuxiliaryDataToEnd(_data); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(bytes const& _data)
appendAuxiliaryDataToEnd	libevmasm/Assembly.h	/^	void appendAuxiliaryDataToEnd(bytes const& _data) { m_auxiliaryData += _data; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(bytes const& _data)
appendBaseConstructor	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendBaseConstructor(FunctionDefinition const& _constructor)$/;"	f	class:ContractCompiler	signature:(FunctionDefinition const& _constructor)
appendBaseConstructor	libsolidity/codegen/ContractCompiler.h	/^	void appendBaseConstructor(FunctionDefinition const& _constructor);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(FunctionDefinition const& _constructor)
appendBeginsub	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendBeginsub(LabelID _labelId, int _arguments) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId, int _arguments)
appendBeginsub	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendBeginsub(LabelID, int)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID, int)
appendBeginsub	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendBeginsub(LabelID _labelId, int _arguments)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId, int _arguments)
appendBeginsub	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendBeginsub(LabelID, int _arguments)$/;"	f	class:NoOutputAssembly	signature:(LabelID, int _arguments)
appendBitOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendBitOperatorCode(Token _operator)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator)
appendBitOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendBitOperatorCode(Token _operator);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator)
appendCallValueCheck	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendCallValueCheck()$/;"	f	class:ContractCompiler	signature:()
appendCallValueCheck	libsolidity/codegen/ContractCompiler.h	/^	void appendCallValueCheck();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
appendCompareOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendCompareOperatorCode(Token _operator, Type const& _type)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _type)
appendCompareOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendCompareOperatorCode(Token _operator, Type const& _type);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _type)
appendConditionalInvalid	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendConditionalInvalid()$/;"	f	class:dev::solidity::CompilerContext	signature:()
appendConditionalInvalid	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendConditionalInvalid();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
appendConditionalJump	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem appendConditionalJump() { return m_asm->appendJumpI().tag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
appendConditionalJumpTo	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendConditionalJumpTo(eth::AssemblyItem const& _tag) { m_asm->appendJumpI(_tag); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyItem const& _tag)
appendConditionalRevert	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendConditionalRevert(bool _forwardReturnData)$/;"	f	class:dev::solidity::CompilerContext	signature:(bool _forwardReturnData)
appendConditionalRevert	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendConditionalRevert(bool _forwardReturnData = false);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(bool _forwardReturnData = false)
appendConstStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendConstStateVariableAccessor(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _varDecl)
appendConstStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.h	/^	void appendConstStateVariableAccessor(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(VariableDeclaration const& _varDecl)
appendConstant	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendConstant(dev::u256 const& _constant) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(dev::u256 const& _constant)
appendConstant	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendConstant(u256 const& _constant)$/;"	f	class:EthAssemblyAdapter	signature:(u256 const& _constant)
appendConstant	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendConstant(u256 const& _constant)$/;"	f	class:EVMAssembly	signature:(u256 const& _constant)
appendConstant	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendConstant(u256 const&)$/;"	f	class:NoOutputAssembly	signature:(u256 const&)
appendConstructor	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendConstructor(FunctionDefinition const& _constructor)$/;"	f	class:ContractCompiler	signature:(FunctionDefinition const& _constructor)
appendConstructor	libsolidity/codegen/ContractCompiler.h	/^	void appendConstructor(FunctionDefinition const& _constructor);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(FunctionDefinition const& _constructor)
appendControlFlow	libsolidity/analysis/ControlFlowBuilder.cpp	/^void ControlFlowBuilder::appendControlFlow(ASTNode const& _node)$/;"	f	class:ControlFlowBuilder	signature:(ASTNode const& _node)
appendControlFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	void appendControlFlow(ASTNode const& _node);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(ASTNode const& _node)
appendData	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem appendData(bytes const& _data) { return m_asm->append(_data); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(bytes const& _data)
appendData	libyul/backends/evm/AbstractAssembly.h	/^	virtual SubID appendData(dev::bytes const& _data) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(dev::bytes const& _data)
appendData	libyul/backends/evm/AsmCodeGen.cpp	/^AbstractAssembly::SubID EthAssemblyAdapter::appendData(bytes const& _data)$/;"	f	class:EthAssemblyAdapter	signature:(bytes const& _data)
appendData	libyul/backends/evm/EVMAssembly.cpp	/^AbstractAssembly::SubID EVMAssembly::appendData(bytes const&)$/;"	f	class:EVMAssembly	signature:(bytes const&)
appendData	libyul/backends/evm/NoOutputAssembly.cpp	/^AbstractAssembly::SubID NoOutputAssembly::appendData(bytes const&)$/;"	f	class:NoOutputAssembly	signature:(bytes const&)
appendDataOffset	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendDataOffset(SubID _sub) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(SubID _sub)
appendDataOffset	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendDataOffset(AbstractAssembly::SubID _sub)$/;"	f	class:EthAssemblyAdapter	signature:(AbstractAssembly::SubID _sub)
appendDataOffset	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendDataOffset(AbstractAssembly::SubID)$/;"	f	class:EVMAssembly	signature:(AbstractAssembly::SubID)
appendDataOffset	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendDataOffset(AbstractAssembly::SubID)$/;"	f	class:NoOutputAssembly	signature:(AbstractAssembly::SubID)
appendDataSize	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendDataSize(SubID _sub) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(SubID _sub)
appendDataSize	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendDataSize(AbstractAssembly::SubID _sub)$/;"	f	class:EthAssemblyAdapter	signature:(AbstractAssembly::SubID _sub)
appendDataSize	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendDataSize(AbstractAssembly::SubID)$/;"	f	class:EVMAssembly	signature:(AbstractAssembly::SubID)
appendDataSize	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendDataSize(AbstractAssembly::SubID)$/;"	f	class:NoOutputAssembly	signature:(AbstractAssembly::SubID)
appendDelegatecallCheck	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendDelegatecallCheck()$/;"	f	class:ContractCompiler	signature:()
appendDelegatecallCheck	libsolidity/codegen/ContractCompiler.h	/^	void appendDelegatecallCheck();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
appendDeployTimeAddress	libsolidity/codegen/CompilerContext.h	/^	void appendDeployTimeAddress() { m_asm->append(eth::PushDeployTimeAddress); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
appendDocTag	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::appendDocTag(iter _pos, iter _end)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end)
appendDocTag	libsolidity/parsing/DocStringParser.h	/^	iter appendDocTag(iter _pos, iter _end);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end)
appendDocTagParam	libsolidity/parsing/DocStringParser.h	/^	iter appendDocTagParam(iter _pos, iter _end);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end)
appendDup	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::appendDup(int _fromPosition, SourceLocation const& _location)$/;"	f	class:CSECodeGenerator	signature:(int _fromPosition, SourceLocation const& _location)
appendDup	libevmasm/CommonSubexpressionEliminator.h	/^	void appendDup(int _fromPosition, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(int _fromPosition, langutil::SourceLocation const& _location)
appendError	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::appendError(string const& _description)$/;"	f	class:DocStringAnalyser	signature:(string const& _description)
appendError	libsolidity/analysis/DocStringAnalyser.h	/^	void appendError(std::string const& _description);$/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:(std::string const& _description)
appendError	libsolidity/parsing/DocStringParser.cpp	/^void DocStringParser::appendError(string const& _description)$/;"	f	class:DocStringParser	signature:(string const& _description)
appendError	libsolidity/parsing/DocStringParser.h	/^	void appendError(std::string const& _description);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(std::string const& _description)
appendExpressionAttributes	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::appendExpressionAttributes($/;"	f	class:dev::solidity::ASTJsonConverter	signature:( std::vector<pair<string, Json::Value>>& _attributes, ExpressionAnnotation const& _annotation )
appendExpressionAttributes	libsolidity/ast/ASTJsonConverter.h	/^	void appendExpressionAttributes($/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:( std::vector<std::pair<std::string, Json::Value>> &_attributes, ExpressionAnnotation const& _annotation )
appendExpressionCopyToMemory	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendExpressionCopyToMemory(Type const& _expectedType, Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Type const& _expectedType, Expression const& _expression)
appendExpressionCopyToMemory	libsolidity/codegen/ExpressionCompiler.h	/^	void appendExpressionCopyToMemory(Type const& _expectedType, Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Type const& _expectedType, Expression const& _expression)
appendExternalFunctionCall	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendExternalFunctionCall($/;"	f	class:dev::solidity::ExpressionCompiler	signature:( FunctionType const& _functionType, vector<ASTPointer<Expression const>> const& _arguments )
appendExternalFunctionCall	libsolidity/codegen/ExpressionCompiler.h	/^	void appendExternalFunctionCall($/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:( FunctionType const& _functionType, std::vector<ASTPointer<Expression const>> const& _arguments )
appendFunctionSelector	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendFunctionSelector(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
appendFunctionSelector	libsolidity/codegen/ContractCompiler.h	/^	void appendFunctionSelector(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
appendInitAndConstructorCode	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendInitAndConstructorCode(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
appendInitAndConstructorCode	libsolidity/codegen/ContractCompiler.h	/^	void appendInitAndConstructorCode(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
appendInlineAssembly	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::appendInlineAssembly($/;"	f	class:dev::solidity::CompilerContext	signature:( string const& _assembly, vector<string> const& _localVariables, set<string> const& _externallyUsedFunctions, bool _system, bool _optimise )
appendInlineAssembly	libsolidity/codegen/CompilerContext.h	/^	void appendInlineAssembly($/;"	p	class:dev::solidity::CompilerContext	access:public	signature:( std::string const& _assembly, std::vector<std::string> const& _localVariables = std::vector<std::string>(), std::set<std::string> const& _externallyUsedFunctions = std::set<std::string>(), bool _system = false, bool _optimise = false )
appendInstruction	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendInstruction(dev::solidity::Instruction _instruction) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(dev::solidity::Instruction _instruction)
appendInstruction	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendInstruction(solidity::Instruction _instruction)$/;"	f	class:EthAssemblyAdapter	signature:(solidity::Instruction _instruction)
appendInstruction	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendInstruction(solidity::Instruction _instr)$/;"	f	class:EVMAssembly	signature:(solidity::Instruction _instr)
appendInstruction	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendInstruction(solidity::Instruction _instr)$/;"	f	class:NoOutputAssembly	signature:(solidity::Instruction _instr)
appendInternalSelector	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendInternalSelector($/;"	f	class:ContractCompiler	signature:( map<FixedHash<4>, eth::AssemblyItem const> const& _entryPoints, vector<FixedHash<4>> const& _ids, eth::AssemblyItem const& _notFoundTag, size_t _runs )
appendInternalSelector	libsolidity/codegen/ContractCompiler.h	/^	void appendInternalSelector($/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:( std::map<FixedHash<4>, eth::AssemblyItem const> const& _entryPoints, std::vector<FixedHash<4>> const& _ids, eth::AssemblyItem const& _notFoundTag, size_t _runs )
appendInvalid	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendInvalid()$/;"	f	class:dev::solidity::CompilerContext	signature:()
appendInvalid	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendInvalid();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
appendItem	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::appendItem(AssemblyItem const& _item)$/;"	f	class:CSECodeGenerator	signature:(AssemblyItem const& _item)
appendItem	libevmasm/CommonSubexpressionEliminator.h	/^	void appendItem(AssemblyItem const& _item);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(AssemblyItem const& _item)
appendJump	libevmasm/Assembly.h	/^	AssemblyItem appendJump() { auto ret = append(newPushTag()); append(solidity::Instruction::JUMP); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
appendJump	libevmasm/Assembly.h	/^	AssemblyItem appendJump(AssemblyItem const& _tag) { auto ret = append(_tag.pushTag()); append(solidity::Instruction::JUMP); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _tag)
appendJump	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendJump(eth::AssemblyItem::JumpType _jumpType)$/;"	f	class:dev::solidity::CompilerContext	signature:(eth::AssemblyItem::JumpType _jumpType)
appendJump	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendJump(eth::AssemblyItem::JumpType _jumpType = eth::AssemblyItem::JumpType::Ordinary);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyItem::JumpType _jumpType = eth::AssemblyItem::JumpType::Ordinary)
appendJump	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJump(int _stackDiffAfter) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(int _stackDiffAfter)
appendJump	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJump(int _stackDiffAfter)$/;"	f	class:EthAssemblyAdapter	signature:(int _stackDiffAfter)
appendJump	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJump(int _stackDiffAfter)$/;"	f	class:EVMAssembly	signature:(int _stackDiffAfter)
appendJump	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJump(int _stackDiffAfter)$/;"	f	class:NoOutputAssembly	signature:(int _stackDiffAfter)
appendJumpI	libevmasm/Assembly.h	/^	AssemblyItem appendJumpI() { auto ret = append(newPushTag()); append(solidity::Instruction::JUMPI); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
appendJumpI	libevmasm/Assembly.h	/^	AssemblyItem appendJumpI(AssemblyItem const& _tag) { auto ret = append(_tag.pushTag()); append(solidity::Instruction::JUMPI); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _tag)
appendJumpTo	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendJumpTo($/;"	f	class:dev::solidity::CompilerContext	access:public	signature:( eth::AssemblyItem const& _tag, eth::AssemblyItem::JumpType _jumpType = eth::AssemblyItem::JumpType::Ordinary )
appendJumpTo	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJumpTo(LabelID _labelId, int _stackDiffAfter = 0) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId, int _stackDiffAfter = 0)
appendJumpTo	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJumpTo(LabelID _labelId, int _stackDiffAfter)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId, int _stackDiffAfter)
appendJumpTo	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJumpTo(LabelID _labelId, int _stackDiffAfter)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId, int _stackDiffAfter)
appendJumpTo	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJumpTo(LabelID _labelId, int _stackDiffAfter)$/;"	f	class:NoOutputAssembly	signature:(LabelID _labelId, int _stackDiffAfter)
appendJumpToIf	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJumpToIf(LabelID _labelId) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId)
appendJumpToIf	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJumpToIf(LabelID _labelId)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId)
appendJumpToIf	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJumpToIf(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
appendJumpToIf	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJumpToIf(LabelID _labelId)$/;"	f	class:NoOutputAssembly	signature:(LabelID _labelId)
appendJumpToNew	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem appendJumpToNew() { return m_asm->appendJump().tag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
appendJumpsub	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJumpsub(LabelID _labelId, int _arguments, int _returns) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId, int _arguments, int _returns)
appendJumpsub	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendJumpsub(LabelID, int, int)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID, int, int)
appendJumpsub	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendJumpsub(LabelID _labelId, int _arguments, int _returns)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId, int _arguments, int _returns)
appendJumpsub	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendJumpsub(LabelID, int _arguments, int _returns)$/;"	f	class:NoOutputAssembly	signature:(LabelID, int _arguments, int _returns)
appendLabel	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendLabel(LabelID _labelId) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId)
appendLabel	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendLabel(LabelID _labelId)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId)
appendLabel	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLabel(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
appendLabel	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendLabel(LabelID)$/;"	f	class:NoOutputAssembly	signature:(LabelID)
appendLabelReference	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendLabelReference(LabelID _labelId) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId)
appendLabelReference	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendLabelReference(LabelID _labelId)$/;"	f	class:EthAssemblyAdapter	signature:(LabelID _labelId)
appendLabelReference	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLabelReference(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
appendLabelReference	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendLabelReference(LabelID)$/;"	f	class:NoOutputAssembly	signature:(LabelID)
appendLabelReferenceInternal	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLabelReferenceInternal(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
appendLabelReferenceInternal	libyul/backends/evm/EVMAssembly.h	/^	void appendLabelReferenceInternal(AbstractAssembly::LabelID _labelId);$/;"	p	class:yul::EVMAssembly	access:private	signature:(AbstractAssembly::LabelID _labelId)
appendLibraryAddress	libevmasm/Assembly.h	/^	void appendLibraryAddress(std::string const& _identifier) { append(newPushLibraryAddress(_identifier)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(std::string const& _identifier)
appendLibraryAddress	libsolidity/codegen/CompilerContext.h	/^	void appendLibraryAddress(std::string const& _identifier) { m_asm->appendLibraryAddress(_identifier); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::string const& _identifier)
appendLinkerSymbol	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendLinkerSymbol(std::string const& _name) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(std::string const& _name)
appendLinkerSymbol	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendLinkerSymbol(std::string const& _linkerSymbol)$/;"	f	class:EthAssemblyAdapter	signature:(std::string const& _linkerSymbol)
appendLinkerSymbol	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendLinkerSymbol(string const&)$/;"	f	class:EVMAssembly	signature:(string const&)
appendLinkerSymbol	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendLinkerSymbol(string const&)$/;"	f	class:NoOutputAssembly	signature:(string const&)
appendMissingFunctions	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendMissingFunctions()$/;"	f	class:ContractCompiler	signature:()
appendMissingFunctions	libsolidity/codegen/ContractCompiler.h	/^	void appendMissingFunctions();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
appendMissingLowLevelFunctions	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::appendMissingLowLevelFunctions()$/;"	f	class:dev::solidity::CompilerContext	signature:()
appendMissingLowLevelFunctions	libsolidity/codegen/CompilerContext.h	/^	void appendMissingLowLevelFunctions();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
appendModifierOrFunctionCode	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendModifierOrFunctionCode()$/;"	f	class:ContractCompiler	signature:()
appendModifierOrFunctionCode	libsolidity/codegen/ContractCompiler.h	/^	void appendModifierOrFunctionCode();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
appendMove	libsolidity/ast/ASTJsonConverter.h	/^	static void appendMove(Json::Value& _array, Json::Value&& _value)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(Json::Value& _array, Json::Value&& _value)
appendOrRemoveSwap	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::appendOrRemoveSwap(int _fromPosition, SourceLocation const& _location)$/;"	f	class:CSECodeGenerator	signature:(int _fromPosition, SourceLocation const& _location)
appendOrRemoveSwap	libevmasm/CommonSubexpressionEliminator.h	/^	void appendOrRemoveSwap(int _fromPosition, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(int _fromPosition, langutil::SourceLocation const& _location)
appendOrdinaryBinaryOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendOrdinaryBinaryOperatorCode(Token _operator, Type const& _type)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _type)
appendOrdinaryBinaryOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendOrdinaryBinaryOperatorCode(Token _operator, Type const& _type);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _type)
appendProgramSize	libevmasm/Assembly.h	/^	void appendProgramSize() { append(AssemblyItem(PushProgramSize)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
appendProgramSize	libsolidity/codegen/CompilerContext.h	/^	void appendProgramSize() { m_asm->appendProgramSize(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
appendReturnValuePacker	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary)$/;"	f	class:ContractCompiler	signature:(TypePointers const& _typeParameters, bool _isLibrary)
appendReturnValuePacker	libsolidity/codegen/ContractCompiler.h	/^	void appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(TypePointers const& _typeParameters, bool _isLibrary)
appendReturnsub	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendReturnsub(int _returns, int _stackDiffAfter = 0) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(int _returns, int _stackDiffAfter = 0)
appendReturnsub	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::appendReturnsub(int, int)$/;"	f	class:EthAssemblyAdapter	signature:(int, int)
appendReturnsub	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::appendReturnsub(int _returns, int _stackDiffAfter)$/;"	f	class:EVMAssembly	signature:(int _returns, int _stackDiffAfter)
appendReturnsub	libyul/backends/evm/NoOutputAssembly.cpp	/^void NoOutputAssembly::appendReturnsub(int _returns, int _stackDiffAfter)$/;"	f	class:NoOutputAssembly	signature:(int _returns, int _stackDiffAfter)
appendRevert	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendRevert()$/;"	f	class:dev::solidity::CompilerContext	signature:()
appendRevert	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendRevert();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
appendShiftOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendShiftOperatorCode(Token _operator, Type const& _valueType, Type const& _shiftAmountType)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _valueType, Type const& _shiftAmountType)
appendShiftOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendShiftOperatorCode(Token _operator, Type const& _valueType, Type const& _shiftAmountType);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _valueType, Type const& _shiftAmountType)
appendStackVariableInitialisation	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::appendStackVariableInitialisation(VariableDeclaration const& _variable)$/;"	f	class:ContractCompiler	signature:(VariableDeclaration const& _variable)
appendStackVariableInitialisation	libsolidity/codegen/ContractCompiler.h	/^	void appendStackVariableInitialisation(VariableDeclaration const& _variable);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(VariableDeclaration const& _variable)
appendStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _varDecl)
appendStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.h	/^	void appendStateVariableAccessor(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(VariableDeclaration const& _varDecl)
appendStateVariableInitialization	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendStateVariableInitialization(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _varDecl)
appendStateVariableInitialization	libsolidity/codegen/ExpressionCompiler.h	/^	void appendStateVariableInitialization(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(VariableDeclaration const& _varDecl)
appendSubroutine	libevmasm/Assembly.h	/^	AssemblyItem appendSubroutine(AssemblyPointer const& _assembly) { auto sub = newSub(_assembly); append(newPushSubSize(size_t(sub.data()))); return sub; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyPointer const& _assembly)
appendTypeName	libyul/AsmPrinter.cpp	/^string AsmPrinter::appendTypeName(YulString _type) const$/;"	f	class:AsmPrinter	signature:(YulString _type) const
appendTypeName	libyul/AsmPrinter.h	/^	std::string appendTypeName(YulString _type) const;$/;"	p	class:yul::AsmPrinter	access:private	signature:(YulString _type) const
appendVariable	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendVariable(VariableDeclaration const& _variable, Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _variable, Expression const& _expression)
appendVariable	libsolidity/codegen/ExpressionCompiler.h	/^	void appendVariable(VariableDeclaration const& _variable, Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(VariableDeclaration const& _variable, Expression const& _expression)
apply	libevmasm/PeepholeOptimiser.cpp	/^	static bool apply(OptimiserState& _state)$/;"	f	struct:__anon19::SimplePeepholeOptimizerMethod	access:public	signature:(OptimiserState& _state)
apply	libevmasm/PeepholeOptimiser.cpp	/^	static bool apply(OptimiserState& _state)$/;"	f	struct:__anon19::UnreachableCode	access:public	signature:(OptimiserState& _state)
apply	libevmasm/PeepholeOptimiser.h	/^	virtual bool apply(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out);$/;"	p	class:dev::eth::PeepholeOptimisationMethod	access:public	signature:(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out)
applyKeccak256	libevmasm/KnownState.cpp	/^KnownState::Id KnownState::applyKeccak256($/;"	f	class:KnownState	signature:( Id _start, Id _length, SourceLocation const& _location )
applyKeccak256	libevmasm/KnownState.h	/^	Id applyKeccak256(Id _start, Id _length, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _start, Id _length, langutil::SourceLocation const& _location)
applyMethods	libevmasm/PeepholeOptimiser.cpp	/^void applyMethods(OptimiserState& _state, Method, OtherMethods... _other)$/;"	f	namespace:__anon19	signature:(OptimiserState& _state, Method, OtherMethods... _other)
applyMethods	libevmasm/PeepholeOptimiser.cpp	/^void applyMethods(OptimiserState&)$/;"	f	namespace:__anon19	signature:(OptimiserState&)
applyRemapping	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::applyRemapping(string const& _path, string const& _context)$/;"	f	class:CompilerStack	signature:(string const& _path, string const& _context)
applyRemapping	libsolidity/interface/CompilerStack.h	/^	std::string applyRemapping(std::string const& _path, std::string const& _context);$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _path, std::string const& _context)
applyRule	libevmasm/PeepholeOptimiser.cpp	/^	static bool applyRule(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::ApplyRule	access:public	signature:(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out)
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple($/;"	f	struct:__anon19::OpPop	access:public	signature:( AssemblyItem const& _op, AssemblyItem const& _pop, std::back_insert_iterator<AssemblyItems> _out )
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple($/;"	f	struct:__anon19::TagConjunctions	access:public	signature:( AssemblyItem const& _pushTag, AssemblyItem const& _pushConstant, AssemblyItem const& _and, std::back_insert_iterator<AssemblyItems> _out )
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple($/;"	f	struct:__anon19::TruthyAnd	access:public	signature:( AssemblyItem const& _push, AssemblyItem const& _not, AssemblyItem const& _and, std::back_insert_iterator<AssemblyItems> )
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _item, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::Identity	access:public	signature:(AssemblyItem const& _item, std::back_insert_iterator<AssemblyItems> _out)
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _push, AssemblyItem const& _pop, std::back_insert_iterator<AssemblyItems>)$/;"	f	struct:__anon19::PushPop	access:public	signature:(AssemblyItem const& _push, AssemblyItem const& _pop, std::back_insert_iterator<AssemblyItems>)
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _push1, AssemblyItem const& _push2, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::DoublePush	access:public	signature:(AssemblyItem const& _push1, AssemblyItem const& _push2, std::back_insert_iterator<AssemblyItems> _out)
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::CommutativeSwap	access:public	signature:(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static bool applySimple(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)$/;"	f	struct:__anon19::SwapComparison	access:public	signature:(AssemblyItem const& _swap, AssemblyItem const& _op, std::back_insert_iterator<AssemblyItems> _out)
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static size_t applySimple($/;"	f	struct:__anon19::JumpToNext	access:public	signature:( AssemblyItem const& _pushTag, AssemblyItem const& _jump, AssemblyItem const& _tag, std::back_insert_iterator<AssemblyItems> _out )
applySimple	libevmasm/PeepholeOptimiser.cpp	/^	static size_t applySimple(AssemblyItem const& _s1, AssemblyItem const& _s2, std::back_insert_iterator<AssemblyItems>)$/;"	f	struct:__anon19::DoubleSwap	access:public	signature:(AssemblyItem const& _s1, AssemblyItem const& _s2, std::back_insert_iterator<AssemblyItems>)
applyTagReplacement	libevmasm/BlockDeduplicator.cpp	/^bool BlockDeduplicator::applyTagReplacement($/;"	f	class:BlockDeduplicator	signature:( AssemblyItems& _items, map<u256, u256> const& _replacements, size_t _subId )
applyTagReplacement	libevmasm/BlockDeduplicator.h	/^	static bool applyTagReplacement($/;"	p	class:dev::eth::BlockDeduplicator	access:public	signature:( AssemblyItems& _items, std::map<u256, u256> const& _replacements, size_t _subID = size_t(-1) )
args	libevmasm/Instruction.h	/^	int args;			\/\/\/< Number of items required on the stack for this instruction (and, for the purposes of ret, the number taken from the stack).$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
argumentTypes	libsolidity/ast/ASTAnnotations.h	/^	std::shared_ptr<std::vector<TypePointer>> argumentTypes;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
arguments	libevmasm/AssemblyItem.cpp	/^int AssemblyItem::arguments() const$/;"	f	class:AssemblyItem	signature:() const
arguments	libevmasm/AssemblyItem.h	/^	int arguments() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
arguments	libevmasm/ExpressionClasses.h	/^		Ids arguments;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
arguments	libevmasm/SimplificationRules.h	/^	std::vector<ExpressionTemplate> arguments;$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
arguments	libevmasm/SimplificationRules.h	/^	std::vector<Pattern> arguments() const { return m_arguments; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression const>> arguments() const { return {m_arguments.begin(), m_arguments.end()}; }$/;"	f	class:dev::solidity::FunctionCall	access:public	signature:() const
arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> const* arguments() const { return m_arguments.get(); }$/;"	f	class:dev::solidity::InheritanceSpecifier::std	access:public	signature:() const
arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> const* arguments() const { return m_arguments.get(); }$/;"	f	class:dev::solidity::ModifierInvocation::std	access:public	signature:() const
arguments	libsolidity/formal/SolverInterface.h	/^	std::vector<Expression> arguments;$/;"	m	class:dev::solidity::smt::Expression	access:public
arguments	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionCall	access:public
arguments	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionalInstruction	access:public
arguments	libyul/AsmScope.h	/^		std::vector<YulType> arguments;$/;"	m	struct:yul::Scope::Function	access:public
arguments	libyul/optimiser/SimplificationRules.h	/^	std::vector<Pattern> arguments() const { return m_arguments; }$/;"	f	class:yul::Pattern	access:public	signature:() const
arithmeticOperation	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::arithmeticOperation(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
arithmeticOperation	libsolidity/formal/SMTChecker.h	/^	void arithmeticOperation(BinaryOperation const& _op);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(BinaryOperation const& _op)
arrayAllocationSizeFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayAllocationSizeFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
arrayAllocationSizeFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayAllocationSizeFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
arrayAssignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::arrayAssignment()$/;"	f	class:SMTChecker	signature:()
arrayAssignment	libsolidity/formal/SMTChecker.h	/^	void arrayAssignment();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
arrayDataAreaFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayDataAreaFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
arrayDataAreaFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayDataAreaFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
arrayIndexAssignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::arrayIndexAssignment(Assignment const& _assignment)$/;"	f	class:SMTChecker	signature:(Assignment const& _assignment)
arrayIndexAssignment	libsolidity/formal/SMTChecker.h	/^	void arrayIndexAssignment(Assignment const& _assignment);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Assignment const& _assignment)
arrayLengthFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayLengthFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
arrayLengthFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayLengthFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
arrayStoreLengthForEncodingFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::arrayStoreLengthForEncodingFunction(ArrayType const& _type, EncodingOptions const& _options)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type, EncodingOptions const& _options)
arrayStoreLengthForEncodingFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayStoreLengthForEncodingFunction(ArrayType const& _type, EncodingOptions const& _options);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type, EncodingOptions const& _options)
arrayUpdateZ3Test	solse/main.cpp	/^void arrayUpdateZ3Test();$/;"	p	file:	signature:()
arrayUpdateZ3Test	solse/main.cpp	/^void arrayUpdateZ3Test(){$/;"	f	signature:()
arrayUpdateZ3Test2	solse/main.cpp	/^void arrayUpdateZ3Test2();$/;"	p	file:	signature:()
arrayUpdateZ3Test2	solse/main.cpp	/^void arrayUpdateZ3Test2(){$/;"	f	signature:()
arrayZ3Test	solse/main.cpp	/^void arrayZ3Test() {$/;"	f	signature:()
arrayZ3Test	solse/main.cpp	/^void arrayZ3Test();$/;"	p	file:	signature:()
arrayZ3Test2	solse/main.cpp	/^void arrayZ3Test2();$/;"	p	file:	signature:()
arrayZ3Test2	solse/main.cpp	/^void arrayZ3Test2(){$/;"	f	signature:()
arrayZ3Test3	solse/main.cpp	/^void arrayZ3Test3() {$/;"	f	signature:()
arrayZ3Test3	solse/main.cpp	/^void arrayZ3Test3();$/;"	p	file:	signature:()
asArray	libdevcore/FixedHash.h	/^	std::array<uint8_t, N> const& asArray() const { return m_data; }$/;"	f	class:dev::FixedHash::std	access:public	signature:() const
asArray	libdevcore/FixedHash.h	/^	std::array<uint8_t, N>& asArray() { return m_data; }$/;"	f	class:dev::FixedHash	access:public	signature:()
asBytes	libdevcore/CommonData.h	/^inline bytes asBytes(std::string const& _b)$/;"	f	namespace:dev	signature:(std::string const& _b)
asBytes	libdevcore/FixedHash.h	/^	bytes asBytes() const { return bytes(data(), data() + N); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
asCallableFunction	libsolidity/ast/Types.cpp	/^FunctionTypePointer FunctionType::asCallableFunction(bool _inLibrary, bool _bound) const$/;"	f	class:FunctionType	signature:(bool _inLibrary, bool _bound) const
asCallableFunction	libsolidity/ast/Types.h	/^	FunctionTypePointer asCallableFunction(bool _inLibrary, bool _bound = false) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(bool _inLibrary, bool _bound = false) const
asIntegerType	libsolidity/ast/Types.cpp	/^std::shared_ptr<IntegerType> FixedPointType::asIntegerType() const$/;"	f	class:FixedPointType	signature:() const
asIntegerType	libsolidity/ast/Types.h	/^	std::shared_ptr<IntegerType> asIntegerType() const;$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:() const
asString	libdevcore/CommonData.h	/^inline std::string asString(bytes const& _b)$/;"	f	namespace:dev	signature:(bytes const& _b)
asString	libdevcore/CommonData.h	/^inline std::string asString(bytesConstRef _b)$/;"	f	namespace:dev	signature:(bytesConstRef _b)
assemble	libevmasm/Assembly.cpp	/^LinkerObject const& Assembly::assemble() const$/;"	f	class:Assembly	signature:() const
assemble	libevmasm/Assembly.h	/^	LinkerObject const& assemble() const;$/;"	p	class:dev::eth::Assembly	access:public	signature:() const
assemble	libyul/AssemblyStack.cpp	/^MachineAssemblyObject AssemblyStack::assemble(Machine _machine, bool _optimize) const$/;"	f	class:AssemblyStack	signature:(Machine _machine, bool _optimize) const
assemble	libyul/AssemblyStack.h	/^	MachineAssemblyObject assemble(Machine _machine, bool _optimize = false) const;$/;"	p	class:yul::AssemblyStack	access:public	signature:(Machine _machine, bool _optimize = false) const
assemble	libyul/backends/evm/AsmCodeGen.cpp	/^void CodeGenerator::assemble($/;"	f	class:CodeGenerator	signature:( Block const& _parsedData, AsmAnalysisInfo& _analysisInfo, eth::Assembly& _assembly, langutil::EVMVersion _evmVersion, ExternalIdentifierAccess const& _identifierAccess, bool _useNamedLabelsForFunctions, bool _optimize )
assemble	libyul/backends/evm/AsmCodeGen.h	/^	static void assemble($/;"	p	class:yul::CodeGenerator	access:public	signature:( Block const& _parsedData, AsmAnalysisInfo& _analysisInfo, dev::eth::Assembly& _assembly, langutil::EVMVersion _evmVersion, ExternalIdentifierAccess const& _identifierAccess = ExternalIdentifierAccess(), bool _useNamedLabelsForFunctions = false, bool _optimize = false )
assemble	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::assemble($/;"	f	class:dev::solidity::CommandLineInterface	signature:( yul::AssemblyStack::Language _language, yul::AssemblyStack::Machine _targetMachine, bool _optimize )
assemble	solse/CommandLineInterface.h	/^	bool assemble(yul::AssemblyStack::Language _language, yul::AssemblyStack::Machine _targetMachine, bool _optimize);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(yul::AssemblyStack::Language _language, yul::AssemblyStack::Machine _targetMachine, bool _optimize)
assembledObject	libsolidity/codegen/Compiler.h	/^	eth::LinkerObject assembledObject() const { return m_context.assembledObject(); }$/;"	f	class:dev::solidity::Compiler	access:public	signature:() const
assembledObject	libsolidity/codegen/CompilerContext.h	/^	eth::LinkerObject const& assembledObject() const { return m_asm->assemble(); }$/;"	f	class:dev::solidity::CompilerContext::eth	access:public	signature:() const
assembledRuntimeObject	libsolidity/codegen/CompilerContext.h	/^	eth::LinkerObject const& assembledRuntimeObject(size_t _subIndex) const { return m_asm->sub(_subIndex).assemble(); }$/;"	f	class:dev::solidity::CompilerContext::eth	access:public	signature:(size_t _subIndex) const
assembly	libsolidity/codegen/Compiler.h	/^	eth::Assembly const& assembly() const { return m_context.assembly(); }$/;"	f	class:dev::solidity::Compiler::eth	access:public	signature:() const
assembly	libsolidity/codegen/CompilerContext.h	/^	eth::Assembly const& assembly() const { return *m_asm; }$/;"	f	class:dev::solidity::CompilerContext::eth	access:public	signature:() const
assembly	libyul/AssemblyStack.h	/^	std::string assembly;$/;"	m	struct:yul::MachineAssemblyObject	access:public
assemblyItems	libsolidity/codegen/Compiler.h	/^	eth::AssemblyItems const& assemblyItems() const { return m_context.assembly().items(); }$/;"	f	class:dev::solidity::Compiler::eth	access:public	signature:() const
assemblyItems	libsolidity/interface/CompilerStack.cpp	/^eth::AssemblyItems const* CompilerStack::assemblyItems(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
assemblyItems	libsolidity/interface/CompilerStack.h	/^	eth::AssemblyItems const* assemblyItems(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
assemblyJSON	libevmasm/Assembly.cpp	/^Json::Value Assembly::assemblyJSON(StringMap const& _sourceCodes) const$/;"	f	class:Assembly	signature:(StringMap const& _sourceCodes) const
assemblyJSON	libevmasm/Assembly.h	/^	Json::Value assemblyJSON($/;"	p	class:dev::eth::Assembly	access:public	signature:( StringMap const& _sourceCodes = StringMap() ) const
assemblyJSON	libsolidity/codegen/Compiler.h	/^	Json::Value assemblyJSON(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::Compiler	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
assemblyJSON	libsolidity/codegen/CompilerContext.h	/^	Json::Value assemblyJSON(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
assemblyJSON	libsolidity/interface/CompilerStack.cpp	/^Json::Value CompilerStack::assemblyJSON(string const& _contractName, StringMap _sourceCodes) const$/;"	f	class:CompilerStack	signature:(string const& _contractName, StringMap _sourceCodes) const
assemblyJSON	libsolidity/interface/CompilerStack.h	/^	Json::Value assemblyJSON(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const
assemblyPtr	libsolidity/codegen/Compiler.h	/^	std::shared_ptr<eth::Assembly> assemblyPtr() const { return m_context.assemblyPtr(); }$/;"	f	class:dev::solidity::Compiler	access:public	signature:() const
assemblyPtr	libsolidity/codegen/CompilerContext.h	/^	std::shared_ptr<eth::Assembly> assemblyPtr() const { return m_asm; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
assemblySeen	libsolidity/analysis/StaticAnalyzer.cpp	/^		bool assemblySeen = false;$/;"	m	class:dev::solidity::ConstructorUsesAssembly::Checker	file:	access:public
assemblySizeReferenceSize	libyul/backends/evm/EVMAssembly.cpp	/^size_t constexpr assemblySizeReferenceSize = 4;$/;"	m	namespace:__anon4	file:
assemblyStream	libevmasm/Assembly.cpp	/^void Assembly::assemblyStream(ostream& _out, string const& _prefix, StringMap const& _sourceCodes) const$/;"	f	class:Assembly	signature:(ostream& _out, string const& _prefix, StringMap const& _sourceCodes) const
assemblyStream	libevmasm/Assembly.h	/^	void assemblyStream($/;"	p	class:dev::eth::Assembly	access:public	signature:( std::ostream& _out, std::string const& _prefix = , StringMap const& _sourceCodes = StringMap() ) const
assemblyString	libevmasm/Assembly.cpp	/^string Assembly::assemblyString(StringMap const& _sourceCodes) const$/;"	f	class:Assembly	signature:(StringMap const& _sourceCodes) const
assemblyString	libevmasm/Assembly.h	/^	std::string assemblyString($/;"	p	class:dev::eth::Assembly	access:public	signature:( StringMap const& _sourceCodes = StringMap() ) const
assemblyString	libsolidity/codegen/Compiler.h	/^	std::string assemblyString(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::Compiler	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
assemblyString	libsolidity/codegen/CompilerContext.h	/^	std::string assemblyString(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
assemblyString	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::assemblyString(string const& _contractName, StringMap _sourceCodes) const$/;"	f	class:CompilerStack	signature:(string const& _contractName, StringMap _sourceCodes) const
assemblyString	libsolidity/interface/CompilerStack.h	/^	std::string assemblyString(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const
assemblyTagToIdentifier	libyul/backends/evm/AsmCodeGen.cpp	/^EthAssemblyAdapter::LabelID EthAssemblyAdapter::assemblyTagToIdentifier(eth::AssemblyItem const& _tag)$/;"	f	class:EthAssemblyAdapter	signature:(eth::AssemblyItem const& _tag)
assemblyTagToIdentifier	libyul/backends/evm/AsmCodeGen.h	/^	static LabelID assemblyTagToIdentifier(dev::eth::AssemblyItem const& _tag);$/;"	p	class:yul::EthAssemblyAdapter	access:private	signature:(dev::eth::AssemblyItem const& _tag)
assertDetails	liblangutil/Token.cpp	/^void ElementaryTypeNameToken::assertDetails(Token _baseType, unsigned const& _first, unsigned const& _second)$/;"	f	class:langutil::ElementaryTypeNameToken	signature:(Token _baseType, unsigned const& _first, unsigned const& _second)
assertDetails	liblangutil/Token.h	/^	void assertDetails(Token _baseType, unsigned const& _first, unsigned const& _second);$/;"	p	class:langutil::ElementaryTypeNameToken	access:private	signature:(Token _baseType, unsigned const& _first, unsigned const& _second)
assertThrow	libdevcore/Assertions.h	43;"	d
assignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::assignment(VariableDeclaration const& _variable, Expression const& _value, SourceLocation const& _location)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _variable, Expression const& _value, SourceLocation const& _location)
assignment	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::assignment(VariableDeclaration const& _variable, smt::Expression const& _value, SourceLocation const& _location)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _variable, smt::Expression const& _value, SourceLocation const& _location)
assignment	libsolidity/formal/SMTChecker.h	/^	void assignment(VariableDeclaration const& _variable, Expression const& _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _variable, Expression const& _value, langutil::SourceLocation const& _location)
assignment	libsolidity/formal/SMTChecker.h	/^	void assignment(VariableDeclaration const& _variable, smt::Expression const& _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _variable, smt::Expression const& _value, langutil::SourceLocation const& _location)
assignmentCount	libyul/optimiser/Metrics.cpp	/^size_t AssignmentCounter::assignmentCount(YulString _name) const$/;"	f	class:AssignmentCounter	signature:(YulString _name) const
assignmentCount	libyul/optimiser/Metrics.h	/^	std::size_t assignmentCount(YulString _name) const;$/;"	p	class:yul::AssignmentCounter	access:public	signature:(YulString _name) const
assignmentOperator	libsolidity/ast/AST.h	/^	Token assignmentOperator() const { return m_assigmentOperator; }$/;"	f	class:dev::solidity::Assignment	access:public	signature:() const
assignmentZ3Test	solse/main.cpp	/^void assignmentZ3Test();$/;"	p	file:	signature:()
assignmentZ3Test	solse/main.cpp	/^void assignmentZ3Test(){$/;"	f	signature:()
assumptions	solse/mechanism.h	/^		std::vector<z3::expr> assumptions; $/;"	m	class:Mechanism	access:public
ast	libsolidity/interface/CompilerStack.cpp	/^SourceUnit const& CompilerStack::ast(string const& _sourceName) const$/;"	f	class:CompilerStack	signature:(string const& _sourceName) const
ast	libsolidity/interface/CompilerStack.h	/^		std::shared_ptr<SourceUnit> ast;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
ast	libsolidity/interface/CompilerStack.h	/^	SourceUnit const& ast(std::string const& _sourceName) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _sourceName) const
astNodeVisitMap	solse/SymExecEngine.h	/^    std::unordered_map<size_t, int> astNodeVisitMap;$/;"	m	class:SymExecEngine	access:private
back	libevmasm/Assembly.h	/^	AssemblyItem const& back() const { return m_items.back(); }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
backString	libevmasm/Assembly.h	/^	std::string backString() const { return m_items.size() && m_items.back().type() == PushString ? m_strings.at((h256)m_items.back().data()) : std::string(); }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
balanceGas	libevmasm/GasMeter.h	/^	inline unsigned balanceGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
baseConstructorArguments	libsolidity/ast/ASTAnnotations.h	/^	std::map<FunctionDefinition const*, ASTNode const*> baseConstructorArguments;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
baseContracts	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<InheritanceSpecifier>> const& baseContracts() const { return m_baseContracts; }$/;"	f	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
baseExpression	libsolidity/ast/AST.h	/^	Expression const& baseExpression() const { return *m_base; }$/;"	f	class:dev::solidity::IndexAccess	access:public	signature:() const
baseStackOffsetOfVariable	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::baseStackOffsetOfVariable(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration) const
baseStackOffsetOfVariable	libsolidity/codegen/CompilerContext.h	/^	unsigned baseStackOffsetOfVariable(Declaration const& _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration) const
baseToCurrentStackOffset	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::baseToCurrentStackOffset(unsigned _baseOffset) const$/;"	f	class:dev::solidity::CompilerContext	signature:(unsigned _baseOffset) const
baseToCurrentStackOffset	libsolidity/codegen/CompilerContext.h	/^	unsigned baseToCurrentStackOffset(unsigned _baseOffset) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(unsigned _baseOffset) const
baseType	libsolidity/ast/AST.h	/^	TypeName const& baseType() const { return *m_baseType; }$/;"	f	class:dev::solidity::ArrayTypeName	access:public	signature:() const
baseType	libsolidity/ast/Types.h	/^	TypePointer const& baseType() const { solAssert(!!m_baseType, ""); return m_baseType;}$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
begin	libdevcore/vector_ref.h	/^	_T const* begin() const { return m_data; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
begin	libdevcore/vector_ref.h	/^	_T* begin() { return m_data; }$/;"	f	class:dev::vector_ref	access:public	signature:()
begin	libevmasm/ControlFlowGraph.h	/^	unsigned begin = 0;$/;"	m	struct:dev::eth::BasicBlock	access:public
begin	libsolidity/ast/Types.h	/^	MemberMap::const_iterator begin() const { return m_memberTypes.begin(); }$/;"	f	class:dev::solidity::MemberList	access:public	signature:() const
bidders	solse/mechanism.h	/^		std::vector<std::vector<z3::expr> > bidders;$/;"	m	class:Mechanism	access:public
bigintShiftLeftWorkaround	libdevcore/CommonData.h	/^template <class S> S bigintShiftLeftWorkaround(S const& _a, unsigned _b)$/;"	f	namespace:dev	signature:(S const& _a, unsigned _b)
bigintToReadableString	libsolidity/ast/Types.cpp	/^string RationalNumberType::bigintToReadableString(dev::bigint const& _num)$/;"	f	class:RationalNumberType	signature:(dev::bigint const& _num)
bigintToReadableString	libsolidity/ast/Types.h	/^	static std::string bigintToReadableString(dev::bigint const& num);$/;"	p	class:dev::solidity::RationalNumberType	access:private	signature:(dev::bigint const& num)
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult AddressType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:AddressType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult BoolType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:BoolType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedBytesType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:FixedBytesType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedPointType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:FixedPointType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FunctionType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:FunctionType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult IntegerType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:IntegerType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult RationalNumberType::binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:RationalNumberType	signature:(Token _operator, TypePointer const& _other) const
binaryOperatorResult	libsolidity/ast/Types.h	/^	virtual TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:dev::solidity::Type	access:public	signature:(Token _operator, TypePointer const& _other) const
binaryVersion	libsolidity/interface/Version.cpp	/^bytes dev::solidity::binaryVersion()$/;"	f	class:dev::solidity	signature:()
binaryVersion	libsolidity/interface/Version.h	/^bytes binaryVersion();$/;"	p	namespace:dev::solidity	signature:()
body	libsolidity/ast/AST.h	/^	Block const& body() const { return *m_body; }$/;"	f	class:dev::solidity::ModifierDefinition	access:public	signature:() const
body	libsolidity/ast/AST.h	/^	Block const& body() const { solAssert(m_body, ""); return *m_body; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
body	libsolidity/ast/AST.h	/^	Statement const& body() const { return *m_body; }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
body	libsolidity/ast/AST.h	/^	Statement const& body() const { return *m_body; }$/;"	f	class:dev::solidity::WhileStatement	access:public	signature:() const
body	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	m	struct:yul::Case	access:public
body	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
body	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
body	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	m	struct:yul::If	access:public
booleanOperation	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::booleanOperation(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
booleanOperation	libsolidity/formal/SMTChecker.h	/^	void booleanOperation(BinaryOperation const& _op);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(BinaryOperation const& _op)
bound	libsolidity/ast/Types.h	/^	bool bound() const { return m_bound; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
boundFunctions	libsolidity/ast/Types.cpp	/^MemberList::MemberMap Type::boundFunctions(Type const& _type, ContractDefinition const& _scope)$/;"	f	class:Type	signature:(Type const& _type, ContractDefinition const& _scope)
boundFunctions	libsolidity/ast/Types.h	/^	static MemberList::MemberMap boundFunctions(Type const& _type, ContractDefinition const& _scope);$/;"	p	class:dev::solidity::Type	access:private	signature:(Type const& _type, ContractDefinition const& _scope)
breakToStatementLevel	libsolidity/interface/GasEstimator.cpp	/^map<ASTNode const*, GasMeter::GasConsumption> GasEstimator::breakToStatementLevel($/;"	f	class:GasEstimator	signature:( ASTGasConsumptionSelfAccumulated const& _gasCosts, vector<ASTNode const*> const& _roots )
breakToStatementLevel	libsolidity/interface/GasEstimator.h	/^	static ASTGasConsumption breakToStatementLevel($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( ASTGasConsumptionSelfAccumulated const& _gasCosts, std::vector<ASTNode const*> const& _roots )
breaksCSEAnalysisBlock	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::breaksCSEAnalysisBlock(AssemblyItem const& _item, bool _msizeImportant)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item, bool _msizeImportant)
breaksCSEAnalysisBlock	libevmasm/SemanticInformation.h	/^	static bool breaksCSEAnalysisBlock(AssemblyItem const& _item, bool _msizeImportant);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item, bool _msizeImportant)
build	libsolidity/analysis/SemVerHandler.h	/^	std::string build;$/;"	m	struct:dev::solidity::SemVerVersion	access:public
builtin	libyul/Dialect.h	/^	virtual BuiltinFunction const* builtin(YulString \/*_name*\/) const { return nullptr; }$/;"	f	struct:yul::Dialect	access:public	signature:(YulString ) const
builtin	libyul/backends/evm/EVMDialect.cpp	/^BuiltinFunctionForEVM const* EVMDialect::builtin(YulString _name) const$/;"	f	class:EVMDialect	signature:(YulString _name) const
bytecode	libevmasm/LinkerObject.h	/^	bytes bytecode;$/;"	m	struct:dev::eth::LinkerObject	access:public
bytecode	libyul/AssemblyStack.h	/^	std::shared_ptr<dev::eth::LinkerObject> bytecode;$/;"	m	struct:yul::MachineAssemblyObject	access:public
bytesMemory	libsolidity/ast/Types.h	/^	static ArrayType& bytesMemory() { static std::shared_ptr<ArrayType> addr(std::make_shared<ArrayType>(DataLocation::Memory)); return *addr; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:()
bytesRequired	libdevcore/CommonData.h	/^inline unsigned bytesRequired(T _i)$/;"	f	namespace:dev	signature:(T _i)
bytesRequired	libevmasm/Assembly.cpp	/^unsigned Assembly::bytesRequired(unsigned subTagSize) const$/;"	f	class:Assembly	signature:(unsigned subTagSize) const
bytesRequired	libevmasm/Assembly.h	/^	unsigned bytesRequired(unsigned subTagSize) const;$/;"	p	class:dev::eth::Assembly	access:protected	signature:(unsigned subTagSize) const
bytesRequired	libevmasm/AssemblyItem.cpp	/^unsigned AssemblyItem::bytesRequired(unsigned _addressLength) const$/;"	f	class:AssemblyItem	signature:(unsigned _addressLength) const
bytesRequired	libevmasm/AssemblyItem.h	/^	unsigned bytesRequired(unsigned _addressLength) const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(unsigned _addressLength) const
bytesRequired	libevmasm/AssemblyItem.h	/^inline size_t bytesRequired(AssemblyItems const& _items, size_t _addressLength)$/;"	f	namespace:dev::eth	signature:(AssemblyItems const& _items, size_t _addressLength)
bytesRequired	libevmasm/ConstantOptimiser.cpp	/^size_t ConstantOptimisationMethod::bytesRequired(AssemblyItems const& _items)$/;"	f	class:ConstantOptimisationMethod	signature:(AssemblyItems const& _items)
bytesRequired	libevmasm/ConstantOptimiser.h	/^	static size_t bytesRequired(AssemblyItems const& _items);$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(AssemblyItems const& _items)
byzantium	liblangutil/EVMVersion.h	/^	static EVMVersion byzantium() { return {Version::Byzantium}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
cThreeMerge	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<_T const*> NameAndTypeResolver::cThreeMerge(list<list<_T const*>>& _toMerge)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(list<list<_T const*>>& _toMerge)
cThreeMerge	libsolidity/analysis/NameAndTypeResolver.h	/^	static std::vector<_T const*> cThreeMerge(std::list<std::list<_T const*>>& _toMerge);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(std::list<std::list<_T const*>>& _toMerge)
c_instructionInfo	libevmasm/Instruction.cpp	/^static std::map<Instruction, InstructionInfo> const c_instructionInfo =$/;"	m	class:std	file:
c_instructions	libevmasm/Instruction.cpp	/^std::map<std::string, Instruction> const dev::solidity::c_instructions =$/;"	m	class:std::dev::solidity	file:
c_invalidPosition	libevmasm/CommonSubexpressionEliminator.h	/^	static int const c_invalidPosition = -0x7fffffff;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
c_maxErrorsAllowed	liblangutil/ErrorReporter.h	/^	unsigned const c_maxErrorsAllowed = 256;$/;"	m	class:langutil::ErrorReporter	access:private
c_maxWarningsAllowed	liblangutil/ErrorReporter.h	/^	unsigned const c_maxWarningsAllowed = 256;$/;"	m	class:langutil::ErrorReporter	access:private
callGas	libevmasm/GasMeter.h	/^	inline unsigned callGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
callLowLevelFunction	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::callLowLevelFunction($/;"	f	class:dev::solidity::CompilerContext	signature:( string const& _name, unsigned _inArgs, unsigned _outArgs, function<void(CompilerContext&)> const& _generator )
callLowLevelFunction	libsolidity/codegen/CompilerContext.h	/^	void callLowLevelFunction($/;"	p	class:dev::solidity::CompilerContext	access:public	signature:( std::string const& _name, unsigned _inArgs, unsigned _outArgs, std::function<void(CompilerContext&)> const& _generator )
callNewAccountGas	libevmasm/GasMeter.h	/^	static unsigned const callNewAccountGas = 25000;$/;"	m	namespace:dev::eth::GasCosts
callStipend	libevmasm/GasMeter.h	/^	static unsigned const callStipend = 2300;$/;"	m	namespace:dev::eth::GasCosts
callValueTransferGas	libevmasm/GasMeter.h	/^	static unsigned const callValueTransferGas = 9000;$/;"	m	namespace:dev::eth::GasCosts
calldataEncodedSize	libsolidity/ast/Types.cpp	/^unsigned ArrayType::calldataEncodedSize(bool _padded) const$/;"	f	class:ArrayType	signature:(bool _padded) const
calldataEncodedSize	libsolidity/ast/Types.cpp	/^unsigned FunctionType::calldataEncodedSize(bool _padded) const$/;"	f	class:FunctionType	signature:(bool _padded) const
calldataEncodedSize	libsolidity/ast/Types.cpp	/^unsigned StructType::calldataEncodedSize(bool) const$/;"	f	class:StructType	signature:(bool) const
calldataEncodedSize	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize() const { return calldataEncodedSize(true); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
calldataEncodedSize	libsolidity/ast/Types.h	/^	virtual unsigned calldataEncodedSize(bool _padded) const { (void)_padded; return 0; }$/;"	f	class:dev::solidity::Type	access:public	signature:(bool _padded) const
calldataOffsetOfMember	libsolidity/ast/Types.cpp	/^unsigned StructType::calldataOffsetOfMember(std::string const& _member) const$/;"	f	class:StructType	signature:(std::string const& _member) const
calldataOffsetOfMember	libsolidity/ast/Types.h	/^	unsigned calldataOffsetOfMember(std::string const& _name) const;$/;"	p	class:dev::solidity::StructType	access:public	signature:(std::string const& _name) const
calldataStride	libsolidity/ast/Types.h	/^	unsigned calldataStride() const { return isByteArray() ? 1 : m_baseType->calldataEncodedSize(); }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
canBeDeployed	libsolidity/ast/AST.cpp	/^bool ContractDefinition::canBeDeployed() const$/;"	f	class:ContractDefinition	signature:() const
canBeDeployed	libsolidity/ast/AST.h	/^	bool canBeDeployed() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
canBeFunctional	libevmasm/AssemblyItem.cpp	/^bool AssemblyItem::canBeFunctional() const$/;"	f	class:AssemblyItem	signature:() const
canBeFunctional	libevmasm/AssemblyItem.h	/^	bool canBeFunctional() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
canBeRemoved	libevmasm/CommonSubexpressionEliminator.cpp	/^bool CSECodeGenerator::canBeRemoved(Id _element, Id _result, int _fromPosition)$/;"	f	class:CSECodeGenerator	signature:(Id _element, Id _result, int _fromPosition)
canBeRemoved	libevmasm/CommonSubexpressionEliminator.h	/^	bool canBeRemoved(Id _element, Id _result = Id(-1), int _fromPosition = c_invalidPosition);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _element, Id _result = Id(-1), int _fromPosition = c_invalidPosition)
canBeStored	libsolidity/ast/Types.h	/^	virtual bool canBeStored() const { return true; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
canBeUsedExternally	libsolidity/ast/Types.cpp	/^bool ArrayType::canBeUsedExternally(bool _inLibrary) const$/;"	f	class:ArrayType	signature:(bool _inLibrary) const
canBeUsedExternally	libsolidity/ast/Types.cpp	/^bool StructType::canBeUsedExternally(bool _inLibrary) const$/;"	f	class:StructType	signature:(bool _inLibrary) const
canBeUsedExternally	libsolidity/ast/Types.h	/^	virtual bool canBeUsedExternally(bool _inLibrary) const { return !!interfaceType(_inLibrary); }$/;"	f	class:dev::solidity::Type	access:public	signature:(bool _inLibrary) const
canLiveOutsideStorage	libsolidity/ast/Types.h	/^	virtual bool canLiveOutsideStorage() const { return true; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
canOverchargeGasForCall	liblangutil/EVMVersion.h	/^	bool canOverchargeGasForCall() const { return *this >= tangerineWhistle(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
canTakeArguments	libsolidity/ast/Types.cpp	/^bool FunctionType::canTakeArguments(TypePointers const& _argumentTypes, TypePointer const& _selfType) const$/;"	f	class:FunctionType	signature:(TypePointers const& _argumentTypes, TypePointer const& _selfType) const
canTakeArguments	libsolidity/ast/Types.h	/^	bool canTakeArguments(TypePointers const& _arguments, TypePointer const& _selfType = TypePointer()) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(TypePointers const& _arguments, TypePointer const& _selfType = TypePointer()) const
canonicalName	libsolidity/ast/ASTAnnotations.h	/^	std::string canonicalName;$/;"	m	struct:dev::solidity::TypeDeclarationAnnotation	access:public
canonicalName	libsolidity/ast/Types.cpp	/^string AddressType::canonicalName() const$/;"	f	class:AddressType	signature:() const
canonicalName	libsolidity/ast/Types.cpp	/^string ArrayType::canonicalName() const$/;"	f	class:ArrayType	signature:() const
canonicalName	libsolidity/ast/Types.cpp	/^string ContractType::canonicalName() const$/;"	f	class:ContractType	signature:() const
canonicalName	libsolidity/ast/Types.cpp	/^string EnumType::canonicalName() const$/;"	f	class:EnumType	signature:() const
canonicalName	libsolidity/ast/Types.cpp	/^string FunctionType::canonicalName() const$/;"	f	class:FunctionType	signature:() const
canonicalName	libsolidity/ast/Types.cpp	/^string MappingType::canonicalName() const$/;"	f	class:MappingType	signature:() const
canonicalName	libsolidity/ast/Types.cpp	/^string StructType::canonicalName() const$/;"	f	class:StructType	signature:() const
canonicalName	libsolidity/ast/Types.h	/^	virtual std::string canonicalName() const { return toString(true); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
cases	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	m	struct:yul::Switch	access:public
category	liblangutil/SourceReferenceExtractor.h	/^		std::string category; \/\/ "Error", "Warning", ...$/;"	m	struct:langutil::SourceReferenceExtractor::Message	access:public
category	libsolidity/ast/Types.h	/^	virtual Category category() const = 0;$/;"	p	class:dev::solidity::Type	access:public	signature:() const
cerr	solse/CommandLineInterface.cpp	99;"	d	file:
changeUndecidedTo	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::changeUndecidedTo(YulString _variable, RedundantAssignEliminator::State _newState)$/;"	f	class:RedundantAssignEliminator	signature:(YulString _variable, RedundantAssignEliminator::State _newState)
changeUndecidedTo	libyul/optimiser/RedundantAssignEliminator.h	/^	void changeUndecidedTo(YulString _variable, State _newState);$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:(YulString _variable, State _newState)
check	libsolidity/analysis/ContractLevelChecker.cpp	/^bool ContractLevelChecker::check(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
check	libsolidity/analysis/ContractLevelChecker.h	/^	bool check(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:public	signature:(ContractDefinition const& _contract)
check	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::check(ASTNode const& _astRoot)$/;"	f	class:PostTypeChecker	signature:(ASTNode const& _astRoot)
check	libsolidity/analysis/PostTypeChecker.h	/^	bool check(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::PostTypeChecker	access:public	signature:(ASTNode const& _astRoot)
check	libsolidity/analysis/StaticAnalyzer.cpp	/^	bool check(ContractDefinition const& _contract)$/;"	f	class:dev::solidity::ConstructorUsesAssembly	access:public	signature:(ContractDefinition const& _contract)
check	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::check()$/;"	f	class:ViewPureChecker	signature:()
check	libsolidity/analysis/ViewPureChecker.h	/^	bool check();$/;"	p	class:dev::solidity::ViewPureChecker	access:public	signature:()
check	libsolidity/codegen/ContractCompiler.cpp	/^	void check() { solAssert(m_context.stackHeight() == stackHeight, std::string("I sense a disturbance in the stack: ") + to_string(m_context.stackHeight()) + " vs " + to_string(stackHeight)); }$/;"	f	class:__anon12::StackHeightChecker	access:public	signature:()
check	libsolidity/formal/CVC4Interface.cpp	/^pair<CheckResult, vector<string>> CVC4Interface::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:CVC4Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
check	libsolidity/formal/SMTLib2Interface.cpp	/^pair<CheckResult, vector<string>> SMTLib2Interface::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTLib2Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
check	libsolidity/formal/SMTPortfolio.cpp	/^pair<CheckResult, vector<string>> SMTPortfolio::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTPortfolio	signature:(vector<Expression> const& _expressionsToEvaluate)
check	libsolidity/formal/SolverInterface.h	/^	check(std::vector<Expression> const& _expressionsToEvaluate) = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:(std::vector<Expression> const& _expressionsToEvaluate)
check	libsolidity/formal/Z3Interface.cpp	/^pair<CheckResult, vector<string>> Z3Interface::check(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:Z3Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
check	solse/mechanism.cpp	/^bool Mechanism::check(){$/;"	f	class:Mechanism	signature:()
check	solse/mechanism.h	/^    bool check();$/;"	p	class:Mechanism	access:public	signature:()
checkAbstractFunctions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkAbstractFunctions(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkAbstractFunctions	libsolidity/analysis/ContractLevelChecker.h	/^	void checkAbstractFunctions(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkAllowed	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void checkAllowed(YulString _name)$/;"	f	class:yul::InlinableExpressionFunctionFinder	access:private	signature:(YulString _name)
checkAssignment	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::checkAssignment(Identifier const& _variable, size_t _valueSize)$/;"	f	class:AsmAnalyzer	signature:(Identifier const& _variable, size_t _valueSize)
checkAssignment	libyul/AsmAnalysis.h	/^	bool checkAssignment(Identifier const& _assignment, size_t _valueSize = size_t(-1));$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(Identifier const& _assignment, size_t _valueSize = size_t(-1))
checkAuxiliaryInputKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkAuxiliaryInputKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
checkBaseABICompatibility	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkBaseABICompatibility(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkBaseABICompatibility	libsolidity/analysis/ContractLevelChecker.h	/^	void checkBaseABICompatibility(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkBaseConstructorArguments(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.h	/^	void checkBaseConstructorArguments(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkBooleanNotConstant	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkBooleanNotConstant(Expression const& _condition, string const& _description)$/;"	f	class:SMTChecker	signature:(Expression const& _condition, string const& _description)
checkBooleanNotConstant	libsolidity/formal/SMTChecker.h	/^	void checkBooleanNotConstant($/;"	p	class:dev::solidity::SMTChecker	access:private	signature:( Expression const& _condition, std::string const& _description )
checkCondPass	solse/SymExecEngine.cpp	/^bool checkCondPass(ContextInfo& cond){$/;"	f	signature:(ContextInfo& cond)
checkCondition	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkCondition($/;"	f	class:SMTChecker	signature:( smt::Expression _condition, SourceLocation const& _location, string const& _description, string const& _additionalValueName, smt::Expression* _additionalValue )
checkCondition	libsolidity/formal/SMTChecker.h	/^	void checkCondition($/;"	p	class:dev::solidity::SMTChecker	access:private	signature:( smt::Expression _condition, langutil::SourceLocation const& _location, std::string const& _description, std::string const& _additionalValueName = , smt::Expression* _additionalValue = nullptr )
checkConstructor	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkConstructor(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkConstructor	libsolidity/analysis/ContractLevelChecker.h	/^	void checkConstructor(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkDoubleStorageAssignment	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::checkDoubleStorageAssignment(Assignment const& _assignment)$/;"	f	class:TypeChecker	signature:(Assignment const& _assignment)
checkDoubleStorageAssignment	libsolidity/analysis/TypeChecker.h	/^	void checkDoubleStorageAssignment(Assignment const& _assignment);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Assignment const& _assignment)
checkDuplicateEvents	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkDuplicateEvents(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkDuplicateEvents	libsolidity/analysis/ContractLevelChecker.h	/^	void checkDuplicateEvents(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkDuplicateFunctions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkDuplicateFunctions(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkDuplicateFunctions	libsolidity/analysis/ContractLevelChecker.h	/^	void checkDuplicateFunctions(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkExpressionAssignment	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::checkExpressionAssignment(Type const& _type, Expression const& _expression)$/;"	f	class:TypeChecker	signature:(Type const& _type, Expression const& _expression)
checkExpressionAssignment	libsolidity/analysis/TypeChecker.h	/^	void checkExpressionAssignment(Type const& _type, Expression const& _expression);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Type const& _type, Expression const& _expression)
checkExternalTypeClashes	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkExternalTypeClashes(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkExternalTypeClashes	libsolidity/analysis/ContractLevelChecker.h	/^	void checkExternalTypeClashes(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkFallbackFunction	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkFallbackFunction(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkFallbackFunction	libsolidity/analysis/ContractLevelChecker.h	/^	void checkFallbackFunction(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkForExcessiveErrors	liblangutil/ErrorReporter.cpp	/^bool ErrorReporter::checkForExcessiveErrors(Error::Type _type)$/;"	f	class:ErrorReporter	signature:(Error::Type _type)
checkForExcessiveErrors	liblangutil/ErrorReporter.h	/^	bool checkForExcessiveErrors(Error::Type _type);$/;"	p	class:langutil::ErrorReporter	access:private	signature:(Error::Type _type)
checkFunctionOverride	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkFunctionOverride(FunctionDefinition const& _function, FunctionDefinition const& _super)$/;"	f	class:ContractLevelChecker	signature:(FunctionDefinition const& _function, FunctionDefinition const& _super)
checkFunctionOverride	libsolidity/analysis/ContractLevelChecker.h	/^	void checkFunctionOverride(FunctionDefinition const& function, FunctionDefinition const& super);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(FunctionDefinition const& function, FunctionDefinition const& super)
checkHashCollisions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkHashCollisions(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkHashCollisions	libsolidity/analysis/ContractLevelChecker.h	/^	void checkHashCollisions(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkIllegalOverrides	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkIllegalOverrides(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkIllegalOverrides	libsolidity/analysis/ContractLevelChecker.h	/^	void checkIllegalOverrides(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkInstruction	libsolidity/analysis/ViewPureChecker.cpp	/^	void checkInstruction(SourceLocation _location, solidity::Instruction _instruction)$/;"	f	class:__anon11::AssemblyViewPureChecker	file:	access:private	signature:(SourceLocation _location, solidity::Instruction _instruction)
checkInternal	libsolidity/analysis/StaticAnalyzer.cpp	/^	bool checkInternal(ContractDefinition const& _contract)$/;"	f	class:dev::solidity::ConstructorUsesAssembly	file:	access:private	signature:(ContractDefinition const& _contract)
checkKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkKeys(Json::Value const& _input, set<string> const& _keys, string const& _name)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input, set<string> const& _keys, string const& _name)
checkLibraryRequirements	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::checkLibraryRequirements(ContractDefinition const& _contract)$/;"	f	class:ContractLevelChecker	signature:(ContractDefinition const& _contract)
checkLibraryRequirements	libsolidity/analysis/ContractLevelChecker.h	/^	void checkLibraryRequirements(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
checkLooseFeature	libyul/AsmAnalysis.cpp	/^void AsmAnalyzer::checkLooseFeature(SourceLocation const& _location, string const& _description)$/;"	f	class:AsmAnalyzer	signature:(SourceLocation const& _location, string const& _description)
checkLooseFeature	libyul/AsmAnalysis.h	/^	void checkLooseFeature(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
checkMetadataKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkMetadataKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
checkOptimizerDetail	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOptimizerDetail(Json::Value const& _details, std::string const& _name, bool& _setting)$/;"	f	namespace:__anon17	signature:(Json::Value const& _details, std::string const& _name, bool& _setting)
checkOptimizerDetailsKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOptimizerDetailsKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
checkOptimizerKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOptimizerKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
checkOutputSelection	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkOutputSelection(Json::Value const& _outputSelection)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection)
checkOverflow	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkOverflow(OverflowTarget& _target)$/;"	f	class:SMTChecker	signature:(OverflowTarget& _target)
checkOverflow	libsolidity/formal/SMTChecker.h	/^	void checkOverflow(OverflowTarget& _target);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(OverflowTarget& _target)
checkParameters	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::checkParameters($/;"	f	class:DocStringAnalyser	signature:( CallableDeclaration const& _callable, DocumentedAnnotation& _annotation )
checkParameters	libsolidity/analysis/DocStringAnalyser.h	/^	void checkParameters($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( CallableDeclaration const& _callable, DocumentedAnnotation& _annotation )
checkRepresentation	libevmasm/ConstantOptimiser.cpp	/^bool ComputeMethod::checkRepresentation(u256 const& _value, AssemblyItems const& _routine) const$/;"	f	class:ComputeMethod	signature:(u256 const& _value, AssemblyItems const& _routine) const
checkRepresentation	libevmasm/ConstantOptimiser.h	/^	bool checkRepresentation(u256 const& _value, AssemblyItems const& _routine) const;$/;"	p	class:dev::eth::ComputeMethod	access:protected	signature:(u256 const& _value, AssemblyItems const& _routine) const
checkRootKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkRootKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
checkSatAndGetValuesCommand	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::checkSatAndGetValuesCommand(vector<Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTLib2Interface	signature:(vector<Expression> const& _expressionsToEvaluate)
checkSatAndGetValuesCommand	libsolidity/formal/SMTLib2Interface.h	/^	std::string checkSatAndGetValuesCommand(std::vector<Expression> const& _expressionsToEvaluate);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::vector<Expression> const& _expressionsToEvaluate)
checkSatisfiability	solse/SymExecEngine.cpp	/^checkSatisfiability(z3::expr property, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(z3::expr property, ContextInfo& ctxInfo)
checkSatisfiability	solse/SymExecEngine.h	/^    bool checkSatisfiability(z3::expr property, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(z3::expr property, ContextInfo& ctxInfo)
checkSatisfiable	libsolidity/formal/SMTChecker.cpp	/^smt::CheckResult SMTChecker::checkSatisfiable()$/;"	f	class:SMTChecker	signature:()
checkSatisfiable	libsolidity/formal/SMTChecker.h	/^	smt::CheckResult checkSatisfiable();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
checkSatisfiableAndGenerateModel	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::checkSatisfiableAndGenerateModel(vector<smt::Expression> const& _expressionsToEvaluate)$/;"	f	class:SMTChecker	signature:(vector<smt::Expression> const& _expressionsToEvaluate)
checkSatisfiableAndGenerateModel	libsolidity/formal/SMTChecker.h	/^	checkSatisfiableAndGenerateModel(std::vector<smt::Expression> const& _expressionsToEvaluate);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::vector<smt::Expression> const& _expressionsToEvaluate)
checkSettingsKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkSettingsKeys(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
checkSingleStatementVariableDeclaration	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::checkSingleStatementVariableDeclaration(ASTNode const& _statement)$/;"	f	class:SyntaxChecker	signature:(ASTNode const& _statement)
checkSingleStatementVariableDeclaration	libsolidity/analysis/SyntaxChecker.h	/^	void checkSingleStatementVariableDeclaration(ASTNode const& _statement);$/;"	p	class:dev::solidity::SyntaxChecker	access:private	signature:(ASTNode const& _statement)
checkSourceKeys	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> checkSourceKeys(Json::Value const& _input, string const& _name)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input, string const& _name)
checkStackHeight	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::checkStackHeight(void const* _astElement) const$/;"	f	class:CodeTransform	signature:(void const* _astElement) const
checkStackHeight	libyul/backends/evm/EVMCodeTransform.h	/^	void checkStackHeight(void const* _astElement) const;$/;"	p	class:yul::CodeTransform	access:private	signature:(void const* _astElement) const
checkSyntax	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::checkSyntax(ASTNode const& _astRoot)$/;"	f	class:SyntaxChecker	signature:(ASTNode const& _astRoot)
checkSyntax	libsolidity/analysis/SyntaxChecker.h	/^	bool checkSyntax(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::SyntaxChecker	access:public	signature:(ASTNode const& _astRoot)
checkTypeRequirements	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::checkTypeRequirements(ASTNode const& _contract)$/;"	f	class:TypeChecker	signature:(ASTNode const& _contract)
checkTypeRequirements	libsolidity/analysis/TypeChecker.h	/^	bool checkTypeRequirements(ASTNode const& _contract);$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(ASTNode const& _contract)
checkUnderOverflow	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkUnderOverflow()$/;"	f	class:SMTChecker	signature:()
checkUnderOverflow	libsolidity/formal/SMTChecker.h	/^	void checkUnderOverflow();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
checkUnderflow	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::checkUnderflow(OverflowTarget& _target)$/;"	f	class:SMTChecker	signature:(OverflowTarget& _target)
checkUnderflow	libsolidity/formal/SMTChecker.h	/^	void checkUnderflow(OverflowTarget& _target);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(OverflowTarget& _target)
checkUninitializedAccess	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^void ControlFlowAnalyzer::checkUninitializedAccess(CFGNode const* _entry, CFGNode const* _exit) const$/;"	f	class:ControlFlowAnalyzer	signature:(CFGNode const* _entry, CFGNode const* _exit) const
checkUninitializedAccess	libsolidity/analysis/ControlFlowAnalyzer.h	/^	void checkUninitializedAccess(CFGNode const* _entry, CFGNode const* _exit) const;$/;"	p	class:dev::solidity::ControlFlowAnalyzer	access:private	signature:(CFGNode const* _entry, CFGNode const* _exit) const
checkUnreachable	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^void ControlFlowAnalyzer::checkUnreachable(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const$/;"	f	class:ControlFlowAnalyzer	signature:(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const
checkUnreachable	libsolidity/analysis/ControlFlowAnalyzer.h	/^	void checkUnreachable(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const;$/;"	p	class:dev::solidity::ControlFlowAnalyzer	access:private	signature:(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const
checkValidity	solse/SymExecEngine.cpp	/^checkValidity(z3::expr property, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(z3::expr property, ContextInfo& ctxInfo)
checkValidity	solse/SymExecEngine.h	/^    bool checkValidity(z3::expr property, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(z3::expr property, ContextInfo& ctxInfo)
check_1stPrice	solse/mechanism.cpp	/^bool Mechanism::check_1stPrice(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_1stPrice	solse/mechanism.h	/^    bool check_1stPrice(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_2ndPrice	solse/mechanism.cpp	/^bool Mechanism::check_2ndPrice(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_2ndPrice	solse/mechanism.h	/^    bool check_2ndPrice(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_TopBidder	solse/mechanism.cpp	/^bool Mechanism::check_TopBidder(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_TopBidder	solse/mechanism.h	/^    bool check_TopBidder(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_collusionfreeness	solse/mechanism.cpp	/^bool Mechanism::check_collusionfreeness(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_collusionfreeness	solse/mechanism.h	/^    bool check_collusionfreeness(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_efficiency	solse/mechanism.cpp	/^bool Mechanism::check_efficiency(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_efficiency	solse/mechanism.h	/^    bool check_efficiency(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_fail_count	solse/SymExecEngine.cpp	/^int check_fail_count = 0;$/;"	v
check_invariant	solse/mechanism.cpp	/^bool Mechanism::check_invariant(){$/;"	f	class:Mechanism	signature:()
check_invariant	solse/mechanism.h	/^    bool check_invariant();$/;"	p	class:Mechanism	access:public	signature:()
check_optimality	solse/mechanism.cpp	/^bool Mechanism::check_optimality(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_optimality	solse/mechanism.h	/^    bool check_optimality(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_property	solse/mechanism.cpp	/^bool Mechanism::check_property(){$/;"	f	class:Mechanism	signature:()
check_property	solse/mechanism.h	/^    bool check_property();$/;"	p	class:Mechanism	access:public	signature:()
check_truthfulness	solse/mechanism.cpp	/^bool Mechanism::check_truthfulness(z3::solver& solver)$/;"	f	class:Mechanism	signature:(z3::solver& solver)
check_truthfulness	solse/mechanism.h	/^    bool check_truthfulness(z3::solver& solver);$/;"	p	class:Mechanism	access:private	signature:(z3::solver& solver)
check_types	solse/mechanism.h	/^		std::vector<z3::expr> check_types;$/;"	m	class:Mechanism	access:public
classElementPosition	libevmasm/CommonSubexpressionEliminator.cpp	/^int CSECodeGenerator::classElementPosition(Id _id) const$/;"	f	class:CSECodeGenerator	signature:(Id _id) const
classElementPosition	libevmasm/CommonSubexpressionEliminator.h	/^	int classElementPosition(Id _id) const;$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _id) const
cleanHigherOrderBits	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::cleanHigherOrderBits(IntegerType const& _typeOnStack)$/;"	f	class:dev::solidity::CompilerUtils	signature:(IntegerType const& _typeOnStack)
cleanHigherOrderBits	libsolidity/codegen/CompilerUtils.h	/^	void cleanHigherOrderBits(IntegerType const& _typeOnStack);$/;"	p	class:dev::solidity::CompilerUtils	access:private	signature:(IntegerType const& _typeOnStack)
cleanedDeclarations	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<Declaration const*> NameAndTypeResolver::cleanedDeclarations($/;"	f	class:dev::solidity::NameAndTypeResolver	signature:( Identifier const& _identifier, vector<Declaration const*> const& _declarations )
cleanedDeclarations	libsolidity/analysis/NameAndTypeResolver.h	/^	std::vector<Declaration const*> cleanedDeclarations($/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:( Identifier const& _identifier, std::vector<Declaration const*> const& _declarations )
cleanupCombinedExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::cleanupCombinedExternalFunctionIdFunction()$/;"	f	class:ABIFunctions	signature:()
cleanupCombinedExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string cleanupCombinedExternalFunctionIdFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
cleanupFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::cleanupFunction(Type const& _type, bool _revertOnFailure)$/;"	f	class:ABIFunctions	signature:(Type const& _type, bool _revertOnFailure)
cleanupFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string cleanupFunction(Type const& _type, bool _revertOnFailure = false);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _type, bool _revertOnFailure = false)
cleanupNeededForOp	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::cleanupNeededForOp(Type::Category _type, Token _op)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Type::Category _type, Token _op)
cleanupNeededForOp	libsolidity/codegen/ExpressionCompiler.h	/^	static bool cleanupNeededForOp(Type::Category _type, Token _op);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Type::Category _type, Token _op)
clear	libdevcore/FixedHash.h	/^	void clear() { m_data.fill(0); }$/;"	f	class:dev::FixedHash	access:public	signature:()
clear	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::clear()$/;"	f	class:ErrorReporter	signature:()
clear	liblangutil/ErrorReporter.h	/^	void clear();$/;"	p	class:langutil::ErrorReporter	access:public	signature:()
clearArray	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::clearArray(ArrayType const& _typeIn) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _typeIn) const
clearArray	libsolidity/codegen/ArrayUtils.h	/^	void clearArray(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
clearCurrentCommentLiteral	liblangutil/Scanner.h	/^	void clearCurrentCommentLiteral() { m_skippedComment.literal.clear(); }$/;"	f	class:langutil::Scanner	access:public	signature:()
clearDynamicArray	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::clearDynamicArray(ArrayType const& _type) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _type) const
clearDynamicArray	libsolidity/codegen/ArrayUtils.h	/^	void clearDynamicArray(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
clearStorageLoop	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::clearStorageLoop(TypePointer const& _type) const$/;"	f	class:ArrayUtils	signature:(TypePointer const& _type) const
clearStorageLoop	libsolidity/codegen/ArrayUtils.h	/^	void clearStorageLoop(TypePointer const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(TypePointer const& _type) const
clearTagUnions	libevmasm/KnownState.cpp	/^void KnownState::clearTagUnions()$/;"	f	class:KnownState	signature:()
clearTagUnions	libevmasm/KnownState.h	/^	void clearTagUnions();$/;"	p	class:dev::eth::KnownState	access:public	signature:()
clearValues	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::clearValues(set<YulString> _variables)$/;"	f	class:DataFlowAnalyzer	signature:(set<YulString> _variables)
clearValues	libyul/optimiser/DataFlowAnalyzer.h	/^	void clearValues(std::set<YulString> _names);$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(std::set<YulString> _names)
closeCurrentScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::closeCurrentScope()$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:()
closeCurrentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void closeCurrentScope();$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:()
closestTemporaryType	libsolidity/ast/Types.cpp	/^TypePointer TupleType::closestTemporaryType(TypePointer const& _targetType) const$/;"	f	class:TupleType	signature:(TypePointer const& _targetType) const
closestTemporaryType	libsolidity/ast/Types.h	/^	virtual TypePointer closestTemporaryType(TypePointer const& _targetType) const$/;"	f	class:dev::solidity::Type	access:public	signature:(TypePointer const& _targetType) const
code	libyul/Object.h	/^	std::shared_ptr<Block> code;$/;"	m	struct:yul::Object	access:public
codeCost	libyul/optimiser/Metrics.cpp	/^size_t CodeCost::codeCost(Expression const& _expr)$/;"	f	class:CodeCost	signature:(Expression const& _expr)
codeCost	libyul/optimiser/Metrics.h	/^	static size_t codeCost(Expression const& _expression);$/;"	p	class:yul::CodeCost	access:public	signature:(Expression const& _expression)
codeSize	libyul/optimiser/EquivalentFunctionDetector.cpp	/^size_t EquivalentFunctionDetector::RoughHeuristic::codeSize() const$/;"	f	class:EquivalentFunctionDetector::RoughHeuristic	signature:() const
codeSize	libyul/optimiser/EquivalentFunctionDetector.h	/^		std::size_t codeSize() const;$/;"	p	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:private	signature:() const
codeSize	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSize(Block const& _block)$/;"	f	class:CodeSize	signature:(Block const& _block)
codeSize	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSize(Expression const& _expression)$/;"	f	class:CodeSize	signature:(Expression const& _expression)
codeSize	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSize(Statement const& _statement)$/;"	f	class:CodeSize	signature:(Statement const& _statement)
codeSize	libyul/optimiser/Metrics.h	/^	static size_t codeSize(Block const& _block);$/;"	p	class:yul::CodeSize	access:public	signature:(Block const& _block)
codeSize	libyul/optimiser/Metrics.h	/^	static size_t codeSize(Expression const& _expression);$/;"	p	class:yul::CodeSize	access:public	signature:(Expression const& _expression)
codeSize	libyul/optimiser/Metrics.h	/^	static size_t codeSize(Statement const& _statement);$/;"	p	class:yul::CodeSize	access:public	signature:(Statement const& _statement)
codeSizeIncludingFunctions	libyul/optimiser/Metrics.cpp	/^size_t CodeSize::codeSizeIncludingFunctions(Block const& _block)$/;"	f	class:CodeSize	signature:(Block const& _block)
codeSizeIncludingFunctions	libyul/optimiser/Metrics.h	/^	static size_t codeSizeIncludingFunctions(Block const& _block);$/;"	p	class:yul::CodeSize	access:public	signature:(Block const& _block)
codomain	libsolidity/formal/SolverInterface.h	/^	SortPointer codomain;$/;"	m	struct:dev::solidity::smt::FunctionSort	access:public
collectContext	solse/SolidityExprTranslator.cpp	/^void ContextInfo::collectContext(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records,$/;"	f	class:ContextInfo	signature:(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records, std::unordered_map<std::string, std::vector<std::string>>& local_variable_records)
collectContext	solse/SolidityExprTranslator.h	/^    void collectContext(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records,$/;"	p	class:ContextInfo	access:public	signature:(std::unordered_map<std::string, std::vector<std::string>>& state_variable_records, std::unordered_map<std::string, std::vector<std::string>>& local_variable_records)
collectEVMObject	libsolidity/interface/StandardCompiler.cpp	/^Json::Value collectEVMObject(eth::LinkerObject const& _object, string const* _sourceMap)$/;"	f	namespace:__anon17	signature:(eth::LinkerObject const& _object, string const* _sourceMap)
collusion_assertions	solse/SymExecEngine.cpp	/^std::vector<z3::expr> collusion_assertions;$/;"	v
collusion_count	solse/SymExecEngine.cpp	/^unsigned collusion_count = 0;$/;"	v
column	liblangutil/SourceReferenceExtractor.h	/^	int column = {-1};$/;"	m	struct:langutil::LineColumn	access:public
combine	libsolidity/ast/Types.cpp	/^void MemberList::combine(MemberList const & _other)$/;"	f	class:MemberList	signature:(MemberList const & _other)
combine	libsolidity/ast/Types.h	/^	void combine(MemberList const& _other);$/;"	p	class:dev::solidity::MemberList	access:public	signature:(MemberList const& _other)
combineExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::combineExternalFunctionIdFunction()$/;"	f	class:ABIFunctions	signature:()
combineExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string combineExternalFunctionIdFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
combineExternalFunctionType	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::combineExternalFunctionType(bool _leftAligned)$/;"	f	class:dev::solidity::CompilerUtils	signature:(bool _leftAligned)
combineExternalFunctionType	libsolidity/codegen/CompilerUtils.h	/^	void combineExternalFunctionType(bool _rightAligned);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(bool _rightAligned)
combineGas	libevmasm/ConstantOptimiser.h	/^	bigint combineGas($/;"	f	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:( bigint const& _runGas, bigint const& _repeatedDataGas, bigint const& _uniqueDataGas ) const
commonType	libsolidity/ast/ASTAnnotations.h	/^	TypePointer commonType;$/;"	m	struct:dev::solidity::BinaryOperationAnnotation	access:public
commonType	libsolidity/ast/Types.cpp	/^TypePointer Type::commonType(TypePointer const& _a, TypePointer const& _b)$/;"	f	class:Type	signature:(TypePointer const& _a, TypePointer const& _b)
commonType	libsolidity/ast/Types.h	/^	static TypePointer commonType(TypePointer const& _a, TypePointer const& _b);$/;"	p	class:dev::solidity::Type	access:public	signature:(TypePointer const& _a, TypePointer const& _b)
compareOperation	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::compareOperation(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
compareOperation	libsolidity/formal/SMTChecker.h	/^	void compareOperation(BinaryOperation const& _op);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(BinaryOperation const& _op)
compareUniquePtr	libyul/optimiser/SyntacticalEquality.h	/^	bool compareUniquePtr(std::unique_ptr<T> const& _lhs, std::unique_ptr<T> const& _rhs)$/;"	f	class:yul::SyntacticallyEqual	access:private	signature:(std::unique_ptr<T> const& _lhs, std::unique_ptr<T> const& _rhs)
compile	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::compile(Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Expression const& _expression)
compile	libsolidity/codegen/ExpressionCompiler.h	/^	void compile(Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(Expression const& _expression)
compile	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::compile()$/;"	f	class:CompilerStack	signature:()
compile	libsolidity/interface/CompilerStack.h	/^	bool compile();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
compile	libyul/backends/evm/EVMObjectCompiler.cpp	/^void EVMObjectCompiler::compile(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize)$/;"	f	class:EVMObjectCompiler	signature:(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize)
compile	libyul/backends/evm/EVMObjectCompiler.h	/^	static void compile(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize);$/;"	p	class:yul::EVMObjectCompiler	access:public	signature:(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize)
compileConstructor	libsolidity/codegen/ContractCompiler.cpp	/^size_t ContractCompiler::compileConstructor($/;"	f	class:ContractCompiler	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers )
compileConstructor	libsolidity/codegen/ContractCompiler.h	/^	size_t compileConstructor($/;"	p	class:dev::solidity::ContractCompiler	access:public	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers )
compileContract	libsolidity/codegen/Compiler.cpp	/^void Compiler::compileContract($/;"	f	class:Compiler	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers, bytes const& _metadata )
compileContract	libsolidity/codegen/Compiler.h	/^	void compileContract($/;"	p	class:dev::solidity::Compiler	access:public	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers, bytes const& _metadata )
compileContract	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::compileContract($/;"	f	class:ContractCompiler	signature:( ContractDefinition const& _contract, map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers )
compileContract	libsolidity/codegen/ContractCompiler.h	/^	void compileContract($/;"	p	class:dev::solidity::ContractCompiler	access:public	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers )
compileContract	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::compileContract($/;"	f	class:CompilerStack	signature:( ContractDefinition const& _contract, map<ContractDefinition const*, shared_ptr<Compiler const>>& _otherCompilers )
compileContract	libsolidity/interface/CompilerStack.h	/^	void compileContract($/;"	p	class:dev::solidity::CompilerStack	access:private	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>>& _otherCompilers )
compileEVM	libyul/AssemblyStack.cpp	/^void AssemblyStack::compileEVM(AbstractAssembly& _assembly, bool _evm15, bool _optimize) const$/;"	f	class:AssemblyStack	signature:(AbstractAssembly& _assembly, bool _evm15, bool _optimize) const
compileEVM	libyul/AssemblyStack.h	/^	void compileEVM(yul::AbstractAssembly& _assembly, bool _evm15, bool _optimize) const;$/;"	p	class:yul::AssemblyStack	access:private	signature:(yul::AbstractAssembly& _assembly, bool _evm15, bool _optimize) const
compileExpression	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::compileExpression(Expression const& _expression, TypePointer const& _targetType)$/;"	f	class:ContractCompiler	signature:(Expression const& _expression, TypePointer const& _targetType)
compileExpression	libsolidity/codegen/ContractCompiler.h	/^	void compileExpression(Expression const& _expression, TypePointer const& _targetType = TypePointer());$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(Expression const& _expression, TypePointer const& _targetType = TypePointer())
compileInternal	libsolidity/interface/StandardCompiler.cpp	/^Json::Value StandardCompiler::compileInternal(Json::Value const& _input)$/;"	f	class:StandardCompiler	signature:(Json::Value const& _input)
compileInternal	libsolidity/interface/StandardCompiler.h	/^	Json::Value compileInternal(Json::Value const& _input);$/;"	p	class:dev::solidity::StandardCompiler	access:private	signature:(Json::Value const& _input)
compiledContract	libsolidity/codegen/CompilerContext.cpp	/^shared_ptr<eth::Assembly> CompilerContext::compiledContract(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
compiledContract	libsolidity/codegen/CompilerContext.h	/^	std::shared_ptr<eth::Assembly> compiledContract(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ContractDefinition const& _contract) const
compiledContractRuntime	libsolidity/codegen/CompilerContext.cpp	/^shared_ptr<eth::Assembly> CompilerContext::compiledContractRuntime(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
compiledContractRuntime	libsolidity/codegen/CompilerContext.h	/^	std::shared_ptr<eth::Assembly> compiledContractRuntime(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ContractDefinition const& _contract) const
compiler	libsolidity/interface/CompilerStack.h	/^		std::shared_ptr<Compiler> compiler;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
complete	liblangutil/Scanner.cpp	/^	void complete() { m_complete = true; }$/;"	f	class:langutil::LiteralScope	access:public	signature:()
components	libsolidity/analysis/SemVerHandler.h	/^		std::vector<MatchComponent> components;$/;"	m	struct:dev::solidity::SemVerMatchExpression::Conjunction	access:public
components	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> const& components() const { return m_components; }$/;"	f	class:dev::solidity::TupleExpression::std	access:public	signature:() const
components	libsolidity/ast/Types.h	/^	std::vector<TypePointer> const& components() const { return m_components; }$/;"	f	class:dev::solidity::TupleType::std	access:public	signature:() const
computeHashStatic	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::computeHashStatic()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
computeHashStatic	libsolidity/codegen/CompilerUtils.h	/^	void computeHashStatic();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
computeOffsets	libsolidity/ast/Types.cpp	/^void StorageOffsets::computeOffsets(TypePointers const& _types)$/;"	f	class:StorageOffsets	signature:(TypePointers const& _types)
computeOffsets	libsolidity/ast/Types.h	/^	void computeOffsets(TypePointers const& _types);$/;"	p	class:dev::solidity::StorageOffsets	access:public	signature:(TypePointers const& _types)
computeSourceMapping	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::computeSourceMapping(eth::AssemblyItems const& _items) const$/;"	f	class:CompilerStack	signature:(eth::AssemblyItems const& _items) const
computeSourceMapping	libsolidity/interface/CompilerStack.h	/^	std::string computeSourceMapping(eth::AssemblyItems const& _items) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(eth::AssemblyItems const& _items) const
condition	libsolidity/ast/AST.h	/^	Expression const& condition() const { return *m_condition; }$/;"	f	class:dev::solidity::Conditional	access:public	signature:() const
condition	libsolidity/ast/AST.h	/^	Expression const& condition() const { return *m_condition; }$/;"	f	class:dev::solidity::IfStatement	access:public	signature:() const
condition	libsolidity/ast/AST.h	/^	Expression const& condition() const { return *m_condition; }$/;"	f	class:dev::solidity::WhileStatement	access:public	signature:() const
condition	libsolidity/ast/AST.h	/^	Expression const* condition() const { return m_condExpression.get(); }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
condition	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
condition	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	m	struct:yul::If	access:public
conflictingDeclaration	libsolidity/analysis/DeclarationContainer.cpp	/^Declaration const* DeclarationContainer::conflictingDeclaration($/;"	f	class:DeclarationContainer	signature:( Declaration const& _declaration, ASTString const* _name ) const
conflictingDeclaration	libsolidity/analysis/DeclarationContainer.h	/^	Declaration const* conflictingDeclaration(Declaration const& _declaration, ASTString const* _name = nullptr) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(Declaration const& _declaration, ASTString const* _name = nullptr) const
connect	libsolidity/analysis/ControlFlowBuilder.cpp	/^void ControlFlowBuilder::connect(CFGNode* _from, CFGNode* _to)$/;"	f	class:ControlFlowBuilder	signature:(CFGNode* _from, CFGNode* _to)
connect	libsolidity/analysis/ControlFlowBuilder.h	/^	static void connect(CFGNode* _from, CFGNode* _to);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFGNode* _from, CFGNode* _to)
constantinople	liblangutil/EVMVersion.h	/^	static EVMVersion constantinople() { return {Version::Constantinople}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
constructFlow	libsolidity/analysis/ControlFlowGraph.cpp	/^bool CFG::constructFlow(ASTNode const& _astRoot)$/;"	f	class:CFG	signature:(ASTNode const& _astRoot)
constructFlow	libsolidity/analysis/ControlFlowGraph.h	/^	bool constructFlow(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::CFG	access:public	signature:(ASTNode const& _astRoot)
constructor	libsolidity/ast/AST.cpp	/^FunctionDefinition const* ContractDefinition::constructor() const$/;"	f	class:ContractDefinition	signature:() const
constructor	libsolidity/ast/AST.h	/^	FunctionDefinition const* constructor() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
constructorIsPublic	libsolidity/ast/AST.cpp	/^bool ContractDefinition::constructorIsPublic() const$/;"	f	class:ContractDefinition	signature:() const
constructorIsPublic	libsolidity/ast/AST.h	/^	bool constructorIsPublic() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
constructorType	libsolidity/ast/Types.cpp	/^FunctionTypePointer StructType::constructorType() const$/;"	f	class:StructType	signature:() const
constructorType	libsolidity/ast/Types.h	/^	FunctionTypePointer constructorType() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
containerEqual	libdevcore/CommonData.h	/^bool containerEqual(Container const& _lhs, Container const& _rhs, Compare&& _compare)$/;"	f	namespace:dev	signature:(Container const& _lhs, Container const& _rhs, Compare&& _compare)
contains	libdevcore/CommonData.h	/^bool contains(T const& _t, V const& _v)$/;"	f	namespace:dev	signature:(T const& _t, V const& _v)
contains	liblangutil/SourceLocation.h	/^	inline bool contains(SourceLocation const& _other) const;$/;"	p	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
contains	liblangutil/SourceLocation.h	/^bool SourceLocation::contains(SourceLocation const& _other) const$/;"	f	class:langutil::SourceLocation	signature:(SourceLocation const& _other) const
containsErrorOfType	liblangutil/Exceptions.h	/^	static Error const* containsErrorOfType(ErrorList const& _list, Error::Type _type)$/;"	f	class:langutil::Error	access:public	signature:(ErrorList const& _list, Error::Type _type)
containsOnlyWarnings	liblangutil/Exceptions.h	/^	static bool containsOnlyWarnings(ErrorList const& _list)$/;"	f	class:langutil::Error	access:public	signature:(ErrorList const& _list)
content	libsolidity/ast/ASTAnnotations.h	/^	std::string content;	\/\/\/< The text content of the tag.$/;"	m	struct:dev::solidity::DocTag	access:public
contents	libdevcore/IndentedWriter.h	/^		std::string contents;$/;"	m	struct:dev::IndentedWriter::Line	access:public
context	libsolidity/interface/CompilerStack.h	/^		std::string context;$/;"	m	struct:dev::solidity::CompilerStack::Remapping	access:public
contract	libsolidity/interface/CompilerStack.cpp	/^CompilerStack::Contract const& CompilerStack::contract(string const& _contractName) const$/;"	f	class:CompilerStack::CompilerStack	signature:(string const& _contractName) const
contract	libsolidity/interface/CompilerStack.h	/^		ContractDefinition const* contract = nullptr;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
contract	libsolidity/interface/CompilerStack.h	/^	Contract const& contract(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _contractName) const
contractABI	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::contractABI(Contract const& _contract) const$/;"	f	class:Json::CompilerStack	signature:(Contract const& _contract) const
contractABI	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::contractABI(string const& _contractName) const$/;"	f	class:Json::CompilerStack	signature:(string const& _contractName) const
contractABI	libsolidity/interface/CompilerStack.h	/^	Json::Value const& contractABI(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:private	signature:(Contract const&) const
contractABI	libsolidity/interface/CompilerStack.h	/^	Json::Value const& contractABI(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:public	signature:(std::string const& _contractName) const
contractDefinition	libsolidity/ast/Types.h	/^	ContractDefinition const& contractDefinition() const { return m_contract; }$/;"	f	class:dev::solidity::ContractType	access:public	signature:() const
contractDefinition	libsolidity/interface/CompilerStack.cpp	/^ContractDefinition const& CompilerStack::contractDefinition(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
contractDefinition	libsolidity/interface/CompilerStack.h	/^	ContractDefinition const& contractDefinition(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _contractName) const
contractDependencies	libsolidity/ast/ASTAnnotations.h	/^	std::set<ContractDefinition const*> contractDependencies;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
contractDependenciesAreCyclic	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::contractDependenciesAreCyclic($/;"	f	class:TypeChecker	signature:( ContractDefinition const& _contract, std::set<ContractDefinition const*> const& _seenContracts ) const
contractDependenciesAreCyclic	libsolidity/analysis/TypeChecker.h	/^	bool contractDependenciesAreCyclic($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( ContractDefinition const& _contract, std::set<ContractDefinition const*> const& _seenContracts = std::set<ContractDefinition const*>() ) const
contractKind	libsolidity/ast/AST.h	/^	ContractKind contractKind() const { return m_contractKind; }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
contractKind	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::contractKind(ContractDefinition::ContractKind _kind)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ContractDefinition::ContractKind _kind)
contractKind	libsolidity/ast/ASTJsonConverter.h	/^	static std::string contractKind(ContractDefinition::ContractKind _kind);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(ContractDefinition::ContractKind _kind)
contractNames	libsolidity/interface/CompilerStack.cpp	/^vector<string> CompilerStack::contractNames() const$/;"	f	class:CompilerStack	signature:() const
contractNames	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> contractNames() const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:() const
contractScope	libsolidity/ast/ASTAnnotations.h	/^	ContractDefinition const* contractScope = nullptr;$/;"	m	struct:dev::solidity::UserDefinedTypeNameAnnotation	access:public
conversionFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::conversionFunction(Type const& _from, Type const& _to)$/;"	f	class:ABIFunctions	signature:(Type const& _from, Type const& _to)
conversionFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string conversionFunction(Type const& _from, Type const& _to);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _from, Type const& _to)
convertLengthToSize	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::convertLengthToSize(ArrayType const& _arrayType, bool _pad) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _arrayType, bool _pad) const
convertLengthToSize	libsolidity/codegen/ArrayUtils.h	/^	void convertLengthToSize(ArrayType const& _arrayType, bool _pad = false) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, bool _pad = false) const
convertType	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::convertType($/;"	f	class:dev::solidity::CompilerUtils	signature:( Type const& _typeOnStack, Type const& _targetType, bool _cleanupNeeded, bool _chopSignBits, bool _asPartOfArgumentDecoding )
convertType	libsolidity/codegen/CompilerUtils.h	/^	void convertType($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( Type const& _typeOnStack, Type const& _targetType, bool _cleanupNeeded = false, bool _chopSignBits = false, bool _asPartOfArgumentDecoding = false )
copy	libevmasm/KnownState.h	/^	std::shared_ptr<KnownState> copy() const { return std::make_shared<KnownState>(*this); }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
copyAndSetGasOrValue	libsolidity/ast/Types.cpp	/^TypePointer FunctionType::copyAndSetGasOrValue(bool _setGas, bool _setValue) const$/;"	f	class:FunctionType	signature:(bool _setGas, bool _setValue) const
copyAndSetGasOrValue	libsolidity/ast/Types.h	/^	TypePointer copyAndSetGasOrValue(bool _setGas, bool _setValue) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(bool _setGas, bool _setValue) const
copyArrayToMemory	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::copyArrayToMemory(ArrayType const& _sourceType, bool _padToWordBoundaries) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _sourceType, bool _padToWordBoundaries) const
copyArrayToMemory	libsolidity/codegen/ArrayUtils.h	/^	void copyArrayToMemory(ArrayType const& _sourceType, bool _padToWordBoundaries = true) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _sourceType, bool _padToWordBoundaries = true) const
copyArrayToStorage	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType const& _sourceType) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _targetType, ArrayType const& _sourceType) const
copyArrayToStorage	libsolidity/codegen/ArrayUtils.h	/^	void copyArrayToStorage(ArrayType const& _targetType, ArrayType const& _sourceType) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _targetType, ArrayType const& _sourceType) const
copyContractCodeToMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::copyContractCodeToMemory(ContractDefinition const& contract, bool _creation)$/;"	f	class:dev::solidity::CompilerUtils	signature:(ContractDefinition const& contract, bool _creation)
copyContractCodeToMemory	libsolidity/codegen/CompilerUtils.h	/^	void copyContractCodeToMemory(ContractDefinition const& contract, bool _creationCode);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(ContractDefinition const& contract, bool _creationCode)
copyForLocation	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::copyForLocation(DataLocation _location, bool _isPointer) const$/;"	f	class:ArrayType	signature:(DataLocation _location, bool _isPointer) const
copyForLocation	libsolidity/ast/Types.cpp	/^TypePointer StructType::copyForLocation(DataLocation _location, bool _isPointer) const$/;"	f	class:StructType	signature:(DataLocation _location, bool _isPointer) const
copyForLocation	libsolidity/ast/Types.h	/^	virtual TypePointer copyForLocation(DataLocation _location, bool _isPointer) const = 0;$/;"	p	class:dev::solidity::ReferenceType	access:public	signature:(DataLocation _location, bool _isPointer) const
copyForLocationIfReference	libsolidity/ast/Types.cpp	/^TypePointer ReferenceType::copyForLocationIfReference(DataLocation _location, TypePointer const& _type)$/;"	f	class:ReferenceType	signature:(DataLocation _location, TypePointer const& _type)
copyForLocationIfReference	libsolidity/ast/Types.cpp	/^TypePointer ReferenceType::copyForLocationIfReference(TypePointer const& _type) const$/;"	f	class:ReferenceType	signature:(TypePointer const& _type) const
copyForLocationIfReference	libsolidity/ast/Types.h	/^	TypePointer copyForLocationIfReference(TypePointer const& _type) const;$/;"	p	class:dev::solidity::ReferenceType	access:protected	signature:(TypePointer const& _type) const
copyForLocationIfReference	libsolidity/ast/Types.h	/^	static TypePointer copyForLocationIfReference(DataLocation _location, TypePointer const& _type);$/;"	p	class:dev::solidity::ReferenceType	access:public	signature:(DataLocation _location, TypePointer const& _type)
copyGas	libevmasm/GasMeter.h	/^	static unsigned const copyGas = 3;$/;"	m	namespace:dev::eth::GasCosts
copyRoutine	libevmasm/ConstantOptimiser.cpp	/^AssemblyItems const& CodeCopyMethod::copyRoutine()$/;"	f	class:CodeCopyMethod	signature:()
copyRoutine	libevmasm/ConstantOptimiser.h	/^	static AssemblyItems const& copyRoutine();$/;"	p	class:dev::eth::CodeCopyMethod	access:protected	signature:()
copyToMemoryFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::copyToMemoryFunction(bool _fromCalldata)$/;"	f	class:ABIFunctions	signature:(bool _fromCalldata)
copyToMemoryFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string copyToMemoryFunction(bool _fromCalldata);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(bool _fromCalldata)
copyToStackTop	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::copyToStackTop(unsigned _stackDepth, unsigned _itemSize)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _stackDepth, unsigned _itemSize)
copyToStackTop	libsolidity/codegen/CompilerUtils.h	/^	void copyToStackTop(unsigned _stackDepth, unsigned _itemSize);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _stackDepth, unsigned _itemSize)
copyVariableIndices	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::VariableIndices SMTChecker::copyVariableIndices()$/;"	f	class:SMTChecker	signature:()
copyVariableIndices	libsolidity/formal/SMTChecker.h	/^	VariableIndices copyVariableIndices();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
count	liblangutil/Scanner.cpp	/^BOOST_STATIC_ASSERT(TokenTraits::count() <= 0x100);$/;"	p	namespace:langutil	file:	signature:()
count	liblangutil/Token.h	/^	constexpr size_t count() { return static_cast<size_t>(Token::NUM_TOKENS); }$/;"	f	namespace:langutil::TokenTraits	signature:()
countReferences	libyul/optimiser/NameCollector.cpp	/^map<YulString, size_t> ReferencesCounter::countReferences(Block const& _block)$/;"	f	class:ReferencesCounter	signature:(Block const& _block)
countReferences	libyul/optimiser/NameCollector.cpp	/^map<YulString, size_t> ReferencesCounter::countReferences(Expression const& _expression)$/;"	f	class:ReferencesCounter	signature:(Expression const& _expression)
countReferences	libyul/optimiser/NameCollector.cpp	/^map<YulString, size_t> ReferencesCounter::countReferences(FunctionDefinition const& _function)$/;"	f	class:ReferencesCounter	signature:(FunctionDefinition const& _function)
countReferences	libyul/optimiser/NameCollector.h	/^	static std::map<YulString, size_t> countReferences(Block const& _block);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(Block const& _block)
countReferences	libyul/optimiser/NameCollector.h	/^	static std::map<YulString, size_t> countReferences(Expression const& _expression);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(Expression const& _expression)
countReferences	libyul/optimiser/NameCollector.h	/^	static std::map<YulString, size_t> countReferences(FunctionDefinition const& _function);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(FunctionDefinition const& _function)
cout	solse/CommandLineInterface.cpp	98;"	d	file:
createCBORMetadata	libsolidity/interface/CompilerStack.cpp	/^bytes CompilerStack::createCBORMetadata(string const& _metadata, bool _experimentalMode)$/;"	f	class:CompilerStack	signature:(string const& _metadata, bool _experimentalMode)
createCBORMetadata	libsolidity/interface/CompilerStack.h	/^	static bytes createCBORMetadata(std::string const& _metadata, bool _experimentalMode);$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _metadata, bool _experimentalMode)
createDataGas	libevmasm/GasMeter.h	/^	static unsigned const createDataGas = 200;$/;"	m	namespace:dev::eth::GasCosts
createEmptyParameterList	libsolidity/parsing/Parser.cpp	/^ASTPointer<ParameterList> Parser::createEmptyParameterList()$/;"	f	class:dev::solidity::Parser	signature:()
createEmptyParameterList	libsolidity/parsing/Parser.h	/^	ASTPointer<ParameterList> createEmptyParameterList();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
createExpr	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::createExpr(Expression const& _e)$/;"	f	class:SMTChecker	signature:(Expression const& _e)
createExpr	libsolidity/formal/SMTChecker.h	/^	void createExpr(Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e)
createExternallyUsedFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::createExternallyUsedFunction(string const& _name, function<string ()> const& _creator)$/;"	f	class:ABIFunctions	signature:(string const& _name, function<string ()> const& _creator)
createExternallyUsedFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string createExternallyUsedFunction(std::string const& _name, std::function<std::string()> const& _creator);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(std::string const& _name, std::function<std::string()> const& _creator)
createFile	solse/CommandLineInterface.cpp	/^void CommandLineInterface::createFile(string const& _fileName, string const& _data)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _fileName, string const& _data)
createFile	solse/CommandLineInterface.h	/^	void createFile(std::string const& _fileName, std::string const& _data);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _fileName, std::string const& _data)
createFlow	libsolidity/analysis/ControlFlowBuilder.cpp	/^CFGNode* ControlFlowBuilder::createFlow(CFGNode* _entry, ASTNode const& _node)$/;"	f	class:ControlFlowBuilder	signature:(CFGNode* _entry, ASTNode const& _node)
createFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* createFlow(CFGNode* _entry, ASTNode const& _node);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFGNode* _entry, ASTNode const& _node)
createFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::createFunction(string const& _name, function<string ()> const& _creator)$/;"	f	class:ABIFunctions	signature:(string const& _name, function<string ()> const& _creator)
createFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string createFunction(std::string const& _name, std::function<std::string()> const& _creator);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(std::string const& _name, std::function<std::string()> const& _creator)
createFunctionFlow	libsolidity/analysis/ControlFlowBuilder.cpp	/^unique_ptr<FunctionFlow> ControlFlowBuilder::createFunctionFlow($/;"	f	class:ControlFlowBuilder	signature:( CFG::NodeContainer& _nodeContainer, FunctionDefinition const& _function )
createFunctionFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	static std::unique_ptr<FunctionFlow> createFunctionFlow($/;"	p	class:dev::solidity::ControlFlowBuilder	access:public	signature:( CFG::NodeContainer& _nodeContainer, FunctionDefinition const& _function )
createGas	libevmasm/GasMeter.h	/^	static unsigned const createGas = 32000;$/;"	m	namespace:dev::eth::GasCosts
createJson	solse/CommandLineInterface.cpp	/^void CommandLineInterface::createJson(string const& _fileName, string const& _json)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _fileName, string const& _json)
createJson	solse/CommandLineInterface.h	/^	void createJson(std::string const& _fileName, std::string const& _json);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _fileName, std::string const& _json)
createJsonValue	libevmasm/Assembly.cpp	/^Json::Value Assembly::createJsonValue(string _name, int _begin, int _end, string _value, string _jumpType)$/;"	f	class:Assembly	signature:(string _name, int _begin, int _end, string _value, string _jumpType)
createJsonValue	libevmasm/Assembly.h	/^	static Json::Value createJsonValue(std::string _name, int _begin, int _end, std::string _value = std::string(), std::string _jumpType = std::string());$/;"	p	class:dev::eth::Assembly	access:private	signature:(std::string _name, int _begin, int _end, std::string _value = std::string(), std::string _jumpType = std::string())
createLabelHere	libsolidity/analysis/ControlFlowBuilder.cpp	/^CFGNode* ControlFlowBuilder::createLabelHere()$/;"	f	class:ControlFlowBuilder	signature:()
createLabelHere	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* createLabelHere();$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:()
createMetadata	libsolidity/interface/CompilerStack.cpp	/^string CompilerStack::createMetadata(Contract const& _contract) const$/;"	f	class:CompilerStack	signature:(Contract const& _contract) const
createMetadata	libsolidity/interface/CompilerStack.h	/^	std::string createMetadata(Contract const& _contract) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(Contract const& _contract) const
createNode	libsolidity/parsing/Parser.cpp	/^	ASTPointer<NodeType> createNode(Args&& ... _args)$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(Args&& .... _args)
createRules	libevmasm/ExpressionClasses.h	/^	std::vector<std::pair<Pattern, std::function<Pattern()>>> createRules() const;$/;"	p	class:dev::eth::ExpressionClasses	access:private	signature:() const
createSourceList	libsolidity/interface/StandardCompiler.cpp	/^StringMap createSourceList(Json::Value const& _input)$/;"	f	namespace:__anon17	signature:(Json::Value const& _input)
createSubAssembly	libyul/backends/evm/AbstractAssembly.h	/^	virtual std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:()
createSubAssembly	libyul/backends/evm/AsmCodeGen.cpp	/^pair<shared_ptr<AbstractAssembly>, AbstractAssembly::SubID> EthAssemblyAdapter::createSubAssembly()$/;"	f	class:EthAssemblyAdapter	signature:()
createSubAssembly	libyul/backends/evm/EVMAssembly.cpp	/^pair<shared_ptr<AbstractAssembly>, AbstractAssembly::SubID> EVMAssembly::createSubAssembly()$/;"	f	class:EVMAssembly	signature:()
createSubAssembly	libyul/backends/evm/NoOutputAssembly.cpp	/^pair<shared_ptr<AbstractAssembly>, AbstractAssembly::SubID> NoOutputAssembly::createSubAssembly()$/;"	f	class:NoOutputAssembly	signature:()
createTupleDecl	libsolidity/analysis/TypeChecker.cpp	/^string createTupleDecl(vector<ASTPointer<VariableDeclaration>> const& _decls)$/;"	f	namespace:__anon10	signature:(vector<ASTPointer<VariableDeclaration>> const& _decls)
createVariable	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::createVariable(VariableDeclaration const& _varDecl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _varDecl)
createVariable	libsolidity/formal/SMTChecker.h	/^	bool createVariable(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _varDecl)
createWithLocation	libyul/AsmParser.h	/^	template <class T> T createWithLocation(langutil::SourceLocation const& _loc = {}) const$/;"	f	class:yul::Parser	access:protected	signature:(langutil::SourceLocation const& _loc = {}) const
cropped	libdevcore/vector_ref.h	/^	vector_ref<_T> cropped(size_t _begin) const { if (m_data && _begin <= m_count) return vector_ref<_T>(m_data + _begin, m_count - _begin); else return vector_ref<_T>(); }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _begin) const
cropped	libdevcore/vector_ref.h	/^	vector_ref<_T> cropped(size_t _begin, size_t _count) const { if (m_data && _begin <= m_count && _count <= m_count && _begin + _count <= m_count) return vector_ref<_T>(m_data + _begin, _count == ~size_t(0) ? m_count - _begin : _count); else return vector_ref<_T>(); }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _begin, size_t _count) const
currentCanonicalName	libsolidity/analysis/NameAndTypeResolver.cpp	/^string DeclarationRegistrationHelper::currentCanonicalName() const$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:() const
currentCanonicalName	libsolidity/analysis/NameAndTypeResolver.h	/^	std::string currentCanonicalName() const;$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:() const
currentChar	libsolidity/analysis/SemVerHandler.cpp	/^char SemVerMatchExpressionParser::currentChar() const$/;"	f	class:SemVerMatchExpressionParser	signature:() const
currentChar	libsolidity/analysis/SemVerHandler.h	/^	char currentChar() const;$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:() const
currentCommentLiteral	liblangutil/Scanner.h	/^	std::string const& currentCommentLiteral() const { return m_skippedComment.literal; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
currentCommentLocation	liblangutil/Scanner.h	/^	SourceLocation currentCommentLocation() const { return m_skippedComment.location; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
currentElementaryTypeNameToken	liblangutil/Scanner.h	/^	ElementaryTypeNameToken currentElementaryTypeNameToken() const$/;"	f	class:langutil::Scanner	access:public	signature:() const
currentFuncDef	solse/SymExecEngine.h	/^    dev::solidity::FunctionDefinition const* currentFuncDef;$/;"	m	class:SymExecEngine::dev::solidity	access:private
currentLiteral	liblangutil/ParserBase.cpp	/^std::string ParserBase::currentLiteral() const$/;"	f	class:ParserBase	signature:() const
currentLiteral	liblangutil/ParserBase.h	/^	std::string currentLiteral() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
currentLiteral	liblangutil/Scanner.h	/^	std::string const& currentLiteral() const { return m_currentToken.literal; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
currentLocation	liblangutil/Scanner.h	/^	SourceLocation currentLocation() const { return m_currentToken.location; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
currentName	libsolidity/formal/SymbolicVariables.cpp	/^string SymbolicVariable::currentName() const$/;"	f	class:SymbolicVariable	signature:() const
currentName	libsolidity/formal/SymbolicVariables.h	/^	std::string currentName() const;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:() const
currentPathConditions	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::currentPathConditions()$/;"	f	class:SMTChecker	signature:()
currentPathConditions	libsolidity/formal/SMTChecker.h	/^	smt::Expression currentPathConditions();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
currentSuper	libsolidity/analysis/GlobalContext.cpp	/^MagicVariableDeclaration const* GlobalContext::currentSuper() const$/;"	f	class:dev::solidity::GlobalContext	signature:() const
currentSuper	libsolidity/analysis/GlobalContext.h	/^	MagicVariableDeclaration const* currentSuper() const;$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:() const
currentThis	libsolidity/analysis/GlobalContext.cpp	/^MagicVariableDeclaration const* GlobalContext::currentThis() const$/;"	f	class:dev::solidity::GlobalContext	signature:() const
currentThis	libsolidity/analysis/GlobalContext.h	/^	MagicVariableDeclaration const* currentThis() const;$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:() const
currentToBaseStackOffset	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::currentToBaseStackOffset(unsigned _offset) const$/;"	f	class:dev::solidity::CompilerContext	signature:(unsigned _offset) const
currentToBaseStackOffset	libsolidity/codegen/CompilerContext.h	/^	unsigned currentToBaseStackOffset(unsigned _offset) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(unsigned _offset) const
currentToken	liblangutil/ParserBase.cpp	/^Token ParserBase::currentToken() const$/;"	f	class:ParserBase	signature:() const
currentToken	liblangutil/ParserBase.h	/^	Token currentToken() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
currentToken	liblangutil/Scanner.h	/^	Token currentToken() const$/;"	f	class:langutil::Scanner	access:public	signature:() const
currentToken	libsolidity/analysis/SemVerHandler.cpp	/^Token SemVerMatchExpressionParser::currentToken() const$/;"	f	class:SemVerMatchExpressionParser	signature:() const
currentToken	libsolidity/analysis/SemVerHandler.h	/^	Token currentToken() const;$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:() const
currentTokenInfo	liblangutil/Scanner.h	/^	std::tuple<unsigned, unsigned> const& currentTokenInfo() const { return m_currentToken.extendedTokenInfo; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
currentValue	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::currentValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
currentValue	libsolidity/formal/SMTChecker.h	/^	smt::Expression currentValue(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
currentValue	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicVariable::currentValue() const$/;"	f	class:SymbolicVariable	signature:() const
currentValue	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression currentValue() const;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:() const
cvc4Sort	libsolidity/formal/CVC4Interface.cpp	/^CVC4::Type CVC4Interface::cvc4Sort(Sort const& _sort)$/;"	f	class:CVC4Interface	signature:(Sort const& _sort)
cvc4Sort	libsolidity/formal/CVC4Interface.cpp	/^vector<CVC4::Type> CVC4Interface::cvc4Sort(vector<SortPointer> const& _sorts)$/;"	f	class:CVC4Interface	signature:(vector<SortPointer> const& _sorts)
cvc4Sort	libsolidity/formal/CVC4Interface.h	/^	CVC4::Type cvc4Sort(smt::Sort const& _sort);$/;"	p	class:dev::solidity::smt::CVC4Interface	access:private	signature:(smt::Sort const& _sort)
cvc4Sort	libsolidity/formal/CVC4Interface.h	/^	std::vector<CVC4::Type> cvc4Sort(std::vector<smt::SortPointer> const& _sorts);$/;"	p	class:dev::solidity::smt::CVC4Interface	access:private	signature:(std::vector<smt::SortPointer> const& _sorts)
d	libevmasm/SimplificationRules.h	/^	u256 const& d() const { return matchGroupValue().item->data(); }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
d	libyul/optimiser/SimplificationRules.cpp	/^u256 Pattern::d() const$/;"	f	class:Pattern	signature:() const
d	libyul/optimiser/SimplificationRules.h	/^	dev::u256 d() const;$/;"	p	class:yul::Pattern	access:public	signature:() const
data	libdevcore/FixedHash.h	/^	uint8_t const* data() const { return m_data.data(); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
data	libdevcore/FixedHash.h	/^	uint8_t* data() { return m_data.data(); }$/;"	f	class:dev::FixedHash	access:public	signature:()
data	libdevcore/vector_ref.h	/^	_T* data() const { return m_data; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
data	libevmasm/Assembly.h	/^	bytes const& data(h256 const& _i) const { return m_data.at(_i); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(h256 const& _i) const
data	libevmasm/AssemblyItem.h	/^	u256 const& data() const { assertThrow(m_type != Operation, Exception, ""); return *m_data; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
data	libevmasm/SimplificationRules.cpp	/^u256 const& Pattern::data() const$/;"	f	class:Pattern	signature:() const
data	libevmasm/SimplificationRules.h	/^	u256 const& data() const;$/;"	p	class:dev::eth::Pattern	access:private	signature:() const
data	libyul/Object.h	/^	dev::bytes data;$/;"	m	struct:yul::Data	access:public
dataGas	libevmasm/ConstantOptimiser.cpp	/^bigint ConstantOptimisationMethod::dataGas(bytes const& _data) const$/;"	f	class:ConstantOptimisationMethod	signature:(bytes const& _data) const
dataGas	libevmasm/ConstantOptimiser.h	/^	bigint dataGas(bytes const& _data) const;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(bytes const& _data) const
dataGas	libevmasm/GasMeter.cpp	/^u256 GasMeter::dataGas(bytes const& _data, bool _inCreation)$/;"	f	class:GasMeter	signature:(bytes const& _data, bool _inCreation)
dataGas	libevmasm/GasMeter.h	/^	static u256 dataGas(bytes const& _data, bool _inCreation);$/;"	p	class:dev::eth::GasMeter	access:public	signature:(bytes const& _data, bool _inCreation)
dataStartOffset	libsolidity/codegen/CompilerUtils.cpp	/^unsigned const CompilerUtils::dataStartOffset = 4;$/;"	m	class:dev::solidity::CompilerUtils	file:
dataStartOffset	libsolidity/codegen/CompilerUtils.h	/^	static unsigned const dataStartOffset;$/;"	m	class:dev::solidity::CompilerUtils	access:public
dataStoredIn	libsolidity/ast/Types.h	/^	virtual bool dataStoredIn(DataLocation) const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:(DataLocation) const
debugMode	solse/SolidityExprTranslator.h	/^    bool debugMode;$/;"	m	class:ContextInfo	access:private
debugMode	solse/SolidityExprTranslator.h	/^    bool debugMode;$/;"	m	class:SolidityExprTranslator	access:private
debugMode	solse/SymExecEngine.h	/^    bool debugMode;$/;"	m	class:SymExecEngine	access:private
declaration	libsolidity/analysis/ControlFlowGraph.h	/^	VariableDeclaration const& declaration() const { return m_declaration; }$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:() const
declaration	libsolidity/ast/ASTAnnotations.h	/^		Declaration const* declaration = nullptr;$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
declaration	libsolidity/ast/Types.h	/^		Declaration const* declaration = nullptr;$/;"	m	struct:dev::solidity::MemberList::Member	access:public
declaration	libsolidity/ast/Types.h	/^	Declaration const& declaration() const$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
declarationError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::declarationError(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
declarationError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::declarationError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
declarationError	liblangutil/ErrorReporter.h	/^	void declarationError($/;"	p	class:langutil::ErrorReporter	access:public	signature:( SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, std::string const& _description )
declarationError	liblangutil/ErrorReporter.h	/^	void declarationError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
declarationError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::declarationError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
declarationError	libsolidity/analysis/ReferencesResolver.h	/^	void declarationError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
declarations	libsolidity/analysis/DeclarationContainer.h	/^	std::map<ASTString, std::vector<Declaration const*>> const& declarations() const { return m_declarations; }$/;"	f	class:dev::solidity::DeclarationContainer::std	access:public	signature:() const
declarations	libsolidity/analysis/GlobalContext.cpp	/^vector<Declaration const*> GlobalContext::declarations() const$/;"	f	class:dev::solidity::GlobalContext	signature:() const
declarations	libsolidity/analysis/GlobalContext.h	/^	std::vector<Declaration const*> declarations() const;$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:() const
declarations	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& declarations() const { return m_variables; }$/;"	f	class:dev::solidity::VariableDeclarationStatement::std	access:public	signature:() const
declareFunction	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::declareFunction(string const& _name, Sort const& _sort)$/;"	f	class:SMTLib2Interface	signature:(string const& _name, Sort const& _sort)
declareFunction	libsolidity/formal/SMTLib2Interface.h	/^	void declareFunction(std::string const&, Sort const&);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string const&, Sort const&)
declareFunction	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::declareFunction(string const& _name, Sort const& _sort)$/;"	f	class:Z3Interface	signature:(string const& _name, Sort const& _sort)
declareFunction	libsolidity/formal/Z3Interface.h	/^	void declareFunction(std::string const& _name, Sort const& _sort);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(std::string const& _name, Sort const& _sort)
declareVariable	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:CVC4Interface	signature:(string const& _name, Sort const& _sort)
declareVariable	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:SMTLib2Interface	signature:(string const& _name, Sort const& _sort)
declareVariable	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:SMTPortfolio	signature:(string const& _name, Sort const& _sort)
declareVariable	libsolidity/formal/SolverInterface.h	/^	virtual void declareVariable(std::string const& _name, Sort const& _sort) = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:(std::string const& _name, Sort const& _sort)
declareVariable	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::declareVariable(string const& _name, Sort const& _sort)$/;"	f	class:Z3Interface	signature:(string const& _name, Sort const& _sort)
decodingType	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::decodingType() const$/;"	f	class:ArrayType	signature:() const
decodingType	libsolidity/ast/Types.h	/^	virtual TypePointer decodingType() const { return encodingType(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
decreaseRecursionDepth	liblangutil/ParserBase.cpp	/^void ParserBase::decreaseRecursionDepth()$/;"	f	class:ParserBase	signature:()
decreaseRecursionDepth	liblangutil/ParserBase.h	/^	void decreaseRecursionDepth();$/;"	p	class:langutil::ParserBase	access:protected	signature:()
decreaseReference	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::decreaseReference(YulString, Scope::Variable const& _var)$/;"	f	class:CodeTransform	signature:(YulString, Scope::Variable const& _var)
decreaseReference	libyul/backends/evm/EVMCodeTransform.h	/^	void decreaseReference(YulString _name, Scope::Variable const& _var);$/;"	p	class:yul::CodeTransform	access:protected	signature:(YulString _name, Scope::Variable const& _var)
decrementLatestStatementPointer	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::decrementLatestStatementPointer()$/;"	f	class:ExpressionJoiner	signature:()
decrementLatestStatementPointer	libyul/optimiser/ExpressionJoiner.h	/^	void decrementLatestStatementPointer();$/;"	p	class:yul::ExpressionJoiner	access:private	signature:()
deduplicate	libevmasm/BlockDeduplicator.cpp	/^bool BlockDeduplicator::deduplicate()$/;"	f	class:BlockDeduplicator	signature:()
deduplicate	libevmasm/BlockDeduplicator.h	/^	bool deduplicate();$/;"	p	class:dev::eth::BlockDeduplicator	access:public	signature:()
defaultVisibility	libsolidity/ast/AST.h	/^	virtual Visibility defaultVisibility() const { return Visibility::Public; }$/;"	f	class:dev::solidity::Declaration	access:protected	signature:() const
defineExpr	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::defineExpr(Expression const& _e, smt::Expression _value)$/;"	f	class:SMTChecker	signature:(Expression const& _e, smt::Expression _value)
defineExpr	libsolidity/formal/SMTChecker.h	/^	void defineExpr(Expression const& _e, smt::Expression _value);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e, smt::Expression _value)
defineGlobalFunction	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::defineGlobalFunction(string const& _name, Expression const& _expr)$/;"	f	class:SMTChecker	signature:(string const& _name, Expression const& _expr)
defineGlobalFunction	libsolidity/formal/SMTChecker.h	/^	void defineGlobalFunction(std::string const& _name, Expression const& _expr);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::string const& _name, Expression const& _expr)
defineGlobalVariable	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::defineGlobalVariable(string const& _name, Expression const& _expr, bool _increaseIndex)$/;"	f	class:SMTChecker	signature:(string const& _name, Expression const& _expr, bool _increaseIndex)
defineGlobalVariable	libsolidity/formal/SMTChecker.h	/^	void defineGlobalVariable(std::string const& _name, Expression const& _expr, bool _increaseIndex = false);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::string const& _name, Expression const& _expr, bool _increaseIndex = false)
definedEnums	libsolidity/ast/AST.h	/^	std::vector<EnumDefinition const*> definedEnums() const { return filteredNodes<EnumDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
definedFunctions	libsolidity/ast/AST.h	/^	std::vector<FunctionDefinition const*> definedFunctions() const { return filteredNodes<FunctionDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
definedStructs	libsolidity/ast/AST.h	/^	std::vector<StructDefinition const*> definedStructs() const { return filteredNodes<StructDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
deleteVariable	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::deleteVariable(Scope::Variable const& _var)$/;"	f	class:CodeTransform	signature:(Scope::Variable const& _var)
deleteVariable	libyul/backends/evm/EVMCodeTransform.h	/^	void deleteVariable(Scope::Variable const& _var);$/;"	p	class:yul::CodeTransform	access:protected	signature:(Scope::Variable const& _var)
deployLibrary	libsolidity/codegen/ContractCompiler.cpp	/^size_t ContractCompiler::deployLibrary(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
deployLibrary	libsolidity/codegen/ContractCompiler.h	/^	size_t deployLibrary(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
deposit	libevmasm/Assembly.h	/^	int deposit() const { return m_deposit; }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
deposit	libevmasm/AssemblyItem.h	/^	int deposit() const { return returnValues() - arguments(); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
depth	libyul/backends/evm/EVMCodeTransform.h	/^	int depth;$/;"	m	struct:yul::StackTooDeepError	access:public
dereference	libsolidity/analysis/TypeChecker.cpp	/^Declaration const& TypeChecker::dereference(Identifier const& _identifier) const$/;"	f	class:TypeChecker	signature:(Identifier const& _identifier) const
dereference	libsolidity/analysis/TypeChecker.cpp	/^Declaration const& TypeChecker::dereference(UserDefinedTypeName const& _typeName) const$/;"	f	class:TypeChecker	signature:(UserDefinedTypeName const& _typeName) const
dereference	libsolidity/analysis/TypeChecker.h	/^	Declaration const& dereference(Identifier const& _identifier) const;$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Identifier const& _identifier) const
dereference	libsolidity/analysis/TypeChecker.h	/^	Declaration const& dereference(UserDefinedTypeName const& _typeName) const;$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(UserDefinedTypeName const& _typeName) const
detail	libdevcore/CommonData.h	/^namespace detail$/;"	n	namespace:dev
dev	libdevcore/Algorithms.h	/^namespace dev$/;"	n
dev	libdevcore/AnsiColorized.h	/^namespace dev$/;"	n
dev	libdevcore/Assertions.h	/^namespace dev$/;"	n
dev	libdevcore/Common.h	/^namespace dev$/;"	n
dev	libdevcore/CommonData.h	/^namespace dev$/;"	n
dev	libdevcore/CommonIO.h	/^namespace dev$/;"	n
dev	libdevcore/Exceptions.h	/^namespace dev$/;"	n
dev	libdevcore/FixedHash.h	/^namespace dev$/;"	n
dev	libdevcore/IndentedWriter.h	/^namespace dev$/;"	n
dev	libdevcore/JSON.cpp	/^namespace dev$/;"	n	file:
dev	libdevcore/JSON.h	/^namespace dev {$/;"	n
dev	libdevcore/Keccak256.cpp	/^namespace dev$/;"	n	file:
dev	libdevcore/Keccak256.h	/^namespace dev$/;"	n
dev	libdevcore/Result.h	/^namespace dev$/;"	n
dev	libdevcore/StringUtils.h	/^namespace dev$/;"	n
dev	libdevcore/SwarmHash.h	/^namespace dev$/;"	n
dev	libdevcore/UTF8.cpp	/^namespace dev$/;"	n	file:
dev	libdevcore/UTF8.h	/^namespace dev$/;"	n
dev	libdevcore/Visitor.h	/^namespace dev$/;"	n
dev	libdevcore/Whiskers.h	/^namespace dev$/;"	n
dev	libdevcore/vector_ref.h	/^namespace dev$/;"	n
dev	libevmasm/Assembly.h	/^namespace dev$/;"	n
dev	libevmasm/AssemblyItem.h	/^namespace dev$/;"	n
dev	libevmasm/BlockDeduplicator.h	/^namespace dev$/;"	n
dev	libevmasm/CommonSubexpressionEliminator.h	/^namespace dev$/;"	n
dev	libevmasm/ConstantOptimiser.h	/^namespace dev$/;"	n
dev	libevmasm/ControlFlowGraph.h	/^namespace dev$/;"	n
dev	libevmasm/Exceptions.h	/^namespace dev$/;"	n
dev	libevmasm/ExpressionClasses.h	/^namespace dev$/;"	n
dev	libevmasm/GasMeter.h	/^namespace dev$/;"	n
dev	libevmasm/Instruction.h	/^namespace dev$/;"	n
dev	libevmasm/JumpdestRemover.h	/^namespace dev$/;"	n
dev	libevmasm/KnownState.h	/^namespace dev$/;"	n
dev	libevmasm/LinkerObject.h	/^namespace dev$/;"	n
dev	libevmasm/PathGasMeter.h	/^namespace dev$/;"	n
dev	libevmasm/PeepholeOptimiser.h	/^namespace dev$/;"	n
dev	libevmasm/RuleList.h	/^namespace dev$/;"	n
dev	libevmasm/SemanticInformation.h	/^namespace dev$/;"	n
dev	libevmasm/SimplificationRule.h	/^namespace dev$/;"	n
dev	libevmasm/SimplificationRules.h	/^namespace dev$/;"	n
dev	liblangutil/SourceReferenceExtractor.h	/^namespace dev$/;"	n
dev	liblangutil/SourceReferenceFormatter.h	/^namespace dev$/;"	n
dev	liblangutil/SourceReferenceFormatterHuman.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ConstantEvaluator.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ContractLevelChecker.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ControlFlowAnalyzer.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ControlFlowBuilder.h	/^namespace dev {$/;"	n
dev	libsolidity/analysis/ControlFlowGraph.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ControlFlowPrinter.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/DeclarationContainer.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/DocStringAnalyser.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/GlobalContext.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/analysis/GlobalContext.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/NameAndTypeResolver.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/analysis/NameAndTypeResolver.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/PostTypeChecker.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ReferencesResolver.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/analysis/ReferencesResolver.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/SemVerHandler.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/StaticAnalyzer.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/SyntaxChecker.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/TypeChecker.h	/^namespace dev$/;"	n
dev	libsolidity/analysis/ViewPureChecker.h	/^namespace dev$/;"	n
dev	libsolidity/ast/AST.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ASTAnnotations.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ASTEnums.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ASTForward.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ASTJsonConverter.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/ast/ASTJsonConverter.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ASTPrinter.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/ast/ASTPrinter.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ASTVisitor.h	/^namespace dev$/;"	n
dev	libsolidity/ast/AST_accept.h	/^namespace dev$/;"	n
dev	libsolidity/ast/ExperimentalFeatures.h	/^namespace dev$/;"	n
dev	libsolidity/ast/Types.h	/^namespace dev$/;"	n
dev	libsolidity/codegen/ABIFunctions.h	/^namespace dev {$/;"	n
dev	libsolidity/codegen/ArrayUtils.h	/^namespace dev$/;"	n
dev	libsolidity/codegen/Compiler.h	/^namespace dev {$/;"	n
dev	libsolidity/codegen/CompilerContext.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/codegen/CompilerContext.h	/^namespace dev {$/;"	n
dev	libsolidity/codegen/CompilerUtils.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/codegen/CompilerUtils.h	/^namespace dev {$/;"	n
dev	libsolidity/codegen/ContractCompiler.h	/^namespace dev$/;"	n
dev	libsolidity/codegen/ExpressionCompiler.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/codegen/ExpressionCompiler.h	/^namespace dev {$/;"	n
dev	libsolidity/codegen/LValue.h	/^namespace dev$/;"	n
dev	libsolidity/formal/CVC4Interface.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SMTChecker.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SMTLib2Interface.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SMTPortfolio.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SSAVariable.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SolverInterface.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SymbolicTypes.h	/^namespace dev$/;"	n
dev	libsolidity/formal/SymbolicVariables.h	/^namespace dev$/;"	n
dev	libsolidity/formal/VariableUsage.h	/^namespace dev$/;"	n
dev	libsolidity/formal/Z3Interface.h	/^namespace dev$/;"	n
dev	libsolidity/interface/ABI.h	/^namespace dev$/;"	n
dev	libsolidity/interface/CompilerStack.h	/^namespace dev$/;"	n
dev	libsolidity/interface/GasEstimator.h	/^namespace dev$/;"	n
dev	libsolidity/interface/Natspec.h	/^namespace dev$/;"	n
dev	libsolidity/interface/OptimiserSettings.h	/^namespace dev$/;"	n
dev	libsolidity/interface/ReadFile.h	/^namespace dev$/;"	n
dev	libsolidity/interface/StandardCompiler.h	/^namespace dev$/;"	n
dev	libsolidity/interface/Version.h	/^namespace dev$/;"	n
dev	libsolidity/parsing/DocStringParser.h	/^namespace dev$/;"	n
dev	libsolidity/parsing/Parser.cpp	/^namespace dev$/;"	n	file:
dev	libsolidity/parsing/Parser.h	/^namespace dev$/;"	n
dev	libsolidity/parsing/Token.h	/^namespace dev$/;"	n
dev	libyul/backends/evm/AbstractAssembly.h	/^namespace dev$/;"	n
dev	libyul/backends/evm/AsmCodeGen.h	/^namespace dev$/;"	n
dev	solse/CommandLineInterface.cpp	/^namespace dev$/;"	n	file:
dev	solse/CommandLineInterface.h	/^namespace dev$/;"	n
dev::AnsiColorized	libdevcore/AnsiColorized.h	/^class AnsiColorized$/;"	c	namespace:dev
dev::AnsiColorized::AnsiColorized	libdevcore/AnsiColorized.h	/^	AnsiColorized(std::ostream& _os, bool const _enabled, std::vector<char const*>&& _formatting):$/;"	f	class:dev::AnsiColorized	access:public	signature:(std::ostream& _os, bool const _enabled, std::vector<char const*>&& _formatting)
dev::AnsiColorized::m_codes	libdevcore/AnsiColorized.h	/^	std::vector<char const*> m_codes;$/;"	m	class:dev::AnsiColorized	access:private
dev::AnsiColorized::m_enabled	libdevcore/AnsiColorized.h	/^	bool m_enabled;$/;"	m	class:dev::AnsiColorized	access:private
dev::AnsiColorized::m_stream	libdevcore/AnsiColorized.h	/^	std::ostream& m_stream;$/;"	m	class:dev::AnsiColorized	access:private
dev::AnsiColorized::operator <<	libdevcore/AnsiColorized.h	/^	std::ostream& operator<<(T&& _t)$/;"	f	class:dev::AnsiColorized	access:public	signature:(T&& _t)
dev::AnsiColorized::~AnsiColorized	libdevcore/AnsiColorized.h	/^	~AnsiColorized()$/;"	f	class:dev::AnsiColorized	access:public	signature:()
dev::BreadthFirstSearch	libdevcore/Algorithms.h	/^struct BreadthFirstSearch$/;"	s	namespace:dev
dev::BreadthFirstSearch::run	libdevcore/Algorithms.h	/^	BreadthFirstSearch& run(ForEachChild&& _forEachChild)$/;"	f	struct:dev::BreadthFirstSearch	access:public	signature:(ForEachChild&& _forEachChild)
dev::BreadthFirstSearch::verticesToTraverse	libdevcore/Algorithms.h	/^	std::set<V const*> verticesToTraverse;$/;"	m	struct:dev::BreadthFirstSearch	access:public
dev::CycleDetector	libdevcore/Algorithms.h	/^class CycleDetector$/;"	c	namespace:dev
dev::CycleDetector::CycleDetector	libdevcore/Algorithms.h	/^	explicit CycleDetector(Visitor _visit):$/;"	f	class:dev::CycleDetector	access:public	signature:(Visitor _visit)
dev::CycleDetector::m_depth	libdevcore/Algorithms.h	/^	size_t m_depth = 0;$/;"	m	class:dev::CycleDetector	access:private
dev::CycleDetector::m_firstCycleVertex	libdevcore/Algorithms.h	/^	V const* m_firstCycleVertex = nullptr;$/;"	m	class:dev::CycleDetector	access:private
dev::CycleDetector::m_processed	libdevcore/Algorithms.h	/^	std::set<V const*> m_processed;$/;"	m	class:dev::CycleDetector	access:private
dev::CycleDetector::m_processing	libdevcore/Algorithms.h	/^	std::set<V const*> m_processing;$/;"	m	class:dev::CycleDetector	access:private
dev::CycleDetector::m_visit	libdevcore/Algorithms.h	/^	Visitor m_visit;$/;"	m	class:dev::CycleDetector	access:private
dev::CycleDetector::run	libdevcore/Algorithms.h	/^	V const* run(V const& _vertex)$/;"	f	class:dev::CycleDetector	access:public	signature:(V const& _vertex)
dev::DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	/^DEV_SIMPLE_EXCEPTION(BadHexCharacter);$/;"	p	namespace:dev	signature:(BadHexCharacter)
dev::DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	/^DEV_SIMPLE_EXCEPTION(FileError);$/;"	p	namespace:dev	signature:(FileError)
dev::DEV_SIMPLE_EXCEPTION	libdevcore/Exceptions.h	/^DEV_SIMPLE_EXCEPTION(InvalidAddress);$/;"	p	namespace:dev	signature:(InvalidAddress)
dev::DEV_SIMPLE_EXCEPTION	libdevcore/IndentedWriter.h	/^DEV_SIMPLE_EXCEPTION(IndentedWriterError);$/;"	p	namespace:dev	signature:(IndentedWriterError)
dev::DEV_SIMPLE_EXCEPTION	libdevcore/Whiskers.h	/^DEV_SIMPLE_EXCEPTION(WhiskersError);$/;"	p	namespace:dev	signature:(WhiskersError)
dev::Exception	libdevcore/Exceptions.h	/^struct Exception: virtual std::exception, virtual boost::exception$/;"	s	namespace:dev	inherits:std::exception,boost::exception
dev::Exception::lineInfo	libdevcore/Exceptions.h	/^	std::string lineInfo() const;$/;"	p	struct:dev::Exception	access:public	signature:() const
dev::Exception::noexcept	libdevcore/Exceptions.h	/^	std::string const* comment() const noexcept;$/;"	m	struct:dev::Exception	access:public
dev::Exception::override	libdevcore/Exceptions.h	/^	char const* what() const noexcept override;$/;"	m	struct:dev::Exception	access:public
dev::FixedHash	libdevcore/FixedHash.h	/^class FixedHash$/;"	c	namespace:dev
dev::FixedHash::AlignLeft	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	e	enum:dev::FixedHash::ConstructFromHashType
dev::FixedHash::AlignRight	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	e	enum:dev::FixedHash::ConstructFromHashType
dev::FixedHash::ConstructFromHashType	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	g	class:dev::FixedHash	access:public
dev::FixedHash::ConstructFromStringType	libdevcore/FixedHash.h	/^	enum ConstructFromStringType { FromHex, FromBinary };$/;"	g	class:dev::FixedHash	access:public
dev::FixedHash::FailIfDifferent	libdevcore/FixedHash.h	/^	enum ConstructFromHashType { AlignLeft, AlignRight, FailIfDifferent };$/;"	e	enum:dev::FixedHash::ConstructFromHashType
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	FixedHash(Arith const& _arith) { toBigEndian(_arith, m_data); }$/;"	f	class:dev::FixedHash	access:public	signature:(Arith const& _arith)
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash() { m_data.fill(0); }$/;"	f	class:dev::FixedHash	access:public	signature:()
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(bytes const& _b, ConstructFromHashType _t = FailIfDifferent) { if (_b.size() == N) memcpy(m_data.data(), _b.data(), std::min<unsigned>(_b.size(), N)); else { m_data.fill(0); if (_t != FailIfDifferent) { auto c = std::min<unsigned>(_b.size(), N); for (unsigned i = 0; i < c; ++i) m_data[_t == AlignRight ? N - 1 - i : i] = _b[_t == AlignRight ? _b.size() - 1 - i : i]; } } }$/;"	f	class:dev::FixedHash	access:public	signature:(bytes const& _b, ConstructFromHashType _t = FailIfDifferent)
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(bytesConstRef _b, ConstructFromHashType _t = FailIfDifferent) { if (_b.size() == N) memcpy(m_data.data(), _b.data(), std::min<unsigned>(_b.size(), N)); else { m_data.fill(0); if (_t != FailIfDifferent) { auto c = std::min<unsigned>(_b.size(), N); for (unsigned i = 0; i < c; ++i) m_data[_t == AlignRight ? N - 1 - i : i] = _b[_t == AlignRight ? _b.size() - 1 - i : i]; } } }$/;"	f	class:dev::FixedHash	access:public	signature:(bytesConstRef _b, ConstructFromHashType _t = FailIfDifferent)
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(std::string const& _s, ConstructFromStringType _t = FromHex, ConstructFromHashType _ht = FailIfDifferent): FixedHash(_t == FromHex ? fromHex(_s, WhenError::Throw) : dev::asBytes(_s), _ht) {}$/;"	f	class:dev::FixedHash	access:public	signature:(std::string const& _s, ConstructFromStringType _t = FromHex, ConstructFromHashType _ht = FailIfDifferent)
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	explicit FixedHash(unsigned _u) { toBigEndian(_u, m_data); }$/;"	f	class:dev::FixedHash	access:public	signature:(unsigned _u)
dev::FixedHash::FixedHash	libdevcore/FixedHash.h	/^	template <unsigned M> explicit FixedHash(FixedHash<M> const& _h, ConstructFromHashType _t = AlignLeft) { m_data.fill(0); unsigned c = std::min(M, N); for (unsigned i = 0; i < c; ++i) m_data[_t == AlignRight ? N - 1 - i : i] = _h[_t == AlignRight ? M - 1 - i : i]; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash<M> const& _h, ConstructFromHashType _t = AlignLeft)
dev::FixedHash::FromBinary	libdevcore/FixedHash.h	/^	enum ConstructFromStringType { FromHex, FromBinary };$/;"	e	enum:dev::FixedHash::ConstructFromStringType
dev::FixedHash::FromHex	libdevcore/FixedHash.h	/^	enum ConstructFromStringType { FromHex, FromBinary };$/;"	e	enum:dev::FixedHash::ConstructFromStringType
dev::FixedHash::asArray	libdevcore/FixedHash.h	/^	std::array<uint8_t, N>& asArray() { return m_data; }$/;"	f	class:dev::FixedHash	access:public	signature:()
dev::FixedHash::asBytes	libdevcore/FixedHash.h	/^	bytes asBytes() const { return bytes(data(), data() + N); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::clear	libdevcore/FixedHash.h	/^	void clear() { m_data.fill(0); }$/;"	f	class:dev::FixedHash	access:public	signature:()
dev::FixedHash::data	libdevcore/FixedHash.h	/^	uint8_t const* data() const { return m_data.data(); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::data	libdevcore/FixedHash.h	/^	uint8_t* data() { return m_data.data(); }$/;"	f	class:dev::FixedHash	access:public	signature:()
dev::FixedHash::firstBitSet	libdevcore/FixedHash.h	/^	inline unsigned firstBitSet() const$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::hex	libdevcore/FixedHash.h	/^	std::string hex() const { return toHex(asBytes()); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::m_data	libdevcore/FixedHash.h	/^	std::array<uint8_t, N> m_data;		\/\/\/< The binary data.$/;"	m	class:dev::FixedHash	access:private
dev::FixedHash::operator !=	libdevcore/FixedHash.h	/^	bool operator!=(FixedHash const& _c) const { return m_data != _c.m_data; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash const& _c) const
dev::FixedHash::operator <	libdevcore/FixedHash.h	/^	bool operator<(FixedHash const& _c) const { for (unsigned i = 0; i < N; ++i) if (m_data[i] < _c.m_data[i]) return true; else if (m_data[i] > _c.m_data[i]) return false; return false; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash const& _c) const
dev::FixedHash::operator ==	libdevcore/FixedHash.h	/^	bool operator==(FixedHash const& _c) const { return m_data == _c.m_data; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash const& _c) const
dev::FixedHash::operator Arith	libdevcore/FixedHash.h	/^	operator Arith() const { return fromBigEndian<Arith>(m_data); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::operator []	libdevcore/FixedHash.h	/^	uint8_t operator[](unsigned _i) const { return m_data[_i]; }$/;"	f	class:dev::FixedHash	access:public	signature:(unsigned _i) const
dev::FixedHash::operator []	libdevcore/FixedHash.h	/^	uint8_t& operator[](unsigned _i) { return m_data[_i]; }$/;"	f	class:dev::FixedHash	access:public	signature:(unsigned _i)
dev::FixedHash::operator bool	libdevcore/FixedHash.h	/^	explicit operator bool() const { return std::any_of(m_data.begin(), m_data.end(), [](uint8_t _b) { return _b != 0; }); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::operator ~	libdevcore/FixedHash.h	/^	FixedHash operator~() const { FixedHash ret; for (unsigned i = 0; i < N; ++i) ret[i] = ~m_data[i]; return ret; }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::ref	libdevcore/FixedHash.h	/^	bytesConstRef ref() const { return bytesConstRef(m_data.data(), N); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
dev::FixedHash::ref	libdevcore/FixedHash.h	/^	bytesRef ref() { return bytesRef(m_data.data(), N); }$/;"	f	class:dev::FixedHash	access:public	signature:()
dev::FixedHash::size	libdevcore/FixedHash.h	/^	enum { size = N };$/;"	e	enum:dev::FixedHash::__anon20
dev::FixedHash::std::asArray	libdevcore/FixedHash.h	/^	std::array<uint8_t, N> const& asArray() const { return m_data; }$/;"	f	class:dev::FixedHash::std	access:public	signature:() const
dev::GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^struct GenericFallbackReturnsVisitor<R, Visitable, Others...>: public GenericFallbackReturnsVisitor<R, Others...>$/;"	s	namespace:dev	inherits:GenericFallbackReturnsVisitor
dev::GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^struct GenericFallbackReturnsVisitor<R>: public boost::static_visitor<R> {$/;"	s	namespace:dev	inherits:boost::static_visitor
dev::GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^struct GenericFallbackReturnsVisitor{};$/;"	s	namespace:dev
dev::GenericFallbackReturnsVisitor::GenericFallbackReturnsVisitor	libdevcore/Visitor.h	/^	explicit GenericFallbackReturnsVisitor($/;"	f	struct:dev::GenericFallbackReturnsVisitor	access:public	signature:( std::function<R(Visitable&)> _visitor, std::function<R(Others&)>... _otherVisitors )
dev::GenericFallbackReturnsVisitor::m_visitor	libdevcore/Visitor.h	/^	std::function<R(Visitable&)> m_visitor;$/;"	m	struct:dev::GenericFallbackReturnsVisitor	access:public
dev::GenericFallbackReturnsVisitor::operator ()	libdevcore/Visitor.h	/^	R operator()(T&) const { return {}; }$/;"	f	struct:dev::GenericFallbackReturnsVisitor	access:public	signature:(T&) const
dev::GenericFallbackReturnsVisitor::operator ()	libdevcore/Visitor.h	/^	R operator()(Visitable& _v) const { return m_visitor(_v); }$/;"	f	struct:dev::GenericFallbackReturnsVisitor	access:public	signature:(Visitable& _v) const
dev::GenericFallbackVisitor	libdevcore/Visitor.h	/^struct GenericFallbackVisitor<>: public boost::static_visitor<> {$/;"	s	namespace:dev	inherits:boost::static_visitor
dev::GenericFallbackVisitor	libdevcore/Visitor.h	/^struct GenericFallbackVisitor<Visitable, Others...>: public GenericFallbackVisitor<Others...>$/;"	s	namespace:dev	inherits:GenericFallbackVisitor
dev::GenericFallbackVisitor	libdevcore/Visitor.h	/^struct GenericFallbackVisitor{};$/;"	s	namespace:dev
dev::GenericFallbackVisitor::GenericFallbackVisitor	libdevcore/Visitor.h	/^	explicit GenericFallbackVisitor($/;"	f	struct:dev::GenericFallbackVisitor	access:public	signature:( std::function<void(Visitable&)> _visitor, std::function<void(Others&)>... _otherVisitors )
dev::GenericFallbackVisitor::m_visitor	libdevcore/Visitor.h	/^	std::function<void(Visitable&)> m_visitor;$/;"	m	struct:dev::GenericFallbackVisitor	access:public
dev::GenericFallbackVisitor::operator ()	libdevcore/Visitor.h	/^	void operator()(T&) const { }$/;"	f	struct:dev::GenericFallbackVisitor	access:public	signature:(T&) const
dev::GenericFallbackVisitor::operator ()	libdevcore/Visitor.h	/^	void operator()(Visitable& _v) const { m_visitor(_v); }$/;"	f	struct:dev::GenericFallbackVisitor	access:public	signature:(Visitable& _v) const
dev::GenericVisitor	libdevcore/Visitor.h	/^struct GenericVisitor<>: public boost::static_visitor<> {$/;"	s	namespace:dev	inherits:boost::static_visitor
dev::GenericVisitor	libdevcore/Visitor.h	/^struct GenericVisitor<Visitable, Others...>: public GenericVisitor<Others...>$/;"	s	namespace:dev	inherits:GenericVisitor
dev::GenericVisitor	libdevcore/Visitor.h	/^struct GenericVisitor{};$/;"	s	namespace:dev
dev::GenericVisitor::GenericVisitor	libdevcore/Visitor.h	/^	explicit GenericVisitor($/;"	f	struct:dev::GenericVisitor	access:public	signature:( std::function<void(Visitable&)> _visitor, std::function<void(Others&)>... _otherVisitors )
dev::GenericVisitor::m_visitor	libdevcore/Visitor.h	/^	std::function<void(Visitable&)> m_visitor;$/;"	m	struct:dev::GenericVisitor	access:public
dev::GenericVisitor::operator ()	libdevcore/Visitor.h	/^	void operator()() const {}$/;"	f	struct:dev::GenericVisitor	access:public	signature:() const
dev::GenericVisitor::operator ()	libdevcore/Visitor.h	/^	void operator()(Visitable& _v) const { m_visitor(_v); }$/;"	f	struct:dev::GenericVisitor	access:public	signature:(Visitable& _v) const
dev::HexCase	libdevcore/CommonData.h	/^enum class HexCase$/;"	c	namespace:dev
dev::HexCase::Lower	libdevcore/CommonData.h	/^	Lower = 0,$/;"	m	class:dev::HexCase	access:private
dev::HexCase::Mixed	libdevcore/CommonData.h	/^	Mixed = 2,$/;"	m	class:dev::HexCase	access:private
dev::HexCase::Upper	libdevcore/CommonData.h	/^	Upper = 1,$/;"	m	class:dev::HexCase	access:private
dev::HexPrefix	libdevcore/CommonData.h	/^enum class HexPrefix$/;"	c	namespace:dev
dev::HexPrefix::Add	libdevcore/CommonData.h	/^	Add = 1,$/;"	m	class:dev::HexPrefix	access:private
dev::HexPrefix::DontAdd	libdevcore/CommonData.h	/^	DontAdd = 0,$/;"	m	class:dev::HexPrefix	access:private
dev::IndentedWriter	libdevcore/IndentedWriter.h	/^class IndentedWriter$/;"	c	namespace:dev
dev::IndentedWriter::Line	libdevcore/IndentedWriter.h	/^	struct Line$/;"	s	class:dev::IndentedWriter	access:private
dev::IndentedWriter::Line::contents	libdevcore/IndentedWriter.h	/^		std::string contents;$/;"	m	struct:dev::IndentedWriter::Line	access:public
dev::IndentedWriter::Line::indentation	libdevcore/IndentedWriter.h	/^		unsigned indentation;$/;"	m	struct:dev::IndentedWriter::Line	access:public
dev::IndentedWriter::add	libdevcore/IndentedWriter.h	/^	void add(std::string const& _str);$/;"	p	class:dev::IndentedWriter	access:public	signature:(std::string const& _str)
dev::IndentedWriter::addLine	libdevcore/IndentedWriter.h	/^	void addLine(std::string const& _line);$/;"	p	class:dev::IndentedWriter	access:public	signature:(std::string const& _line)
dev::IndentedWriter::format	libdevcore/IndentedWriter.h	/^	std::string format() const;$/;"	p	class:dev::IndentedWriter	access:public	signature:() const
dev::IndentedWriter::indent	libdevcore/IndentedWriter.h	/^	void indent();$/;"	p	class:dev::IndentedWriter	access:public	signature:()
dev::IndentedWriter::newLine	libdevcore/IndentedWriter.h	/^	void newLine();$/;"	p	class:dev::IndentedWriter	access:public	signature:()
dev::IndentedWriter::unindent	libdevcore/IndentedWriter.h	/^	void unindent();$/;"	p	class:dev::IndentedWriter	access:public	signature:()
dev::Result	libdevcore/Result.h	/^class Result$/;"	c	namespace:dev
dev::Result::Result	libdevcore/Result.h	/^	Result(ResultType _value): Result(_value, std::string{}) {}$/;"	f	class:dev::Result	access:public	signature:(ResultType _value)
dev::Result::Result	libdevcore/Result.h	/^	Result(std::string _message): Result(ResultType{}, std::move(_message)) {}$/;"	f	class:dev::Result	access:public	signature:(std::string _message)
dev::Result::Result	libdevcore/Result.h	/^	explicit Result(ResultType _value, std::string _message):$/;"	f	class:dev::Result	access:private	signature:(ResultType _value, std::string _message)
dev::Result::get	libdevcore/Result.h	/^	ResultType const& get() const { return m_value; }$/;"	f	class:dev::Result	access:public	signature:() const
dev::Result::m_message	libdevcore/Result.h	/^	std::string m_message;$/;"	m	class:dev::Result	access:private
dev::Result::m_value	libdevcore/Result.h	/^	ResultType m_value;$/;"	m	class:dev::Result	access:private
dev::Result::operator ResultType const&	libdevcore/Result.h	/^	operator ResultType const&() const { return m_value; }$/;"	f	class:dev::Result	access:public	signature:() const
dev::Result::std::message	libdevcore/Result.h	/^	std::string const& message() const { return m_message; }$/;"	f	class:dev::Result::std	access:public	signature:() const
dev::ScopeGuard	libdevcore/Common.h	/^class ScopeGuard$/;"	c	namespace:dev
dev::ScopeGuard::ScopeGuard	libdevcore/Common.h	/^	explicit ScopeGuard(std::function<void(void)> _f): m_f(_f) {}$/;"	f	class:dev::ScopeGuard	access:public	signature:(std::function<void(void)> _f)
dev::ScopeGuard::m_f	libdevcore/Common.h	/^	std::function<void(void)> m_f;$/;"	m	class:dev::ScopeGuard	access:private
dev::ScopeGuard::~ScopeGuard	libdevcore/Common.h	/^	~ScopeGuard() { m_f(); }$/;"	f	class:dev::ScopeGuard	access:public	signature:()
dev::WhenError	libdevcore/CommonData.h	/^enum class WhenError$/;"	c	namespace:dev
dev::WhenError::DontThrow	libdevcore/CommonData.h	/^	DontThrow = 0,$/;"	m	class:dev::WhenError	access:private
dev::WhenError::Throw	libdevcore/CommonData.h	/^	Throw = 1,$/;"	m	class:dev::WhenError	access:private
dev::Whiskers	libdevcore/Whiskers.h	/^class Whiskers$/;"	c	namespace:dev
dev::Whiskers::joinMaps	libdevcore/Whiskers.h	/^	static StringMap joinMaps(StringMap const& _a, StringMap const& _b);$/;"	p	class:dev::Whiskers	access:private	signature:(StringMap const& _a, StringMap const& _b)
dev::Whiskers::m_listParameters	libdevcore/Whiskers.h	/^	StringListMap m_listParameters;$/;"	m	class:dev::Whiskers	access:private
dev::Whiskers::m_parameters	libdevcore/Whiskers.h	/^	StringMap m_parameters;$/;"	m	class:dev::Whiskers	access:private
dev::Whiskers::m_template	libdevcore/Whiskers.h	/^	std::string m_template;$/;"	m	class:dev::Whiskers	access:private
dev::Whiskers::operator ()	libdevcore/Whiskers.h	/^	Whiskers& operator()($/;"	p	class:dev::Whiskers	access:public	signature:( std::string const& _listParameter, std::vector<StringMap> const& _values )
dev::Whiskers::operator ()	libdevcore/Whiskers.h	/^	Whiskers& operator()(std::string const& _parameter, std::string const& _value);$/;"	p	class:dev::Whiskers	access:public	signature:(std::string const& _parameter, std::string const& _value)
dev::Whiskers::render	libdevcore/Whiskers.h	/^	std::string render() const;$/;"	p	class:dev::Whiskers	access:public	signature:() const
dev::Whiskers::replace	libdevcore/Whiskers.h	/^	static std::string replace($/;"	p	class:dev::Whiskers	access:private	signature:( std::string const& _template, StringMap const& _parameters, StringListMap const& _listParameters = StringListMap() )
dev::__anon21::isWellFormed	libdevcore/UTF8.cpp	/^bool isWellFormed(unsigned char byte1, unsigned char byte2)$/;"	f	namespace:dev::__anon21	signature:(unsigned char byte1, unsigned char byte2)
dev::__anon21::validateUTF8	libdevcore/UTF8.cpp	/^bool validateUTF8(unsigned char const* _input, size_t _length, size_t& _invalidPosition)$/;"	f	namespace:dev::__anon21	signature:(unsigned char const* _input, size_t _length, size_t& _invalidPosition)
dev::__anon23::RC	libdevcore/Keccak256.cpp	/^static uint64_t const RC[24] = \\$/;"	m	namespace:dev::__anon23	file:
dev::__anon23::hash	libdevcore/Keccak256.cpp	/^inline void hash($/;"	f	namespace:dev::__anon23	signature:( uint8_t* out, size_t outlen, uint8_t const* in, size_t inlen, size_t rate, uint8_t delim )
dev::__anon23::keccakf	libdevcore/Keccak256.cpp	/^static inline void keccakf(void* state) {$/;"	f	namespace:dev::__anon23	signature:(void* state)
dev::__anon23::pi	libdevcore/Keccak256.cpp	/^static uint8_t const pi[24] = \\$/;"	m	namespace:dev::__anon23	file:
dev::__anon23::rho	libdevcore/Keccak256.cpp	/^static uint8_t const rho[24] = \\$/;"	m	namespace:dev::__anon23	file:
dev::__anon25::StreamWriterBuilder	libdevcore/JSON.cpp	/^class StreamWriterBuilder: public Json::StreamWriterBuilder$/;"	c	namespace:dev::__anon25	file:	inherits:Json::StreamWriterBuilder
dev::__anon25::StreamWriterBuilder::StreamWriterBuilder	libdevcore/JSON.cpp	/^	explicit StreamWriterBuilder(map<string, string> const& _settings)$/;"	f	class:dev::__anon25::StreamWriterBuilder	access:public	signature:(map<string, string> const& _settings)
dev::__anon25::StrictModeCharReaderBuilder	libdevcore/JSON.cpp	/^class StrictModeCharReaderBuilder: public Json::CharReaderBuilder$/;"	c	namespace:dev::__anon25	file:	inherits:Json::CharReaderBuilder
dev::__anon25::StrictModeCharReaderBuilder::StrictModeCharReaderBuilder	libdevcore/JSON.cpp	/^	StrictModeCharReaderBuilder()$/;"	f	class:dev::__anon25::StrictModeCharReaderBuilder	access:public	signature:()
dev::__anon25::parse	libdevcore/JSON.cpp	/^bool parse(Json::CharReaderBuilder& _builder, string const& _input, Json::Value& _json, string* _errs)$/;"	f	namespace:dev::__anon25	signature:(Json::CharReaderBuilder& _builder, string const& _input, Json::Value& _json, string* _errs)
dev::__anon25::print	libdevcore/JSON.cpp	/^string print(Json::Value const& _input, Json::StreamWriterBuilder const& _builder)$/;"	f	namespace:dev::__anon25	signature:(Json::Value const& _input, Json::StreamWriterBuilder const& _builder)
dev::absolutePath	libdevcore/CommonIO.cpp	/^string dev::absolutePath(string const& _path, string const& _reference)$/;"	f	class:dev	signature:(string const& _path, string const& _reference)
dev::absolutePath	libdevcore/CommonIO.h	/^std::string absolutePath(std::string const& _path, std::string const& _reference);$/;"	p	namespace:dev	signature:(std::string const& _path, std::string const& _reference)
dev::asBytes	libdevcore/CommonData.h	/^inline bytes asBytes(std::string const& _b)$/;"	f	namespace:dev	signature:(std::string const& _b)
dev::asString	libdevcore/CommonData.h	/^inline std::string asString(bytes const& _b)$/;"	f	namespace:dev	signature:(bytes const& _b)
dev::asString	libdevcore/CommonData.h	/^inline std::string asString(bytesConstRef _b)$/;"	f	namespace:dev	signature:(bytesConstRef _b)
dev::bigintShiftLeftWorkaround	libdevcore/CommonData.h	/^template <class S> S bigintShiftLeftWorkaround(S const& _a, unsigned _b)$/;"	f	namespace:dev	signature:(S const& _a, unsigned _b)
dev::bytesRequired	libdevcore/CommonData.h	/^inline unsigned bytesRequired(T _i)$/;"	f	namespace:dev	signature:(T _i)
dev::containerEqual	libdevcore/CommonData.h	/^bool containerEqual(Container const& _lhs, Container const& _rhs, Compare&& _compare)$/;"	f	namespace:dev	signature:(Container const& _lhs, Container const& _rhs, Compare&& _compare)
dev::contains	libdevcore/CommonData.h	/^bool contains(T const& _t, V const& _v)$/;"	f	namespace:dev	signature:(T const& _t, V const& _v)
dev::detail	libdevcore/CommonData.h	/^namespace detail$/;"	n	namespace:dev
dev::detail::iterateReplacingWindow	libdevcore/CommonData.h	/^void iterateReplacingWindow(std::vector<T>& _vector, F const& _f, std::index_sequence<I...>)$/;"	f	namespace:dev::detail	signature:(std::vector<T>& _vector, F const& _f, std::index_sequence<I...>)
dev::eth	libevmasm/Assembly.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/AssemblyItem.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/BlockDeduplicator.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/CommonSubexpressionEliminator.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/ConstantOptimiser.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/ControlFlowGraph.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/Exceptions.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/ExpressionClasses.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/GasMeter.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/JumpdestRemover.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/KnownState.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/LinkerObject.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/PathGasMeter.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/PeepholeOptimiser.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/SemanticInformation.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libevmasm/SimplificationRules.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libsolidity/codegen/ExpressionCompiler.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libsolidity/interface/CompilerStack.h	/^namespace eth$/;"	n	namespace:dev
dev::eth	libyul/backends/evm/AsmCodeGen.h	/^namespace eth$/;"	n	namespace:dev
dev::eth::Assembly	libevmasm/Assembly.h	/^class Assembly$/;"	c	namespace:dev::eth
dev::eth::Assembly::OptimiserSettings	libevmasm/Assembly.h	/^	struct OptimiserSettings$/;"	s	class:dev::eth::Assembly	access:public
dev::eth::Assembly::OptimiserSettings::evmVersion	libevmasm/Assembly.h	/^		langutil::EVMVersion evmVersion;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::expectedExecutionsPerDeployment	libevmasm/Assembly.h	/^		size_t expectedExecutionsPerDeployment = 200;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::isCreation	libevmasm/Assembly.h	/^		bool isCreation = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::runCSE	libevmasm/Assembly.h	/^		bool runCSE = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::runConstantOptimiser	libevmasm/Assembly.h	/^		bool runConstantOptimiser = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::runDeduplicate	libevmasm/Assembly.h	/^		bool runDeduplicate = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::runJumpdestRemover	libevmasm/Assembly.h	/^		bool runJumpdestRemover = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::OptimiserSettings::runPeephole	libevmasm/Assembly.h	/^		bool runPeephole = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
dev::eth::Assembly::adjustDeposit	libevmasm/Assembly.h	/^	void adjustDeposit(int _adjustment) { m_deposit += _adjustment; assertThrow(m_deposit >= 0, InvalidDeposit, ""); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(int _adjustment)
dev::eth::Assembly::append	libevmasm/Assembly.h	/^	AssemblyItem const& append(AssemblyItem const& _i);$/;"	p	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _i)
dev::eth::Assembly::append	libevmasm/Assembly.h	/^	AssemblyItem const& append(bytes const& _data) { return append(newData(_data)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(bytes const& _data)
dev::eth::Assembly::append	libevmasm/Assembly.h	/^	AssemblyItem const& append(std::string const& _data) { return append(newPushString(_data)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(std::string const& _data)
dev::eth::Assembly::append	libevmasm/Assembly.h	/^	void append(Assembly const& _a);$/;"	p	class:dev::eth::Assembly	access:public	signature:(Assembly const& _a)
dev::eth::Assembly::append	libevmasm/Assembly.h	/^	void append(Assembly const& _a, int _deposit);$/;"	p	class:dev::eth::Assembly	access:public	signature:(Assembly const& _a, int _deposit)
dev::eth::Assembly::appendAuxiliaryDataToEnd	libevmasm/Assembly.h	/^	void appendAuxiliaryDataToEnd(bytes const& _data) { m_auxiliaryData += _data; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(bytes const& _data)
dev::eth::Assembly::appendJump	libevmasm/Assembly.h	/^	AssemblyItem appendJump() { auto ret = append(newPushTag()); append(solidity::Instruction::JUMP); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
dev::eth::Assembly::appendJump	libevmasm/Assembly.h	/^	AssemblyItem appendJump(AssemblyItem const& _tag) { auto ret = append(_tag.pushTag()); append(solidity::Instruction::JUMP); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _tag)
dev::eth::Assembly::appendJumpI	libevmasm/Assembly.h	/^	AssemblyItem appendJumpI() { auto ret = append(newPushTag()); append(solidity::Instruction::JUMPI); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
dev::eth::Assembly::appendJumpI	libevmasm/Assembly.h	/^	AssemblyItem appendJumpI(AssemblyItem const& _tag) { auto ret = append(_tag.pushTag()); append(solidity::Instruction::JUMPI); return ret; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _tag)
dev::eth::Assembly::appendLibraryAddress	libevmasm/Assembly.h	/^	void appendLibraryAddress(std::string const& _identifier) { append(newPushLibraryAddress(_identifier)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(std::string const& _identifier)
dev::eth::Assembly::appendProgramSize	libevmasm/Assembly.h	/^	void appendProgramSize() { append(AssemblyItem(PushProgramSize)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
dev::eth::Assembly::appendSubroutine	libevmasm/Assembly.h	/^	AssemblyItem appendSubroutine(AssemblyPointer const& _assembly) { auto sub = newSub(_assembly); append(newPushSubSize(size_t(sub.data()))); return sub; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyPointer const& _assembly)
dev::eth::Assembly::assemble	libevmasm/Assembly.h	/^	LinkerObject const& assemble() const;$/;"	p	class:dev::eth::Assembly	access:public	signature:() const
dev::eth::Assembly::assemblyJSON	libevmasm/Assembly.h	/^	Json::Value assemblyJSON($/;"	p	class:dev::eth::Assembly	access:public	signature:( StringMap const& _sourceCodes = StringMap() ) const
dev::eth::Assembly::assemblyStream	libevmasm/Assembly.h	/^	void assemblyStream($/;"	p	class:dev::eth::Assembly	access:public	signature:( std::ostream& _out, std::string const& _prefix = , StringMap const& _sourceCodes = StringMap() ) const
dev::eth::Assembly::assemblyString	libevmasm/Assembly.h	/^	std::string assemblyString($/;"	p	class:dev::eth::Assembly	access:public	signature:( StringMap const& _sourceCodes = StringMap() ) const
dev::eth::Assembly::back	libevmasm/Assembly.h	/^	AssemblyItem const& back() const { return m_items.back(); }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
dev::eth::Assembly::backString	libevmasm/Assembly.h	/^	std::string backString() const { return m_items.size() && m_items.back().type() == PushString ? m_strings.at((h256)m_items.back().data()) : std::string(); }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
dev::eth::Assembly::bytesRequired	libevmasm/Assembly.h	/^	unsigned bytesRequired(unsigned subTagSize) const;$/;"	p	class:dev::eth::Assembly	access:protected	signature:(unsigned subTagSize) const
dev::eth::Assembly::createJsonValue	libevmasm/Assembly.h	/^	static Json::Value createJsonValue(std::string _name, int _begin, int _end, std::string _value = std::string(), std::string _jumpType = std::string());$/;"	p	class:dev::eth::Assembly	access:private	signature:(std::string _name, int _begin, int _end, std::string _value = std::string(), std::string _jumpType = std::string())
dev::eth::Assembly::data	libevmasm/Assembly.h	/^	bytes const& data(h256 const& _i) const { return m_data.at(_i); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(h256 const& _i) const
dev::eth::Assembly::deposit	libevmasm/Assembly.h	/^	int deposit() const { return m_deposit; }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
dev::eth::Assembly::injectStart	libevmasm/Assembly.h	/^	void injectStart(AssemblyItem const& _i);$/;"	p	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _i)
dev::eth::Assembly::items	libevmasm/Assembly.h	/^	AssemblyItems const& items() const { return m_items; }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
dev::eth::Assembly::items	libevmasm/Assembly.h	/^	AssemblyItems& items() { return m_items; }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
dev::eth::Assembly::m_assembledObject	libevmasm/Assembly.h	/^	mutable LinkerObject m_assembledObject;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_auxiliaryData	libevmasm/Assembly.h	/^	bytes m_auxiliaryData;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_currentSourceLocation	libevmasm/Assembly.h	/^	langutil::SourceLocation m_currentSourceLocation;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_data	libevmasm/Assembly.h	/^	std::map<h256, bytes> m_data;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_deposit	libevmasm/Assembly.h	/^	int m_deposit = 0;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_items	libevmasm/Assembly.h	/^	AssemblyItems m_items;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_libraries	libevmasm/Assembly.h	/^	std::map<h256, std::string> m_libraries; \/\/\/< Identifiers of libraries to be linked.$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_namedTags	libevmasm/Assembly.h	/^	std::map<std::string, size_t> m_namedTags;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_strings	libevmasm/Assembly.h	/^	std::map<h256, std::string> m_strings;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_subs	libevmasm/Assembly.h	/^	std::vector<std::shared_ptr<Assembly>> m_subs;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_tagPositionsInBytecode	libevmasm/Assembly.h	/^	mutable std::vector<size_t> m_tagPositionsInBytecode;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::m_usedTags	libevmasm/Assembly.h	/^	unsigned m_usedTags = 1;$/;"	m	class:dev::eth::Assembly	access:protected
dev::eth::Assembly::namedTag	libevmasm/Assembly.h	/^	AssemblyItem namedTag(std::string const& _name);$/;"	p	class:dev::eth::Assembly	access:public	signature:(std::string const& _name)
dev::eth::Assembly::newData	libevmasm/Assembly.h	/^	AssemblyItem newData(bytes const& _data) { h256 h(dev::keccak256(asString(_data))); m_data[h] = _data; return AssemblyItem(PushData, h); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(bytes const& _data)
dev::eth::Assembly::newPushLibraryAddress	libevmasm/Assembly.h	/^	AssemblyItem newPushLibraryAddress(std::string const& _identifier);$/;"	p	class:dev::eth::Assembly	access:public	signature:(std::string const& _identifier)
dev::eth::Assembly::newPushString	libevmasm/Assembly.h	/^	AssemblyItem newPushString(std::string const& _data) { h256 h(dev::keccak256(_data)); m_strings[h] = _data; return AssemblyItem(PushString, h); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(std::string const& _data)
dev::eth::Assembly::newPushSubSize	libevmasm/Assembly.h	/^	AssemblyItem newPushSubSize(u256 const& _subId) { return AssemblyItem(PushSubSize, _subId); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(u256 const& _subId)
dev::eth::Assembly::newPushTag	libevmasm/Assembly.h	/^	AssemblyItem newPushTag() { assertThrow(m_usedTags < 0xffffffff, AssemblyException, ""); return AssemblyItem(PushTag, m_usedTags++); }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
dev::eth::Assembly::newSub	libevmasm/Assembly.h	/^	AssemblyItem newSub(AssemblyPointer const& _sub) { m_subs.push_back(_sub); return AssemblyItem(PushSub, m_subs.size() - 1); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyPointer const& _sub)
dev::eth::Assembly::newTag	libevmasm/Assembly.h	/^	AssemblyItem newTag() { assertThrow(m_usedTags < 0xffffffff, AssemblyException, ""); return AssemblyItem(Tag, m_usedTags++); }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
dev::eth::Assembly::operator <<	libevmasm/Assembly.h	/^	template <class T> Assembly& operator<<(T const& _d) { append(_d); return *this; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(T const& _d)
dev::eth::Assembly::optimise	libevmasm/Assembly.h	/^	Assembly& optimise(OptimiserSettings const& _settings);$/;"	p	class:dev::eth::Assembly	access:public	signature:(OptimiserSettings const& _settings)
dev::eth::Assembly::optimise	libevmasm/Assembly.h	/^	Assembly& optimise(bool _enable, langutil::EVMVersion _evmVersion, bool _isCreation, size_t _runs);$/;"	p	class:dev::eth::Assembly	access:public	signature:(bool _enable, langutil::EVMVersion _evmVersion, bool _isCreation, size_t _runs)
dev::eth::Assembly::optimiseInternal	libevmasm/Assembly.h	/^	std::map<u256, u256> optimiseInternal(OptimiserSettings const& _settings, std::set<size_t> _tagsReferencedFromOutside);$/;"	p	class:dev::eth::Assembly	access:protected	signature:(OptimiserSettings const& _settings, std::set<size_t> _tagsReferencedFromOutside)
dev::eth::Assembly::pushSubroutineOffset	libevmasm/Assembly.h	/^	void pushSubroutineOffset(size_t _subRoutine) { append(AssemblyItem(PushSub, _subRoutine)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _subRoutine)
dev::eth::Assembly::pushSubroutineSize	libevmasm/Assembly.h	/^	void pushSubroutineSize(size_t _subRoutine) { append(newPushSubSize(_subRoutine)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _subRoutine)
dev::eth::Assembly::setDeposit	libevmasm/Assembly.h	/^	void setDeposit(int _deposit) { m_deposit = _deposit; assertThrow(m_deposit >= 0, InvalidDeposit, ""); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(int _deposit)
dev::eth::Assembly::setSourceLocation	libevmasm/Assembly.h	/^	void setSourceLocation(langutil::SourceLocation const& _location) { m_currentSourceLocation = _location; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(langutil::SourceLocation const& _location)
dev::eth::Assembly::sub	libevmasm/Assembly.h	/^	Assembly const& sub(size_t _sub) const { return *m_subs.at(_sub); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _sub) const
dev::eth::Assembly::sub	libevmasm/Assembly.h	/^	Assembly& sub(size_t _sub) { return *m_subs.at(_sub); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _sub)
dev::eth::Assembly::toStringInHex	libevmasm/Assembly.h	/^	static std::string toStringInHex(u256 _value);$/;"	p	class:dev::eth::Assembly	access:private	signature:(u256 _value)
dev::eth::AssemblyException	libevmasm/Exceptions.h	/^struct AssemblyException: virtual Exception {};$/;"	s	namespace:dev::eth	inherits:Exception
dev::eth::AssemblyItem	libevmasm/AssemblyItem.h	/^class AssemblyItem$/;"	c	namespace:dev::eth
dev::eth::AssemblyItem::AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(AssemblyItem const&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const&)
dev::eth::AssemblyItem::AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(AssemblyItem&&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem&&)
dev::eth::AssemblyItem::AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(AssemblyItemType _type, u256 _data = 0, langutil::SourceLocation _location = langutil::SourceLocation()):$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItemType _type, u256 _data = 0, langutil::SourceLocation _location = langutil::SourceLocation())
dev::eth::AssemblyItem::AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(solidity::Instruction _i, langutil::SourceLocation _location = langutil::SourceLocation()):$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(solidity::Instruction _i, langutil::SourceLocation _location = langutil::SourceLocation())
dev::eth::AssemblyItem::AssemblyItem	libevmasm/AssemblyItem.h	/^	AssemblyItem(u256 _push, langutil::SourceLocation _location = langutil::SourceLocation()):$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(u256 _push, langutil::SourceLocation _location = langutil::SourceLocation())
dev::eth::AssemblyItem::JumpType	libevmasm/AssemblyItem.h	/^	enum class JumpType { Ordinary, IntoFunction, OutOfFunction };$/;"	c	class:dev::eth::AssemblyItem	access:public
dev::eth::AssemblyItem::JumpType::IntoFunction	libevmasm/AssemblyItem.h	/^	enum class JumpType { Ordinary, IntoFunction, OutOfFunction };$/;"	m	class:dev::eth::AssemblyItem::JumpType	access:private
dev::eth::AssemblyItem::JumpType::Ordinary	libevmasm/AssemblyItem.h	/^	enum class JumpType { Ordinary, IntoFunction, OutOfFunction };$/;"	m	class:dev::eth::AssemblyItem::JumpType	access:private
dev::eth::AssemblyItem::arguments	libevmasm/AssemblyItem.h	/^	int arguments() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::bytesRequired	libevmasm/AssemblyItem.h	/^	unsigned bytesRequired(unsigned _addressLength) const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(unsigned _addressLength) const
dev::eth::AssemblyItem::canBeFunctional	libevmasm/AssemblyItem.h	/^	bool canBeFunctional() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::data	libevmasm/AssemblyItem.h	/^	u256 const& data() const { assertThrow(m_type != Operation, Exception, ""); return *m_data; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::deposit	libevmasm/AssemblyItem.h	/^	int deposit() const { return returnValues() - arguments(); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::getJumpType	libevmasm/AssemblyItem.h	/^	JumpType getJumpType() const { return m_jumpType; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::getJumpTypeAsString	libevmasm/AssemblyItem.h	/^	std::string getJumpTypeAsString() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::instruction	libevmasm/AssemblyItem.h	/^	Instruction instruction() const { assertThrow(m_type == Operation, Exception, ""); return m_instruction; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::langutil::location	libevmasm/AssemblyItem.h	/^	langutil::SourceLocation const& location() const { return m_location; }$/;"	f	class:dev::eth::AssemblyItem::langutil	access:public	signature:() const
dev::eth::AssemblyItem::m_data	libevmasm/AssemblyItem.h	/^	std::shared_ptr<u256> m_data; \/\/\/< Only valid if m_type != Operation$/;"	m	class:dev::eth::AssemblyItem	access:private
dev::eth::AssemblyItem::m_instruction	libevmasm/AssemblyItem.h	/^	Instruction m_instruction; \/\/\/< Only valid if m_type == Operation$/;"	m	class:dev::eth::AssemblyItem	access:private
dev::eth::AssemblyItem::m_jumpType	libevmasm/AssemblyItem.h	/^	JumpType m_jumpType = JumpType::Ordinary;$/;"	m	class:dev::eth::AssemblyItem	access:private
dev::eth::AssemblyItem::m_location	libevmasm/AssemblyItem.h	/^	langutil::SourceLocation m_location;$/;"	m	class:dev::eth::AssemblyItem	access:private
dev::eth::AssemblyItem::m_pushedValue	libevmasm/AssemblyItem.h	/^	mutable std::shared_ptr<u256> m_pushedValue;$/;"	m	class:dev::eth::AssemblyItem	access:private
dev::eth::AssemblyItem::m_type	libevmasm/AssemblyItem.h	/^	AssemblyItemType m_type;$/;"	m	class:dev::eth::AssemblyItem	access:private
dev::eth::AssemblyItem::operator !=	libevmasm/AssemblyItem.h	/^	bool operator!=(AssemblyItem const& _other) const { return !operator==(_other); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const& _other) const
dev::eth::AssemblyItem::operator !=	libevmasm/AssemblyItem.h	/^	bool operator!=(Instruction _instr) const { return !operator==(_instr); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(Instruction _instr) const
dev::eth::AssemblyItem::operator <	libevmasm/AssemblyItem.h	/^	bool operator<(AssemblyItem const& _other) const$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const& _other) const
dev::eth::AssemblyItem::operator =	libevmasm/AssemblyItem.h	/^	AssemblyItem& operator=(AssemblyItem const&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const&)
dev::eth::AssemblyItem::operator =	libevmasm/AssemblyItem.h	/^	AssemblyItem& operator=(AssemblyItem&&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem&&)
dev::eth::AssemblyItem::operator ==	libevmasm/AssemblyItem.h	/^	bool operator==(AssemblyItem const& _other) const$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const& _other) const
dev::eth::AssemblyItem::operator ==	libevmasm/AssemblyItem.h	/^	bool operator==(Instruction _instr) const$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(Instruction _instr) const
dev::eth::AssemblyItem::pushTag	libevmasm/AssemblyItem.h	/^	AssemblyItem pushTag() const { assertThrow(m_type == PushTag || m_type == Tag, Exception, ""); return AssemblyItem(PushTag, data()); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::pushedValue	libevmasm/AssemblyItem.h	/^	u256 const* pushedValue() const { return m_pushedValue.get(); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::returnValues	libevmasm/AssemblyItem.h	/^	int returnValues() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::setData	libevmasm/AssemblyItem.h	/^	void setData(u256 const& _data) { assertThrow(m_type != Operation, Exception, ""); m_data = std::make_shared<u256>(_data); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(u256 const& _data)
dev::eth::AssemblyItem::setJumpType	libevmasm/AssemblyItem.h	/^	void setJumpType(JumpType _jumpType) { m_jumpType = _jumpType; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(JumpType _jumpType)
dev::eth::AssemblyItem::setLocation	libevmasm/AssemblyItem.h	/^	void setLocation(langutil::SourceLocation const& _location) { m_location = _location; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(langutil::SourceLocation const& _location)
dev::eth::AssemblyItem::setPushTagSubIdAndTag	libevmasm/AssemblyItem.h	/^	void setPushTagSubIdAndTag(size_t _subId, size_t _tag);$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(size_t _subId, size_t _tag)
dev::eth::AssemblyItem::setPushedValue	libevmasm/AssemblyItem.h	/^	void setPushedValue(u256 const& _value) const { m_pushedValue = std::make_shared<u256>(_value); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(u256 const& _value) const
dev::eth::AssemblyItem::splitForeignPushTag	libevmasm/AssemblyItem.h	/^	std::pair<size_t, size_t> splitForeignPushTag() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::tag	libevmasm/AssemblyItem.h	/^	AssemblyItem tag() const { assertThrow(m_type == PushTag || m_type == Tag, Exception, ""); return AssemblyItem(Tag, data()); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::toAssemblyText	libevmasm/AssemblyItem.h	/^	std::string toAssemblyText() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItem::toSubAssemblyTag	libevmasm/AssemblyItem.h	/^	AssemblyItem toSubAssemblyTag(size_t _subId) const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(size_t _subId) const
dev::eth::AssemblyItem::type	libevmasm/AssemblyItem.h	/^	AssemblyItemType type() const { return m_type; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
dev::eth::AssemblyItemType	libevmasm/AssemblyItem.h	/^enum AssemblyItemType {$/;"	g	namespace:dev::eth
dev::eth::BasicBlock	libevmasm/ControlFlowGraph.h	/^struct BasicBlock$/;"	s	namespace:dev::eth
dev::eth::BasicBlock::EndType	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	c	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::EndType::JUMP	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	m	class:dev::eth::BasicBlock::EndType	access:private
dev::eth::BasicBlock::EndType::JUMPI	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	m	class:dev::eth::BasicBlock::EndType	access:private
dev::eth::BasicBlock::EndType::STOP	libevmasm/ControlFlowGraph.h	/^	enum class EndType { JUMP, JUMPI, STOP, HANDOVER };$/;"	m	class:dev::eth::BasicBlock::EndType	access:private
dev::eth::BasicBlock::begin	libevmasm/ControlFlowGraph.h	/^	unsigned begin = 0;$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::end	libevmasm/ControlFlowGraph.h	/^	unsigned end = 0;$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::endState	libevmasm/ControlFlowGraph.h	/^	KnownStatePointer endState;$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::endType	libevmasm/ControlFlowGraph.h	/^	EndType endType = EndType::HANDOVER;$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::next	libevmasm/ControlFlowGraph.h	/^	BlockId next = BlockId::invalid();$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::prev	libevmasm/ControlFlowGraph.h	/^	BlockId prev = BlockId::invalid();$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::pushedTags	libevmasm/ControlFlowGraph.h	/^	std::vector<BlockId> pushedTags;$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BasicBlock::startState	libevmasm/ControlFlowGraph.h	/^	KnownStatePointer startState;$/;"	m	struct:dev::eth::BasicBlock	access:public
dev::eth::BlockDeduplicator	libevmasm/BlockDeduplicator.h	/^class BlockDeduplicator$/;"	c	namespace:dev::eth
dev::eth::BlockDeduplicator::BlockDeduplicator	libevmasm/BlockDeduplicator.h	/^	explicit BlockDeduplicator(AssemblyItems& _items): m_items(_items) {}$/;"	f	class:dev::eth::BlockDeduplicator	access:public	signature:(AssemblyItems& _items)
dev::eth::BlockDeduplicator::BlockIterator	libevmasm/BlockDeduplicator.h	/^	struct BlockIterator: std::iterator<std::forward_iterator_tag, AssemblyItem const>$/;"	s	class:dev::eth::BlockDeduplicator	inherits:std::iterator	access:private
dev::eth::BlockDeduplicator::BlockIterator::BlockIterator	libevmasm/BlockDeduplicator.h	/^		BlockIterator($/;"	f	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:( AssemblyItems::const_iterator _it, AssemblyItems::const_iterator _end, AssemblyItem const* _replaceItem = nullptr, AssemblyItem const* _replaceWith = nullptr )
dev::eth::BlockDeduplicator::BlockIterator::end	libevmasm/BlockDeduplicator.h	/^		AssemblyItems::const_iterator end;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
dev::eth::BlockDeduplicator::BlockIterator::it	libevmasm/BlockDeduplicator.h	/^		AssemblyItems::const_iterator it;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
dev::eth::BlockDeduplicator::BlockIterator::operator !=	libevmasm/BlockDeduplicator.h	/^		bool operator!=(BlockIterator const& _other) const { return it != _other.it; }$/;"	f	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:(BlockIterator const& _other) const
dev::eth::BlockDeduplicator::BlockIterator::operator *	libevmasm/BlockDeduplicator.h	/^		AssemblyItem const& operator*() const;$/;"	p	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:() const
dev::eth::BlockDeduplicator::BlockIterator::operator ++	libevmasm/BlockDeduplicator.h	/^		BlockIterator& operator++();$/;"	p	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:()
dev::eth::BlockDeduplicator::BlockIterator::operator ==	libevmasm/BlockDeduplicator.h	/^		bool operator==(BlockIterator const& _other) const { return it == _other.it; }$/;"	f	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:(BlockIterator const& _other) const
dev::eth::BlockDeduplicator::BlockIterator::replaceItem	libevmasm/BlockDeduplicator.h	/^		AssemblyItem const* replaceItem;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
dev::eth::BlockDeduplicator::BlockIterator::replaceWith	libevmasm/BlockDeduplicator.h	/^		AssemblyItem const* replaceWith;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
dev::eth::BlockDeduplicator::applyTagReplacement	libevmasm/BlockDeduplicator.h	/^	static bool applyTagReplacement($/;"	p	class:dev::eth::BlockDeduplicator	access:public	signature:( AssemblyItems& _items, std::map<u256, u256> const& _replacements, size_t _subID = size_t(-1) )
dev::eth::BlockDeduplicator::deduplicate	libevmasm/BlockDeduplicator.h	/^	bool deduplicate();$/;"	p	class:dev::eth::BlockDeduplicator	access:public	signature:()
dev::eth::BlockDeduplicator::m_items	libevmasm/BlockDeduplicator.h	/^	AssemblyItems& m_items;$/;"	m	class:dev::eth::BlockDeduplicator	access:private
dev::eth::BlockDeduplicator::m_replacedTags	libevmasm/BlockDeduplicator.h	/^	std::map<u256, u256> m_replacedTags;$/;"	m	class:dev::eth::BlockDeduplicator	access:private
dev::eth::BlockDeduplicator::std::replacedTags	libevmasm/BlockDeduplicator.h	/^	std::map<u256, u256> const& replacedTags() const { return m_replacedTags; }$/;"	f	class:dev::eth::BlockDeduplicator::std	access:public	signature:() const
dev::eth::BlockId	libevmasm/ControlFlowGraph.h	/^class BlockId$/;"	c	namespace:dev::eth
dev::eth::BlockId::BlockId	libevmasm/ControlFlowGraph.h	/^	BlockId() { *this = invalid(); }$/;"	f	class:dev::eth::BlockId	access:public	signature:()
dev::eth::BlockId::BlockId	libevmasm/ControlFlowGraph.h	/^	explicit BlockId(u256 const& _id);$/;"	p	class:dev::eth::BlockId	access:public	signature:(u256 const& _id)
dev::eth::BlockId::BlockId	libevmasm/ControlFlowGraph.h	/^	explicit BlockId(unsigned _id): m_id(_id) {}$/;"	f	class:dev::eth::BlockId	access:public	signature:(unsigned _id)
dev::eth::BlockId::initial	libevmasm/ControlFlowGraph.h	/^	static BlockId initial() { return BlockId(-2); }$/;"	f	class:dev::eth::BlockId	access:public	signature:()
dev::eth::BlockId::invalid	libevmasm/ControlFlowGraph.h	/^	static BlockId invalid() { return BlockId(-1); }$/;"	f	class:dev::eth::BlockId	access:public	signature:()
dev::eth::BlockId::m_id	libevmasm/ControlFlowGraph.h	/^	unsigned m_id;$/;"	m	class:dev::eth::BlockId	access:private
dev::eth::BlockId::operator !=	libevmasm/ControlFlowGraph.h	/^	bool operator!=(BlockId const& _other) const { return m_id != _other.m_id; }$/;"	f	class:dev::eth::BlockId	access:public	signature:(BlockId const& _other) const
dev::eth::BlockId::operator <	libevmasm/ControlFlowGraph.h	/^	bool operator<(BlockId const& _other) const { return m_id < _other.m_id; }$/;"	f	class:dev::eth::BlockId	access:public	signature:(BlockId const& _other) const
dev::eth::BlockId::operator ==	libevmasm/ControlFlowGraph.h	/^	bool operator==(BlockId const& _other) const { return m_id == _other.m_id; }$/;"	f	class:dev::eth::BlockId	access:public	signature:(BlockId const& _other) const
dev::eth::BlockId::operator bool	libevmasm/ControlFlowGraph.h	/^	explicit operator bool() const { return *this != invalid(); }$/;"	f	class:dev::eth::BlockId	access:public	signature:() const
dev::eth::CSECodeGenerator	libevmasm/CommonSubexpressionEliminator.h	/^class CSECodeGenerator$/;"	c	namespace:dev::eth
dev::eth::CSECodeGenerator::addDependencies	libevmasm/CommonSubexpressionEliminator.h	/^	void addDependencies(Id _c);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _c)
dev::eth::CSECodeGenerator::appendDup	libevmasm/CommonSubexpressionEliminator.h	/^	void appendDup(int _fromPosition, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(int _fromPosition, langutil::SourceLocation const& _location)
dev::eth::CSECodeGenerator::appendItem	libevmasm/CommonSubexpressionEliminator.h	/^	void appendItem(AssemblyItem const& _item);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(AssemblyItem const& _item)
dev::eth::CSECodeGenerator::appendOrRemoveSwap	libevmasm/CommonSubexpressionEliminator.h	/^	void appendOrRemoveSwap(int _fromPosition, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(int _fromPosition, langutil::SourceLocation const& _location)
dev::eth::CSECodeGenerator::c_invalidPosition	libevmasm/CommonSubexpressionEliminator.h	/^	static int const c_invalidPosition = -0x7fffffff;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::canBeRemoved	libevmasm/CommonSubexpressionEliminator.h	/^	bool canBeRemoved(Id _element, Id _result = Id(-1), int _fromPosition = c_invalidPosition);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _element, Id _result = Id(-1), int _fromPosition = c_invalidPosition)
dev::eth::CSECodeGenerator::classElementPosition	libevmasm/CommonSubexpressionEliminator.h	/^	int classElementPosition(Id _id) const;$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _id) const
dev::eth::CSECodeGenerator::generateClassElement	libevmasm/CommonSubexpressionEliminator.h	/^	void generateClassElement(Id _c, bool _allowSequenced = false);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _c, bool _allowSequenced = false)
dev::eth::CSECodeGenerator::generateCode	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItems generateCode($/;"	p	class:dev::eth::CSECodeGenerator	access:public	signature:( unsigned _initialSequenceNumber, int _initialStackHeight, std::map<int, Id> const& _initialStack, std::map<int, Id> const& _targetStackContents )
dev::eth::CSECodeGenerator::m_classPositions	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<Id, std::set<int>> m_classPositions;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_expressionClasses	libevmasm/CommonSubexpressionEliminator.h	/^	ExpressionClasses& m_expressionClasses;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_finalClasses	libevmasm/CommonSubexpressionEliminator.h	/^	std::set<Id> m_finalClasses;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_generatedItems	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItems m_generatedItems;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_neededBy	libevmasm/CommonSubexpressionEliminator.h	/^	std::multimap<Id, Id> m_neededBy;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_stack	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<int, Id> m_stack;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_stackHeight	libevmasm/CommonSubexpressionEliminator.h	/^	int m_stackHeight = 0;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_storeOperations	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<std::pair<StoreOperation::Target, Id>, StoreOperations> m_storeOperations;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::m_targetStack	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<int, Id> m_targetStack;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
dev::eth::CSECodeGenerator::removeStackTopIfPossible	libevmasm/CommonSubexpressionEliminator.h	/^	bool removeStackTopIfPossible();$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:()
dev::eth::CodeCopyMethod	libevmasm/ConstantOptimiser.h	/^class CodeCopyMethod: public ConstantOptimisationMethod$/;"	c	namespace:dev::eth	inherits:ConstantOptimisationMethod
dev::eth::CodeCopyMethod::CodeCopyMethod	libevmasm/ConstantOptimiser.h	/^	explicit CodeCopyMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::CodeCopyMethod	access:public	signature:(Params const& _params, u256 const& _value)
dev::eth::CodeCopyMethod::copyRoutine	libevmasm/ConstantOptimiser.h	/^	static AssemblyItems const& copyRoutine();$/;"	p	class:dev::eth::CodeCopyMethod	access:protected	signature:()
dev::eth::CodeCopyMethod::override	libevmasm/ConstantOptimiser.h	/^	AssemblyItems execute(Assembly& _assembly) const override;$/;"	m	class:dev::eth::CodeCopyMethod	access:public
dev::eth::CodeCopyMethod::override	libevmasm/ConstantOptimiser.h	/^	bigint gasNeeded() const override;$/;"	m	class:dev::eth::CodeCopyMethod	access:public
dev::eth::CommonSubexpressionEliminator	libevmasm/CommonSubexpressionEliminator.h	/^class CommonSubexpressionEliminator$/;"	c	namespace:dev::eth
dev::eth::CommonSubexpressionEliminator::CommonSubexpressionEliminator	libevmasm/CommonSubexpressionEliminator.h	/^	explicit CommonSubexpressionEliminator(KnownState const& _state): m_initialState(_state), m_state(_state) {}$/;"	f	class:dev::eth::CommonSubexpressionEliminator	access:public	signature:(KnownState const& _state)
dev::eth::CommonSubexpressionEliminator::feedItem	libevmasm/CommonSubexpressionEliminator.h	/^	void feedItem(AssemblyItem const& _item, bool _copyItem = false);$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:private	signature:(AssemblyItem const& _item, bool _copyItem = false)
dev::eth::CommonSubexpressionEliminator::feedItems	libevmasm/CommonSubexpressionEliminator.h	/^	_AssemblyItemIterator feedItems(_AssemblyItemIterator _iterator, _AssemblyItemIterator _end, bool _msizeImportant);$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:public	signature:(_AssemblyItemIterator _iterator, _AssemblyItemIterator _end, bool _msizeImportant)
dev::eth::CommonSubexpressionEliminator::feedItems	libevmasm/CommonSubexpressionEliminator.h	/^_AssemblyItemIterator CommonSubexpressionEliminator::feedItems($/;"	f	class:dev::eth::CommonSubexpressionEliminator	signature:( _AssemblyItemIterator _iterator, _AssemblyItemIterator _end, bool _msizeImportant )
dev::eth::CommonSubexpressionEliminator::getOptimizedItems	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItems getOptimizedItems();$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:public	signature:()
dev::eth::CommonSubexpressionEliminator::m_breakingItem	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItem const* m_breakingItem = nullptr;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
dev::eth::CommonSubexpressionEliminator::m_initialState	libevmasm/CommonSubexpressionEliminator.h	/^	KnownState m_initialState;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
dev::eth::CommonSubexpressionEliminator::m_state	libevmasm/CommonSubexpressionEliminator.h	/^	KnownState m_state;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
dev::eth::CommonSubexpressionEliminator::m_storeOperations	libevmasm/CommonSubexpressionEliminator.h	/^	std::vector<StoreOperation> m_storeOperations;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
dev::eth::CommonSubexpressionEliminator::optimizeBreakingItem	libevmasm/CommonSubexpressionEliminator.h	/^	void optimizeBreakingItem();$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:private	signature:()
dev::eth::ComputeMethod	libevmasm/ConstantOptimiser.h	/^class ComputeMethod: public ConstantOptimisationMethod$/;"	c	namespace:dev::eth	inherits:ConstantOptimisationMethod
dev::eth::ComputeMethod::ComputeMethod	libevmasm/ConstantOptimiser.h	/^	explicit ComputeMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::ComputeMethod	access:public	signature:(Params const& _params, u256 const& _value)
dev::eth::ComputeMethod::checkRepresentation	libevmasm/ConstantOptimiser.h	/^	bool checkRepresentation(u256 const& _value, AssemblyItems const& _routine) const;$/;"	p	class:dev::eth::ComputeMethod	access:protected	signature:(u256 const& _value, AssemblyItems const& _routine) const
dev::eth::ComputeMethod::findRepresentation	libevmasm/ConstantOptimiser.h	/^	AssemblyItems findRepresentation(u256 const& _value);$/;"	p	class:dev::eth::ComputeMethod	access:protected	signature:(u256 const& _value)
dev::eth::ComputeMethod::gasNeeded	libevmasm/ConstantOptimiser.h	/^	bigint gasNeeded(AssemblyItems const& _routine) const;$/;"	p	class:dev::eth::ComputeMethod	access:protected	signature:(AssemblyItems const& _routine) const
dev::eth::ComputeMethod::m_maxSteps	libevmasm/ConstantOptimiser.h	/^	size_t m_maxSteps = 10000;$/;"	m	class:dev::eth::ComputeMethod	access:protected
dev::eth::ComputeMethod::m_routine	libevmasm/ConstantOptimiser.h	/^	AssemblyItems m_routine;$/;"	m	class:dev::eth::ComputeMethod	access:protected
dev::eth::ConstantOptimisationMethod	libevmasm/ConstantOptimiser.h	/^class ConstantOptimisationMethod$/;"	c	namespace:dev::eth
dev::eth::ConstantOptimisationMethod::ConstantOptimisationMethod	libevmasm/ConstantOptimiser.h	/^	explicit ConstantOptimisationMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(Params const& _params, u256 const& _value)
dev::eth::ConstantOptimisationMethod::Params	libevmasm/ConstantOptimiser.h	/^	struct Params$/;"	s	class:dev::eth::ConstantOptimisationMethod	access:protected
dev::eth::ConstantOptimisationMethod::Params::evmVersion	libevmasm/ConstantOptimiser.h	/^		langutil::EVMVersion evmVersion; \/\/\/< Version of the EVM$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
dev::eth::ConstantOptimisationMethod::Params::isCreation	libevmasm/ConstantOptimiser.h	/^		bool isCreation; \/\/\/< Whether this is called during contract creation or runtime.$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
dev::eth::ConstantOptimisationMethod::Params::multiplicity	libevmasm/ConstantOptimiser.h	/^		size_t multiplicity; \/\/\/< Number of times the constant appears in the code.$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
dev::eth::ConstantOptimisationMethod::Params::runs	libevmasm/ConstantOptimiser.h	/^		size_t runs; \/\/\/< Estimated number of calls per opcode oven the lifetime of the contract.$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
dev::eth::ConstantOptimisationMethod::bytesRequired	libevmasm/ConstantOptimiser.h	/^	static size_t bytesRequired(AssemblyItems const& _items);$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(AssemblyItems const& _items)
dev::eth::ConstantOptimisationMethod::combineGas	libevmasm/ConstantOptimiser.h	/^	bigint combineGas($/;"	f	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:( bigint const& _runGas, bigint const& _repeatedDataGas, bigint const& _uniqueDataGas ) const
dev::eth::ConstantOptimisationMethod::dataGas	libevmasm/ConstantOptimiser.h	/^	bigint dataGas(bytes const& _data) const;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(bytes const& _data) const
dev::eth::ConstantOptimisationMethod::execute	libevmasm/ConstantOptimiser.h	/^	virtual AssemblyItems execute(Assembly& _assembly) const = 0;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(Assembly& _assembly) const
dev::eth::ConstantOptimisationMethod::gasNeeded	libevmasm/ConstantOptimiser.h	/^	virtual bigint gasNeeded() const = 0;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:() const
dev::eth::ConstantOptimisationMethod::m_params	libevmasm/ConstantOptimiser.h	/^	Params m_params;$/;"	m	class:dev::eth::ConstantOptimisationMethod	access:protected
dev::eth::ConstantOptimisationMethod::m_value	libevmasm/ConstantOptimiser.h	/^	u256 const& m_value;$/;"	m	class:dev::eth::ConstantOptimisationMethod	access:protected
dev::eth::ConstantOptimisationMethod::optimiseConstants	libevmasm/ConstantOptimiser.h	/^	static unsigned optimiseConstants($/;"	p	class:dev::eth::ConstantOptimisationMethod	access:public	signature:( bool _isCreation, size_t _runs, langutil::EVMVersion _evmVersion, Assembly& _assembly )
dev::eth::ConstantOptimisationMethod::replaceConstants	libevmasm/ConstantOptimiser.h	/^	static void replaceConstants(AssemblyItems& _items, std::map<u256, AssemblyItems> const& _replacements);$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(AssemblyItems& _items, std::map<u256, AssemblyItems> const& _replacements)
dev::eth::ConstantOptimisationMethod::simpleRunGas	libevmasm/ConstantOptimiser.h	/^	static bigint simpleRunGas(AssemblyItems const& _items);$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(AssemblyItems const& _items)
dev::eth::ConstantOptimisationMethod::~ConstantOptimisationMethod	libevmasm/ConstantOptimiser.h	/^	virtual ~ConstantOptimisationMethod() = default;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:()
dev::eth::ControlFlowGraph	libevmasm/ControlFlowGraph.h	/^class ControlFlowGraph$/;"	c	namespace:dev::eth
dev::eth::ControlFlowGraph::ControlFlowGraph	libevmasm/ControlFlowGraph.h	/^	explicit ControlFlowGraph(AssemblyItems const& _items, bool _joinKnowledge = true):$/;"	f	class:dev::eth::ControlFlowGraph	access:public	signature:(AssemblyItems const& _items, bool _joinKnowledge = true)
dev::eth::ControlFlowGraph::findLargestTag	libevmasm/ControlFlowGraph.h	/^	void findLargestTag();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::gatherKnowledge	libevmasm/ControlFlowGraph.h	/^	void gatherKnowledge();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::generateNewId	libevmasm/ControlFlowGraph.h	/^	BlockId generateNewId();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::m_blocks	libevmasm/ControlFlowGraph.h	/^	std::map<BlockId, BasicBlock> m_blocks;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
dev::eth::ControlFlowGraph::m_items	libevmasm/ControlFlowGraph.h	/^	AssemblyItems const& m_items;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
dev::eth::ControlFlowGraph::m_joinKnowledge	libevmasm/ControlFlowGraph.h	/^	bool m_joinKnowledge = true;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
dev::eth::ControlFlowGraph::m_lastUsedId	libevmasm/ControlFlowGraph.h	/^	unsigned m_lastUsedId = 0;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
dev::eth::ControlFlowGraph::optimisedBlocks	libevmasm/ControlFlowGraph.h	/^	BasicBlocks optimisedBlocks();$/;"	p	class:dev::eth::ControlFlowGraph	access:public	signature:()
dev::eth::ControlFlowGraph::rebuildCode	libevmasm/ControlFlowGraph.h	/^	BasicBlocks rebuildCode();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::removeUnusedBlocks	libevmasm/ControlFlowGraph.h	/^	void removeUnusedBlocks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::resolveNextLinks	libevmasm/ControlFlowGraph.h	/^	void resolveNextLinks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::setPrevLinks	libevmasm/ControlFlowGraph.h	/^	void setPrevLinks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ControlFlowGraph::splitBlocks	libevmasm/ControlFlowGraph.h	/^	void splitBlocks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
dev::eth::ExpressionClasses	libevmasm/ExpressionClasses.h	/^class ExpressionClasses$/;"	c	namespace:dev::eth
dev::eth::ExpressionClasses::Expression	libevmasm/ExpressionClasses.h	/^	struct Expression$/;"	s	class:dev::eth::ExpressionClasses	access:public
dev::eth::ExpressionClasses::Expression::arguments	libevmasm/ExpressionClasses.h	/^		Ids arguments;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
dev::eth::ExpressionClasses::Expression::id	libevmasm/ExpressionClasses.h	/^		Id id;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
dev::eth::ExpressionClasses::Expression::item	libevmasm/ExpressionClasses.h	/^		AssemblyItem const* item = nullptr;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
dev::eth::ExpressionClasses::Expression::operator <	libevmasm/ExpressionClasses.h	/^		bool operator<(Expression const& _other) const;$/;"	p	struct:dev::eth::ExpressionClasses::Expression	access:public	signature:(Expression const& _other) const
dev::eth::ExpressionClasses::Expression::sequenceNumber	libevmasm/ExpressionClasses.h	/^		unsigned sequenceNumber = 0;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
dev::eth::ExpressionClasses::createRules	libevmasm/ExpressionClasses.h	/^	std::vector<std::pair<Pattern, std::function<Pattern()>>> createRules() const;$/;"	p	class:dev::eth::ExpressionClasses	access:private	signature:() const
dev::eth::ExpressionClasses::find	libevmasm/ExpressionClasses.h	/^	Id find($/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:( AssemblyItem const& _item, Ids const& _arguments = {}, bool _copyItem = true, unsigned _sequenceNumber = 0 )
dev::eth::ExpressionClasses::forceEqual	libevmasm/ExpressionClasses.h	/^	void forceEqual(Id _id, AssemblyItem const& _item, Ids const& _arguments, bool _copyItem = true);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _id, AssemblyItem const& _item, Ids const& _arguments, bool _copyItem = true)
dev::eth::ExpressionClasses::fullDAGToString	libevmasm/ExpressionClasses.h	/^	std::string fullDAGToString(Id _id) const;$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _id) const
dev::eth::ExpressionClasses::knownConstant	libevmasm/ExpressionClasses.h	/^	u256 const* knownConstant(Id _c);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _c)
dev::eth::ExpressionClasses::knownNonZero	libevmasm/ExpressionClasses.h	/^	bool knownNonZero(Id _c);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _c)
dev::eth::ExpressionClasses::knownToBeDifferent	libevmasm/ExpressionClasses.h	/^	bool knownToBeDifferent(Id _a, Id _b);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _a, Id _b)
dev::eth::ExpressionClasses::knownToBeDifferentBy32	libevmasm/ExpressionClasses.h	/^	bool knownToBeDifferentBy32(Id _a, Id _b);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _a, Id _b)
dev::eth::ExpressionClasses::knownZero	libevmasm/ExpressionClasses.h	/^	bool knownZero(Id _c);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _c)
dev::eth::ExpressionClasses::m_expressions	libevmasm/ExpressionClasses.h	/^	std::set<Expression> m_expressions;$/;"	m	class:dev::eth::ExpressionClasses	access:private
dev::eth::ExpressionClasses::m_representatives	libevmasm/ExpressionClasses.h	/^	std::vector<Expression> m_representatives;$/;"	m	class:dev::eth::ExpressionClasses	access:private
dev::eth::ExpressionClasses::m_spareAssemblyItems	libevmasm/ExpressionClasses.h	/^	std::vector<std::shared_ptr<AssemblyItem>> m_spareAssemblyItems;$/;"	m	class:dev::eth::ExpressionClasses	access:private
dev::eth::ExpressionClasses::newClass	libevmasm/ExpressionClasses.h	/^	Id newClass(langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(langutil::SourceLocation const& _location)
dev::eth::ExpressionClasses::rebuildExpression	libevmasm/ExpressionClasses.h	/^	Id rebuildExpression(ExpressionTemplate const& _template);$/;"	p	class:dev::eth::ExpressionClasses	access:private	signature:(ExpressionTemplate const& _template)
dev::eth::ExpressionClasses::representative	libevmasm/ExpressionClasses.h	/^	Expression const& representative(Id _id) const { return m_representatives.at(_id); }$/;"	f	class:dev::eth::ExpressionClasses	access:public	signature:(Id _id) const
dev::eth::ExpressionClasses::size	libevmasm/ExpressionClasses.h	/^	Id size() const { return m_representatives.size(); }$/;"	f	class:dev::eth::ExpressionClasses	access:public	signature:() const
dev::eth::ExpressionClasses::storeItem	libevmasm/ExpressionClasses.h	/^	AssemblyItem const* storeItem(AssemblyItem const& _item);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(AssemblyItem const& _item)
dev::eth::ExpressionClasses::tryToSimplify	libevmasm/ExpressionClasses.h	/^	Id tryToSimplify(Expression const& _expr);$/;"	p	class:dev::eth::ExpressionClasses	access:private	signature:(Expression const& _expr)
dev::eth::ExpressionTemplate	libevmasm/SimplificationRules.h	/^struct ExpressionTemplate$/;"	s	namespace:dev::eth
dev::eth::ExpressionTemplate::arguments	libevmasm/SimplificationRules.h	/^	std::vector<ExpressionTemplate> arguments;$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
dev::eth::ExpressionTemplate::hasId	libevmasm/SimplificationRules.h	/^	bool hasId = false;$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
dev::eth::ExpressionTemplate::id	libevmasm/SimplificationRules.h	/^	Id id = Id(-1);$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
dev::eth::ExpressionTemplate::item	libevmasm/SimplificationRules.h	/^	AssemblyItem item = UndefinedItem;$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
dev::eth::ExpressionTemplate::toString	libevmasm/SimplificationRules.h	/^	std::string toString() const;$/;"	p	struct:dev::eth::ExpressionTemplate	access:public	signature:() const
dev::eth::GasCosts	libevmasm/GasMeter.h	/^namespace GasCosts$/;"	n	namespace:dev::eth
dev::eth::GasCosts::balanceGas	libevmasm/GasMeter.h	/^	inline unsigned balanceGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
dev::eth::GasCosts::callGas	libevmasm/GasMeter.h	/^	inline unsigned callGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
dev::eth::GasCosts::callNewAccountGas	libevmasm/GasMeter.h	/^	static unsigned const callNewAccountGas = 25000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::callStipend	libevmasm/GasMeter.h	/^	static unsigned const callStipend = 2300;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::callValueTransferGas	libevmasm/GasMeter.h	/^	static unsigned const callValueTransferGas = 9000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::copyGas	libevmasm/GasMeter.h	/^	static unsigned const copyGas = 3;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::createDataGas	libevmasm/GasMeter.h	/^	static unsigned const createDataGas = 200;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::createGas	libevmasm/GasMeter.h	/^	static unsigned const createGas = 32000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::expByteGas	libevmasm/GasMeter.h	/^	inline unsigned expByteGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
dev::eth::GasCosts::expGas	libevmasm/GasMeter.h	/^	static unsigned const expGas = 10;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::extCodeGas	libevmasm/GasMeter.h	/^	inline unsigned extCodeGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
dev::eth::GasCosts::jumpdestGas	libevmasm/GasMeter.h	/^	static unsigned const jumpdestGas = 1;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::keccak256Gas	libevmasm/GasMeter.h	/^	static unsigned const keccak256Gas = 30;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::keccak256WordGas	libevmasm/GasMeter.h	/^	static unsigned const keccak256WordGas = 6;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::logDataGas	libevmasm/GasMeter.h	/^	static unsigned const logDataGas = 8;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::logGas	libevmasm/GasMeter.h	/^	static unsigned const logGas = 375;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::logTopicGas	libevmasm/GasMeter.h	/^	static unsigned const logTopicGas = 375;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::memoryGas	libevmasm/GasMeter.h	/^	static unsigned const memoryGas = 3;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::quadCoeffDiv	libevmasm/GasMeter.h	/^	static unsigned const quadCoeffDiv = 512;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::selfdestructGas	libevmasm/GasMeter.h	/^	inline unsigned selfdestructGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
dev::eth::GasCosts::selfdestructRefundGas	libevmasm/GasMeter.h	/^	static unsigned const selfdestructRefundGas = 24000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::sloadGas	libevmasm/GasMeter.h	/^	inline unsigned sloadGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
dev::eth::GasCosts::sstoreRefundGas	libevmasm/GasMeter.h	/^	static unsigned const sstoreRefundGas = 15000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::sstoreResetGas	libevmasm/GasMeter.h	/^	static unsigned const sstoreResetGas = 5000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::sstoreSetGas	libevmasm/GasMeter.h	/^	static unsigned const sstoreSetGas = 20000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::stackLimit	libevmasm/GasMeter.h	/^	static unsigned const stackLimit = 1024;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier0Gas	libevmasm/GasMeter.h	/^	static unsigned const tier0Gas = 0;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier1Gas	libevmasm/GasMeter.h	/^	static unsigned const tier1Gas = 2;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier2Gas	libevmasm/GasMeter.h	/^	static unsigned const tier2Gas = 3;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier3Gas	libevmasm/GasMeter.h	/^	static unsigned const tier3Gas = 5;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier4Gas	libevmasm/GasMeter.h	/^	static unsigned const tier4Gas = 8;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier5Gas	libevmasm/GasMeter.h	/^	static unsigned const tier5Gas = 10;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier6Gas	libevmasm/GasMeter.h	/^	static unsigned const tier6Gas = 20;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::tier7Gas	libevmasm/GasMeter.h	/^	static unsigned const tier7Gas = 0;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::txCreateGas	libevmasm/GasMeter.h	/^	static unsigned const txCreateGas = 53000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::txDataNonZeroGas	libevmasm/GasMeter.h	/^	static unsigned const txDataNonZeroGas = 68;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::txDataZeroGas	libevmasm/GasMeter.h	/^	static unsigned const txDataZeroGas = 4;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasCosts::txGas	libevmasm/GasMeter.h	/^	static unsigned const txGas = 21000;$/;"	m	namespace:dev::eth::GasCosts
dev::eth::GasMeter	libevmasm/GasMeter.h	/^class GasMeter$/;"	c	namespace:dev::eth
dev::eth::GasMeter::GasConsumption	libevmasm/GasMeter.h	/^	struct GasConsumption$/;"	s	class:dev::eth::GasMeter	access:public
dev::eth::GasMeter::GasConsumption::GasConsumption	libevmasm/GasMeter.h	/^		GasConsumption(u256 _value, bool _infinite = false): value(_value), isInfinite(_infinite) {}$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(u256 _value, bool _infinite = false)
dev::eth::GasMeter::GasConsumption::GasConsumption	libevmasm/GasMeter.h	/^		GasConsumption(unsigned _value = 0, bool _infinite = false): value(_value), isInfinite(_infinite) {}$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(unsigned _value = 0, bool _infinite = false)
dev::eth::GasMeter::GasConsumption::infinite	libevmasm/GasMeter.h	/^		static GasConsumption infinite() { return GasConsumption(0, true); }$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:()
dev::eth::GasMeter::GasConsumption::isInfinite	libevmasm/GasMeter.h	/^		bool isInfinite;$/;"	m	struct:dev::eth::GasMeter::GasConsumption	access:public
dev::eth::GasMeter::GasConsumption::operator +=	libevmasm/GasMeter.h	/^		GasConsumption& operator+=(GasConsumption const& _other);$/;"	p	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(GasConsumption const& _other)
dev::eth::GasMeter::GasConsumption::operator <	libevmasm/GasMeter.h	/^		bool operator<(GasConsumption const& _other) const$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(GasConsumption const& _other) const
dev::eth::GasMeter::GasConsumption::value	libevmasm/GasMeter.h	/^		u256 value;$/;"	m	struct:dev::eth::GasMeter::GasConsumption	access:public
dev::eth::GasMeter::GasMeter	libevmasm/GasMeter.h	/^	GasMeter(std::shared_ptr<KnownState> const& _state, langutil::EVMVersion _evmVersion, u256 const& _largestMemoryAccess = 0):$/;"	f	class:dev::eth::GasMeter	access:public	signature:(std::shared_ptr<KnownState> const& _state, langutil::EVMVersion _evmVersion, u256 const& _largestMemoryAccess = 0)
dev::eth::GasMeter::dataGas	libevmasm/GasMeter.h	/^	static u256 dataGas(bytes const& _data, bool _inCreation);$/;"	p	class:dev::eth::GasMeter	access:public	signature:(bytes const& _data, bool _inCreation)
dev::eth::GasMeter::estimateMax	libevmasm/GasMeter.h	/^	GasConsumption estimateMax(AssemblyItem const& _item, bool _includeExternalCosts = true);$/;"	p	class:dev::eth::GasMeter	access:public	signature:(AssemblyItem const& _item, bool _includeExternalCosts = true)
dev::eth::GasMeter::largestMemoryAccess	libevmasm/GasMeter.h	/^	u256 const& largestMemoryAccess() const { return m_largestMemoryAccess; }$/;"	f	class:dev::eth::GasMeter	access:public	signature:() const
dev::eth::GasMeter::m_evmVersion	libevmasm/GasMeter.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::eth::GasMeter	access:private
dev::eth::GasMeter::m_largestMemoryAccess	libevmasm/GasMeter.h	/^	u256 m_largestMemoryAccess;$/;"	m	class:dev::eth::GasMeter	access:private
dev::eth::GasMeter::m_state	libevmasm/GasMeter.h	/^	std::shared_ptr<KnownState> m_state;$/;"	m	class:dev::eth::GasMeter	access:private
dev::eth::GasMeter::memoryGas	libevmasm/GasMeter.h	/^	GasConsumption memoryGas(ExpressionClasses::Id _position);$/;"	p	class:dev::eth::GasMeter	access:private	signature:(ExpressionClasses::Id _position)
dev::eth::GasMeter::memoryGas	libevmasm/GasMeter.h	/^	GasConsumption memoryGas(int _stackPosOffset, int _stackPosSize);$/;"	p	class:dev::eth::GasMeter	access:private	signature:(int _stackPosOffset, int _stackPosSize)
dev::eth::GasMeter::runGas	libevmasm/GasMeter.h	/^	static unsigned runGas(Instruction _instruction);$/;"	p	class:dev::eth::GasMeter	access:public	signature:(Instruction _instruction)
dev::eth::GasMeter::wordGas	libevmasm/GasMeter.h	/^	GasConsumption wordGas(u256 const& _multiplier, ExpressionClasses::Id _value);$/;"	p	class:dev::eth::GasMeter	access:private	signature:(u256 const& _multiplier, ExpressionClasses::Id _value)
dev::eth::GasPath	libevmasm/PathGasMeter.h	/^struct GasPath$/;"	s	namespace:dev::eth
dev::eth::GasPath::gas	libevmasm/PathGasMeter.h	/^	GasMeter::GasConsumption gas;$/;"	m	struct:dev::eth::GasPath	access:public
dev::eth::GasPath::index	libevmasm/PathGasMeter.h	/^	size_t index = 0;$/;"	m	struct:dev::eth::GasPath	access:public
dev::eth::GasPath::largestMemoryAccess	libevmasm/PathGasMeter.h	/^	u256 largestMemoryAccess;$/;"	m	struct:dev::eth::GasPath	access:public
dev::eth::GasPath::state	libevmasm/PathGasMeter.h	/^	std::shared_ptr<KnownState> state;$/;"	m	struct:dev::eth::GasPath	access:public
dev::eth::GasPath::visitedJumpdests	libevmasm/PathGasMeter.h	/^	std::set<size_t> visitedJumpdests;$/;"	m	struct:dev::eth::GasPath	access:public
dev::eth::ItemNotAvailableException	libevmasm/Exceptions.h	/^struct ItemNotAvailableException: virtual OptimizerException {};$/;"	s	namespace:dev::eth	inherits:OptimizerException
dev::eth::JumpdestRemover	libevmasm/JumpdestRemover.h	/^class JumpdestRemover$/;"	c	namespace:dev::eth
dev::eth::JumpdestRemover::JumpdestRemover	libevmasm/JumpdestRemover.h	/^	explicit JumpdestRemover(AssemblyItems& _items): m_items(_items) {}$/;"	f	class:dev::eth::JumpdestRemover	access:public	signature:(AssemblyItems& _items)
dev::eth::JumpdestRemover::m_items	libevmasm/JumpdestRemover.h	/^	AssemblyItems& m_items;$/;"	m	class:dev::eth::JumpdestRemover	access:private
dev::eth::JumpdestRemover::optimise	libevmasm/JumpdestRemover.h	/^	bool optimise(std::set<size_t> const& _tagsReferencedFromOutside);$/;"	p	class:dev::eth::JumpdestRemover	access:public	signature:(std::set<size_t> const& _tagsReferencedFromOutside)
dev::eth::JumpdestRemover::referencedTags	libevmasm/JumpdestRemover.h	/^	static std::set<size_t> referencedTags(AssemblyItems const& _items, size_t _subId);$/;"	p	class:dev::eth::JumpdestRemover	access:public	signature:(AssemblyItems const& _items, size_t _subId)
dev::eth::KnownState	libevmasm/KnownState.h	/^class KnownState$/;"	c	namespace:dev::eth
dev::eth::KnownState::KnownState	libevmasm/KnownState.h	/^	explicit KnownState($/;"	f	class:dev::eth::KnownState	access:public	signature:( std::shared_ptr<ExpressionClasses> _expressionClasses = std::make_shared<ExpressionClasses>() )
dev::eth::KnownState::StoreOperation	libevmasm/KnownState.h	/^	struct StoreOperation$/;"	s	class:dev::eth::KnownState	access:public
dev::eth::KnownState::StoreOperation::Invalid	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	e	enum:dev::eth::KnownState::StoreOperation::Target
dev::eth::KnownState::StoreOperation::Memory	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	e	enum:dev::eth::KnownState::StoreOperation::Target
dev::eth::KnownState::StoreOperation::Storage	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	e	enum:dev::eth::KnownState::StoreOperation::Target
dev::eth::KnownState::StoreOperation::Target	libevmasm/KnownState.h	/^		enum Target { Invalid, Memory, Storage };$/;"	g	struct:dev::eth::KnownState::StoreOperation	access:public
dev::eth::KnownState::StoreOperation::isValid	libevmasm/KnownState.h	/^		bool isValid() const { return target != Invalid; }$/;"	f	struct:dev::eth::KnownState::StoreOperation	access:public	signature:() const
dev::eth::KnownState::applyKeccak256	libevmasm/KnownState.h	/^	Id applyKeccak256(Id _start, Id _length, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _start, Id _length, langutil::SourceLocation const& _location)
dev::eth::KnownState::clearTagUnions	libevmasm/KnownState.h	/^	void clearTagUnions();$/;"	p	class:dev::eth::KnownState	access:public	signature:()
dev::eth::KnownState::copy	libevmasm/KnownState.h	/^	std::shared_ptr<KnownState> copy() const { return std::make_shared<KnownState>(*this); }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
dev::eth::KnownState::expressionClasses	libevmasm/KnownState.h	/^	ExpressionClasses& expressionClasses() const { return *m_expressionClasses; }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
dev::eth::KnownState::feedItem	libevmasm/KnownState.h	/^	StoreOperation feedItem(AssemblyItem const& _item, bool _copyItem = false);$/;"	p	class:dev::eth::KnownState	access:public	signature:(AssemblyItem const& _item, bool _copyItem = false)
dev::eth::KnownState::loadFromMemory	libevmasm/KnownState.h	/^	Id loadFromMemory(Id _slot, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, langutil::SourceLocation const& _location)
dev::eth::KnownState::loadFromStorage	libevmasm/KnownState.h	/^	Id loadFromStorage(Id _slot, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, langutil::SourceLocation const& _location)
dev::eth::KnownState::m_expressionClasses	libevmasm/KnownState.h	/^	std::shared_ptr<ExpressionClasses> m_expressionClasses;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_knownKeccak256Hashes	libevmasm/KnownState.h	/^	std::map<std::vector<Id>, Id> m_knownKeccak256Hashes;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_memoryContent	libevmasm/KnownState.h	/^	std::map<Id, Id> m_memoryContent;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_sequenceNumber	libevmasm/KnownState.h	/^	unsigned m_sequenceNumber = 1;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_stackElements	libevmasm/KnownState.h	/^	std::map<int, Id> m_stackElements;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_stackHeight	libevmasm/KnownState.h	/^	int m_stackHeight = 0;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_storageContent	libevmasm/KnownState.h	/^	std::map<Id, Id> m_storageContent;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::m_tagUnions	libevmasm/KnownState.h	/^	boost::bimap<Id, std::set<u256>> m_tagUnions;$/;"	m	class:dev::eth::KnownState	access:private
dev::eth::KnownState::operator ==	libevmasm/KnownState.h	/^	bool operator==(KnownState const& _other) const;$/;"	p	class:dev::eth::KnownState	access:public	signature:(KnownState const& _other) const
dev::eth::KnownState::reduceToCommonKnowledge	libevmasm/KnownState.h	/^	void reduceToCommonKnowledge(KnownState const& _other, bool _combineSequenceNumbers);$/;"	p	class:dev::eth::KnownState	access:public	signature:(KnownState const& _other, bool _combineSequenceNumbers)
dev::eth::KnownState::relativeStackElement	libevmasm/KnownState.h	/^	Id relativeStackElement(int _stackOffset, langutil::SourceLocation const& _location = {});$/;"	p	class:dev::eth::KnownState	access:public	signature:(int _stackOffset, langutil::SourceLocation const& _location = {})
dev::eth::KnownState::reset	libevmasm/KnownState.h	/^	void reset() { resetStorage(); resetMemory(); resetStack(); }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
dev::eth::KnownState::resetMemory	libevmasm/KnownState.h	/^	void resetMemory() { m_memoryContent.clear(); }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
dev::eth::KnownState::resetStack	libevmasm/KnownState.h	/^	void resetStack() { m_stackElements.clear(); m_stackHeight = 0; }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
dev::eth::KnownState::resetStorage	libevmasm/KnownState.h	/^	void resetStorage() { m_storageContent.clear(); }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
dev::eth::KnownState::sequenceNumber	libevmasm/KnownState.h	/^	unsigned sequenceNumber() const { return m_sequenceNumber; }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
dev::eth::KnownState::setStackElement	libevmasm/KnownState.h	/^	void setStackElement(int _stackHeight, Id _class);$/;"	p	class:dev::eth::KnownState	access:private	signature:(int _stackHeight, Id _class)
dev::eth::KnownState::stackElement	libevmasm/KnownState.h	/^	Id stackElement(int _stackHeight, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:public	signature:(int _stackHeight, langutil::SourceLocation const& _location)
dev::eth::KnownState::stackHeight	libevmasm/KnownState.h	/^	int stackHeight() const { return m_stackHeight; }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
dev::eth::KnownState::std::stackElements	libevmasm/KnownState.h	/^	std::map<int, Id> const& stackElements() const { return m_stackElements; }$/;"	f	class:dev::eth::KnownState::std	access:public	signature:() const
dev::eth::KnownState::std::storageContent	libevmasm/KnownState.h	/^	std::map<Id, Id> const& storageContent() const { return m_storageContent; }$/;"	f	class:dev::eth::KnownState::std	access:public	signature:() const
dev::eth::KnownState::storeInMemory	libevmasm/KnownState.h	/^	StoreOperation storeInMemory(Id _slot, Id _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, Id _value, langutil::SourceLocation const& _location)
dev::eth::KnownState::storeInStorage	libevmasm/KnownState.h	/^	StoreOperation storeInStorage(Id _slot, Id _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, Id _value, langutil::SourceLocation const& _location)
dev::eth::KnownState::stream	libevmasm/KnownState.h	/^	std::ostream& stream(std::ostream& _out) const;$/;"	p	class:dev::eth::KnownState	access:public	signature:(std::ostream& _out) const
dev::eth::KnownState::swapStackElements	libevmasm/KnownState.h	/^	void swapStackElements(int _stackHeightA, int _stackHeightB, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(int _stackHeightA, int _stackHeightB, langutil::SourceLocation const& _location)
dev::eth::KnownState::tagUnion	libevmasm/KnownState.h	/^	Id tagUnion(std::set<u256> _tags);$/;"	p	class:dev::eth::KnownState	access:private	signature:(std::set<u256> _tags)
dev::eth::KnownState::tagsInExpression	libevmasm/KnownState.h	/^	std::set<u256> tagsInExpression(Id _expressionId);$/;"	p	class:dev::eth::KnownState	access:public	signature:(Id _expressionId)
dev::eth::LinkerObject	libevmasm/LinkerObject.h	/^struct LinkerObject$/;"	s	namespace:dev::eth
dev::eth::LinkerObject::append	libevmasm/LinkerObject.h	/^	void append(LinkerObject const& _other);$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:(LinkerObject const& _other)
dev::eth::LinkerObject::bytecode	libevmasm/LinkerObject.h	/^	bytes bytecode;$/;"	m	struct:dev::eth::LinkerObject	access:public
dev::eth::LinkerObject::libraryPlaceholder	libevmasm/LinkerObject.h	/^	static std::string libraryPlaceholder(std::string const& _libraryName);$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:(std::string const& _libraryName)
dev::eth::LinkerObject::link	libevmasm/LinkerObject.h	/^	void link(std::map<std::string, h160> const& _libraryAddresses);$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:(std::map<std::string, h160> const& _libraryAddresses)
dev::eth::LinkerObject::linkReferences	libevmasm/LinkerObject.h	/^	std::map<size_t, std::string> linkReferences;$/;"	m	struct:dev::eth::LinkerObject	access:public
dev::eth::LinkerObject::matchLibrary	libevmasm/LinkerObject.h	/^	static h160 const* matchLibrary($/;"	p	struct:dev::eth::LinkerObject	access:private	signature:( std::string const& _linkRefName, std::map<std::string, h160> const& _libraryAddresses )
dev::eth::LinkerObject::toHex	libevmasm/LinkerObject.h	/^	std::string toHex() const;$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:() const
dev::eth::LiteralMethod	libevmasm/ConstantOptimiser.h	/^class LiteralMethod: public ConstantOptimisationMethod$/;"	c	namespace:dev::eth	inherits:ConstantOptimisationMethod
dev::eth::LiteralMethod::LiteralMethod	libevmasm/ConstantOptimiser.h	/^	explicit LiteralMethod(Params const& _params, u256 const& _value):$/;"	f	class:dev::eth::LiteralMethod	access:public	signature:(Params const& _params, u256 const& _value)
dev::eth::LiteralMethod::override	libevmasm/ConstantOptimiser.h	/^	bigint gasNeeded() const override;$/;"	m	class:dev::eth::LiteralMethod	access:public
dev::eth::Operation	libevmasm/AssemblyItem.h	/^	Operation,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::OptimizerException	libevmasm/Exceptions.h	/^struct OptimizerException: virtual AssemblyException {};$/;"	s	namespace:dev::eth	inherits:AssemblyException
dev::eth::PathGasMeter	libevmasm/PathGasMeter.h	/^class PathGasMeter$/;"	c	namespace:dev::eth
dev::eth::PathGasMeter::PathGasMeter	libevmasm/PathGasMeter.h	/^	explicit PathGasMeter(AssemblyItems const& _items, langutil::EVMVersion _evmVersion);$/;"	p	class:dev::eth::PathGasMeter	access:public	signature:(AssemblyItems const& _items, langutil::EVMVersion _evmVersion)
dev::eth::PathGasMeter::estimateMax	libevmasm/PathGasMeter.h	/^	GasMeter::GasConsumption estimateMax(size_t _startIndex, std::shared_ptr<KnownState> const& _state);$/;"	p	class:dev::eth::PathGasMeter	access:public	signature:(size_t _startIndex, std::shared_ptr<KnownState> const& _state)
dev::eth::PathGasMeter::estimateMax	libevmasm/PathGasMeter.h	/^	static GasMeter::GasConsumption estimateMax($/;"	f	class:dev::eth::PathGasMeter	access:public	signature:( AssemblyItems const& _items, langutil::EVMVersion _evmVersion, size_t _startIndex, std::shared_ptr<KnownState> const& _state )
dev::eth::PathGasMeter::handleQueueItem	libevmasm/PathGasMeter.h	/^	GasMeter::GasConsumption handleQueueItem();$/;"	p	class:dev::eth::PathGasMeter	access:private	signature:()
dev::eth::PathGasMeter::m_evmVersion	libevmasm/PathGasMeter.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::eth::PathGasMeter	access:private
dev::eth::PathGasMeter::m_highestGasUsagePerJumpdest	libevmasm/PathGasMeter.h	/^	std::map<size_t, GasMeter::GasConsumption> m_highestGasUsagePerJumpdest;$/;"	m	class:dev::eth::PathGasMeter	access:private
dev::eth::PathGasMeter::m_items	libevmasm/PathGasMeter.h	/^	AssemblyItems const& m_items;$/;"	m	class:dev::eth::PathGasMeter	access:private
dev::eth::PathGasMeter::m_queue	libevmasm/PathGasMeter.h	/^	std::map<size_t, std::unique_ptr<GasPath>> m_queue;$/;"	m	class:dev::eth::PathGasMeter	access:private
dev::eth::PathGasMeter::m_tagPositions	libevmasm/PathGasMeter.h	/^	std::map<u256, size_t> m_tagPositions;$/;"	m	class:dev::eth::PathGasMeter	access:private
dev::eth::PathGasMeter::queue	libevmasm/PathGasMeter.h	/^	void queue(std::unique_ptr<GasPath>&& _newPath);$/;"	p	class:dev::eth::PathGasMeter	access:private	signature:(std::unique_ptr<GasPath>&& _newPath)
dev::eth::Pattern	libevmasm/SimplificationRules.h	/^class Pattern$/;"	c	namespace:dev::eth
dev::eth::Pattern::Pattern	libevmasm/SimplificationRules.h	/^	Pattern(AssemblyItemType _type = UndefinedItem): m_type(_type) {}$/;"	f	class:dev::eth::Pattern	access:public	signature:(AssemblyItemType _type = UndefinedItem)
dev::eth::Pattern::Pattern	libevmasm/SimplificationRules.h	/^	Pattern(Instruction _instruction, std::vector<Pattern> const& _arguments = {});$/;"	p	class:dev::eth::Pattern	access:public	signature:(Instruction _instruction, std::vector<Pattern> const& _arguments = {})
dev::eth::Pattern::Pattern	libevmasm/SimplificationRules.h	/^	Pattern(u256 const& _value): m_type(Push), m_requireDataMatch(true), m_data(std::make_shared<u256>(_value)) {}$/;"	f	class:dev::eth::Pattern	access:public	signature:(u256 const& _value)
dev::eth::Pattern::Pattern	libevmasm/SimplificationRules.h	/^	Pattern(unsigned _value): Pattern(u256(_value)) {}$/;"	f	class:dev::eth::Pattern	access:public	signature:(unsigned _value)
dev::eth::Pattern::arguments	libevmasm/SimplificationRules.h	/^	std::vector<Pattern> arguments() const { return m_arguments; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::Pattern::d	libevmasm/SimplificationRules.h	/^	u256 const& d() const { return matchGroupValue().item->data(); }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::Pattern::data	libevmasm/SimplificationRules.h	/^	u256 const& data() const;$/;"	p	class:dev::eth::Pattern	access:private	signature:() const
dev::eth::Pattern::id	libevmasm/SimplificationRules.h	/^	Id id() const { return matchGroupValue().id; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::Pattern::instruction	libevmasm/SimplificationRules.h	/^	Instruction instruction() const$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::Pattern::m_arguments	libevmasm/SimplificationRules.h	/^	std::vector<Pattern> m_arguments;$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::m_data	libevmasm/SimplificationRules.h	/^	std::shared_ptr<u256> m_data; \/\/\/< Only valid if m_type is not Operation$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::m_instruction	libevmasm/SimplificationRules.h	/^	Instruction m_instruction; \/\/\/< Only valid if m_type is Operation$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::m_matchGroup	libevmasm/SimplificationRules.h	/^	unsigned m_matchGroup = 0;$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::m_matchGroups	libevmasm/SimplificationRules.h	/^	std::map<unsigned, Expression const*>* m_matchGroups = nullptr;$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::m_requireDataMatch	libevmasm/SimplificationRules.h	/^	bool m_requireDataMatch = false;$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::m_type	libevmasm/SimplificationRules.h	/^	AssemblyItemType m_type;$/;"	m	class:dev::eth::Pattern	access:private
dev::eth::Pattern::matchGroup	libevmasm/SimplificationRules.h	/^	unsigned matchGroup() const { return m_matchGroup; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::Pattern::matchGroupValue	libevmasm/SimplificationRules.h	/^	Expression const& matchGroupValue() const;$/;"	p	class:dev::eth::Pattern	access:private	signature:() const
dev::eth::Pattern::matches	libevmasm/SimplificationRules.h	/^	bool matches(Expression const& _expr, ExpressionClasses const& _classes) const;$/;"	p	class:dev::eth::Pattern	access:public	signature:(Expression const& _expr, ExpressionClasses const& _classes) const
dev::eth::Pattern::matchesBaseItem	libevmasm/SimplificationRules.h	/^	bool matchesBaseItem(AssemblyItem const* _item) const;$/;"	p	class:dev::eth::Pattern	access:private	signature:(AssemblyItem const* _item) const
dev::eth::Pattern::setMatchGroup	libevmasm/SimplificationRules.h	/^	void setMatchGroup(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups);$/;"	p	class:dev::eth::Pattern	access:public	signature:(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups)
dev::eth::Pattern::toAssemblyItem	libevmasm/SimplificationRules.h	/^	AssemblyItem toAssemblyItem(langutil::SourceLocation const& _location) const;$/;"	p	class:dev::eth::Pattern	access:public	signature:(langutil::SourceLocation const& _location) const
dev::eth::Pattern::toString	libevmasm/SimplificationRules.h	/^	std::string toString() const;$/;"	p	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::Pattern::type	libevmasm/SimplificationRules.h	/^	AssemblyItemType type() const { return m_type; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
dev::eth::PeepholeOptimisationMethod	libevmasm/PeepholeOptimiser.h	/^class PeepholeOptimisationMethod$/;"	c	namespace:dev::eth
dev::eth::PeepholeOptimisationMethod::apply	libevmasm/PeepholeOptimiser.h	/^	virtual bool apply(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out);$/;"	p	class:dev::eth::PeepholeOptimisationMethod	access:public	signature:(AssemblyItems::const_iterator _in, std::back_insert_iterator<AssemblyItems> _out)
dev::eth::PeepholeOptimisationMethod::windowSize	libevmasm/PeepholeOptimiser.h	/^	virtual size_t windowSize() const;$/;"	p	class:dev::eth::PeepholeOptimisationMethod	access:public	signature:() const
dev::eth::PeepholeOptimisationMethod::~PeepholeOptimisationMethod	libevmasm/PeepholeOptimiser.h	/^	virtual ~PeepholeOptimisationMethod() = default;$/;"	p	class:dev::eth::PeepholeOptimisationMethod	access:public	signature:()
dev::eth::PeepholeOptimiser	libevmasm/PeepholeOptimiser.h	/^class PeepholeOptimiser$/;"	c	namespace:dev::eth
dev::eth::PeepholeOptimiser::PeepholeOptimiser	libevmasm/PeepholeOptimiser.h	/^	explicit PeepholeOptimiser(AssemblyItems& _items): m_items(_items) {}$/;"	f	class:dev::eth::PeepholeOptimiser	access:public	signature:(AssemblyItems& _items)
dev::eth::PeepholeOptimiser::m_items	libevmasm/PeepholeOptimiser.h	/^	AssemblyItems& m_items;$/;"	m	class:dev::eth::PeepholeOptimiser	access:private
dev::eth::PeepholeOptimiser::m_optimisedItems	libevmasm/PeepholeOptimiser.h	/^	AssemblyItems m_optimisedItems;$/;"	m	class:dev::eth::PeepholeOptimiser	access:private
dev::eth::PeepholeOptimiser::optimise	libevmasm/PeepholeOptimiser.h	/^	bool optimise();$/;"	p	class:dev::eth::PeepholeOptimiser	access:public	signature:()
dev::eth::PeepholeOptimiser::~PeepholeOptimiser	libevmasm/PeepholeOptimiser.h	/^	virtual ~PeepholeOptimiser() = default;$/;"	p	class:dev::eth::PeepholeOptimiser	access:public	signature:()
dev::eth::Push	libevmasm/AssemblyItem.h	/^	Push,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushData	libevmasm/AssemblyItem.h	/^	PushData,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushDeployTimeAddress	libevmasm/AssemblyItem.h	/^	PushDeployTimeAddress \/\/\/< Push an address to be filled at deploy time. Should not be touched by the optimizer.$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushLibraryAddress	libevmasm/AssemblyItem.h	/^	PushLibraryAddress, \/\/\/< Push a currently unknown address of another (library) contract.$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushProgramSize	libevmasm/AssemblyItem.h	/^	PushProgramSize,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushString	libevmasm/AssemblyItem.h	/^	PushString,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushSub	libevmasm/AssemblyItem.h	/^	PushSub,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushSubSize	libevmasm/AssemblyItem.h	/^	PushSubSize,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::PushTag	libevmasm/AssemblyItem.h	/^	PushTag,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::Rules	libevmasm/SimplificationRules.h	/^class Rules: public boost::noncopyable$/;"	c	namespace:dev::eth	inherits:boost::noncopyable
dev::eth::Rules::addRule	libevmasm/SimplificationRules.h	/^	void addRule(SimplificationRule<Pattern> const& _rule);$/;"	p	class:dev::eth::Rules	access:private	signature:(SimplificationRule<Pattern> const& _rule)
dev::eth::Rules::addRules	libevmasm/SimplificationRules.h	/^	void addRules(std::vector<SimplificationRule<Pattern>> const& _rules);$/;"	p	class:dev::eth::Rules	access:private	signature:(std::vector<SimplificationRule<Pattern>> const& _rules)
dev::eth::Rules::findFirstMatch	libevmasm/SimplificationRules.h	/^	SimplificationRule<Pattern> const* findFirstMatch($/;"	p	class:dev::eth::Rules	access:public	signature:( Expression const& _expr, ExpressionClasses const& _classes )
dev::eth::Rules::isInitialized	libevmasm/SimplificationRules.h	/^	bool isInitialized() const;$/;"	p	class:dev::eth::Rules	access:public	signature:() const
dev::eth::Rules::m_matchGroups	libevmasm/SimplificationRules.h	/^	std::map<unsigned, Expression const*> m_matchGroups;$/;"	m	class:dev::eth::Rules	access:private
dev::eth::Rules::m_rules	libevmasm/SimplificationRules.h	/^	std::vector<SimplificationRule<Pattern>> m_rules[256];$/;"	m	class:dev::eth::Rules	access:private
dev::eth::Rules::resetMatchGroups	libevmasm/SimplificationRules.h	/^	void resetMatchGroups() { m_matchGroups.clear(); }$/;"	f	class:dev::eth::Rules	access:private	signature:()
dev::eth::SemanticInformation	libevmasm/SemanticInformation.h	/^struct SemanticInformation$/;"	s	namespace:dev::eth
dev::eth::SemanticInformation::altersControlFlow	libevmasm/SemanticInformation.h	/^	static bool altersControlFlow(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
dev::eth::SemanticInformation::breaksCSEAnalysisBlock	libevmasm/SemanticInformation.h	/^	static bool breaksCSEAnalysisBlock(AssemblyItem const& _item, bool _msizeImportant);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item, bool _msizeImportant)
dev::eth::SemanticInformation::invalidInPureFunctions	libevmasm/SemanticInformation.h	/^	static bool invalidInPureFunctions(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
dev::eth::SemanticInformation::invalidInViewFunctions	libevmasm/SemanticInformation.h	/^	static bool invalidInViewFunctions(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
dev::eth::SemanticInformation::invalidatesMemory	libevmasm/SemanticInformation.h	/^	static bool invalidatesMemory(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
dev::eth::SemanticInformation::invalidatesStorage	libevmasm/SemanticInformation.h	/^	static bool invalidatesStorage(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
dev::eth::SemanticInformation::isCommutativeOperation	libevmasm/SemanticInformation.h	/^	static bool isCommutativeOperation(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
dev::eth::SemanticInformation::isDeterministic	libevmasm/SemanticInformation.h	/^	static bool isDeterministic(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
dev::eth::SemanticInformation::isDupInstruction	libevmasm/SemanticInformation.h	/^	static bool isDupInstruction(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
dev::eth::SemanticInformation::isJumpInstruction	libevmasm/SemanticInformation.h	/^	static bool isJumpInstruction(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
dev::eth::SemanticInformation::isSwapInstruction	libevmasm/SemanticInformation.h	/^	static bool isSwapInstruction(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
dev::eth::SemanticInformation::movable	libevmasm/SemanticInformation.h	/^	static bool movable(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
dev::eth::StackTooDeepException	libevmasm/Exceptions.h	/^struct StackTooDeepException: virtual OptimizerException {};$/;"	s	namespace:dev::eth	inherits:OptimizerException
dev::eth::Tag	libevmasm/AssemblyItem.h	/^	Tag,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::UndefinedItem	libevmasm/AssemblyItem.h	/^	UndefinedItem,$/;"	e	enum:dev::eth::AssemblyItemType
dev::eth::bytesRequired	libevmasm/AssemblyItem.h	/^inline size_t bytesRequired(AssemblyItems const& _items, size_t _addressLength)$/;"	f	namespace:dev::eth	signature:(AssemblyItems const& _items, size_t _addressLength)
dev::eth::operator <<	libevmasm/Assembly.h	/^inline std::ostream& operator<<(std::ostream& _out, Assembly const& _a)$/;"	f	namespace:dev::eth	signature:(std::ostream& _out, Assembly const& _a)
dev::eth::operator <<	libevmasm/AssemblyItem.cpp	/^ostream& dev::eth::operator<<(ostream& _out, AssemblyItem const& _item)$/;"	f	class:dev::eth	signature:(ostream& _out, AssemblyItem const& _item)
dev::eth::operator <<	libevmasm/AssemblyItem.h	/^inline std::ostream& operator<<(std::ostream& _out, AssemblyItems const& _items)$/;"	f	namespace:dev::eth	signature:(std::ostream& _out, AssemblyItems const& _items)
dev::eth::operator <<	libevmasm/AssemblyItem.h	/^std::ostream& operator<<(std::ostream& _out, AssemblyItem const& _item);$/;"	p	namespace:dev::eth	signature:(std::ostream& _out, AssemblyItem const& _item)
dev::eth::operator <<	libevmasm/GasMeter.h	/^inline std::ostream& operator<<(std::ostream& _str, GasMeter::GasConsumption const& _consumption)$/;"	f	namespace:dev::eth	signature:(std::ostream& _str, GasMeter::GasConsumption const& _consumption)
dev::findAnyOf	libdevcore/CommonData.h	/^inline std::string findAnyOf(std::string const& _haystack, std::vector<std::string> const& _needles)$/;"	f	namespace:dev	signature:(std::string const& _haystack, std::vector<std::string> const& _needles)
dev::formatNumber	libdevcore/CommonData.h	/^inline std::string formatNumber(bigint const& _value)$/;"	f	namespace:dev	signature:(bigint const& _value)
dev::formatNumber	libdevcore/CommonData.h	/^inline std::string formatNumber(u256 const& _value)$/;"	f	namespace:dev	signature:(u256 const& _value)
dev::formatNumberReadable	libdevcore/StringUtils.h	/^inline std::string formatNumberReadable($/;"	f	namespace:dev	signature:( T const& _value, bool _useTruncation = false )
dev::formatting	libdevcore/AnsiColorized.h	/^namespace formatting$/;"	n	namespace:dev
dev::formatting::BLACK	libdevcore/AnsiColorized.h	/^static constexpr char const* BLACK = "\\033[30m";$/;"	m	namespace:dev::formatting
dev::formatting::BLACK_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* BLACK_BACKGROUND = "\\033[40m";$/;"	m	namespace:dev::formatting
dev::formatting::BLUE	libdevcore/AnsiColorized.h	/^static constexpr char const* BLUE = "\\033[34m";$/;"	m	namespace:dev::formatting
dev::formatting::BLUE_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* BLUE_BACKGROUND = "\\033[44m";$/;"	m	namespace:dev::formatting
dev::formatting::BOLD	libdevcore/AnsiColorized.h	/^static constexpr char const* BOLD = "\\033[1m";$/;"	m	namespace:dev::formatting
dev::formatting::BRIGHT	libdevcore/AnsiColorized.h	/^static constexpr char const* BRIGHT = BOLD;$/;"	m	namespace:dev::formatting
dev::formatting::CYAN	libdevcore/AnsiColorized.h	/^static constexpr char const* CYAN = "\\033[36m";$/;"	m	namespace:dev::formatting
dev::formatting::CYAN_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* CYAN_BACKGROUND = "\\033[46m";$/;"	m	namespace:dev::formatting
dev::formatting::GREEN	libdevcore/AnsiColorized.h	/^static constexpr char const* GREEN = "\\033[32m";$/;"	m	namespace:dev::formatting
dev::formatting::GREEN_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* GREEN_BACKGROUND = "\\033[42m";$/;"	m	namespace:dev::formatting
dev::formatting::INVERSE	libdevcore/AnsiColorized.h	/^static constexpr char const* INVERSE = "\\033[7m";$/;"	m	namespace:dev::formatting
dev::formatting::MAGENTA	libdevcore/AnsiColorized.h	/^static constexpr char const* MAGENTA = "\\033[35m";$/;"	m	namespace:dev::formatting
dev::formatting::MAGENTA_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* MAGENTA_BACKGROUND = "\\033[45m";$/;"	m	namespace:dev::formatting
dev::formatting::ORANGE_BACKGROUND_256	libdevcore/AnsiColorized.h	/^static constexpr char const* ORANGE_BACKGROUND_256 = "\\033[48;5;166m";$/;"	m	namespace:dev::formatting
dev::formatting::RED	libdevcore/AnsiColorized.h	/^static constexpr char const* RED = "\\033[31m";$/;"	m	namespace:dev::formatting
dev::formatting::RED_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* RED_BACKGROUND = "\\033[41m";$/;"	m	namespace:dev::formatting
dev::formatting::RED_BACKGROUND_256	libdevcore/AnsiColorized.h	/^static constexpr char const* RED_BACKGROUND_256 = "\\033[48;5;160m";$/;"	m	namespace:dev::formatting
dev::formatting::RESET	libdevcore/AnsiColorized.h	/^static constexpr char const* RESET = "\\033[0m";$/;"	m	namespace:dev::formatting
dev::formatting::WHITE	libdevcore/AnsiColorized.h	/^static constexpr char const* WHITE = "\\033[37m";$/;"	m	namespace:dev::formatting
dev::formatting::WHITE_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* WHITE_BACKGROUND = "\\033[47m";$/;"	m	namespace:dev::formatting
dev::formatting::YELLOW	libdevcore/AnsiColorized.h	/^static constexpr char const* YELLOW = "\\033[33m";$/;"	m	namespace:dev::formatting
dev::formatting::YELLOW_BACKGROUND	libdevcore/AnsiColorized.h	/^static constexpr char const* YELLOW_BACKGROUND = "\\033[43m";$/;"	m	namespace:dev::formatting
dev::fromBigEndian	libdevcore/CommonData.h	/^inline T fromBigEndian(_In const& _bytes)$/;"	f	namespace:dev	signature:(_In const& _bytes)
dev::fromHex	libdevcore/CommonData.cpp	/^bytes dev::fromHex(std::string const& _s, WhenError _throw)$/;"	f	class:dev	signature:(std::string const& _s, WhenError _throw)
dev::fromHex	libdevcore/CommonData.cpp	/^int dev::fromHex(char _i, WhenError _throw)$/;"	f	class:dev	signature:(char _i, WhenError _throw)
dev::fromHex	libdevcore/CommonData.h	/^bytes fromHex(std::string const& _s, WhenError _throw = WhenError::DontThrow);$/;"	p	namespace:dev	signature:(std::string const& _s, WhenError _throw = WhenError::DontThrow)
dev::fromHex	libdevcore/CommonData.h	/^int fromHex(char _i, WhenError _throw);$/;"	p	namespace:dev	signature:(char _i, WhenError _throw)
dev::getChecksummedAddress	libdevcore/CommonData.cpp	/^string dev::getChecksummedAddress(string const& _addr)$/;"	f	class:dev	signature:(string const& _addr)
dev::getChecksummedAddress	libdevcore/CommonData.h	/^std::string getChecksummedAddress(std::string const& _addr);$/;"	p	namespace:dev	signature:(std::string const& _addr)
dev::isValidDecimal	libdevcore/CommonData.cpp	/^bool dev::isValidDecimal(string const& _string)$/;"	f	class:dev	signature:(string const& _string)
dev::isValidDecimal	libdevcore/CommonData.h	/^bool isValidDecimal(std::string const& _string);$/;"	p	namespace:dev	signature:(std::string const& _string)
dev::isValidHex	libdevcore/CommonData.cpp	/^bool dev::isValidHex(string const& _string)$/;"	f	class:dev	signature:(string const& _string)
dev::isValidHex	libdevcore/CommonData.h	/^bool isValidHex(std::string const& _string);$/;"	p	namespace:dev	signature:(std::string const& _string)
dev::iterateReplacing	libdevcore/CommonData.h	/^void iterateReplacing(std::vector<T>& _vector, F const& _f)$/;"	f	namespace:dev	signature:(std::vector<T>& _vector, F const& _f)
dev::iterateReplacingWindow	libdevcore/CommonData.h	/^void iterateReplacingWindow(std::vector<T>& _vector, F const& _f)$/;"	f	namespace:dev	signature:(std::vector<T>& _vector, F const& _f)
dev::joinHumanReadable	libdevcore/StringUtils.h	/^std::string joinHumanReadable$/;"	f	namespace:dev	signature:( T const& _list, std::string const& _separator = , std::string const& _lastSeparator =  )
dev::jsonCompactPrint	libdevcore/JSON.cpp	/^string jsonCompactPrint(Json::Value const& _input)$/;"	f	namespace:dev	signature:(Json::Value const& _input)
dev::jsonCompactPrint	libdevcore/JSON.h	/^std::string jsonCompactPrint(Json::Value const& _input);$/;"	p	namespace:dev	signature:(Json::Value const& _input)
dev::jsonParse	libdevcore/JSON.cpp	/^bool jsonParse(string const& _input, Json::Value& _json, string *_errs \/* = nullptr *\/)$/;"	f	namespace:dev	signature:(string const& _input, Json::Value& _json, string *_errs )
dev::jsonParse	libdevcore/JSON.h	/^bool jsonParse(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr);$/;"	p	namespace:dev	signature:(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr)
dev::jsonParseFile	libdevcore/JSON.cpp	/^bool jsonParseFile(string const& _fileName, Json::Value& _json, string *_errs \/* = nullptr *\/)$/;"	f	namespace:dev	signature:(string const& _fileName, Json::Value& _json, string *_errs )
dev::jsonParseFile	libdevcore/JSON.h	/^bool jsonParseFile(std::string const& _fileName, Json::Value& _json, std::string* _errs = nullptr);$/;"	p	namespace:dev	signature:(std::string const& _fileName, Json::Value& _json, std::string* _errs = nullptr)
dev::jsonParseStrict	libdevcore/JSON.cpp	/^bool jsonParseStrict(string const& _input, Json::Value& _json, string* _errs \/* = nullptr *\/)$/;"	f	namespace:dev	signature:(string const& _input, Json::Value& _json, string* _errs )
dev::jsonParseStrict	libdevcore/JSON.h	/^bool jsonParseStrict(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr);$/;"	p	namespace:dev	signature:(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr)
dev::jsonPrettyPrint	libdevcore/JSON.cpp	/^string jsonPrettyPrint(Json::Value const& _input)$/;"	f	namespace:dev	signature:(Json::Value const& _input)
dev::jsonPrettyPrint	libdevcore/JSON.h	/^std::string jsonPrettyPrint(Json::Value const& _input);$/;"	p	namespace:dev	signature:(Json::Value const& _input)
dev::keccak256	libdevcore/Keccak256.cpp	/^h256 keccak256(bytesConstRef _input)$/;"	f	namespace:dev	signature:(bytesConstRef _input)
dev::keccak256	libdevcore/Keccak256.h	/^h256 keccak256(bytesConstRef _input);$/;"	p	namespace:dev	signature:(bytesConstRef _input)
dev::keccak256	libdevcore/Keccak256.h	/^inline h256 keccak256(bytes const& _input) { return keccak256(bytesConstRef(&_input)); }$/;"	f	namespace:dev	signature:(bytes const& _input)
dev::keccak256	libdevcore/Keccak256.h	/^inline h256 keccak256(std::string const& _input) { return keccak256(bytesConstRef(_input)); }$/;"	f	namespace:dev	signature:(std::string const& _input)
dev::keccak256	libdevcore/Keccak256.h	/^template<unsigned N> inline h256 keccak256(FixedHash<N> const& _input) { return keccak256(_input.ref()); }$/;"	f	namespace:dev	signature:(FixedHash<N> const& _input)
dev::operator +	libdevcore/CommonData.h	/^inline std::vector<T> operator+(std::vector<T> const& _a, std::vector<T> const& _b)$/;"	f	namespace:dev	signature:(std::vector<T> const& _a, std::vector<T> const& _b)
dev::operator +	libdevcore/CommonData.h	/^inline std::vector<T> operator+(std::vector<T>&& _a, std::vector<T>&& _b)$/;"	f	namespace:dev	signature:(std::vector<T>&& _a, std::vector<T>&& _b)
dev::operator +=	libdevcore/CommonData.h	/^template <class T, class U> std::set<T>& operator+=(std::set<T>& _a, U const& _b)$/;"	f	namespace:dev	signature:(std::set<T>& _a, U const& _b)
dev::operator +=	libdevcore/CommonData.h	/^template <class T, class U> std::vector<T>& operator+=(std::vector<T>& _a, U const& _b)$/;"	f	namespace:dev	signature:(std::vector<T>& _a, U const& _b)
dev::operator +=	libdevcore/CommonData.h	/^template <class T, class U> std::vector<T>& operator+=(std::vector<T>& _a, U&& _b)$/;"	f	namespace:dev	signature:(std::vector<T>& _a, U&& _b)
dev::operator <<	libdevcore/Common.h	/^inline std::ostream& operator<<(std::ostream& os, bytes const& _bytes)$/;"	f	namespace:dev	signature:(std::ostream& os, bytes const& _bytes)
dev::operator <<	libdevcore/FixedHash.h	/^inline std::ostream& operator<<(std::ostream& _out, FixedHash<N> const& _h)$/;"	f	namespace:dev	signature:(std::ostream& _out, FixedHash<N> const& _h)
dev::passesAddressChecksum	libdevcore/CommonData.cpp	/^bool dev::passesAddressChecksum(string const& _str, bool _strict)$/;"	f	class:dev	signature:(string const& _str, bool _strict)
dev::passesAddressChecksum	libdevcore/CommonData.h	/^bool passesAddressChecksum(std::string const& _str, bool _strict);$/;"	p	namespace:dev	signature:(std::string const& _str, bool _strict)
dev::quotedAlternativesList	libdevcore/StringUtils.cpp	/^string dev::quotedAlternativesList(vector<string> const& suggestions)$/;"	f	class:dev	signature:(vector<string> const& suggestions)
dev::quotedAlternativesList	libdevcore/StringUtils.h	/^std::string quotedAlternativesList(std::vector<std::string> const& suggestions);$/;"	p	namespace:dev	signature:(std::vector<std::string> const& suggestions)
dev::readFileAsString	libdevcore/CommonIO.cpp	/^string dev::readFileAsString(string const& _file)$/;"	f	class:dev	signature:(string const& _file)
dev::readFileAsString	libdevcore/CommonIO.h	/^std::string readFileAsString(std::string const& _file);$/;"	p	namespace:dev	signature:(std::string const& _file)
dev::readStandardInput	libdevcore/CommonIO.cpp	/^string dev::readStandardInput()$/;"	f	class:dev	signature:()
dev::readStandardInput	libdevcore/CommonIO.h	/^std::string readStandardInput();$/;"	p	namespace:dev	signature:()
dev::readStandardInputChar	libdevcore/CommonIO.cpp	/^int dev::readStandardInputChar()$/;"	f	class:dev	signature:()
dev::readStandardInputChar	libdevcore/CommonIO.h	/^int readStandardInputChar();$/;"	p	namespace:dev	signature:()
dev::s2u	libdevcore/Common.h	/^inline u256 s2u(s256 _u)$/;"	f	namespace:dev	signature:(s256 _u)
dev::sanitizePath	libdevcore/CommonIO.cpp	/^string dev::sanitizePath(string const& _path) {$/;"	f	class:dev	signature:(string const& _path)
dev::sanitizePath	libdevcore/CommonIO.h	/^std::string sanitizePath(std::string const& _path);$/;"	p	namespace:dev	signature:(std::string const& _path)
dev::solidity	libevmasm/Instruction.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libevmasm/RuleList.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libevmasm/SimplificationRule.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ConstantEvaluator.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ContractLevelChecker.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ControlFlowAnalyzer.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ControlFlowBuilder.h	/^namespace solidity {$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ControlFlowGraph.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ControlFlowPrinter.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/DeclarationContainer.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/DocStringAnalyser.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/GlobalContext.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/analysis/GlobalContext.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/NameAndTypeResolver.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/analysis/NameAndTypeResolver.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/PostTypeChecker.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ReferencesResolver.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/analysis/ReferencesResolver.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/SemVerHandler.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/StaticAnalyzer.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/SyntaxChecker.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/TypeChecker.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/analysis/ViewPureChecker.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/AST.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ASTAnnotations.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ASTEnums.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ASTForward.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ASTJsonConverter.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/ast/ASTJsonConverter.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ASTPrinter.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/ast/ASTPrinter.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ASTVisitor.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/AST_accept.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/ExperimentalFeatures.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/ast/Types.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/ABIFunctions.h	/^namespace solidity {$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/ArrayUtils.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/Compiler.h	/^namespace solidity {$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/CompilerContext.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/codegen/CompilerContext.h	/^namespace solidity {$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/CompilerUtils.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/codegen/CompilerUtils.h	/^namespace solidity {$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/ContractCompiler.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/ExpressionCompiler.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/codegen/ExpressionCompiler.h	/^namespace solidity {$/;"	n	namespace:dev
dev::solidity	libsolidity/codegen/LValue.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/CVC4Interface.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SMTChecker.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SMTLib2Interface.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SMTPortfolio.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SSAVariable.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SolverInterface.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SymbolicTypes.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/SymbolicVariables.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/VariableUsage.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/formal/Z3Interface.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/ABI.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/CompilerStack.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/GasEstimator.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/Natspec.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/OptimiserSettings.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/ReadFile.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/StandardCompiler.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/interface/Version.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/parsing/DocStringParser.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/parsing/Parser.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	libsolidity/parsing/Parser.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libsolidity/parsing/Token.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	libyul/backends/evm/AbstractAssembly.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity	solse/CommandLineInterface.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
dev::solidity	solse/CommandLineInterface.h	/^namespace solidity$/;"	n	namespace:dev
dev::solidity::ABI	libsolidity/interface/ABI.h	/^class ABI$/;"	c	namespace:dev::solidity
dev::solidity::ABI::formatType	libsolidity/interface/ABI.h	/^	static Json::Value formatType(std::string const& _name, Type const& _type, bool _forLibrary);$/;"	p	class:dev::solidity::ABI	access:private	signature:(std::string const& _name, Type const& _type, bool _forLibrary)
dev::solidity::ABI::formatTypeList	libsolidity/interface/ABI.h	/^	static Json::Value formatTypeList($/;"	p	class:dev::solidity::ABI	access:private	signature:( std::vector<std::string> const& _names, std::vector<TypePointer> const& _types, bool _forLibrary )
dev::solidity::ABI::generate	libsolidity/interface/ABI.h	/^	static Json::Value generate(ContractDefinition const& _contractDef);$/;"	p	class:dev::solidity::ABI	access:public	signature:(ContractDefinition const& _contractDef)
dev::solidity::ABIFunctions	libsolidity/codegen/ABIFunctions.h	/^class ABIFunctions$/;"	c	namespace:dev::solidity
dev::solidity::ABIFunctions::ABIFunctions	libsolidity/codegen/ABIFunctions.h	/^	explicit ABIFunctions(langutil::EVMVersion _evmVersion = langutil::EVMVersion{}) : m_evmVersion(_evmVersion) {}$/;"	f	class:dev::solidity::ABIFunctions	access:public	signature:(langutil::EVMVersion _evmVersion = langutil::EVMVersion{})
dev::solidity::ABIFunctions::EncodingOptions	libsolidity/codegen/ABIFunctions.h	/^	struct EncodingOptions$/;"	s	class:dev::solidity::ABIFunctions	access:private
dev::solidity::ABIFunctions::EncodingOptions::dynamicInplace	libsolidity/codegen/ABIFunctions.h	/^		bool dynamicInplace = false;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
dev::solidity::ABIFunctions::EncodingOptions::encodeAsLibraryTypes	libsolidity/codegen/ABIFunctions.h	/^		bool encodeAsLibraryTypes = false;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
dev::solidity::ABIFunctions::EncodingOptions::encodeFunctionFromStack	libsolidity/codegen/ABIFunctions.h	/^		bool encodeFunctionFromStack = false;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
dev::solidity::ABIFunctions::EncodingOptions::padded	libsolidity/codegen/ABIFunctions.h	/^		bool padded = true;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
dev::solidity::ABIFunctions::EncodingOptions::toFunctionNameSuffix	libsolidity/codegen/ABIFunctions.h	/^		std::string toFunctionNameSuffix() const;$/;"	p	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public	signature:() const
dev::solidity::ABIFunctions::abiDecodingFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunction($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _Type, bool _fromMemory, bool _forUseOnStack )
dev::solidity::ABIFunctions::abiDecodingFunctionArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionArray(ArrayType const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type, bool _fromMemory)
dev::solidity::ABIFunctions::abiDecodingFunctionByteArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionByteArray(ArrayType const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type, bool _fromMemory)
dev::solidity::ABIFunctions::abiDecodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionCalldataArray(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
dev::solidity::ABIFunctions::abiDecodingFunctionCalldataStruct	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionCalldataStruct(StructType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(StructType const& _type)
dev::solidity::ABIFunctions::abiDecodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionFunctionType(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(FunctionType const& _type, bool _fromMemory, bool _forUseOnStack)
dev::solidity::ABIFunctions::abiDecodingFunctionStruct	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionStruct(StructType const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(StructType const& _type, bool _fromMemory)
dev::solidity::ABIFunctions::abiDecodingFunctionValueType	libsolidity/codegen/ABIFunctions.h	/^	std::string abiDecodingFunctionValueType(Type const& _type, bool _fromMemory);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _type, bool _fromMemory)
dev::solidity::ABIFunctions::abiEncodeAndReturnUpdatedPosFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodeAndReturnUpdatedPosFunction($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunction($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionCalldataArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionCalldataArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionCompactStorageArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionCompactStorageArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( ArrayType const& _givenType, ArrayType const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionFunctionType	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionFunctionType($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( FunctionType const& _from, Type const& _to, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionMemoryByteArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionMemoryByteArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( ArrayType const& _givenType, ArrayType const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionSimpleArray	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionSimpleArray($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( ArrayType const& _givenType, ArrayType const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionStringLiteral	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionStringLiteral($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( Type const& _givenType, Type const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::abiEncodingFunctionStruct	libsolidity/codegen/ABIFunctions.h	/^	std::string abiEncodingFunctionStruct($/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:( StructType const& _givenType, StructType const& _targetType, EncodingOptions const& _options )
dev::solidity::ABIFunctions::allocationFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string allocationFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
dev::solidity::ABIFunctions::arrayAllocationSizeFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayAllocationSizeFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
dev::solidity::ABIFunctions::arrayDataAreaFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayDataAreaFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
dev::solidity::ABIFunctions::arrayLengthFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayLengthFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
dev::solidity::ABIFunctions::arrayStoreLengthForEncodingFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string arrayStoreLengthForEncodingFunction(ArrayType const& _type, EncodingOptions const& _options);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type, EncodingOptions const& _options)
dev::solidity::ABIFunctions::cleanupCombinedExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string cleanupCombinedExternalFunctionIdFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
dev::solidity::ABIFunctions::cleanupFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string cleanupFunction(Type const& _type, bool _revertOnFailure = false);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _type, bool _revertOnFailure = false)
dev::solidity::ABIFunctions::combineExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string combineExternalFunctionIdFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
dev::solidity::ABIFunctions::conversionFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string conversionFunction(Type const& _from, Type const& _to);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _from, Type const& _to)
dev::solidity::ABIFunctions::copyToMemoryFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string copyToMemoryFunction(bool _fromCalldata);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(bool _fromCalldata)
dev::solidity::ABIFunctions::createExternallyUsedFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string createExternallyUsedFunction(std::string const& _name, std::function<std::string()> const& _creator);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(std::string const& _name, std::function<std::string()> const& _creator)
dev::solidity::ABIFunctions::createFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string createFunction(std::string const& _name, std::function<std::string()> const& _creator);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(std::string const& _name, std::function<std::string()> const& _creator)
dev::solidity::ABIFunctions::headSize	libsolidity/codegen/ABIFunctions.h	/^	static size_t headSize(TypePointers const& _targetTypes);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(TypePointers const& _targetTypes)
dev::solidity::ABIFunctions::leftAlignFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string leftAlignFunction(Type const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _type)
dev::solidity::ABIFunctions::m_evmVersion	libsolidity/codegen/ABIFunctions.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::ABIFunctions	access:private
dev::solidity::ABIFunctions::m_externallyUsedFunctions	libsolidity/codegen/ABIFunctions.h	/^	std::set<std::string> m_externallyUsedFunctions;$/;"	m	class:dev::solidity::ABIFunctions	access:private
dev::solidity::ABIFunctions::m_requestedFunctions	libsolidity/codegen/ABIFunctions.h	/^	std::map<std::string, std::string> m_requestedFunctions;$/;"	m	class:dev::solidity::ABIFunctions	access:private
dev::solidity::ABIFunctions::nextArrayElementFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string nextArrayElementFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
dev::solidity::ABIFunctions::requestedFunctions	libsolidity/codegen/ABIFunctions.h	/^	std::pair<std::string, std::set<std::string>> requestedFunctions();$/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:()
dev::solidity::ABIFunctions::roundUpFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string roundUpFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
dev::solidity::ABIFunctions::shiftLeftFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string shiftLeftFunction(size_t _numBits);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(size_t _numBits)
dev::solidity::ABIFunctions::shiftRightFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string shiftRightFunction(size_t _numBits);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(size_t _numBits)
dev::solidity::ABIFunctions::splitExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string splitExternalFunctionIdFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
dev::solidity::ABIFunctions::tupleDecoder	libsolidity/codegen/ABIFunctions.h	/^	std::string tupleDecoder(TypePointers const& _types, bool _fromMemory = false);$/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:(TypePointers const& _types, bool _fromMemory = false)
dev::solidity::ABIFunctions::tupleEncoder	libsolidity/codegen/ABIFunctions.h	/^	std::string tupleEncoder($/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false )
dev::solidity::ABIFunctions::tupleEncoderPacked	libsolidity/codegen/ABIFunctions.h	/^	std::string tupleEncoderPacked(TypePointers const& _givenTypes, TypePointers const& _targetTypes);$/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:(TypePointers const& _givenTypes, TypePointers const& _targetTypes)
dev::solidity::ASTAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ASTAnnotation$/;"	s	namespace:dev::solidity
dev::solidity::ASTAnnotation::~ASTAnnotation	libsolidity/ast/ASTAnnotations.h	/^	virtual ~ASTAnnotation() = default;$/;"	p	struct:dev::solidity::ASTAnnotation	access:public	signature:()
dev::solidity::ASTConstVisitor	libsolidity/ast/ASTVisitor.h	/^class ASTConstVisitor$/;"	c	namespace:dev::solidity
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ArrayTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ArrayTypeName const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Assignment const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Assignment const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(BinaryOperation const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(BinaryOperation const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Block const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Block const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Break const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Break const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Conditional const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Conditional const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Continue const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Continue const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ContractDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ContractDefinition const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeName const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeNameExpression const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeNameExpression const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EmitStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EmitStatement const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumDefinition const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumValue const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumValue const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EventDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EventDefinition const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ExpressionStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ExpressionStatement const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ForStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ForStatement const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionCall const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionCall const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionDefinition const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionTypeName const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Identifier const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Identifier const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IfStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IfStatement const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ImportDirective const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ImportDirective const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IndexAccess const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IndexAccess const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InheritanceSpecifier const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InheritanceSpecifier const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InlineAssembly const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InlineAssembly const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Literal const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Literal const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Mapping const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Mapping const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(MemberAccess const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(MemberAccess const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierDefinition const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierInvocation const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierInvocation const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(NewExpression const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(NewExpression const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ParameterList const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ParameterList const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PlaceholderStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PlaceholderStatement const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PragmaDirective const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PragmaDirective const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Return const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Return const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(SourceUnit const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(SourceUnit const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(StructDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(StructDefinition const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Throw const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Throw const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(TupleExpression const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(TupleExpression const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UnaryOperation const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UnaryOperation const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UserDefinedTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UserDefinedTypeName const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UsingForDirective const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UsingForDirective const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclaration const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclaration const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclarationStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclarationStatement const& _node)
dev::solidity::ASTConstVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(WhileStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(WhileStatement const& _node)
dev::solidity::ASTConstVisitor::endVisitNode	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisitNode(ASTNode const&) { }$/;"	f	class:dev::solidity::ASTConstVisitor	access:protected	signature:(ASTNode const&)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ArrayTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ArrayTypeName const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Assignment const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Assignment const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(BinaryOperation const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(BinaryOperation const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Block const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Block const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Break const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Break const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Conditional const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Conditional const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Continue const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Continue const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ContractDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ContractDefinition const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeName const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeNameExpression const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeNameExpression const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EmitStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EmitStatement const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumDefinition const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumValue const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumValue const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EventDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EventDefinition const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ExpressionStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ExpressionStatement const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ForStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ForStatement const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionCall const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionCall const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionDefinition const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionTypeName const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Identifier const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Identifier const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IfStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IfStatement const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ImportDirective const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ImportDirective const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IndexAccess const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IndexAccess const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InheritanceSpecifier const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InheritanceSpecifier const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InlineAssembly const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InlineAssembly const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Literal const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Literal const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Mapping const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Mapping const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(MemberAccess const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(MemberAccess const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierDefinition const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierInvocation const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierInvocation const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(NewExpression const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(NewExpression const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ParameterList const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ParameterList const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PlaceholderStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PlaceholderStatement const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PragmaDirective const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PragmaDirective const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Return const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Return const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(SourceUnit const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(SourceUnit const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(StructDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(StructDefinition const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Throw const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Throw const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(TupleExpression const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(TupleExpression const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UnaryOperation const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UnaryOperation const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UserDefinedTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UserDefinedTypeName const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UsingForDirective const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UsingForDirective const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclaration const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclaration const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclarationStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclarationStatement const& _node)
dev::solidity::ASTConstVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(WhileStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(WhileStatement const& _node)
dev::solidity::ASTConstVisitor::visitNode	libsolidity/ast/ASTVisitor.h	/^	virtual bool visitNode(ASTNode const&) { return true; }$/;"	f	class:dev::solidity::ASTConstVisitor	access:protected	signature:(ASTNode const&)
dev::solidity::ASTConstVisitor::~ASTConstVisitor	libsolidity/ast/ASTVisitor.h	/^	virtual ~ASTConstVisitor() = default;$/;"	p	class:dev::solidity::ASTConstVisitor	access:public	signature:()
dev::solidity::ASTJsonConverter	libsolidity/ast/ASTJsonConverter.h	/^class ASTJsonConverter: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ASTJsonConverter::ASTJsonConverter	libsolidity/ast/ASTJsonConverter.cpp	/^ASTJsonConverter::ASTJsonConverter(bool _legacy, map<string, unsigned> _sourceIndices):$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(bool _legacy, map<string, unsigned> _sourceIndices)
dev::solidity::ASTJsonConverter::ASTJsonConverter	libsolidity/ast/ASTJsonConverter.h	/^	explicit ASTJsonConverter($/;"	p	class:dev::solidity::ASTJsonConverter	access:public	signature:( bool _legacy, std::map<std::string, unsigned> _sourceIndices = std::map<std::string, unsigned>() )
dev::solidity::ASTJsonConverter::appendExpressionAttributes	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::appendExpressionAttributes($/;"	f	class:dev::solidity::ASTJsonConverter	signature:( std::vector<pair<string, Json::Value>>& _attributes, ExpressionAnnotation const& _annotation )
dev::solidity::ASTJsonConverter::appendExpressionAttributes	libsolidity/ast/ASTJsonConverter.h	/^	void appendExpressionAttributes($/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:( std::vector<std::pair<std::string, Json::Value>> &_attributes, ExpressionAnnotation const& _annotation )
dev::solidity::ASTJsonConverter::appendMove	libsolidity/ast/ASTJsonConverter.h	/^	static void appendMove(Json::Value& _array, Json::Value&& _value)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(Json::Value& _array, Json::Value&& _value)
dev::solidity::ASTJsonConverter::contractKind	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::contractKind(ContractDefinition::ContractKind _kind)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ContractDefinition::ContractKind _kind)
dev::solidity::ASTJsonConverter::contractKind	libsolidity/ast/ASTJsonConverter.h	/^	static std::string contractKind(ContractDefinition::ContractKind _kind);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(ContractDefinition::ContractKind _kind)
dev::solidity::ASTJsonConverter::endVisit	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::endVisit(EventDefinition const&)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EventDefinition const&)
dev::solidity::ASTJsonConverter::functionCallKind	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::functionCallKind(FunctionCallKind _kind)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionCallKind _kind)
dev::solidity::ASTJsonConverter::functionCallKind	libsolidity/ast/ASTJsonConverter.h	/^	static std::string functionCallKind(FunctionCallKind _kind);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(FunctionCallKind _kind)
dev::solidity::ASTJsonConverter::getContainerIds	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value getContainerIds(Container const& container)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(Container const& container)
dev::solidity::ASTJsonConverter::idOrNull	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value idOrNull(ASTNode const* _pt)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(ASTNode const* _pt)
dev::solidity::ASTJsonConverter::inlineAssemblyIdentifierToJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value ASTJsonConverter::inlineAssemblyIdentifierToJson(pair<yul::Identifier const* ,InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(pair<yul::Identifier const* ,InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const
dev::solidity::ASTJsonConverter::inlineAssemblyIdentifierToJson	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value inlineAssemblyIdentifierToJson(std::pair<yul::Identifier const* , InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const;$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(std::pair<yul::Identifier const* , InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const
dev::solidity::ASTJsonConverter::literalTokenKind	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::literalTokenKind(Token _token)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Token _token)
dev::solidity::ASTJsonConverter::literalTokenKind	libsolidity/ast/ASTJsonConverter.h	/^	static std::string literalTokenKind(Token _token);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(Token _token)
dev::solidity::ASTJsonConverter::location	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::location(VariableDeclaration::Location _location)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclaration::Location _location)
dev::solidity::ASTJsonConverter::location	libsolidity/ast/ASTJsonConverter.h	/^	static std::string location(VariableDeclaration::Location _location);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(VariableDeclaration::Location _location)
dev::solidity::ASTJsonConverter::m_currentValue	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value m_currentValue;$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
dev::solidity::ASTJsonConverter::m_inEvent	libsolidity/ast/ASTJsonConverter.h	/^	bool m_inEvent = false; \/\/\/< whether we are currently inside an event or not$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
dev::solidity::ASTJsonConverter::m_legacy	libsolidity/ast/ASTJsonConverter.h	/^	bool m_legacy = false; \/\/\/< if true, use legacy format$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
dev::solidity::ASTJsonConverter::m_sourceIndices	libsolidity/ast/ASTJsonConverter.h	/^	std::map<std::string, unsigned> m_sourceIndices;$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
dev::solidity::ASTJsonConverter::namePathToString	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::namePathToString(std::vector<ASTString> const& _namePath)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(std::vector<ASTString> const& _namePath)
dev::solidity::ASTJsonConverter::namePathToString	libsolidity/ast/ASTJsonConverter.h	/^	static std::string namePathToString(std::vector<ASTString> const& _namePath);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(std::vector<ASTString> const& _namePath)
dev::solidity::ASTJsonConverter::nodeId	libsolidity/ast/ASTJsonConverter.h	/^	static int nodeId(ASTNode const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(ASTNode const& _node)
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ArrayTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Assignment const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(BinaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Block const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Break const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Conditional const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Continue const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ElementaryTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ElementaryTypeNameExpression const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EmitStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EnumDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EnumValue const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EventDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ExpressionStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ForStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(FunctionCall const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(FunctionTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Identifier const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(IfStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ImportDirective const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(IndexAccess const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(InheritanceSpecifier const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(InlineAssembly const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Literal const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Mapping const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(MemberAccess const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ModifierDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ModifierInvocation const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(NewExpression const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ParameterList const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(PlaceholderStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(PragmaDirective const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Return const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(SourceUnit const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(StructDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Throw const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(TupleExpression const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(UnaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(UserDefinedTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(UsingForDirective const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(VariableDeclaration const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(VariableDeclarationStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(WhileStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::override	libsolidity/ast/ASTJsonConverter.h	/^	void endVisit(EventDefinition const&) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
dev::solidity::ASTJsonConverter::print	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::print(ostream& _stream, ASTNode const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ostream& _stream, ASTNode const& _node)
dev::solidity::ASTJsonConverter::print	libsolidity/ast/ASTJsonConverter.h	/^	void print(std::ostream& _stream, ASTNode const& _node);$/;"	p	class:dev::solidity::ASTJsonConverter	access:public	signature:(std::ostream& _stream, ASTNode const& _node)
dev::solidity::ASTJsonConverter::setJsonNode	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::setJsonNode($/;"	f	class:dev::solidity::ASTJsonConverter	signature:( ASTNode const& _node, string const& _nodeName, initializer_list<pair<string, Json::Value>>&& _attributes )
dev::solidity::ASTJsonConverter::setJsonNode	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::setJsonNode($/;"	f	class:dev::solidity::ASTJsonConverter	signature:( ASTNode const& _node, string const& _nodeType, std::vector<pair<string, Json::Value>>&& _attributes )
dev::solidity::ASTJsonConverter::setJsonNode	libsolidity/ast/ASTJsonConverter.h	/^	void setJsonNode($/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:( ASTNode const& _node, std::string const& _nodeName, std::initializer_list<std::pair<std::string, Json::Value>>&& _attributes )
dev::solidity::ASTJsonConverter::setJsonNode	libsolidity/ast/ASTJsonConverter.h	/^	void setJsonNode($/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:( ASTNode const& _node, std::string const& _nodeName, std::vector<std::pair<std::string, Json::Value>>&& _attributes )
dev::solidity::ASTJsonConverter::sourceLocationToString	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::sourceLocationToString(SourceLocation const& _location) const$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(SourceLocation const& _location) const
dev::solidity::ASTJsonConverter::sourceLocationToString	libsolidity/ast/ASTJsonConverter.h	/^	std::string sourceLocationToString(langutil::SourceLocation const& _location) const;$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(langutil::SourceLocation const& _location) const
dev::solidity::ASTJsonConverter::toJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value&& ASTJsonConverter::toJson(ASTNode const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ASTNode const& _node)
dev::solidity::ASTJsonConverter::toJson	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value toJson(std::vector<ASTPointer<T>> const& _nodes)$/;"	f	class:dev::solidity::ASTJsonConverter	access:public	signature:(std::vector<ASTPointer<T>> const& _nodes)
dev::solidity::ASTJsonConverter::toJson	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value&& toJson(ASTNode const& _node);$/;"	p	class:dev::solidity::ASTJsonConverter	access:public	signature:(ASTNode const& _node)
dev::solidity::ASTJsonConverter::toJsonOrNull	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value toJsonOrNull(ASTNode const* _node)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(ASTNode const* _node)
dev::solidity::ASTJsonConverter::type	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::type(Expression const& _expression)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Expression const& _expression)
dev::solidity::ASTJsonConverter::type	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::type(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ASTJsonConverter::type	libsolidity/ast/ASTJsonConverter.h	/^	static std::string type(Expression const& _expression);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(Expression const& _expression)
dev::solidity::ASTJsonConverter::type	libsolidity/ast/ASTJsonConverter.h	/^	static std::string type(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ASTJsonConverter::typePointerToJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value ASTJsonConverter::typePointerToJson(TypePointer _tp, bool _short)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(TypePointer _tp, bool _short)
dev::solidity::ASTJsonConverter::typePointerToJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value ASTJsonConverter::typePointerToJson(std::shared_ptr<std::vector<TypePointer>> _tps)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(std::shared_ptr<std::vector<TypePointer>> _tps)
dev::solidity::ASTJsonConverter::typePointerToJson	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value typePointerToJson(TypePointer _tp, bool _short = false);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(TypePointer _tp, bool _short = false)
dev::solidity::ASTJsonConverter::typePointerToJson	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value typePointerToJson(std::shared_ptr<std::vector<TypePointer>> _tps);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(std::shared_ptr<std::vector<TypePointer>> _tps)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ArrayTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ArrayTypeName const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Assignment const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Assignment const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(BinaryOperation const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(BinaryOperation const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Block const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Block const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Break const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Break const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Conditional const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Conditional const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Continue const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Continue const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ContractDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ContractDefinition const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ElementaryTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ElementaryTypeName const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ElementaryTypeNameExpression const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ElementaryTypeNameExpression const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EmitStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EmitStatement const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EnumDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EnumDefinition const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EnumValue const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EnumValue const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EventDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EventDefinition const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ExpressionStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ExpressionStatement const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ForStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ForStatement const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(FunctionCall const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionCall const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(FunctionDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionDefinition const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(FunctionTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionTypeName const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Identifier const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Identifier const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(IfStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(IfStatement const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ImportDirective const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ImportDirective const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(IndexAccess const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(IndexAccess const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(InheritanceSpecifier const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(InheritanceSpecifier const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(InlineAssembly const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(InlineAssembly const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Literal const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Literal const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Mapping const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Mapping const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(MemberAccess const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(MemberAccess const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ModifierDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ModifierDefinition const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ModifierInvocation const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ModifierInvocation const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(NewExpression const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(NewExpression const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ParameterList const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ParameterList const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(PlaceholderStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(PlaceholderStatement const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(PragmaDirective const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(PragmaDirective const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Return const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Return const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(SourceUnit const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(SourceUnit const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(StructDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(StructDefinition const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Throw const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Throw const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(TupleExpression const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(TupleExpression const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(UnaryOperation const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(UnaryOperation const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(UserDefinedTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(UserDefinedTypeName const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(UsingForDirective const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(UsingForDirective const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(VariableDeclaration const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclaration const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(VariableDeclarationStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclarationStatement const& _node)
dev::solidity::ASTJsonConverter::visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(WhileStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(WhileStatement const& _node)
dev::solidity::ASTNode	libsolidity/ast/AST.h	/^class ASTNode: private boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
dev::solidity::ASTNode::accept	libsolidity/ast/AST.h	/^	virtual void accept(ASTConstVisitor& _visitor) const = 0;$/;"	p	class:dev::solidity::ASTNode	access:public	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ASTNode::accept	libsolidity/ast/AST.h	/^	virtual void accept(ASTVisitor& _visitor) = 0;$/;"	p	class:dev::solidity::ASTNode	access:public	signature:(ASTVisitor& _visitor)
dev::solidity::ASTNode::annotation	libsolidity/ast/AST.h	/^	virtual ASTAnnotation& annotation() const;$/;"	p	class:dev::solidity::ASTNode	access:public	signature:() const
dev::solidity::ASTNode::filteredNodes	libsolidity/ast/AST.h	/^	static std::vector<_T const*> filteredNodes(std::vector<ASTPointer<ASTNode>> const& _nodes);$/;"	p	class:dev::solidity::ASTNode	access:public	signature:(std::vector<ASTPointer<ASTNode>> const& _nodes)
dev::solidity::ASTNode::filteredNodes	libsolidity/ast/AST.h	/^std::vector<_T const*> ASTNode::filteredNodes(std::vector<ASTPointer<ASTNode>> const& _nodes)$/;"	f	class:dev::solidity::ASTNode	signature:(std::vector<ASTPointer<ASTNode>> const& _nodes)
dev::solidity::ASTNode::id	libsolidity/ast/AST.h	/^	size_t id() const { return m_id; }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:() const
dev::solidity::ASTNode::listAccept	libsolidity/ast/AST.h	/^	static void listAccept(std::vector<T> const& _list, ASTConstVisitor& _visitor)$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(std::vector<T> const& _list, ASTConstVisitor& _visitor)
dev::solidity::ASTNode::listAccept	libsolidity/ast/AST.h	/^	static void listAccept(std::vector<T> const& _list, ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(std::vector<T> const& _list, ASTVisitor& _visitor)
dev::solidity::ASTNode::location	libsolidity/ast/AST.h	/^	SourceLocation const& location() const { return m_location; }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:() const
dev::solidity::ASTNode::m_annotation	libsolidity/ast/AST.h	/^	mutable ASTAnnotation* m_annotation = nullptr;$/;"	m	class:dev::solidity::ASTNode	access:protected
dev::solidity::ASTNode::m_id	libsolidity/ast/AST.h	/^	size_t const m_id = 0;$/;"	m	class:dev::solidity::ASTNode	access:protected
dev::solidity::ASTNode::m_location	libsolidity/ast/AST.h	/^	SourceLocation m_location;$/;"	m	class:dev::solidity::ASTNode	access:private
dev::solidity::ASTNode::operator !=	libsolidity/ast/AST.h	/^	bool operator!=(ASTNode const& _other) const { return !operator==(_other); }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(ASTNode const& _other) const
dev::solidity::ASTNode::operator ==	libsolidity/ast/AST.h	/^	bool operator==(ASTNode const& _other) const { return this == &_other; }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(ASTNode const& _other) const
dev::solidity::ASTNode::resetID	libsolidity/ast/AST.h	/^	static void resetID();$/;"	p	class:dev::solidity::ASTNode	access:public	signature:()
dev::solidity::ASTNode::~ASTNode	libsolidity/ast/AST.h	/^	virtual ~ASTNode();$/;"	p	class:dev::solidity::ASTNode	access:public	signature:()
dev::solidity::ASTPrinter	libsolidity/ast/ASTPrinter.h	/^class ASTPrinter: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ASTPrinter::ASTPrinter	libsolidity/ast/ASTPrinter.cpp	/^ASTPrinter::ASTPrinter($/;"	f	class:dev::solidity::ASTPrinter	signature:( ASTNode const& _ast, string const& _source, GasEstimator::ASTGasConsumption const& _gasCosts )
dev::solidity::ASTPrinter::ASTPrinter	libsolidity/ast/ASTPrinter.h	/^	ASTPrinter($/;"	p	class:dev::solidity::ASTPrinter	access:public	signature:( ASTNode const& _ast, std::string const& _source = std::string(), GasEstimator::ASTGasConsumption const& _gasCosts = GasEstimator::ASTGasConsumption() )
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ArrayTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ArrayTypeName const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Assignment const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Assignment const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(BinaryOperation const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(BinaryOperation const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Block const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Block const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Break const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Break const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Conditional const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Conditional const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Continue const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Continue const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ContractDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ContractDefinition const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ElementaryTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeName const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ElementaryTypeNameExpression const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeNameExpression const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EmitStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EmitStatement const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EnumDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumDefinition const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EnumValue const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumValue const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EventDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EventDefinition const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ExpressionStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ExpressionStatement const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ForStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ForStatement const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(FunctionCall const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionCall const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(FunctionDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionDefinition const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(FunctionTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionTypeName const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Identifier const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Identifier const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(IfStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IfStatement const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ImportDirective const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ImportDirective const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(IndexAccess const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IndexAccess const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(InheritanceSpecifier const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InheritanceSpecifier const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(InlineAssembly const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InlineAssembly const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Literal const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Literal const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Mapping const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Mapping const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(MemberAccess const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(MemberAccess const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ModifierDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierDefinition const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ModifierInvocation const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierInvocation const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(NewExpression const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(NewExpression const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ParameterList const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ParameterList const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(PlaceholderStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PlaceholderStatement const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(PragmaDirective const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PragmaDirective const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Return const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Return const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(StructDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(StructDefinition const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Throw const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Throw const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(TupleExpression const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(TupleExpression const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(UnaryOperation const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UnaryOperation const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(UserDefinedTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UserDefinedTypeName const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(UsingForDirective const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UsingForDirective const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(VariableDeclaration const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclaration const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(VariableDeclarationStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclarationStatement const&)
dev::solidity::ASTPrinter::endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(WhileStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(WhileStatement const&)
dev::solidity::ASTPrinter::goDeeper	libsolidity/ast/ASTPrinter.h	/^	bool goDeeper() { m_indentation++; return true; }$/;"	f	class:dev::solidity::ASTPrinter	access:private	signature:()
dev::solidity::ASTPrinter::indentation	libsolidity/ast/ASTPrinter.cpp	/^string ASTPrinter::indentation() const$/;"	f	class:dev::solidity::ASTPrinter	signature:() const
dev::solidity::ASTPrinter::indentation	libsolidity/ast/ASTPrinter.h	/^	std::string indentation() const;$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:() const
dev::solidity::ASTPrinter::m_ast	libsolidity/ast/ASTPrinter.h	/^	ASTNode const* m_ast;$/;"	m	class:dev::solidity::ASTPrinter	access:private
dev::solidity::ASTPrinter::m_gasCosts	libsolidity/ast/ASTPrinter.h	/^	GasEstimator::ASTGasConsumption m_gasCosts;$/;"	m	class:dev::solidity::ASTPrinter	access:private
dev::solidity::ASTPrinter::m_indentation	libsolidity/ast/ASTPrinter.h	/^	int m_indentation;$/;"	m	class:dev::solidity::ASTPrinter	access:private
dev::solidity::ASTPrinter::m_ostream	libsolidity/ast/ASTPrinter.h	/^	std::ostream* m_ostream = nullptr;$/;"	m	class:dev::solidity::ASTPrinter	access:private
dev::solidity::ASTPrinter::m_source	libsolidity/ast/ASTPrinter.h	/^	std::string m_source;$/;"	m	class:dev::solidity::ASTPrinter	access:private
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ArrayTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Assignment const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(BinaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Block const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Break const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Conditional const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Continue const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ElementaryTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ElementaryTypeNameExpression const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EmitStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EnumDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EnumValue const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EventDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ExpressionStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ForStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(FunctionCall const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(FunctionTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Identifier const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(IfStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ImportDirective const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(IndexAccess const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(InheritanceSpecifier const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(InlineAssembly const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Literal const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Mapping const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(MemberAccess const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ModifierDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ModifierInvocation const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(NewExpression const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ParameterList const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(PlaceholderStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(PragmaDirective const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Return const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(StructDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Throw const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(TupleExpression const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(UnaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(UserDefinedTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(UsingForDirective const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(VariableDeclaration const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(VariableDeclarationStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	bool visit(WhileStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ArrayTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Assignment const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(BinaryOperation const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Block const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Break const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Conditional const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Continue const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ContractDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ElementaryTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ElementaryTypeNameExpression const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EmitStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EnumDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EnumValue const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EventDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ExpressionStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ForStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(FunctionCall const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(FunctionDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(FunctionTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Identifier const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(IfStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ImportDirective const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(IndexAccess const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(InheritanceSpecifier const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(InlineAssembly const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Literal const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Mapping const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(MemberAccess const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ModifierDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ModifierInvocation const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(NewExpression const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ParameterList const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(PlaceholderStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(PragmaDirective const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Return const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(StructDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Throw const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(TupleExpression const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(UnaryOperation const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(UserDefinedTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(UsingForDirective const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(VariableDeclaration const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(VariableDeclarationStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(WhileStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
dev::solidity::ASTPrinter::print	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::print(ostream& _stream)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ostream& _stream)
dev::solidity::ASTPrinter::print	libsolidity/ast/ASTPrinter.h	/^	void print(std::ostream& _stream);$/;"	p	class:dev::solidity::ASTPrinter	access:public	signature:(std::ostream& _stream)
dev::solidity::ASTPrinter::printSourcePart	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::printSourcePart(ASTNode const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ASTNode const& _node)
dev::solidity::ASTPrinter::printSourcePart	libsolidity/ast/ASTPrinter.h	/^	void printSourcePart(ASTNode const& _node);$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:(ASTNode const& _node)
dev::solidity::ASTPrinter::printType	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::printType(Expression const& _expression)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Expression const& _expression)
dev::solidity::ASTPrinter::printType	libsolidity/ast/ASTPrinter.h	/^	void printType(Expression const& _expression);$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:(Expression const& _expression)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ArrayTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ArrayTypeName const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Assignment const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Assignment const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(BinaryOperation const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(BinaryOperation const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Block const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Block const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Break const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Break const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Conditional const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Conditional const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Continue const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Continue const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ContractDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ContractDefinition const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ElementaryTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeName const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ElementaryTypeNameExpression const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeNameExpression const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EmitStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EmitStatement const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EnumDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumDefinition const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EnumValue const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumValue const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EventDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EventDefinition const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ExpressionStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ExpressionStatement const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ForStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ForStatement const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(FunctionCall const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionCall const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(FunctionDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionDefinition const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(FunctionTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionTypeName const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Identifier const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Identifier const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(IfStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IfStatement const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ImportDirective const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ImportDirective const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(IndexAccess const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IndexAccess const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(InheritanceSpecifier const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InheritanceSpecifier const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(InlineAssembly const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InlineAssembly const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Literal const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Literal const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Mapping const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Mapping const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(MemberAccess const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(MemberAccess const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ModifierDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierDefinition const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ModifierInvocation const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierInvocation const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(NewExpression const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(NewExpression const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ParameterList const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ParameterList const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(PlaceholderStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PlaceholderStatement const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(PragmaDirective const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PragmaDirective const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Return const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Return const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(StructDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(StructDefinition const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Throw const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Throw const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(TupleExpression const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(TupleExpression const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(UnaryOperation const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UnaryOperation const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(UserDefinedTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UserDefinedTypeName const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(UsingForDirective const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UsingForDirective const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(VariableDeclaration const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclaration const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(VariableDeclarationStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclarationStatement const& _node)
dev::solidity::ASTPrinter::visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(WhileStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(WhileStatement const& _node)
dev::solidity::ASTPrinter::writeLine	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::writeLine(string const& _line)$/;"	f	class:dev::solidity::ASTPrinter	signature:(string const& _line)
dev::solidity::ASTPrinter::writeLine	libsolidity/ast/ASTPrinter.h	/^	void writeLine(std::string const& _line);$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:(std::string const& _line)
dev::solidity::ASTReduce	libsolidity/ast/ASTVisitor.h	/^class ASTReduce: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ASTReduce::ASTReduce	libsolidity/ast/ASTVisitor.h	/^	ASTReduce($/;"	f	class:dev::solidity::ASTReduce	access:public	signature:( std::function<bool(ASTNode const&)> _onNode, std::function<void(ASTNode const&, ASTNode const&)> _onEdge )
dev::solidity::ASTReduce::m_onEdge	libsolidity/ast/ASTVisitor.h	/^	std::function<void(ASTNode const&, ASTNode const&)> m_onEdge;$/;"	m	class:dev::solidity::ASTReduce	access:private
dev::solidity::ASTReduce::m_onNode	libsolidity/ast/ASTVisitor.h	/^	std::function<bool(ASTNode const&)> m_onNode;$/;"	m	class:dev::solidity::ASTReduce	access:private
dev::solidity::ASTReduce::m_parents	libsolidity/ast/ASTVisitor.h	/^	std::vector<ASTNode const*> m_parents;$/;"	m	class:dev::solidity::ASTReduce	access:private
dev::solidity::ASTVisitor	libsolidity/ast/ASTVisitor.h	/^class ASTVisitor$/;"	c	namespace:dev::solidity
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ArrayTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ArrayTypeName& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Assignment& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Assignment& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(BinaryOperation& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(BinaryOperation& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Block& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Block& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Break& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Break& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Conditional& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Conditional& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Continue& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Continue& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ContractDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ContractDefinition& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeName& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeNameExpression& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeNameExpression& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EmitStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EmitStatement& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumDefinition& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumValue& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumValue& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EventDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EventDefinition& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ExpressionStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ExpressionStatement& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ForStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ForStatement& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionCall& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionCall& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionDefinition& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionTypeName& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Identifier& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Identifier& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IfStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IfStatement& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ImportDirective& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ImportDirective& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IndexAccess& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IndexAccess& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InheritanceSpecifier& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InheritanceSpecifier& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InlineAssembly& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InlineAssembly& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Literal& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Literal& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Mapping& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Mapping& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(MemberAccess& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(MemberAccess& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierDefinition& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierInvocation& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierInvocation& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(NewExpression& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(NewExpression& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ParameterList& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ParameterList& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PlaceholderStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PlaceholderStatement& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PragmaDirective& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PragmaDirective& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Return& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Return& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(SourceUnit& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(SourceUnit& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(StructDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(StructDefinition& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Throw& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Throw& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(TupleExpression& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(TupleExpression& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UnaryOperation& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UnaryOperation& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UserDefinedTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UserDefinedTypeName& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UsingForDirective& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UsingForDirective& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclaration& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclaration& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclarationStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclarationStatement& _node)
dev::solidity::ASTVisitor::endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(WhileStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(WhileStatement& _node)
dev::solidity::ASTVisitor::endVisitNode	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisitNode(ASTNode&) { }$/;"	f	class:dev::solidity::ASTVisitor	access:protected	signature:(ASTNode&)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ArrayTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ArrayTypeName& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Assignment& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Assignment& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(BinaryOperation& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(BinaryOperation& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Block& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Block& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Break& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Break& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Conditional& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Conditional& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Continue& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Continue& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ContractDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ContractDefinition& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeName& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeNameExpression& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeNameExpression& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EmitStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EmitStatement& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumDefinition& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumValue& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumValue& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EventDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EventDefinition& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ExpressionStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ExpressionStatement& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ForStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ForStatement& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionCall& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionCall& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionDefinition& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionTypeName& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Identifier& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Identifier& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IfStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IfStatement& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ImportDirective& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ImportDirective& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IndexAccess& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IndexAccess& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InheritanceSpecifier& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InheritanceSpecifier& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InlineAssembly& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InlineAssembly& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Literal& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Literal& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Mapping& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Mapping& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(MemberAccess& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(MemberAccess& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierDefinition& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierInvocation& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierInvocation& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(NewExpression& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(NewExpression& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ParameterList& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ParameterList& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PlaceholderStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PlaceholderStatement& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PragmaDirective& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PragmaDirective& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Return& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Return& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(SourceUnit& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(SourceUnit& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(StructDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(StructDefinition& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Throw& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Throw& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(TupleExpression& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(TupleExpression& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UnaryOperation& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UnaryOperation& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UserDefinedTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UserDefinedTypeName& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UsingForDirective& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UsingForDirective& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclaration& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclaration& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclarationStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclarationStatement& _node)
dev::solidity::ASTVisitor::visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(WhileStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(WhileStatement& _node)
dev::solidity::ASTVisitor::visitNode	libsolidity/ast/ASTVisitor.h	/^	virtual bool visitNode(ASTNode&) { return true; }$/;"	f	class:dev::solidity::ASTVisitor	access:protected	signature:(ASTNode&)
dev::solidity::ASTVisitor::~ASTVisitor	libsolidity/ast/ASTVisitor.h	/^	virtual ~ASTVisitor() = default;$/;"	p	class:dev::solidity::ASTVisitor	access:public	signature:()
dev::solidity::AddressType	libsolidity/ast/Types.h	/^class AddressType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::AddressType::AddressType	libsolidity/ast/Types.h	/^	explicit AddressType(StateMutability _stateMutability);$/;"	p	class:dev::solidity::AddressType	access:public	signature:(StateMutability _stateMutability)
dev::solidity::AddressType::address	libsolidity/ast/Types.h	/^	static AddressType& address() { static std::shared_ptr<AddressType> addr(std::make_shared<AddressType>(StateMutability::NonPayable)); return *addr; }$/;"	f	class:dev::solidity::AddressType	access:public	signature:()
dev::solidity::AddressType::addressPayable	libsolidity/ast/Types.h	/^	static AddressType& addressPayable() { static std::shared_ptr<AddressType> addr(std::make_shared<AddressType>(StateMutability::Payable)); return *addr; }$/;"	f	class:dev::solidity::AddressType	access:public	signature:()
dev::solidity::AddressType::m_stateMutability	libsolidity/ast/Types.h	/^	StateMutability m_stateMutability;$/;"	m	class:dev::solidity::AddressType	access:private
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _other) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::override	libsolidity/ast/Types.h	/^	u256 literalValue(Literal const* _literal) const override;$/;"	m	class:dev::solidity::AddressType	access:public
dev::solidity::AddressType::stateMutability	libsolidity/ast/Types.h	/^	StateMutability stateMutability(void) const { return m_stateMutability; }$/;"	f	class:dev::solidity::AddressType	access:public	signature:(void) const
dev::solidity::ArrayType	libsolidity/ast/Types.h	/^class ArrayType: public ReferenceType$/;"	c	namespace:dev::solidity	inherits:ReferenceType
dev::solidity::ArrayType::ArrayKind	libsolidity/ast/Types.h	/^	enum class ArrayKind { Ordinary, Bytes, String };$/;"	c	class:dev::solidity::ArrayType	access:private
dev::solidity::ArrayType::ArrayKind::Bytes	libsolidity/ast/Types.h	/^	enum class ArrayKind { Ordinary, Bytes, String };$/;"	m	class:dev::solidity::ArrayType::ArrayKind	access:private
dev::solidity::ArrayType::ArrayKind::Ordinary	libsolidity/ast/Types.h	/^	enum class ArrayKind { Ordinary, Bytes, String };$/;"	m	class:dev::solidity::ArrayType::ArrayKind	access:private
dev::solidity::ArrayType::ArrayType	libsolidity/ast/Types.h	/^	ArrayType(DataLocation _location, TypePointer const& _baseType):$/;"	f	class:dev::solidity::ArrayType	access:public	signature:(DataLocation _location, TypePointer const& _baseType)
dev::solidity::ArrayType::ArrayType	libsolidity/ast/Types.h	/^	ArrayType(DataLocation _location, TypePointer const& _baseType, u256 const& _length):$/;"	f	class:dev::solidity::ArrayType	access:public	signature:(DataLocation _location, TypePointer const& _baseType, u256 const& _length)
dev::solidity::ArrayType::ArrayType	libsolidity/ast/Types.h	/^	explicit ArrayType(DataLocation _location, bool _isString = false):$/;"	f	class:dev::solidity::ArrayType	access:public	signature:(DataLocation _location, bool _isString = false)
dev::solidity::ArrayType::baseType	libsolidity/ast/Types.h	/^	TypePointer const& baseType() const { solAssert(!!m_baseType, ""); return m_baseType;}$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::bytesMemory	libsolidity/ast/Types.h	/^	static ArrayType& bytesMemory() { static std::shared_ptr<ArrayType> addr(std::make_shared<ArrayType>(DataLocation::Memory)); return *addr; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:()
dev::solidity::ArrayType::calldataStride	libsolidity/ast/Types.h	/^	unsigned calldataStride() const { return isByteArray() ? 1 : m_baseType->calldataEncodedSize(); }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::isByteArray	libsolidity/ast/Types.h	/^	bool isByteArray() const { return m_arrayKind != ArrayKind::Ordinary; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::isString	libsolidity/ast/Types.h	/^	bool isString() const { return m_arrayKind == ArrayKind::String; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::length	libsolidity/ast/Types.h	/^	u256 const& length() const { return m_length; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::m_arrayKind	libsolidity/ast/Types.h	/^	ArrayKind m_arrayKind = ArrayKind::Ordinary;$/;"	m	class:dev::solidity::ArrayType	access:private
dev::solidity::ArrayType::m_baseType	libsolidity/ast/Types.h	/^	TypePointer m_baseType;$/;"	m	class:dev::solidity::ArrayType	access:private
dev::solidity::ArrayType::m_hasDynamicLength	libsolidity/ast/Types.h	/^	bool m_hasDynamicLength = true;$/;"	m	class:dev::solidity::ArrayType	access:private
dev::solidity::ArrayType::m_length	libsolidity/ast/Types.h	/^	u256 m_length;$/;"	m	class:dev::solidity::ArrayType	access:private
dev::solidity::ArrayType::memorySize	libsolidity/ast/Types.h	/^	u256 memorySize() const;$/;"	p	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::memoryStride	libsolidity/ast/Types.h	/^	unsigned memoryStride() const { return isByteArray() ? 1 : m_baseType->memoryHeadSize(); }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	TypePointer copyForLocation(DataLocation _location, bool _isPointer) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	TypePointer decodingType() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	TypePointer encodingType() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	TypePointer interfaceType(bool _inLibrary) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	bool canBeUsedExternally(bool _inLibrary) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	bool isDynamicallyEncoded() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	std::string signatureInExternalFunction(bool _structsByName) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize(bool _padded) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
dev::solidity::ArrayType::storageStride	libsolidity/ast/Types.h	/^	unsigned storageStride() const { return isByteArray() ? 1 : m_baseType->storageBytes(); }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayType::stringMemory	libsolidity/ast/Types.h	/^	static ArrayType& stringMemory() { static std::shared_ptr<ArrayType> addr(std::make_shared<ArrayType>(DataLocation::Memory, true)); return *addr; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:()
dev::solidity::ArrayType::unlimitedCalldataEncodedSize	libsolidity/ast/Types.h	/^	bigint unlimitedCalldataEncodedSize(bool _padded) const;$/;"	p	class:dev::solidity::ArrayType	access:private	signature:(bool _padded) const
dev::solidity::ArrayType::validForCalldata	libsolidity/ast/Types.h	/^	bool validForCalldata() const;$/;"	p	class:dev::solidity::ArrayType	access:public	signature:() const
dev::solidity::ArrayTypeName	libsolidity/ast/AST.h	/^class ArrayTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
dev::solidity::ArrayTypeName::ArrayTypeName	libsolidity/ast/AST.h	/^	ArrayTypeName($/;"	f	class:dev::solidity::ArrayTypeName	access:public	signature:( SourceLocation const& _location, ASTPointer<TypeName> const& _baseType, ASTPointer<Expression> const& _length )
dev::solidity::ArrayTypeName::accept	libsolidity/ast/AST_accept.h	/^void ArrayTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ArrayTypeName	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ArrayTypeName::accept	libsolidity/ast/AST_accept.h	/^void ArrayTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ArrayTypeName	signature:(ASTVisitor& _visitor)
dev::solidity::ArrayTypeName::baseType	libsolidity/ast/AST.h	/^	TypeName const& baseType() const { return *m_baseType; }$/;"	f	class:dev::solidity::ArrayTypeName	access:public	signature:() const
dev::solidity::ArrayTypeName::length	libsolidity/ast/AST.h	/^	Expression const* length() const { return m_length.get(); }$/;"	f	class:dev::solidity::ArrayTypeName	access:public	signature:() const
dev::solidity::ArrayTypeName::m_baseType	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_baseType;$/;"	m	class:dev::solidity::ArrayTypeName	access:private
dev::solidity::ArrayTypeName::m_length	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_length; \/\/\/< Length of the array, might be empty.$/;"	m	class:dev::solidity::ArrayTypeName	access:private
dev::solidity::ArrayTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ArrayTypeName	access:public
dev::solidity::ArrayTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ArrayTypeName	access:public
dev::solidity::ArrayUtils	libsolidity/codegen/ArrayUtils.h	/^class ArrayUtils$/;"	c	namespace:dev::solidity
dev::solidity::ArrayUtils::ArrayUtils	libsolidity/codegen/ArrayUtils.h	/^	explicit ArrayUtils(CompilerContext& _context): m_context(_context) {}$/;"	f	class:dev::solidity::ArrayUtils	access:public	signature:(CompilerContext& _context)
dev::solidity::ArrayUtils::accessIndex	libsolidity/codegen/ArrayUtils.h	/^	void accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck = true) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, bool _doBoundsCheck = true) const
dev::solidity::ArrayUtils::clearArray	libsolidity/codegen/ArrayUtils.h	/^	void clearArray(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
dev::solidity::ArrayUtils::clearDynamicArray	libsolidity/codegen/ArrayUtils.h	/^	void clearDynamicArray(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
dev::solidity::ArrayUtils::clearStorageLoop	libsolidity/codegen/ArrayUtils.h	/^	void clearStorageLoop(TypePointer const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(TypePointer const& _type) const
dev::solidity::ArrayUtils::convertLengthToSize	libsolidity/codegen/ArrayUtils.h	/^	void convertLengthToSize(ArrayType const& _arrayType, bool _pad = false) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, bool _pad = false) const
dev::solidity::ArrayUtils::copyArrayToMemory	libsolidity/codegen/ArrayUtils.h	/^	void copyArrayToMemory(ArrayType const& _sourceType, bool _padToWordBoundaries = true) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _sourceType, bool _padToWordBoundaries = true) const
dev::solidity::ArrayUtils::copyArrayToStorage	libsolidity/codegen/ArrayUtils.h	/^	void copyArrayToStorage(ArrayType const& _targetType, ArrayType const& _sourceType) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _targetType, ArrayType const& _sourceType) const
dev::solidity::ArrayUtils::incrementByteOffset	libsolidity/codegen/ArrayUtils.h	/^	void incrementByteOffset(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const;$/;"	p	class:dev::solidity::ArrayUtils	access:private	signature:(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const
dev::solidity::ArrayUtils::incrementDynamicArraySize	libsolidity/codegen/ArrayUtils.h	/^	void incrementDynamicArraySize(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
dev::solidity::ArrayUtils::m_context	libsolidity/codegen/ArrayUtils.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::ArrayUtils	access:private
dev::solidity::ArrayUtils::popStorageArrayElement	libsolidity/codegen/ArrayUtils.h	/^	void popStorageArrayElement(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
dev::solidity::ArrayUtils::resizeDynamicArray	libsolidity/codegen/ArrayUtils.h	/^	void resizeDynamicArray(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
dev::solidity::ArrayUtils::retrieveLength	libsolidity/codegen/ArrayUtils.h	/^	void retrieveLength(ArrayType const& _arrayType, unsigned _stackDepth = 0) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, unsigned _stackDepth = 0) const
dev::solidity::ArrayUtils::storeLength	libsolidity/codegen/ArrayUtils.h	/^	void storeLength(ArrayType const& _arrayType, unsigned _stackDepthLength = 0, unsigned _stackDepthRef = 1) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, unsigned _stackDepthLength = 0, unsigned _stackDepthRef = 1) const
dev::solidity::Assignment	libsolidity/ast/AST.h	/^class Assignment: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::Assignment::Assignment	libsolidity/ast/AST.h	/^	Assignment($/;"	f	class:dev::solidity::Assignment	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _leftHandSide, Token _assignmentOperator, ASTPointer<Expression> const& _rightHandSide )
dev::solidity::Assignment::accept	libsolidity/ast/AST_accept.h	/^void Assignment::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Assignment	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Assignment::accept	libsolidity/ast/AST_accept.h	/^void Assignment::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Assignment	signature:(ASTVisitor& _visitor)
dev::solidity::Assignment::assignmentOperator	libsolidity/ast/AST.h	/^	Token assignmentOperator() const { return m_assigmentOperator; }$/;"	f	class:dev::solidity::Assignment	access:public	signature:() const
dev::solidity::Assignment::leftHandSide	libsolidity/ast/AST.h	/^	Expression const& leftHandSide() const { return *m_leftHandSide; }$/;"	f	class:dev::solidity::Assignment	access:public	signature:() const
dev::solidity::Assignment::m_assigmentOperator	libsolidity/ast/AST.h	/^	Token m_assigmentOperator;$/;"	m	class:dev::solidity::Assignment	access:private
dev::solidity::Assignment::m_leftHandSide	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_leftHandSide;$/;"	m	class:dev::solidity::Assignment	access:private
dev::solidity::Assignment::m_rightHandSide	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_rightHandSide;$/;"	m	class:dev::solidity::Assignment	access:private
dev::solidity::Assignment::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Assignment	access:public
dev::solidity::Assignment::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Assignment	access:public
dev::solidity::Assignment::rightHandSide	libsolidity/ast/AST.h	/^	Expression const& rightHandSide() const { return *m_rightHandSide; }$/;"	f	class:dev::solidity::Assignment	access:public	signature:() const
dev::solidity::BinaryOperation	libsolidity/ast/AST.h	/^class BinaryOperation: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::BinaryOperation::BinaryOperation	libsolidity/ast/AST.h	/^	BinaryOperation($/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _left, Token _operator, ASTPointer<Expression> const& _right )
dev::solidity::BinaryOperation::accept	libsolidity/ast/AST_accept.h	/^void BinaryOperation::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::BinaryOperation	signature:(ASTConstVisitor& _visitor) const
dev::solidity::BinaryOperation::accept	libsolidity/ast/AST_accept.h	/^void BinaryOperation::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::BinaryOperation	signature:(ASTVisitor& _visitor)
dev::solidity::BinaryOperation::getOperator	libsolidity/ast/AST.h	/^	Token getOperator() const { return m_operator; }$/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:() const
dev::solidity::BinaryOperation::leftExpression	libsolidity/ast/AST.h	/^	Expression const& leftExpression() const { return *m_left; }$/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:() const
dev::solidity::BinaryOperation::m_left	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_left;$/;"	m	class:dev::solidity::BinaryOperation	access:private
dev::solidity::BinaryOperation::m_operator	libsolidity/ast/AST.h	/^	Token m_operator;$/;"	m	class:dev::solidity::BinaryOperation	access:private
dev::solidity::BinaryOperation::m_right	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_right;$/;"	m	class:dev::solidity::BinaryOperation	access:private
dev::solidity::BinaryOperation::override	libsolidity/ast/AST.h	/^	BinaryOperationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::BinaryOperation	access:public
dev::solidity::BinaryOperation::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::BinaryOperation	access:public
dev::solidity::BinaryOperation::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::BinaryOperation	access:public
dev::solidity::BinaryOperation::rightExpression	libsolidity/ast/AST.h	/^	Expression const& rightExpression() const { return *m_right; }$/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:() const
dev::solidity::BinaryOperationAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct BinaryOperationAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
dev::solidity::BinaryOperationAnnotation::commonType	libsolidity/ast/ASTAnnotations.h	/^	TypePointer commonType;$/;"	m	struct:dev::solidity::BinaryOperationAnnotation	access:public
dev::solidity::Block	libsolidity/ast/AST.h	/^class Block: public Statement, public Scopable$/;"	c	namespace:dev::solidity	inherits:Statement,Scopable
dev::solidity::Block::Block	libsolidity/ast/AST.h	/^	Block($/;"	f	class:dev::solidity::Block	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, std::vector<ASTPointer<Statement>> const& _statements )
dev::solidity::Block::accept	libsolidity/ast/AST_accept.h	/^void Block::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Block	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Block::accept	libsolidity/ast/AST_accept.h	/^void Block::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Block	signature:(ASTVisitor& _visitor)
dev::solidity::Block::m_statements	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Statement>> m_statements;$/;"	m	class:dev::solidity::Block	access:private
dev::solidity::Block::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Block	access:public
dev::solidity::Block::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Block	access:public
dev::solidity::Block::std::statements	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Statement>> const& statements() const { return m_statements; }$/;"	f	class:dev::solidity::Block::std	access:public	signature:() const
dev::solidity::BoolType	libsolidity/ast/Types.h	/^class BoolType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::BoolType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::BoolType	access:public
dev::solidity::BoolType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::BoolType	access:public
dev::solidity::BoolType::override	libsolidity/ast/Types.h	/^	u256 literalValue(Literal const* _literal) const override;$/;"	m	class:dev::solidity::BoolType	access:public
dev::solidity::Break	libsolidity/ast/AST.h	/^class Break: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::Break::Break	libsolidity/ast/AST.h	/^	explicit Break(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):$/;"	f	class:dev::solidity::Break	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _docString)
dev::solidity::Break::accept	libsolidity/ast/AST_accept.h	/^void Break::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Break	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Break::accept	libsolidity/ast/AST_accept.h	/^void Break::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Break	signature:(ASTVisitor& _visitor)
dev::solidity::Break::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Break	access:public
dev::solidity::Break::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Break	access:public
dev::solidity::BreakableStatement	libsolidity/ast/AST.h	/^class BreakableStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::BreakableStatement::BreakableStatement	libsolidity/ast/AST.h	/^	explicit BreakableStatement($/;"	f	class:dev::solidity::BreakableStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString )
dev::solidity::CFG	libsolidity/analysis/ControlFlowGraph.h	/^class CFG: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::CFG::CFG	libsolidity/analysis/ControlFlowGraph.h	/^	explicit CFG(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::CFG	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::CFG::NodeContainer	libsolidity/analysis/ControlFlowGraph.h	/^	class NodeContainer$/;"	c	class:dev::solidity::CFG	access:public
dev::solidity::CFG::NodeContainer::m_nodes	libsolidity/analysis/ControlFlowGraph.h	/^		std::vector<std::unique_ptr<CFGNode>> m_nodes;$/;"	m	class:dev::solidity::CFG::NodeContainer	access:private
dev::solidity::CFG::NodeContainer::newNode	libsolidity/analysis/ControlFlowGraph.h	/^		CFGNode* newNode();$/;"	p	class:dev::solidity::CFG::NodeContainer	access:public	signature:()
dev::solidity::CFG::accept	libsolidity/analysis/ControlFlowGraph.h	/^  void accept(CFGConstVisitor& _visitor) const;$/;"	p	class:dev::solidity::CFG	access:public	signature:(CFGConstVisitor& _visitor) const
dev::solidity::CFG::constructFlow	libsolidity/analysis/ControlFlowGraph.h	/^	bool constructFlow(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::CFG	access:public	signature:(ASTNode const& _astRoot)
dev::solidity::CFG::functionFlow	libsolidity/analysis/ControlFlowGraph.h	/^	FunctionFlow const& functionFlow(FunctionDefinition const& _function) const;$/;"	p	class:dev::solidity::CFG	access:public	signature:(FunctionDefinition const& _function) const
dev::solidity::CFG::m_errorReporter	libsolidity/analysis/ControlFlowGraph.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::CFG	access:private
dev::solidity::CFG::m_functionControlFlow	libsolidity/analysis/ControlFlowGraph.h	/^	std::map<FunctionDefinition const*, std::unique_ptr<FunctionFlow>> m_functionControlFlow;$/;"	m	class:dev::solidity::CFG	access:private
dev::solidity::CFG::m_nodeContainer	libsolidity/analysis/ControlFlowGraph.h	/^	NodeContainer m_nodeContainer;$/;"	m	class:dev::solidity::CFG	access:private
dev::solidity::CFG::override	libsolidity/analysis/ControlFlowGraph.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::CFG	access:public
dev::solidity::CFGConstVisitor	libsolidity/analysis/ControlFlowGraph.h	/^class CFGConstVisitor$/;"	c	namespace:dev::solidity
dev::solidity::CFGConstVisitor::visit	libsolidity/analysis/ControlFlowGraph.h	/^	virtual bool visit(FunctionDefinition const& _function) { return visitNode(_function); }$/;"	f	class:dev::solidity::CFGConstVisitor	access:public	signature:(FunctionDefinition const& _function)
dev::solidity::CFGConstVisitor::visitNode	libsolidity/analysis/ControlFlowGraph.h	/^  virtual bool visitNode(ASTNode const&){ return true; }$/;"	f	class:dev::solidity::CFGConstVisitor	access:protected	signature:(ASTNode const&)
dev::solidity::CFGConstVisitor::~CFGConstVisitor	libsolidity/analysis/ControlFlowGraph.h	/^	virtual ~CFGConstVisitor() = default;$/;"	p	class:dev::solidity::CFGConstVisitor	access:public	signature:()
dev::solidity::CFGNode	libsolidity/analysis/ControlFlowGraph.h	/^struct CFGNode$/;"	s	namespace:dev::solidity
dev::solidity::CFGNode::entries	libsolidity/analysis/ControlFlowGraph.h	/^	std::vector<CFGNode*> entries;$/;"	m	struct:dev::solidity::CFGNode	access:public
dev::solidity::CFGNode::exits	libsolidity/analysis/ControlFlowGraph.h	/^	std::vector<CFGNode*> exits;$/;"	m	struct:dev::solidity::CFGNode	access:public
dev::solidity::CFGNode::location	libsolidity/analysis/ControlFlowGraph.h	/^	langutil::SourceLocation location;$/;"	m	struct:dev::solidity::CFGNode	access:public
dev::solidity::CFGNode::variableOccurrences	libsolidity/analysis/ControlFlowGraph.h	/^	std::vector<VariableOccurrence> variableOccurrences;$/;"	m	struct:dev::solidity::CFGNode	access:public
dev::solidity::CallableDeclaration	libsolidity/ast/AST.h	/^class CallableDeclaration: public Declaration, public VariableScope$/;"	c	namespace:dev::solidity	inherits:Declaration,VariableScope
dev::solidity::CallableDeclaration::CallableDeclaration	libsolidity/ast/AST.h	/^	CallableDeclaration($/;"	f	class:dev::solidity::CallableDeclaration	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, Declaration::Visibility _visibility, ASTPointer<ParameterList> const& _parameters, ASTPointer<ParameterList> const& _returnParameters = ASTPointer<ParameterList>() )
dev::solidity::CallableDeclaration::m_parameters	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_parameters;$/;"	m	class:dev::solidity::CallableDeclaration	access:protected
dev::solidity::CallableDeclaration::m_returnParameters	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_returnParameters;$/;"	m	class:dev::solidity::CallableDeclaration	access:protected
dev::solidity::CallableDeclaration::parameterList	libsolidity/ast/AST.h	/^	ParameterList const& parameterList() const { return *m_parameters; }$/;"	f	class:dev::solidity::CallableDeclaration	access:public	signature:() const
dev::solidity::CallableDeclaration::returnParameterList	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> const& returnParameterList() const { return m_returnParameters; }$/;"	f	class:dev::solidity::CallableDeclaration	access:public	signature:() const
dev::solidity::CallableDeclaration::std::parameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& parameters() const { return m_parameters->parameters(); }$/;"	f	class:dev::solidity::CallableDeclaration::std	access:public	signature:() const
dev::solidity::CallableDeclaration::std::returnParameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& returnParameters() const { return m_returnParameters->parameters(); }$/;"	f	class:dev::solidity::CallableDeclaration::std	access:public	signature:() const
dev::solidity::CommandLineInterface::actOnInput	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::actOnInput()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::CommandLineInterface::assemble	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::assemble($/;"	f	class:dev::solidity::CommandLineInterface	signature:( yul::AssemblyStack::Language _language, yul::AssemblyStack::Machine _targetMachine, bool _optimize )
dev::solidity::CommandLineInterface::createFile	solse/CommandLineInterface.cpp	/^void CommandLineInterface::createFile(string const& _fileName, string const& _data)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _fileName, string const& _data)
dev::solidity::CommandLineInterface::createJson	solse/CommandLineInterface.cpp	/^void CommandLineInterface::createJson(string const& _fileName, string const& _json)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _fileName, string const& _json)
dev::solidity::CommandLineInterface::handleABI	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleABI(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::handleAst	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleAst(string const& _argStr)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _argStr)
dev::solidity::CommandLineInterface::handleBinary	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleBinary(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::handleBytecode	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleBytecode(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::handleCombinedJSON	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleCombinedJSON()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::CommandLineInterface::handleGasEstimation	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleGasEstimation(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::handleMetadata	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleMetadata(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::handleNatspec	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleNatspec(bool _natspecDev, string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(bool _natspecDev, string const& _contract)
dev::solidity::CommandLineInterface::handleOpcode	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleOpcode(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::handleSignatureHashes	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleSignatureHashes(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
dev::solidity::CommandLineInterface::libraryPlaceholderHint	solse/CommandLineInterface.cpp	/^string CommandLineInterface::libraryPlaceholderHint(string const& _libraryName)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _libraryName)
dev::solidity::CommandLineInterface::link	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::link()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::CommandLineInterface::objectWithLinkRefsHex	solse/CommandLineInterface.cpp	/^string CommandLineInterface::objectWithLinkRefsHex(eth::LinkerObject const& _obj)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(eth::LinkerObject const& _obj)
dev::solidity::CommandLineInterface::outputCompilationResults	solse/CommandLineInterface.cpp	/^void CommandLineInterface::outputCompilationResults()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::CommandLineInterface::parseArguments	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::parseArguments(int _argc, char** _argv)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(int _argc, char** _argv)
dev::solidity::CommandLineInterface::parseLibraryOption	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::parseLibraryOption(string const& _input)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _input)
dev::solidity::CommandLineInterface::processInput	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::processInput()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::CommandLineInterface::readInputFilesAndConfigureRemappings	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::readInputFilesAndConfigureRemappings()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::CommandLineInterface::writeLinkedFiles	solse/CommandLineInterface.cpp	/^void CommandLineInterface::writeLinkedFiles()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
dev::solidity::Compiler	libsolidity/codegen/Compiler.h	/^class Compiler$/;"	c	namespace:dev::solidity
dev::solidity::Compiler::Compiler	libsolidity/codegen/Compiler.h	/^	explicit Compiler(langutil::EVMVersion _evmVersion, OptimiserSettings _optimiserSettings):$/;"	f	class:dev::solidity::Compiler	access:public	signature:(langutil::EVMVersion _evmVersion, OptimiserSettings _optimiserSettings)
dev::solidity::Compiler::assembledObject	libsolidity/codegen/Compiler.h	/^	eth::LinkerObject assembledObject() const { return m_context.assembledObject(); }$/;"	f	class:dev::solidity::Compiler	access:public	signature:() const
dev::solidity::Compiler::assemblyJSON	libsolidity/codegen/Compiler.h	/^	Json::Value assemblyJSON(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::Compiler	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
dev::solidity::Compiler::assemblyPtr	libsolidity/codegen/Compiler.h	/^	std::shared_ptr<eth::Assembly> assemblyPtr() const { return m_context.assemblyPtr(); }$/;"	f	class:dev::solidity::Compiler	access:public	signature:() const
dev::solidity::Compiler::assemblyString	libsolidity/codegen/Compiler.h	/^	std::string assemblyString(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::Compiler	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
dev::solidity::Compiler::compileContract	libsolidity/codegen/Compiler.h	/^	void compileContract($/;"	p	class:dev::solidity::Compiler	access:public	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers, bytes const& _metadata )
dev::solidity::Compiler::eth::assembly	libsolidity/codegen/Compiler.h	/^	eth::Assembly const& assembly() const { return m_context.assembly(); }$/;"	f	class:dev::solidity::Compiler::eth	access:public	signature:() const
dev::solidity::Compiler::eth::assemblyItems	libsolidity/codegen/Compiler.h	/^	eth::AssemblyItems const& assemblyItems() const { return m_context.assembly().items(); }$/;"	f	class:dev::solidity::Compiler::eth	access:public	signature:() const
dev::solidity::Compiler::eth::runtimeAssemblyItems	libsolidity/codegen/Compiler.h	/^	eth::AssemblyItems const& runtimeAssemblyItems() const { return m_context.assembly().sub(m_runtimeSub).items(); }$/;"	f	class:dev::solidity::Compiler::eth	access:public	signature:() const
dev::solidity::Compiler::functionEntryLabel	libsolidity/codegen/Compiler.h	/^	eth::AssemblyItem functionEntryLabel(FunctionDefinition const& _function) const;$/;"	p	class:dev::solidity::Compiler	access:public	signature:(FunctionDefinition const& _function) const
dev::solidity::Compiler::m_context	libsolidity/codegen/Compiler.h	/^	CompilerContext m_context;$/;"	m	class:dev::solidity::Compiler	access:private
dev::solidity::Compiler::m_optimiserSettings	libsolidity/codegen/Compiler.h	/^	OptimiserSettings const m_optimiserSettings;$/;"	m	class:dev::solidity::Compiler	access:private
dev::solidity::Compiler::m_runtimeContext	libsolidity/codegen/Compiler.h	/^	CompilerContext m_runtimeContext;$/;"	m	class:dev::solidity::Compiler	access:private
dev::solidity::Compiler::m_runtimeSub	libsolidity/codegen/Compiler.h	/^	size_t m_runtimeSub = size_t(-1); \/\/\/< Identifier of the runtime sub-assembly, if present.$/;"	m	class:dev::solidity::Compiler	access:private
dev::solidity::Compiler::runtimeAssemblyPtr	libsolidity/codegen/Compiler.h	/^	std::shared_ptr<eth::Assembly> runtimeAssemblyPtr() const;$/;"	p	class:dev::solidity::Compiler	access:public	signature:() const
dev::solidity::Compiler::runtimeObject	libsolidity/codegen/Compiler.h	/^	eth::LinkerObject runtimeObject() const { return m_context.assembledRuntimeObject(m_runtimeSub); }$/;"	f	class:dev::solidity::Compiler	access:public	signature:() const
dev::solidity::CompilerContext	libsolidity/codegen/CompilerContext.h	/^class CompilerContext$/;"	c	namespace:dev::solidity
dev::solidity::CompilerContext::CompilerContext	libsolidity/codegen/CompilerContext.h	/^	explicit CompilerContext(langutil::EVMVersion _evmVersion, CompilerContext* _runtimeContext = nullptr):$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(langutil::EVMVersion _evmVersion, CompilerContext* _runtimeContext = nullptr)
dev::solidity::CompilerContext::FunctionCompilationQueue	libsolidity/codegen/CompilerContext.h	/^	struct FunctionCompilationQueue$/;"	s	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::FunctionCompilationQueue::entryLabel	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::FunctionCompilationQueue::entryLabel($/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:( Declaration const& _declaration, CompilerContext& _context )
dev::solidity::CompilerContext::FunctionCompilationQueue::entryLabel	libsolidity/codegen/CompilerContext.h	/^		eth::AssemblyItem entryLabel(Declaration const& _declaration, CompilerContext& _context);$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:(Declaration const& _declaration, CompilerContext& _context)
dev::solidity::CompilerContext::FunctionCompilationQueue::entryLabelIfExists	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::FunctionCompilationQueue::entryLabelIfExists(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::FunctionCompilationQueue::entryLabelIfExists	libsolidity/codegen/CompilerContext.h	/^		eth::AssemblyItem entryLabelIfExists(Declaration const& _declaration) const;$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::FunctionCompilationQueue::m_alreadyCompiledFunctions	libsolidity/codegen/CompilerContext.h	/^		std::set<Declaration const*> m_alreadyCompiledFunctions;$/;"	m	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public
dev::solidity::CompilerContext::FunctionCompilationQueue::m_entryLabels	libsolidity/codegen/CompilerContext.h	/^		std::map<Declaration const*, eth::AssemblyItem> m_entryLabels;$/;"	m	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public
dev::solidity::CompilerContext::FunctionCompilationQueue::m_functionsToCompile	libsolidity/codegen/CompilerContext.h	/^		mutable std::queue<Declaration const*> m_functionsToCompile;$/;"	m	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public
dev::solidity::CompilerContext::FunctionCompilationQueue::nextFunctionToCompile	libsolidity/codegen/CompilerContext.cpp	/^Declaration const* CompilerContext::FunctionCompilationQueue::nextFunctionToCompile() const$/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:() const
dev::solidity::CompilerContext::FunctionCompilationQueue::nextFunctionToCompile	libsolidity/codegen/CompilerContext.h	/^		Declaration const* nextFunctionToCompile() const;$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:() const
dev::solidity::CompilerContext::FunctionCompilationQueue::startFunction	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::FunctionCompilationQueue::startFunction(Declaration const& _function)$/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:(Declaration const& _function)
dev::solidity::CompilerContext::FunctionCompilationQueue::startFunction	libsolidity/codegen/CompilerContext.h	/^		void startFunction(Declaration const& _function);$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:(Declaration const& _function)
dev::solidity::CompilerContext::LocationSetter	libsolidity/codegen/CompilerContext.h	/^	class LocationSetter: public ScopeGuard$/;"	c	class:dev::solidity::CompilerContext	inherits:ScopeGuard	access:public
dev::solidity::CompilerContext::LocationSetter::LocationSetter	libsolidity/codegen/CompilerContext.h	/^		LocationSetter(CompilerContext& _compilerContext, ASTNode const& _node):$/;"	f	class:dev::solidity::CompilerContext::LocationSetter	access:public	signature:(CompilerContext& _compilerContext, ASTNode const& _node)
dev::solidity::CompilerContext::abiFunctions	libsolidity/codegen/CompilerContext.h	/^	ABIFunctions& abiFunctions() { return m_abiFunctions; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::addStateVariable	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::addStateVariable($/;"	f	class:dev::solidity::CompilerContext	signature:( VariableDeclaration const& _declaration, u256 const& _storageOffset, unsigned _byteOffset )
dev::solidity::CompilerContext::addStateVariable	libsolidity/codegen/CompilerContext.h	/^	void addStateVariable(VariableDeclaration const& _declaration, u256 const& _storageOffset, unsigned _byteOffset);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(VariableDeclaration const& _declaration, u256 const& _storageOffset, unsigned _byteOffset)
dev::solidity::CompilerContext::addSubroutine	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem addSubroutine(eth::AssemblyPointer const& _assembly) { return m_asm->appendSubroutine(_assembly); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyPointer const& _assembly)
dev::solidity::CompilerContext::addVariable	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::addVariable($/;"	f	class:dev::solidity::CompilerContext	signature:( VariableDeclaration const& _declaration, unsigned _offsetToCurrent )
dev::solidity::CompilerContext::addVariable	libsolidity/codegen/CompilerContext.h	/^	void addVariable(VariableDeclaration const& _declaration, unsigned _offsetToCurrent = 0);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(VariableDeclaration const& _declaration, unsigned _offsetToCurrent = 0)
dev::solidity::CompilerContext::adjustStackOffset	libsolidity/codegen/CompilerContext.h	/^	void adjustStackOffset(int _adjustment) { m_asm->adjustDeposit(_adjustment); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(int _adjustment)
dev::solidity::CompilerContext::appendAuxiliaryData	libsolidity/codegen/CompilerContext.h	/^	void appendAuxiliaryData(bytes const& _data) { m_asm->appendAuxiliaryDataToEnd(_data); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(bytes const& _data)
dev::solidity::CompilerContext::appendConditionalInvalid	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendConditionalInvalid()$/;"	f	class:dev::solidity::CompilerContext	signature:()
dev::solidity::CompilerContext::appendConditionalInvalid	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendConditionalInvalid();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendConditionalJump	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem appendConditionalJump() { return m_asm->appendJumpI().tag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendConditionalJumpTo	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendConditionalJumpTo(eth::AssemblyItem const& _tag) { m_asm->appendJumpI(_tag); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyItem const& _tag)
dev::solidity::CompilerContext::appendConditionalRevert	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendConditionalRevert(bool _forwardReturnData)$/;"	f	class:dev::solidity::CompilerContext	signature:(bool _forwardReturnData)
dev::solidity::CompilerContext::appendConditionalRevert	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendConditionalRevert(bool _forwardReturnData = false);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(bool _forwardReturnData = false)
dev::solidity::CompilerContext::appendData	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem appendData(bytes const& _data) { return m_asm->append(_data); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(bytes const& _data)
dev::solidity::CompilerContext::appendDeployTimeAddress	libsolidity/codegen/CompilerContext.h	/^	void appendDeployTimeAddress() { m_asm->append(eth::PushDeployTimeAddress); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendInlineAssembly	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::appendInlineAssembly($/;"	f	class:dev::solidity::CompilerContext	signature:( string const& _assembly, vector<string> const& _localVariables, set<string> const& _externallyUsedFunctions, bool _system, bool _optimise )
dev::solidity::CompilerContext::appendInlineAssembly	libsolidity/codegen/CompilerContext.h	/^	void appendInlineAssembly($/;"	p	class:dev::solidity::CompilerContext	access:public	signature:( std::string const& _assembly, std::vector<std::string> const& _localVariables = std::vector<std::string>(), std::set<std::string> const& _externallyUsedFunctions = std::set<std::string>(), bool _system = false, bool _optimise = false )
dev::solidity::CompilerContext::appendInvalid	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendInvalid()$/;"	f	class:dev::solidity::CompilerContext	signature:()
dev::solidity::CompilerContext::appendInvalid	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendInvalid();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendJump	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendJump(eth::AssemblyItem::JumpType _jumpType)$/;"	f	class:dev::solidity::CompilerContext	signature:(eth::AssemblyItem::JumpType _jumpType)
dev::solidity::CompilerContext::appendJump	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendJump(eth::AssemblyItem::JumpType _jumpType = eth::AssemblyItem::JumpType::Ordinary);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyItem::JumpType _jumpType = eth::AssemblyItem::JumpType::Ordinary)
dev::solidity::CompilerContext::appendJumpTo	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendJumpTo($/;"	f	class:dev::solidity::CompilerContext	access:public	signature:( eth::AssemblyItem const& _tag, eth::AssemblyItem::JumpType _jumpType = eth::AssemblyItem::JumpType::Ordinary )
dev::solidity::CompilerContext::appendJumpToNew	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem appendJumpToNew() { return m_asm->appendJump().tag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendLibraryAddress	libsolidity/codegen/CompilerContext.h	/^	void appendLibraryAddress(std::string const& _identifier) { m_asm->appendLibraryAddress(_identifier); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::string const& _identifier)
dev::solidity::CompilerContext::appendMissingLowLevelFunctions	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::appendMissingLowLevelFunctions()$/;"	f	class:dev::solidity::CompilerContext	signature:()
dev::solidity::CompilerContext::appendMissingLowLevelFunctions	libsolidity/codegen/CompilerContext.h	/^	void appendMissingLowLevelFunctions();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendProgramSize	libsolidity/codegen/CompilerContext.h	/^	void appendProgramSize() { m_asm->appendProgramSize(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::appendRevert	libsolidity/codegen/CompilerContext.cpp	/^CompilerContext& CompilerContext::appendRevert()$/;"	f	class:dev::solidity::CompilerContext	signature:()
dev::solidity::CompilerContext::appendRevert	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& appendRevert();$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::assemblyJSON	libsolidity/codegen/CompilerContext.h	/^	Json::Value assemblyJSON(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
dev::solidity::CompilerContext::assemblyPtr	libsolidity/codegen/CompilerContext.h	/^	std::shared_ptr<eth::Assembly> assemblyPtr() const { return m_asm; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
dev::solidity::CompilerContext::assemblyString	libsolidity/codegen/CompilerContext.h	/^	std::string assemblyString(StringMap const& _sourceCodes = StringMap()) const$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(StringMap const& _sourceCodes = StringMap()) const
dev::solidity::CompilerContext::baseStackOffsetOfVariable	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::baseStackOffsetOfVariable(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::baseStackOffsetOfVariable	libsolidity/codegen/CompilerContext.h	/^	unsigned baseStackOffsetOfVariable(Declaration const& _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::baseToCurrentStackOffset	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::baseToCurrentStackOffset(unsigned _baseOffset) const$/;"	f	class:dev::solidity::CompilerContext	signature:(unsigned _baseOffset) const
dev::solidity::CompilerContext::baseToCurrentStackOffset	libsolidity/codegen/CompilerContext.h	/^	unsigned baseToCurrentStackOffset(unsigned _baseOffset) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(unsigned _baseOffset) const
dev::solidity::CompilerContext::callLowLevelFunction	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::callLowLevelFunction($/;"	f	class:dev::solidity::CompilerContext	signature:( string const& _name, unsigned _inArgs, unsigned _outArgs, function<void(CompilerContext&)> const& _generator )
dev::solidity::CompilerContext::callLowLevelFunction	libsolidity/codegen/CompilerContext.h	/^	void callLowLevelFunction($/;"	p	class:dev::solidity::CompilerContext	access:public	signature:( std::string const& _name, unsigned _inArgs, unsigned _outArgs, std::function<void(CompilerContext&)> const& _generator )
dev::solidity::CompilerContext::compiledContract	libsolidity/codegen/CompilerContext.cpp	/^shared_ptr<eth::Assembly> CompilerContext::compiledContract(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::compiledContract	libsolidity/codegen/CompilerContext.h	/^	std::shared_ptr<eth::Assembly> compiledContract(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::compiledContractRuntime	libsolidity/codegen/CompilerContext.cpp	/^shared_ptr<eth::Assembly> CompilerContext::compiledContractRuntime(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::compiledContractRuntime	libsolidity/codegen/CompilerContext.h	/^	std::shared_ptr<eth::Assembly> compiledContractRuntime(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::currentToBaseStackOffset	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::currentToBaseStackOffset(unsigned _offset) const$/;"	f	class:dev::solidity::CompilerContext	signature:(unsigned _offset) const
dev::solidity::CompilerContext::currentToBaseStackOffset	libsolidity/codegen/CompilerContext.h	/^	unsigned currentToBaseStackOffset(unsigned _offset) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(unsigned _offset) const
dev::solidity::CompilerContext::eth::assembledObject	libsolidity/codegen/CompilerContext.h	/^	eth::LinkerObject const& assembledObject() const { return m_asm->assemble(); }$/;"	f	class:dev::solidity::CompilerContext::eth	access:public	signature:() const
dev::solidity::CompilerContext::eth::assembledRuntimeObject	libsolidity/codegen/CompilerContext.h	/^	eth::LinkerObject const& assembledRuntimeObject(size_t _subIndex) const { return m_asm->sub(_subIndex).assemble(); }$/;"	f	class:dev::solidity::CompilerContext::eth	access:public	signature:(size_t _subIndex) const
dev::solidity::CompilerContext::eth::assembly	libsolidity/codegen/CompilerContext.h	/^	eth::Assembly const& assembly() const { return *m_asm; }$/;"	f	class:dev::solidity::CompilerContext::eth	access:public	signature:() const
dev::solidity::CompilerContext::experimentalFeatureActive	libsolidity/codegen/CompilerContext.h	/^	bool experimentalFeatureActive(ExperimentalFeature _feature) const { return m_experimentalFeatures.count(_feature); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(ExperimentalFeature _feature) const
dev::solidity::CompilerContext::functionEntryLabel	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::functionEntryLabel(Declaration const& _declaration)$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration)
dev::solidity::CompilerContext::functionEntryLabel	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem functionEntryLabel(Declaration const& _declaration);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration)
dev::solidity::CompilerContext::functionEntryLabelIfExists	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::functionEntryLabelIfExists(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::functionEntryLabelIfExists	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem functionEntryLabelIfExists(Declaration const& _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::isLocalVariable	libsolidity/codegen/CompilerContext.cpp	/^bool CompilerContext::isLocalVariable(Declaration const* _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const* _declaration) const
dev::solidity::CompilerContext::isLocalVariable	libsolidity/codegen/CompilerContext.h	/^	bool isLocalVariable(Declaration const* _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const* _declaration) const
dev::solidity::CompilerContext::isStateVariable	libsolidity/codegen/CompilerContext.h	/^	bool isStateVariable(Declaration const* _declaration) const { return m_stateVariables.count(_declaration) != 0; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const* _declaration) const
dev::solidity::CompilerContext::langutil::evmVersion	libsolidity/codegen/CompilerContext.h	/^	langutil::EVMVersion const& evmVersion() const { return m_evmVersion; }$/;"	f	class:dev::solidity::CompilerContext::langutil	access:public	signature:() const
dev::solidity::CompilerContext::lowLevelFunctionTag	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::lowLevelFunctionTag($/;"	f	class:dev::solidity::CompilerContext	signature:( string const& _name, unsigned _inArgs, unsigned _outArgs, function<void(CompilerContext&)> const& _generator )
dev::solidity::CompilerContext::lowLevelFunctionTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem lowLevelFunctionTag($/;"	p	class:dev::solidity::CompilerContext	access:public	signature:( std::string const& _name, unsigned _inArgs, unsigned _outArgs, std::function<void(CompilerContext&)> const& _generator )
dev::solidity::CompilerContext::m_abiFunctions	libsolidity/codegen/CompilerContext.h	/^	ABIFunctions m_abiFunctions;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_asm	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyPointer m_asm;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_evmVersion	libsolidity/codegen/CompilerContext.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_experimentalFeatures	libsolidity/codegen/CompilerContext.h	/^	std::set<ExperimentalFeature> m_experimentalFeatures;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_functionCompilationQueue	libsolidity/codegen/CompilerContext.h	/^	} m_functionCompilationQueue;$/;"	m	class:dev::solidity::CompilerContext	typeref:struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:private
dev::solidity::CompilerContext::m_inheritanceHierarchy	libsolidity/codegen/CompilerContext.h	/^	std::vector<ContractDefinition const*> m_inheritanceHierarchy;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_localVariables	libsolidity/codegen/CompilerContext.h	/^	std::map<Declaration const*, std::vector<unsigned>> m_localVariables;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_lowLevelFunctionGenerationQueue	libsolidity/codegen/CompilerContext.h	/^	std::queue<std::tuple<std::string, unsigned, unsigned, std::function<void(CompilerContext&)>>> m_lowLevelFunctionGenerationQueue;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_lowLevelFunctions	libsolidity/codegen/CompilerContext.h	/^	std::map<std::string, eth::AssemblyItem> m_lowLevelFunctions;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_otherCompilers	libsolidity/codegen/CompilerContext.h	/^	std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> m_otherCompilers;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_runtimeContext	libsolidity/codegen/CompilerContext.h	/^	CompilerContext *m_runtimeContext;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_runtimeSub	libsolidity/codegen/CompilerContext.h	/^	size_t m_runtimeSub = -1;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_stateVariables	libsolidity/codegen/CompilerContext.h	/^	std::map<Declaration const*, std::pair<u256, unsigned>> m_stateVariables;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::m_visitedNodes	libsolidity/codegen/CompilerContext.h	/^	std::stack<ASTNode const*> m_visitedNodes;$/;"	m	class:dev::solidity::CompilerContext	access:private
dev::solidity::CompilerContext::namedTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem namedTag(std::string const& _name) { return m_asm->namedTag(_name); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::string const& _name)
dev::solidity::CompilerContext::newTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem newTag() { return m_asm->newTag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::nextConstructor	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const* CompilerContext::nextConstructor(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::nextConstructor	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const* nextConstructor(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::nextFunctionToCompile	libsolidity/codegen/CompilerContext.cpp	/^Declaration const* CompilerContext::nextFunctionToCompile() const$/;"	f	class:dev::solidity::CompilerContext	signature:() const
dev::solidity::CompilerContext::nextFunctionToCompile	libsolidity/codegen/CompilerContext.h	/^	Declaration const* nextFunctionToCompile() const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:() const
dev::solidity::CompilerContext::numberOfLocalVariables	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::numberOfLocalVariables() const$/;"	f	class:dev::solidity::CompilerContext	signature:() const
dev::solidity::CompilerContext::numberOfLocalVariables	libsolidity/codegen/CompilerContext.h	/^	unsigned numberOfLocalVariables() const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:() const
dev::solidity::CompilerContext::operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(Instruction _instruction) { m_asm->append(_instruction); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(Instruction _instruction)
dev::solidity::CompilerContext::operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(bytes const& _data) { m_asm->append(_data); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(bytes const& _data)
dev::solidity::CompilerContext::operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(eth::AssemblyItem const& _item) { m_asm->append(_item); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyItem const& _item)
dev::solidity::CompilerContext::operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(u256 const& _value) { m_asm->append(_value); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(u256 const& _value)
dev::solidity::CompilerContext::optimise	libsolidity/codegen/CompilerContext.h	/^	void optimise(OptimiserSettings const& _settings) { m_asm->optimise(translateOptimiserSettings(_settings)); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(OptimiserSettings const& _settings)
dev::solidity::CompilerContext::popVisitedNodes	libsolidity/codegen/CompilerContext.h	/^	void popVisitedNodes() { m_visitedNodes.pop(); updateSourceLocation(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::pushNewTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem pushNewTag() { return m_asm->append(m_asm->newPushTag()).tag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
dev::solidity::CompilerContext::pushSubroutineOffset	libsolidity/codegen/CompilerContext.h	/^	void pushSubroutineOffset(size_t _subRoutine) { m_asm->pushSubroutineOffset(_subRoutine); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(size_t _subRoutine)
dev::solidity::CompilerContext::pushSubroutineSize	libsolidity/codegen/CompilerContext.h	/^	void pushSubroutineSize(size_t _subRoutine) { m_asm->pushSubroutineSize(_subRoutine); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(size_t _subRoutine)
dev::solidity::CompilerContext::pushVisitedNodes	libsolidity/codegen/CompilerContext.h	/^	void pushVisitedNodes(ASTNode const* _node) { m_visitedNodes.push(_node); updateSourceLocation(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(ASTNode const* _node)
dev::solidity::CompilerContext::removeVariable	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::removeVariable(Declaration const& _declaration)$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration)
dev::solidity::CompilerContext::removeVariable	libsolidity/codegen/CompilerContext.h	/^	void removeVariable(Declaration const& _declaration);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration)
dev::solidity::CompilerContext::removeVariablesAboveStackHeight	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::removeVariablesAboveStackHeight(unsigned _stackHeight)$/;"	f	class:dev::solidity::CompilerContext	signature:(unsigned _stackHeight)
dev::solidity::CompilerContext::removeVariablesAboveStackHeight	libsolidity/codegen/CompilerContext.h	/^	void removeVariablesAboveStackHeight(unsigned _stackHeight);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(unsigned _stackHeight)
dev::solidity::CompilerContext::resetVisitedNodes	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::resetVisitedNodes(ASTNode const* _node)$/;"	f	class:dev::solidity::CompilerContext	signature:(ASTNode const* _node)
dev::solidity::CompilerContext::resetVisitedNodes	libsolidity/codegen/CompilerContext.h	/^	void resetVisitedNodes(ASTNode const* _node);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ASTNode const* _node)
dev::solidity::CompilerContext::resolveVirtualFunction	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const& CompilerContext::resolveVirtualFunction($/;"	f	class:dev::solidity::CompilerContext	signature:( FunctionDefinition const& _function, vector<ContractDefinition const*>::const_iterator _searchStart )
dev::solidity::CompilerContext::resolveVirtualFunction	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const& CompilerContext::resolveVirtualFunction(FunctionDefinition const& _function)$/;"	f	class:dev::solidity::CompilerContext	signature:(FunctionDefinition const& _function)
dev::solidity::CompilerContext::resolveVirtualFunction	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const& resolveVirtualFunction($/;"	p	class:dev::solidity::CompilerContext	access:private	signature:( FunctionDefinition const& _function, std::vector<ContractDefinition const*>::const_iterator _searchStart )
dev::solidity::CompilerContext::resolveVirtualFunction	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const& resolveVirtualFunction(FunctionDefinition const& _function);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(FunctionDefinition const& _function)
dev::solidity::CompilerContext::resolveVirtualFunctionModifier	libsolidity/codegen/CompilerContext.cpp	/^ModifierDefinition const& CompilerContext::resolveVirtualFunctionModifier($/;"	f	class:dev::solidity::CompilerContext	signature:( ModifierDefinition const& _modifier ) const
dev::solidity::CompilerContext::resolveVirtualFunctionModifier	libsolidity/codegen/CompilerContext.h	/^	ModifierDefinition const& resolveVirtualFunctionModifier(ModifierDefinition const& _modifier) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ModifierDefinition const& _modifier) const
dev::solidity::CompilerContext::runtimeContext	libsolidity/codegen/CompilerContext.h	/^	CompilerContext* runtimeContext() const { return m_runtimeContext; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
dev::solidity::CompilerContext::runtimeSub	libsolidity/codegen/CompilerContext.h	/^	size_t runtimeSub() const { return m_runtimeSub; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
dev::solidity::CompilerContext::setExperimentalFeatures	libsolidity/codegen/CompilerContext.h	/^	void setExperimentalFeatures(std::set<ExperimentalFeature> const& _features) { m_experimentalFeatures = _features; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::set<ExperimentalFeature> const& _features)
dev::solidity::CompilerContext::setInheritanceHierarchy	libsolidity/codegen/CompilerContext.h	/^	void setInheritanceHierarchy(std::vector<ContractDefinition const*> const& _hierarchy) { m_inheritanceHierarchy = _hierarchy; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::vector<ContractDefinition const*> const& _hierarchy)
dev::solidity::CompilerContext::setOtherCompilers	libsolidity/codegen/CompilerContext.h	/^	void setOtherCompilers(std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers) { m_otherCompilers = _otherCompilers; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers)
dev::solidity::CompilerContext::setStackOffset	libsolidity/codegen/CompilerContext.h	/^	void setStackOffset(int _offset) { m_asm->setDeposit(_offset); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(int _offset)
dev::solidity::CompilerContext::stackHeight	libsolidity/codegen/CompilerContext.h	/^	unsigned stackHeight() const { solAssert(m_asm->deposit() >= 0, ""); return unsigned(m_asm->deposit()); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
dev::solidity::CompilerContext::startFunction	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::startFunction(Declaration const& _function)$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _function)
dev::solidity::CompilerContext::startFunction	libsolidity/codegen/CompilerContext.h	/^	void startFunction(Declaration const& _function);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _function)
dev::solidity::CompilerContext::storageLocationOfVariable	libsolidity/codegen/CompilerContext.cpp	/^pair<u256, unsigned> CompilerContext::storageLocationOfVariable(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::storageLocationOfVariable	libsolidity/codegen/CompilerContext.h	/^	std::pair<u256, unsigned> storageLocationOfVariable(Declaration const& _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration) const
dev::solidity::CompilerContext::superContract	libsolidity/codegen/CompilerContext.cpp	/^vector<ContractDefinition const*>::const_iterator CompilerContext::superContract(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::superContract	libsolidity/codegen/CompilerContext.h	/^	std::vector<ContractDefinition const*>::const_iterator superContract(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:private	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerContext::superFunction	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const& CompilerContext::superFunction(FunctionDefinition const& _function, ContractDefinition const& _base)$/;"	f	class:dev::solidity::CompilerContext	signature:(FunctionDefinition const& _function, ContractDefinition const& _base)
dev::solidity::CompilerContext::superFunction	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const& superFunction(FunctionDefinition const& _function, ContractDefinition const& _base);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(FunctionDefinition const& _function, ContractDefinition const& _base)
dev::solidity::CompilerContext::translateOptimiserSettings	libsolidity/codegen/CompilerContext.cpp	/^eth::Assembly::OptimiserSettings CompilerContext::translateOptimiserSettings(OptimiserSettings const& _settings)$/;"	f	class:dev::solidity::CompilerContext	signature:(OptimiserSettings const& _settings)
dev::solidity::CompilerContext::translateOptimiserSettings	libsolidity/codegen/CompilerContext.h	/^	eth::Assembly::OptimiserSettings translateOptimiserSettings(OptimiserSettings const& _settings);$/;"	p	class:dev::solidity::CompilerContext	access:private	signature:(OptimiserSettings const& _settings)
dev::solidity::CompilerContext::updateSourceLocation	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::updateSourceLocation()$/;"	f	class:dev::solidity::CompilerContext	signature:()
dev::solidity::CompilerContext::updateSourceLocation	libsolidity/codegen/CompilerContext.h	/^	void updateSourceLocation();$/;"	p	class:dev::solidity::CompilerContext	access:private	signature:()
dev::solidity::CompilerStack	libsolidity/interface/CompilerStack.h	/^class CompilerStack: boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
dev::solidity::CompilerStack::AnalysisSuccessful	libsolidity/interface/CompilerStack.h	/^		AnalysisSuccessful,$/;"	e	enum:dev::solidity::CompilerStack::State
dev::solidity::CompilerStack::CompilationSuccessful	libsolidity/interface/CompilerStack.h	/^		CompilationSuccessful$/;"	e	enum:dev::solidity::CompilerStack::State
dev::solidity::CompilerStack::CompilerStack	libsolidity/interface/CompilerStack.h	/^	explicit CompilerStack(ReadCallback::Callback const& _readFile = ReadCallback::Callback()):$/;"	f	class:dev::solidity::CompilerStack	access:public	signature:(ReadCallback::Callback const& _readFile = ReadCallback::Callback())
dev::solidity::CompilerStack::Contract	libsolidity/interface/CompilerStack.h	/^	struct Contract$/;"	s	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::Contract::abi	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<Json::Value const> abi;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::compiler	libsolidity/interface/CompilerStack.h	/^		std::shared_ptr<Compiler> compiler;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::contract	libsolidity/interface/CompilerStack.h	/^		ContractDefinition const* contract = nullptr;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::devDocumentation	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<Json::Value const> devDocumentation;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::metadata	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<std::string const> metadata; \/\/\/< The metadata json that will be hashed into the chain.$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::object	libsolidity/interface/CompilerStack.h	/^		eth::LinkerObject object; \/\/\/< Deployment object (includes the runtime sub-object).$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::runtimeObject	libsolidity/interface/CompilerStack.h	/^		eth::LinkerObject runtimeObject; \/\/\/< Runtime object.$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::runtimeSourceMapping	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<std::string const> runtimeSourceMapping;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::sourceMapping	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<std::string const> sourceMapping;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Contract::userDocumentation	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<Json::Value const> userDocumentation;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
dev::solidity::CompilerStack::Empty	libsolidity/interface/CompilerStack.h	/^		Empty,$/;"	e	enum:dev::solidity::CompilerStack::State
dev::solidity::CompilerStack::Json::contractABI	libsolidity/interface/CompilerStack.h	/^	Json::Value const& contractABI(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:private	signature:(Contract const&) const
dev::solidity::CompilerStack::Json::contractABI	libsolidity/interface/CompilerStack.h	/^	Json::Value const& contractABI(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::Json::natspecDev	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecDev(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:private	signature:(Contract const&) const
dev::solidity::CompilerStack::Json::natspecDev	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecDev(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::Json::natspecUser	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecUser(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:private	signature:(Contract const&) const
dev::solidity::CompilerStack::Json::natspecUser	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecUser(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::ParsingSuccessful	libsolidity/interface/CompilerStack.h	/^		ParsingSuccessful,$/;"	e	enum:dev::solidity::CompilerStack::State
dev::solidity::CompilerStack::Remapping	libsolidity/interface/CompilerStack.h	/^	struct Remapping$/;"	s	class:dev::solidity::CompilerStack	access:public
dev::solidity::CompilerStack::Remapping::context	libsolidity/interface/CompilerStack.h	/^		std::string context;$/;"	m	struct:dev::solidity::CompilerStack::Remapping	access:public
dev::solidity::CompilerStack::Remapping::prefix	libsolidity/interface/CompilerStack.h	/^		std::string prefix;$/;"	m	struct:dev::solidity::CompilerStack::Remapping	access:public
dev::solidity::CompilerStack::Remapping::target	libsolidity/interface/CompilerStack.h	/^		std::string target;$/;"	m	struct:dev::solidity::CompilerStack::Remapping	access:public
dev::solidity::CompilerStack::Source	libsolidity/interface/CompilerStack.h	/^	struct Source$/;"	s	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::Source::ast	libsolidity/interface/CompilerStack.h	/^		std::shared_ptr<SourceUnit> ast;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
dev::solidity::CompilerStack::Source::isLibrary	libsolidity/interface/CompilerStack.h	/^		bool isLibrary = false;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
dev::solidity::CompilerStack::Source::keccak256	libsolidity/interface/CompilerStack.h	/^		h256 const& keccak256() const;$/;"	p	struct:dev::solidity::CompilerStack::Source	access:public	signature:() const
dev::solidity::CompilerStack::Source::keccak256HashCached	libsolidity/interface/CompilerStack.h	/^		h256 mutable keccak256HashCached;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
dev::solidity::CompilerStack::Source::reset	libsolidity/interface/CompilerStack.h	/^		void reset() { *this = Source(); }$/;"	f	struct:dev::solidity::CompilerStack::Source	access:public	signature:()
dev::solidity::CompilerStack::Source::scanner	libsolidity/interface/CompilerStack.h	/^		std::shared_ptr<langutil::Scanner> scanner;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
dev::solidity::CompilerStack::Source::swarmHash	libsolidity/interface/CompilerStack.h	/^		h256 const& swarmHash() const;$/;"	p	struct:dev::solidity::CompilerStack::Source	access:public	signature:() const
dev::solidity::CompilerStack::Source::swarmHashCached	libsolidity/interface/CompilerStack.h	/^		h256 mutable swarmHashCached;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
dev::solidity::CompilerStack::SourcesSet	libsolidity/interface/CompilerStack.h	/^		SourcesSet,$/;"	e	enum:dev::solidity::CompilerStack::State
dev::solidity::CompilerStack::State	libsolidity/interface/CompilerStack.h	/^	enum State {$/;"	g	class:dev::solidity::CompilerStack	access:public
dev::solidity::CompilerStack::addSMTLib2Response	libsolidity/interface/CompilerStack.h	/^	void addSMTLib2Response(h256 const& _hash, std::string const& _response);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(h256 const& _hash, std::string const& _response)
dev::solidity::CompilerStack::addSource	libsolidity/interface/CompilerStack.h	/^	bool addSource(std::string const& _name, std::string const& _content, bool _isLibrary = false);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _name, std::string const& _content, bool _isLibrary = false)
dev::solidity::CompilerStack::analyze	libsolidity/interface/CompilerStack.h	/^	bool analyze();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
dev::solidity::CompilerStack::applyRemapping	libsolidity/interface/CompilerStack.h	/^	std::string applyRemapping(std::string const& _path, std::string const& _context);$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _path, std::string const& _context)
dev::solidity::CompilerStack::assemblyJSON	libsolidity/interface/CompilerStack.h	/^	Json::Value assemblyJSON(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const
dev::solidity::CompilerStack::assemblyString	libsolidity/interface/CompilerStack.h	/^	std::string assemblyString(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName, StringMap _sourceCodes = StringMap()) const
dev::solidity::CompilerStack::ast	libsolidity/interface/CompilerStack.h	/^	SourceUnit const& ast(std::string const& _sourceName) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _sourceName) const
dev::solidity::CompilerStack::compile	libsolidity/interface/CompilerStack.h	/^	bool compile();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
dev::solidity::CompilerStack::compileContract	libsolidity/interface/CompilerStack.h	/^	void compileContract($/;"	p	class:dev::solidity::CompilerStack	access:private	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>>& _otherCompilers )
dev::solidity::CompilerStack::computeSourceMapping	libsolidity/interface/CompilerStack.h	/^	std::string computeSourceMapping(eth::AssemblyItems const& _items) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(eth::AssemblyItems const& _items) const
dev::solidity::CompilerStack::contract	libsolidity/interface/CompilerStack.h	/^	Contract const& contract(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::contractDefinition	libsolidity/interface/CompilerStack.h	/^	ContractDefinition const& contractDefinition(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::contractNames	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> contractNames() const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:() const
dev::solidity::CompilerStack::createCBORMetadata	libsolidity/interface/CompilerStack.h	/^	static bytes createCBORMetadata(std::string const& _metadata, bool _experimentalMode);$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _metadata, bool _experimentalMode)
dev::solidity::CompilerStack::createMetadata	libsolidity/interface/CompilerStack.h	/^	std::string createMetadata(Contract const& _contract) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(Contract const& _contract) const
dev::solidity::CompilerStack::eth::assemblyItems	libsolidity/interface/CompilerStack.h	/^	eth::AssemblyItems const* assemblyItems(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::eth::object	libsolidity/interface/CompilerStack.h	/^	eth::LinkerObject const& object(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::eth::runtimeAssemblyItems	libsolidity/interface/CompilerStack.h	/^	eth::AssemblyItems const* runtimeAssemblyItems(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::eth::runtimeObject	libsolidity/interface/CompilerStack.h	/^	eth::LinkerObject const& runtimeObject(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::functionEntryPoint	libsolidity/interface/CompilerStack.h	/^	size_t functionEntryPoint($/;"	p	class:dev::solidity::CompilerStack	access:private	signature:( std::string const& _contractName, FunctionDefinition const& _function ) const
dev::solidity::CompilerStack::gasEstimates	libsolidity/interface/CompilerStack.h	/^	Json::Value gasEstimates(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::isRequestedContract	libsolidity/interface/CompilerStack.h	/^	bool isRequestedContract(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(ContractDefinition const& _contract) const
dev::solidity::CompilerStack::langutil::errors	libsolidity/interface/CompilerStack.h	/^	langutil::ErrorList const& errors() const { return m_errorReporter.errors(); }$/;"	f	class:dev::solidity::CompilerStack::langutil	access:public	signature:() const
dev::solidity::CompilerStack::langutil::scanner	libsolidity/interface/CompilerStack.h	/^	langutil::Scanner const& scanner(std::string const& _sourceName) const;$/;"	p	class:dev::solidity::CompilerStack::langutil	access:public	signature:(std::string const& _sourceName) const
dev::solidity::CompilerStack::link	libsolidity/interface/CompilerStack.h	/^	void link();$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:()
dev::solidity::CompilerStack::loadMissingSources	libsolidity/interface/CompilerStack.h	/^	StringMap loadMissingSources(SourceUnit const& _ast, std::string const& _path);$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(SourceUnit const& _ast, std::string const& _path)
dev::solidity::CompilerStack::m_contracts	libsolidity/interface/CompilerStack.h	/^	std::map<std::string const, Contract> m_contracts;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_errorList	libsolidity/interface/CompilerStack.h	/^	langutil::ErrorList m_errorList;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_errorReporter	libsolidity/interface/CompilerStack.h	/^	langutil::ErrorReporter m_errorReporter;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_evmVersion	libsolidity/interface/CompilerStack.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_globalContext	libsolidity/interface/CompilerStack.h	/^	std::shared_ptr<GlobalContext> m_globalContext;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_libraries	libsolidity/interface/CompilerStack.h	/^	std::map<std::string, h160> m_libraries;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_metadataLiteralSources	libsolidity/interface/CompilerStack.h	/^	bool m_metadataLiteralSources = false;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_optimiserSettings	libsolidity/interface/CompilerStack.h	/^	OptimiserSettings m_optimiserSettings;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_readFile	libsolidity/interface/CompilerStack.h	/^	ReadCallback::Callback m_readFile;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_remappings	libsolidity/interface/CompilerStack.h	/^	std::vector<Remapping> m_remappings;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_requestedContractNames	libsolidity/interface/CompilerStack.h	/^	std::set<std::string> m_requestedContractNames;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_scopes	libsolidity/interface/CompilerStack.h	/^	std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>> m_scopes;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_smtlib2Responses	libsolidity/interface/CompilerStack.h	/^	std::map<h256, std::string> m_smtlib2Responses;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_sourceOrder	libsolidity/interface/CompilerStack.h	/^	std::vector<Source const*> m_sourceOrder;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_sources	libsolidity/interface/CompilerStack.h	/^	std::map<std::string const, Source> m_sources;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_stackState	libsolidity/interface/CompilerStack.h	/^	State m_stackState = Empty;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::m_unhandledSMTLib2Queries	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> m_unhandledSMTLib2Queries;$/;"	m	class:dev::solidity::CompilerStack	access:private
dev::solidity::CompilerStack::methodIdentifiers	libsolidity/interface/CompilerStack.h	/^	Json::Value methodIdentifiers(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::parse	libsolidity/interface/CompilerStack.h	/^	bool parse();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
dev::solidity::CompilerStack::parseAndAnalyze	libsolidity/interface/CompilerStack.h	/^	bool parseAndAnalyze();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
dev::solidity::CompilerStack::parseRemapping	libsolidity/interface/CompilerStack.h	/^	static boost::optional<Remapping> parseRemapping(std::string const& _remapping);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _remapping)
dev::solidity::CompilerStack::positionFromSourceLocation	libsolidity/interface/CompilerStack.h	/^	std::tuple<int, int, int, int> positionFromSourceLocation(langutil::SourceLocation const& _sourceLocation) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(langutil::SourceLocation const& _sourceLocation) const
dev::solidity::CompilerStack::reset	libsolidity/interface/CompilerStack.h	/^	void reset(bool _keepSources = false);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(bool _keepSources = false)
dev::solidity::CompilerStack::resolveImports	libsolidity/interface/CompilerStack.h	/^	void resolveImports();$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:()
dev::solidity::CompilerStack::setEVMVersion	libsolidity/interface/CompilerStack.h	/^	void setEVMVersion(langutil::EVMVersion _version = langutil::EVMVersion{});$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(langutil::EVMVersion _version = langutil::EVMVersion{})
dev::solidity::CompilerStack::setLibraries	libsolidity/interface/CompilerStack.h	/^	void setLibraries(std::map<std::string, h160> const& _libraries = std::map<std::string, h160>{});$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::map<std::string, h160> const& _libraries = std::map<std::string, h160>{})
dev::solidity::CompilerStack::setOptimiserSettings	libsolidity/interface/CompilerStack.h	/^	void setOptimiserSettings(OptimiserSettings _settings);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(OptimiserSettings _settings)
dev::solidity::CompilerStack::setOptimiserSettings	libsolidity/interface/CompilerStack.h	/^	void setOptimiserSettings(bool _optimize, unsigned _runs = 200);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(bool _optimize, unsigned _runs = 200)
dev::solidity::CompilerStack::setRemappings	libsolidity/interface/CompilerStack.h	/^	void setRemappings(std::vector<Remapping> const& _remappings);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::vector<Remapping> const& _remappings)
dev::solidity::CompilerStack::setRequestedContractNames	libsolidity/interface/CompilerStack.h	/^	void setRequestedContractNames(std::set<std::string> const& _contractNames = std::set<std::string>{}) {$/;"	f	class:dev::solidity::CompilerStack	access:public	signature:(std::set<std::string> const& _contractNames = std::set<std::string>{})
dev::solidity::CompilerStack::source	libsolidity/interface/CompilerStack.h	/^	Source const& source(std::string const& _sourceName) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _sourceName) const
dev::solidity::CompilerStack::sourceIndices	libsolidity/interface/CompilerStack.h	/^	std::map<std::string, unsigned> sourceIndices() const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:() const
dev::solidity::CompilerStack::sourceNames	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> sourceNames() const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:() const
dev::solidity::CompilerStack::state	libsolidity/interface/CompilerStack.h	/^	State state() const { return m_stackState; }$/;"	f	class:dev::solidity::CompilerStack	access:public	signature:() const
dev::solidity::CompilerStack::std::filesystemFriendlyName	libsolidity/interface/CompilerStack.h	/^	std::string const filesystemFriendlyName(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::std::lastContractName	libsolidity/interface/CompilerStack.h	/^	std::string const lastContractName() const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:() const
dev::solidity::CompilerStack::std::metadata	libsolidity/interface/CompilerStack.h	/^	std::string const& metadata(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:private	signature:(Contract const&) const
dev::solidity::CompilerStack::std::metadata	libsolidity/interface/CompilerStack.h	/^	std::string const& metadata(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::std::runtimeSourceMapping	libsolidity/interface/CompilerStack.h	/^	std::string const* runtimeSourceMapping(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::std::sourceMapping	libsolidity/interface/CompilerStack.h	/^	std::string const* sourceMapping(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
dev::solidity::CompilerStack::std::unhandledSMTLib2Queries	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> const& unhandledSMTLib2Queries() const { return m_unhandledSMTLib2Queries; }$/;"	f	class:dev::solidity::CompilerStack::std	access:public	signature:() const
dev::solidity::CompilerStack::useMetadataLiteralSources	libsolidity/interface/CompilerStack.h	/^	void useMetadataLiteralSources(bool _metadataLiteralSources);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(bool _metadataLiteralSources)
dev::solidity::CompilerUtils	libsolidity/codegen/CompilerUtils.h	/^class CompilerUtils$/;"	c	namespace:dev::solidity
dev::solidity::CompilerUtils::CompilerUtils	libsolidity/codegen/CompilerUtils.h	/^	explicit CompilerUtils(CompilerContext& _context): m_context(_context) {}$/;"	f	class:dev::solidity::CompilerUtils	access:public	signature:(CompilerContext& _context)
dev::solidity::CompilerUtils::abiDecode	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::abiDecode(TypePointers const& _typeParameters, bool _fromMemory)$/;"	f	class:dev::solidity::CompilerUtils	signature:(TypePointers const& _typeParameters, bool _fromMemory)
dev::solidity::CompilerUtils::abiDecode	libsolidity/codegen/CompilerUtils.h	/^	void abiDecode(TypePointers const& _typeParameters, bool _fromMemory = false);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(TypePointers const& _typeParameters, bool _fromMemory = false)
dev::solidity::CompilerUtils::abiDecodeV2	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::abiDecodeV2(TypePointers const& _parameterTypes, bool _fromMemory)$/;"	f	class:dev::solidity::CompilerUtils	signature:(TypePointers const& _parameterTypes, bool _fromMemory)
dev::solidity::CompilerUtils::abiDecodeV2	libsolidity/codegen/CompilerUtils.h	/^	void abiDecodeV2(TypePointers const& _parameterTypes, bool _fromMemory = false);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(TypePointers const& _parameterTypes, bool _fromMemory = false)
dev::solidity::CompilerUtils::abiEncode	libsolidity/codegen/CompilerUtils.h	/^	void abiEncode($/;"	f	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false )
dev::solidity::CompilerUtils::abiEncodeV2	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::abiEncodeV2($/;"	f	class:dev::solidity::CompilerUtils	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes, bool _padToWordBoundaries )
dev::solidity::CompilerUtils::abiEncodeV2	libsolidity/codegen/CompilerUtils.h	/^	void abiEncodeV2($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false, bool _padToWordBoundaries = true )
dev::solidity::CompilerUtils::allocateMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::allocateMemory()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::allocateMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::allocateMemory(u256 const& size)$/;"	f	class:dev::solidity::CompilerUtils	signature:(u256 const& size)
dev::solidity::CompilerUtils::allocateMemory	libsolidity/codegen/CompilerUtils.h	/^	void allocateMemory();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::allocateMemory	libsolidity/codegen/CompilerUtils.h	/^	void allocateMemory(u256 const& size);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(u256 const& size)
dev::solidity::CompilerUtils::cleanHigherOrderBits	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::cleanHigherOrderBits(IntegerType const& _typeOnStack)$/;"	f	class:dev::solidity::CompilerUtils	signature:(IntegerType const& _typeOnStack)
dev::solidity::CompilerUtils::cleanHigherOrderBits	libsolidity/codegen/CompilerUtils.h	/^	void cleanHigherOrderBits(IntegerType const& _typeOnStack);$/;"	p	class:dev::solidity::CompilerUtils	access:private	signature:(IntegerType const& _typeOnStack)
dev::solidity::CompilerUtils::combineExternalFunctionType	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::combineExternalFunctionType(bool _leftAligned)$/;"	f	class:dev::solidity::CompilerUtils	signature:(bool _leftAligned)
dev::solidity::CompilerUtils::combineExternalFunctionType	libsolidity/codegen/CompilerUtils.h	/^	void combineExternalFunctionType(bool _rightAligned);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(bool _rightAligned)
dev::solidity::CompilerUtils::computeHashStatic	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::computeHashStatic()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::computeHashStatic	libsolidity/codegen/CompilerUtils.h	/^	void computeHashStatic();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::convertType	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::convertType($/;"	f	class:dev::solidity::CompilerUtils	signature:( Type const& _typeOnStack, Type const& _targetType, bool _cleanupNeeded, bool _chopSignBits, bool _asPartOfArgumentDecoding )
dev::solidity::CompilerUtils::convertType	libsolidity/codegen/CompilerUtils.h	/^	void convertType($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( Type const& _typeOnStack, Type const& _targetType, bool _cleanupNeeded = false, bool _chopSignBits = false, bool _asPartOfArgumentDecoding = false )
dev::solidity::CompilerUtils::copyContractCodeToMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::copyContractCodeToMemory(ContractDefinition const& contract, bool _creation)$/;"	f	class:dev::solidity::CompilerUtils	signature:(ContractDefinition const& contract, bool _creation)
dev::solidity::CompilerUtils::copyContractCodeToMemory	libsolidity/codegen/CompilerUtils.h	/^	void copyContractCodeToMemory(ContractDefinition const& contract, bool _creationCode);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(ContractDefinition const& contract, bool _creationCode)
dev::solidity::CompilerUtils::copyToStackTop	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::copyToStackTop(unsigned _stackDepth, unsigned _itemSize)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _stackDepth, unsigned _itemSize)
dev::solidity::CompilerUtils::copyToStackTop	libsolidity/codegen/CompilerUtils.h	/^	void copyToStackTop(unsigned _stackDepth, unsigned _itemSize);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _stackDepth, unsigned _itemSize)
dev::solidity::CompilerUtils::dataStartOffset	libsolidity/codegen/CompilerUtils.cpp	/^unsigned const CompilerUtils::dataStartOffset = 4;$/;"	m	class:dev::solidity::CompilerUtils	file:
dev::solidity::CompilerUtils::dataStartOffset	libsolidity/codegen/CompilerUtils.h	/^	static unsigned const dataStartOffset;$/;"	m	class:dev::solidity::CompilerUtils	access:public
dev::solidity::CompilerUtils::encodeToMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::encodeToMemory($/;"	f	class:dev::solidity::CompilerUtils	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _padToWordBoundaries, bool _copyDynamicDataInPlace, bool _encodeAsLibraryTypes )
dev::solidity::CompilerUtils::encodeToMemory	libsolidity/codegen/CompilerUtils.h	/^	void encodeToMemory($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _padToWords, bool _copyDynamicDataInPlace, bool _encodeAsLibraryTypes = false )
dev::solidity::CompilerUtils::fetchFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::fetchFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::fetchFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void fetchFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::freeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^size_t const CompilerUtils::freeMemoryPointer = 64;$/;"	m	class:dev::solidity::CompilerUtils	file:
dev::solidity::CompilerUtils::freeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	static size_t const freeMemoryPointer;$/;"	m	class:dev::solidity::CompilerUtils	access:public
dev::solidity::CompilerUtils::generalPurposeMemoryStart	libsolidity/codegen/CompilerUtils.cpp	/^size_t const CompilerUtils::generalPurposeMemoryStart = CompilerUtils::zeroPointer + 32;$/;"	m	class:dev::solidity::CompilerUtils	file:
dev::solidity::CompilerUtils::generalPurposeMemoryStart	libsolidity/codegen/CompilerUtils.h	/^	static size_t const generalPurposeMemoryStart;$/;"	m	class:dev::solidity::CompilerUtils	access:public
dev::solidity::CompilerUtils::identityContractAddress	libsolidity/codegen/CompilerUtils.cpp	/^unsigned const CompilerUtils::identityContractAddress = 4;$/;"	m	class:dev::solidity::CompilerUtils	file:
dev::solidity::CompilerUtils::identityContractAddress	libsolidity/codegen/CompilerUtils.h	/^	static unsigned const identityContractAddress;$/;"	m	class:dev::solidity::CompilerUtils	access:private
dev::solidity::CompilerUtils::initialiseFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::initialiseFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::initialiseFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void initialiseFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::leftShiftNumberOnStack	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::leftShiftNumberOnStack(unsigned _bits)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _bits)
dev::solidity::CompilerUtils::leftShiftNumberOnStack	libsolidity/codegen/CompilerUtils.h	/^	void leftShiftNumberOnStack(unsigned _bits);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _bits)
dev::solidity::CompilerUtils::loadFromMemory	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::loadFromMemory($/;"	f	class:dev::solidity::CompilerUtils	signature:( unsigned _offset, Type const& _type, bool _fromCalldata, bool _padToWordBoundaries )
dev::solidity::CompilerUtils::loadFromMemory	libsolidity/codegen/CompilerUtils.h	/^	unsigned loadFromMemory($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( unsigned _offset, Type const& _type = IntegerType::uint256(), bool _fromCalldata = false, bool _padToWords = false )
dev::solidity::CompilerUtils::loadFromMemoryDynamic	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::loadFromMemoryDynamic($/;"	f	class:dev::solidity::CompilerUtils	signature:( Type const& _type, bool _fromCalldata, bool _padToWordBoundaries, bool _keepUpdatedMemoryOffset )
dev::solidity::CompilerUtils::loadFromMemoryDynamic	libsolidity/codegen/CompilerUtils.h	/^	void loadFromMemoryDynamic($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( Type const& _type, bool _fromCalldata = false, bool _padToWords = true, bool _keepUpdatedMemoryOffset = true )
dev::solidity::CompilerUtils::loadFromMemoryHelper	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::loadFromMemoryHelper(Type const& _type, bool _fromCalldata, bool _padToWords)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type, bool _fromCalldata, bool _padToWords)
dev::solidity::CompilerUtils::loadFromMemoryHelper	libsolidity/codegen/CompilerUtils.h	/^	unsigned loadFromMemoryHelper(Type const& _type, bool _fromCalldata, bool _padToWords);$/;"	p	class:dev::solidity::CompilerUtils	access:private	signature:(Type const& _type, bool _fromCalldata, bool _padToWords)
dev::solidity::CompilerUtils::m_context	libsolidity/codegen/CompilerUtils.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::CompilerUtils	access:private
dev::solidity::CompilerUtils::memoryCopy	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::memoryCopy()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::memoryCopy	libsolidity/codegen/CompilerUtils.h	/^	void memoryCopy();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::memoryCopy32	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::memoryCopy32()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::memoryCopy32	libsolidity/codegen/CompilerUtils.h	/^	void memoryCopy32();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::moveIntoStack	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::moveIntoStack(unsigned _stackDepth, unsigned _itemSize)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _stackDepth, unsigned _itemSize)
dev::solidity::CompilerUtils::moveIntoStack	libsolidity/codegen/CompilerUtils.h	/^	void moveIntoStack(unsigned _stackDepth, unsigned _itemSize = 1);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _stackDepth, unsigned _itemSize = 1)
dev::solidity::CompilerUtils::moveToStackTop	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::moveToStackTop(unsigned _stackDepth, unsigned _itemSize)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _stackDepth, unsigned _itemSize)
dev::solidity::CompilerUtils::moveToStackTop	libsolidity/codegen/CompilerUtils.h	/^	void moveToStackTop(unsigned _stackDepth, unsigned _itemSize = 1);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _stackDepth, unsigned _itemSize = 1)
dev::solidity::CompilerUtils::moveToStackVariable	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::moveToStackVariable(VariableDeclaration const& _variable)$/;"	f	class:dev::solidity::CompilerUtils	signature:(VariableDeclaration const& _variable)
dev::solidity::CompilerUtils::moveToStackVariable	libsolidity/codegen/CompilerUtils.h	/^	void moveToStackVariable(VariableDeclaration const& _variable);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(VariableDeclaration const& _variable)
dev::solidity::CompilerUtils::packedEncode	libsolidity/codegen/CompilerUtils.h	/^	void packedEncode($/;"	f	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false )
dev::solidity::CompilerUtils::popAndJump	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::popAndJump(unsigned _toHeight, eth::AssemblyItem const& _jumpTo)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _toHeight, eth::AssemblyItem const& _jumpTo)
dev::solidity::CompilerUtils::popAndJump	libsolidity/codegen/CompilerUtils.h	/^	void popAndJump(unsigned _toHeight, eth::AssemblyItem const& _jumpTo);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _toHeight, eth::AssemblyItem const& _jumpTo)
dev::solidity::CompilerUtils::popStackElement	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::popStackElement(Type const& _type)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type)
dev::solidity::CompilerUtils::popStackElement	libsolidity/codegen/CompilerUtils.h	/^	void popStackElement(Type const& _type);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _type)
dev::solidity::CompilerUtils::popStackSlots	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::popStackSlots(size_t _amount)$/;"	f	class:dev::solidity::CompilerUtils	signature:(size_t _amount)
dev::solidity::CompilerUtils::popStackSlots	libsolidity/codegen/CompilerUtils.h	/^	void popStackSlots(size_t _amount);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(size_t _amount)
dev::solidity::CompilerUtils::prepareMemoryStore	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::prepareMemoryStore(Type const& _type, bool _padToWords)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type, bool _padToWords)
dev::solidity::CompilerUtils::prepareMemoryStore	libsolidity/codegen/CompilerUtils.h	/^	unsigned prepareMemoryStore(Type const& _type, bool _padToWords);$/;"	p	class:dev::solidity::CompilerUtils	access:private	signature:(Type const& _type, bool _padToWords)
dev::solidity::CompilerUtils::pushCombinedFunctionEntryLabel	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::pushCombinedFunctionEntryLabel(Declaration const& _function, bool _runtimeOnly)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Declaration const& _function, bool _runtimeOnly)
dev::solidity::CompilerUtils::pushCombinedFunctionEntryLabel	libsolidity/codegen/CompilerUtils.h	/^	void pushCombinedFunctionEntryLabel(Declaration const& _function, bool _runtimeOnly = true);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Declaration const& _function, bool _runtimeOnly = true)
dev::solidity::CompilerUtils::pushZeroPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::pushZeroPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::pushZeroPointer	libsolidity/codegen/CompilerUtils.h	/^	void pushZeroPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::pushZeroValue	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::pushZeroValue(Type const& _type)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type)
dev::solidity::CompilerUtils::pushZeroValue	libsolidity/codegen/CompilerUtils.h	/^	void pushZeroValue(Type const& _type);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _type)
dev::solidity::CompilerUtils::revertWithStringData	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::revertWithStringData(Type const& _argumentType)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _argumentType)
dev::solidity::CompilerUtils::revertWithStringData	libsolidity/codegen/CompilerUtils.h	/^	void revertWithStringData(Type const& _argumentType);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _argumentType)
dev::solidity::CompilerUtils::rightShiftNumberOnStack	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::rightShiftNumberOnStack(unsigned _bits)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _bits)
dev::solidity::CompilerUtils::rightShiftNumberOnStack	libsolidity/codegen/CompilerUtils.h	/^	void rightShiftNumberOnStack(unsigned _bits);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _bits)
dev::solidity::CompilerUtils::rotateStackDown	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::rotateStackDown(unsigned _items)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _items)
dev::solidity::CompilerUtils::rotateStackDown	libsolidity/codegen/CompilerUtils.h	/^	void rotateStackDown(unsigned _items);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _items)
dev::solidity::CompilerUtils::rotateStackUp	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::rotateStackUp(unsigned _items)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _items)
dev::solidity::CompilerUtils::rotateStackUp	libsolidity/codegen/CompilerUtils.h	/^	void rotateStackUp(unsigned _items);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _items)
dev::solidity::CompilerUtils::sizeOnStack	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::sizeOnStack(vector<shared_ptr<Type const>> const& _variableTypes)$/;"	f	class:dev::solidity::CompilerUtils	signature:(vector<shared_ptr<Type const>> const& _variableTypes)
dev::solidity::CompilerUtils::sizeOnStack	libsolidity/codegen/CompilerUtils.h	/^	static unsigned sizeOnStack(std::vector<T> const& _variables);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(std::vector<T> const& _variables)
dev::solidity::CompilerUtils::sizeOnStack	libsolidity/codegen/CompilerUtils.h	/^	static unsigned sizeOnStack(std::vector<std::shared_ptr<Type const>> const& _variableTypes);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(std::vector<std::shared_ptr<Type const>> const& _variableTypes)
dev::solidity::CompilerUtils::sizeOnStack	libsolidity/codegen/CompilerUtils.h	/^unsigned CompilerUtils::sizeOnStack(std::vector<T> const& _variables)$/;"	f	class:dev::solidity::CompilerUtils	signature:(std::vector<T> const& _variables)
dev::solidity::CompilerUtils::splitExternalFunctionType	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::splitExternalFunctionType(bool _leftAligned)$/;"	f	class:dev::solidity::CompilerUtils	signature:(bool _leftAligned)
dev::solidity::CompilerUtils::splitExternalFunctionType	libsolidity/codegen/CompilerUtils.h	/^	void splitExternalFunctionType(bool _rightAligned);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(bool _rightAligned)
dev::solidity::CompilerUtils::storeFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::storeFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void storeFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::storeInMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeInMemory(unsigned _offset)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _offset)
dev::solidity::CompilerUtils::storeInMemory	libsolidity/codegen/CompilerUtils.h	/^	void storeInMemory(unsigned _offset);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _offset)
dev::solidity::CompilerUtils::storeInMemoryDynamic	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeInMemoryDynamic(Type const& _type, bool _padToWordBoundaries)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type, bool _padToWordBoundaries)
dev::solidity::CompilerUtils::storeInMemoryDynamic	libsolidity/codegen/CompilerUtils.h	/^	void storeInMemoryDynamic(Type const& _type, bool _padToWords = true);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _type, bool _padToWords = true)
dev::solidity::CompilerUtils::storeStringData	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeStringData(bytesConstRef _data)$/;"	f	class:dev::solidity::CompilerUtils	signature:(bytesConstRef _data)
dev::solidity::CompilerUtils::storeStringData	libsolidity/codegen/CompilerUtils.h	/^	void storeStringData(bytesConstRef _data);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(bytesConstRef _data)
dev::solidity::CompilerUtils::toSizeAfterFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::toSizeAfterFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
dev::solidity::CompilerUtils::toSizeAfterFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void toSizeAfterFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
dev::solidity::CompilerUtils::zeroInitialiseMemoryArray	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::zeroInitialiseMemoryArray(ArrayType const& _type)$/;"	f	class:dev::solidity::CompilerUtils	signature:(ArrayType const& _type)
dev::solidity::CompilerUtils::zeroInitialiseMemoryArray	libsolidity/codegen/CompilerUtils.h	/^	void zeroInitialiseMemoryArray(ArrayType const& _type);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(ArrayType const& _type)
dev::solidity::CompilerUtils::zeroPointer	libsolidity/codegen/CompilerUtils.cpp	/^size_t const CompilerUtils::zeroPointer = CompilerUtils::freeMemoryPointer + 32;$/;"	m	class:dev::solidity::CompilerUtils	file:
dev::solidity::CompilerUtils::zeroPointer	libsolidity/codegen/CompilerUtils.h	/^	static size_t const zeroPointer;$/;"	m	class:dev::solidity::CompilerUtils	access:public
dev::solidity::Conditional	libsolidity/ast/AST.h	/^class Conditional: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::Conditional::Conditional	libsolidity/ast/AST.h	/^	Conditional($/;"	f	class:dev::solidity::Conditional	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _condition, ASTPointer<Expression> const& _trueExpression, ASTPointer<Expression> const& _falseExpression )
dev::solidity::Conditional::accept	libsolidity/ast/AST_accept.h	/^void Conditional::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Conditional	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Conditional::accept	libsolidity/ast/AST_accept.h	/^void Conditional::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Conditional	signature:(ASTVisitor& _visitor)
dev::solidity::Conditional::condition	libsolidity/ast/AST.h	/^	Expression const& condition() const { return *m_condition; }$/;"	f	class:dev::solidity::Conditional	access:public	signature:() const
dev::solidity::Conditional::falseExpression	libsolidity/ast/AST.h	/^	Expression const& falseExpression() const { return *m_falseExpression; }$/;"	f	class:dev::solidity::Conditional	access:public	signature:() const
dev::solidity::Conditional::m_condition	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condition;$/;"	m	class:dev::solidity::Conditional	access:private
dev::solidity::Conditional::m_falseExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_falseExpression;$/;"	m	class:dev::solidity::Conditional	access:private
dev::solidity::Conditional::m_trueExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_trueExpression;$/;"	m	class:dev::solidity::Conditional	access:private
dev::solidity::Conditional::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Conditional	access:public
dev::solidity::Conditional::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Conditional	access:public
dev::solidity::Conditional::trueExpression	libsolidity/ast/AST.h	/^	Expression const& trueExpression() const { return *m_trueExpression; }$/;"	f	class:dev::solidity::Conditional	access:public	signature:() const
dev::solidity::ConstantEvaluator	libsolidity/analysis/ConstantEvaluator.h	/^class ConstantEvaluator: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ConstantEvaluator::ConstantEvaluator	libsolidity/analysis/ConstantEvaluator.h	/^	ConstantEvaluator($/;"	f	class:dev::solidity::ConstantEvaluator	access:public	signature:( langutil::ErrorReporter& _errorReporter, size_t _newDepth = 0, std::shared_ptr<std::map<ASTNode const*, TypePointer>> _types = std::make_shared<std::map<ASTNode const*, TypePointer>>() )
dev::solidity::ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(BinaryOperation const& _operation);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(BinaryOperation const& _operation)
dev::solidity::ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(Identifier const& _identifier);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(Identifier const& _identifier)
dev::solidity::ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(Literal const& _literal);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(Literal const& _literal)
dev::solidity::ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(TupleExpression const& _tuple);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(TupleExpression const& _tuple)
dev::solidity::ConstantEvaluator::endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(UnaryOperation const& _operation);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(UnaryOperation const& _operation)
dev::solidity::ConstantEvaluator::evaluate	libsolidity/analysis/ConstantEvaluator.h	/^	TypePointer evaluate(Expression const& _expr);$/;"	p	class:dev::solidity::ConstantEvaluator	access:public	signature:(Expression const& _expr)
dev::solidity::ConstantEvaluator::m_depth	libsolidity/analysis/ConstantEvaluator.h	/^	size_t m_depth = 0;$/;"	m	class:dev::solidity::ConstantEvaluator	access:private
dev::solidity::ConstantEvaluator::m_errorReporter	libsolidity/analysis/ConstantEvaluator.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ConstantEvaluator	access:private
dev::solidity::ConstantEvaluator::m_types	libsolidity/analysis/ConstantEvaluator.h	/^	std::shared_ptr<std::map<ASTNode const*, TypePointer>> m_types;$/;"	m	class:dev::solidity::ConstantEvaluator	access:private
dev::solidity::ConstantEvaluator::setType	libsolidity/analysis/ConstantEvaluator.h	/^	void setType(ASTNode const& _node, TypePointer const& _type);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(ASTNode const& _node, TypePointer const& _type)
dev::solidity::ConstantEvaluator::type	libsolidity/analysis/ConstantEvaluator.h	/^	TypePointer type(ASTNode const& _node);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(ASTNode const& _node)
dev::solidity::ConstructorUsesAssembly	libsolidity/analysis/StaticAnalyzer.cpp	/^class dev::solidity::ConstructorUsesAssembly$/;"	c	class:dev::solidity	file:
dev::solidity::ConstructorUsesAssembly::Checker	libsolidity/analysis/StaticAnalyzer.cpp	/^	class Checker: public ASTConstVisitor$/;"	c	class:dev::solidity::ConstructorUsesAssembly	file:	inherits:ASTConstVisitor	access:private
dev::solidity::ConstructorUsesAssembly::Checker::Checker	libsolidity/analysis/StaticAnalyzer.cpp	/^		Checker(FunctionDefinition const& _f) { _f.accept(*this); }$/;"	f	class:dev::solidity::ConstructorUsesAssembly::Checker	access:public	signature:(FunctionDefinition const& _f)
dev::solidity::ConstructorUsesAssembly::Checker::assemblySeen	libsolidity/analysis/StaticAnalyzer.cpp	/^		bool assemblySeen = false;$/;"	m	class:dev::solidity::ConstructorUsesAssembly::Checker	file:	access:public
dev::solidity::ConstructorUsesAssembly::check	libsolidity/analysis/StaticAnalyzer.cpp	/^	bool check(ContractDefinition const& _contract)$/;"	f	class:dev::solidity::ConstructorUsesAssembly	access:public	signature:(ContractDefinition const& _contract)
dev::solidity::ConstructorUsesAssembly::checkInternal	libsolidity/analysis/StaticAnalyzer.cpp	/^	bool checkInternal(ContractDefinition const& _contract)$/;"	f	class:dev::solidity::ConstructorUsesAssembly	file:	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ConstructorUsesAssembly::m_usesAssembly	libsolidity/analysis/StaticAnalyzer.cpp	/^	map<ContractDefinition const*, bool> m_usesAssembly;$/;"	m	class:dev::solidity::ConstructorUsesAssembly	file:	access:private
dev::solidity::Continue	libsolidity/ast/AST.h	/^class Continue: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::Continue::Continue	libsolidity/ast/AST.h	/^	explicit Continue(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):$/;"	f	class:dev::solidity::Continue	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _docString)
dev::solidity::Continue::accept	libsolidity/ast/AST_accept.h	/^void Continue::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Continue	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Continue::accept	libsolidity/ast/AST_accept.h	/^void Continue::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Continue	signature:(ASTVisitor& _visitor)
dev::solidity::Continue::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Continue	access:public
dev::solidity::Continue::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Continue	access:public
dev::solidity::ContractCompiler	libsolidity/codegen/ContractCompiler.h	/^class ContractCompiler: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ContractCompiler::ContractCompiler	libsolidity/codegen/ContractCompiler.h	/^	explicit ContractCompiler($/;"	f	class:dev::solidity::ContractCompiler	access:public	signature:( ContractCompiler* _runtimeCompiler, CompilerContext& _context, OptimiserSettings _optimiserSettings )
dev::solidity::ContractCompiler::appendBaseConstructor	libsolidity/codegen/ContractCompiler.h	/^	void appendBaseConstructor(FunctionDefinition const& _constructor);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(FunctionDefinition const& _constructor)
dev::solidity::ContractCompiler::appendCallValueCheck	libsolidity/codegen/ContractCompiler.h	/^	void appendCallValueCheck();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
dev::solidity::ContractCompiler::appendConstructor	libsolidity/codegen/ContractCompiler.h	/^	void appendConstructor(FunctionDefinition const& _constructor);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(FunctionDefinition const& _constructor)
dev::solidity::ContractCompiler::appendDelegatecallCheck	libsolidity/codegen/ContractCompiler.h	/^	void appendDelegatecallCheck();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
dev::solidity::ContractCompiler::appendFunctionSelector	libsolidity/codegen/ContractCompiler.h	/^	void appendFunctionSelector(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractCompiler::appendInitAndConstructorCode	libsolidity/codegen/ContractCompiler.h	/^	void appendInitAndConstructorCode(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractCompiler::appendInternalSelector	libsolidity/codegen/ContractCompiler.h	/^	void appendInternalSelector($/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:( std::map<FixedHash<4>, eth::AssemblyItem const> const& _entryPoints, std::vector<FixedHash<4>> const& _ids, eth::AssemblyItem const& _notFoundTag, size_t _runs )
dev::solidity::ContractCompiler::appendMissingFunctions	libsolidity/codegen/ContractCompiler.h	/^	void appendMissingFunctions();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
dev::solidity::ContractCompiler::appendModifierOrFunctionCode	libsolidity/codegen/ContractCompiler.h	/^	void appendModifierOrFunctionCode();$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:()
dev::solidity::ContractCompiler::appendReturnValuePacker	libsolidity/codegen/ContractCompiler.h	/^	void appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(TypePointers const& _typeParameters, bool _isLibrary)
dev::solidity::ContractCompiler::appendStackVariableInitialisation	libsolidity/codegen/ContractCompiler.h	/^	void appendStackVariableInitialisation(VariableDeclaration const& _variable);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(VariableDeclaration const& _variable)
dev::solidity::ContractCompiler::compileConstructor	libsolidity/codegen/ContractCompiler.h	/^	size_t compileConstructor($/;"	p	class:dev::solidity::ContractCompiler	access:public	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers )
dev::solidity::ContractCompiler::compileContract	libsolidity/codegen/ContractCompiler.h	/^	void compileContract($/;"	p	class:dev::solidity::ContractCompiler	access:public	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers )
dev::solidity::ContractCompiler::compileExpression	libsolidity/codegen/ContractCompiler.h	/^	void compileExpression(Expression const& _expression, TypePointer const& _targetType = TypePointer());$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(Expression const& _expression, TypePointer const& _targetType = TypePointer())
dev::solidity::ContractCompiler::deployLibrary	libsolidity/codegen/ContractCompiler.h	/^	size_t deployLibrary(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractCompiler::initializeContext	libsolidity/codegen/ContractCompiler.h	/^	void initializeContext($/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers )
dev::solidity::ContractCompiler::initializeStateVariables	libsolidity/codegen/ContractCompiler.h	/^	void initializeStateVariables(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractCompiler::m_breakTags	libsolidity/codegen/ContractCompiler.h	/^	std::vector<std::pair<eth::AssemblyItem, unsigned>> m_breakTags;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_context	libsolidity/codegen/ContractCompiler.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_continueTags	libsolidity/codegen/ContractCompiler.h	/^	std::vector<std::pair<eth::AssemblyItem, unsigned>> m_continueTags;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_currentFunction	libsolidity/codegen/ContractCompiler.h	/^	FunctionDefinition const* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_modifierDepth	libsolidity/codegen/ContractCompiler.h	/^	unsigned m_modifierDepth = 0;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_optimiserSettings	libsolidity/codegen/ContractCompiler.h	/^	OptimiserSettings const m_optimiserSettings;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_returnTags	libsolidity/codegen/ContractCompiler.h	/^	std::vector<std::pair<eth::AssemblyItem, unsigned>> m_returnTags;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_runtimeCompiler	libsolidity/codegen/ContractCompiler.h	/^	ContractCompiler* m_runtimeCompiler = nullptr;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::m_scopeStackHeight	libsolidity/codegen/ContractCompiler.h	/^	std::map<unsigned, std::map<ASTNode const*, unsigned>> m_scopeStackHeight;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Block const& _block) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Break const& _breakStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Continue const& _continueStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(EmitStatement const& _emit) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(ExpressionStatement const& _expressionStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(PlaceholderStatement const&) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Throw const& _throw) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(VariableDeclaration const& _variableDeclaration) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::override	libsolidity/codegen/ContractCompiler.h	/^	void endVisit(Block const& _block) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
dev::solidity::ContractCompiler::packIntoContractCreator	libsolidity/codegen/ContractCompiler.h	/^	size_t packIntoContractCreator(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractCompiler::popScopedVariables	libsolidity/codegen/ContractCompiler.h	/^	void popScopedVariables(ASTNode const* _node);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ASTNode const* _node)
dev::solidity::ContractCompiler::registerStateVariables	libsolidity/codegen/ContractCompiler.h	/^	void registerStateVariables(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractCompiler::std::m_baseArguments	libsolidity/codegen/ContractCompiler.h	/^	std::map<FunctionDefinition const*, ASTNode const*> const* m_baseArguments;$/;"	m	class:dev::solidity::ContractCompiler::std	access:private
dev::solidity::ContractCompiler::storeStackHeight	libsolidity/codegen/ContractCompiler.h	/^	void storeStackHeight(ASTNode const* _node);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ASTNode const* _node)
dev::solidity::ContractDefinition	libsolidity/ast/AST.h	/^class ContractDefinition: public Declaration, public Documented$/;"	c	namespace:dev::solidity	inherits:Declaration,Documented
dev::solidity::ContractDefinition::ContractDefinition	libsolidity/ast/AST.h	/^	ContractDefinition($/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, ASTPointer<ASTString> const& _documentation, std::vector<ASTPointer<InheritanceSpecifier>> const& _baseContracts, std::vector<ASTPointer<ASTNode>> const& _subNodes, ContractKind _contractKind = ContractKind::Contract )
dev::solidity::ContractDefinition::ContractKind	libsolidity/ast/AST.h	/^	enum class ContractKind { Interface, Contract, Library };$/;"	c	class:dev::solidity::ContractDefinition	access:public
dev::solidity::ContractDefinition::ContractKind::Contract	libsolidity/ast/AST.h	/^	enum class ContractKind { Interface, Contract, Library };$/;"	m	class:dev::solidity::ContractDefinition::ContractKind	access:private
dev::solidity::ContractDefinition::ContractKind::Interface	libsolidity/ast/AST.h	/^	enum class ContractKind { Interface, Contract, Library };$/;"	m	class:dev::solidity::ContractDefinition::ContractKind	access:private
dev::solidity::ContractDefinition::accept	libsolidity/ast/AST_accept.h	/^void ContractDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ContractDefinition	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ContractDefinition::accept	libsolidity/ast/AST_accept.h	/^void ContractDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ContractDefinition	signature:(ASTVisitor& _visitor)
dev::solidity::ContractDefinition::canBeDeployed	libsolidity/ast/AST.h	/^	bool canBeDeployed() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::constructor	libsolidity/ast/AST.h	/^	FunctionDefinition const* constructor() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::constructorIsPublic	libsolidity/ast/AST.h	/^	bool constructorIsPublic() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::contractKind	libsolidity/ast/AST.h	/^	ContractKind contractKind() const { return m_contractKind; }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::definedEnums	libsolidity/ast/AST.h	/^	std::vector<EnumDefinition const*> definedEnums() const { return filteredNodes<EnumDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::definedFunctions	libsolidity/ast/AST.h	/^	std::vector<FunctionDefinition const*> definedFunctions() const { return filteredNodes<FunctionDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::definedStructs	libsolidity/ast/AST.h	/^	std::vector<StructDefinition const*> definedStructs() const { return filteredNodes<StructDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::events	libsolidity/ast/AST.h	/^	std::vector<EventDefinition const*> events() const { return filteredNodes<EventDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::fallbackFunction	libsolidity/ast/AST.h	/^	FunctionDefinition const* fallbackFunction() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::fullyQualifiedName	libsolidity/ast/AST.h	/^	std::string fullyQualifiedName() const { return sourceUnitName() + ":" + name(); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::functionModifiers	libsolidity/ast/AST.h	/^	std::vector<ModifierDefinition const*> functionModifiers() const { return filteredNodes<ModifierDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::interfaceFunctions	libsolidity/ast/AST.h	/^	std::map<FixedHash<4>, FunctionTypePointer> interfaceFunctions() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::isInterface	libsolidity/ast/AST.h	/^	bool isInterface() const { return m_contractKind == ContractKind::Interface; }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::isLibrary	libsolidity/ast/AST.h	/^	bool isLibrary() const { return m_contractKind == ContractKind::Library; }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::m_baseContracts	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<InheritanceSpecifier>> m_baseContracts;$/;"	m	class:dev::solidity::ContractDefinition	access:private
dev::solidity::ContractDefinition::m_contractKind	libsolidity/ast/AST.h	/^	ContractKind m_contractKind;$/;"	m	class:dev::solidity::ContractDefinition	access:private
dev::solidity::ContractDefinition::m_inheritableMembers	libsolidity/ast/AST.h	/^	mutable std::unique_ptr<std::vector<Declaration const*>> m_inheritableMembers;$/;"	m	class:dev::solidity::ContractDefinition	access:private
dev::solidity::ContractDefinition::m_interfaceEvents	libsolidity/ast/AST.h	/^	mutable std::unique_ptr<std::vector<EventDefinition const*>> m_interfaceEvents;$/;"	m	class:dev::solidity::ContractDefinition	access:private
dev::solidity::ContractDefinition::m_interfaceFunctionList	libsolidity/ast/AST.h	/^	mutable std::unique_ptr<std::vector<std::pair<FixedHash<4>, FunctionTypePointer>>> m_interfaceFunctionList;$/;"	m	class:dev::solidity::ContractDefinition	access:private
dev::solidity::ContractDefinition::m_subNodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> m_subNodes;$/;"	m	class:dev::solidity::ContractDefinition	access:private
dev::solidity::ContractDefinition::override	libsolidity/ast/AST.h	/^	ContractDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
dev::solidity::ContractDefinition::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
dev::solidity::ContractDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
dev::solidity::ContractDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
dev::solidity::ContractDefinition::stateVariables	libsolidity/ast/AST.h	/^	std::vector<VariableDeclaration const*> stateVariables() const { return filteredNodes<VariableDeclaration>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinition::std::baseContracts	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<InheritanceSpecifier>> const& baseContracts() const { return m_baseContracts; }$/;"	f	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
dev::solidity::ContractDefinition::std::inheritableMembers	libsolidity/ast/AST.h	/^	std::vector<Declaration const*> const& inheritableMembers() const;$/;"	p	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
dev::solidity::ContractDefinition::std::interfaceEvents	libsolidity/ast/AST.h	/^	std::vector<EventDefinition const*> const& interfaceEvents() const;$/;"	p	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
dev::solidity::ContractDefinition::std::interfaceFunctionList	libsolidity/ast/AST.h	/^	std::vector<std::pair<FixedHash<4>, FunctionTypePointer>> const& interfaceFunctionList() const;$/;"	p	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
dev::solidity::ContractDefinition::std::subNodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> const& subNodes() const { return m_subNodes; }$/;"	f	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
dev::solidity::ContractDefinition::usingForDirectives	libsolidity/ast/AST.h	/^	std::vector<UsingForDirective const*> usingForDirectives() const { return filteredNodes<UsingForDirective>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
dev::solidity::ContractDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ContractDefinitionAnnotation: TypeDeclarationAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:TypeDeclarationAnnotation,DocumentedAnnotation
dev::solidity::ContractDefinitionAnnotation::baseConstructorArguments	libsolidity/ast/ASTAnnotations.h	/^	std::map<FunctionDefinition const*, ASTNode const*> baseConstructorArguments;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
dev::solidity::ContractDefinitionAnnotation::contractDependencies	libsolidity/ast/ASTAnnotations.h	/^	std::set<ContractDefinition const*> contractDependencies;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
dev::solidity::ContractDefinitionAnnotation::linearizedBaseContracts	libsolidity/ast/ASTAnnotations.h	/^	std::vector<ContractDefinition const*> linearizedBaseContracts;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
dev::solidity::ContractDefinitionAnnotation::unimplementedFunctions	libsolidity/ast/ASTAnnotations.h	/^	std::vector<FunctionDefinition const*> unimplementedFunctions;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
dev::solidity::ContractLevelChecker	libsolidity/analysis/ContractLevelChecker.h	/^class ContractLevelChecker$/;"	c	namespace:dev::solidity
dev::solidity::ContractLevelChecker::ContractLevelChecker	libsolidity/analysis/ContractLevelChecker.h	/^	explicit ContractLevelChecker(langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::ContractLevelChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::ContractLevelChecker::annotateBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.h	/^	void annotateBaseConstructorArguments($/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:( ContractDefinition const& _currentContract, FunctionDefinition const* _baseConstructor, ASTNode const* _argumentNode )
dev::solidity::ContractLevelChecker::check	libsolidity/analysis/ContractLevelChecker.h	/^	bool check(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:public	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkAbstractFunctions	libsolidity/analysis/ContractLevelChecker.h	/^	void checkAbstractFunctions(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkBaseABICompatibility	libsolidity/analysis/ContractLevelChecker.h	/^	void checkBaseABICompatibility(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkBaseConstructorArguments	libsolidity/analysis/ContractLevelChecker.h	/^	void checkBaseConstructorArguments(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkConstructor	libsolidity/analysis/ContractLevelChecker.h	/^	void checkConstructor(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkDuplicateEvents	libsolidity/analysis/ContractLevelChecker.h	/^	void checkDuplicateEvents(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkDuplicateFunctions	libsolidity/analysis/ContractLevelChecker.h	/^	void checkDuplicateFunctions(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkExternalTypeClashes	libsolidity/analysis/ContractLevelChecker.h	/^	void checkExternalTypeClashes(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkFallbackFunction	libsolidity/analysis/ContractLevelChecker.h	/^	void checkFallbackFunction(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkFunctionOverride	libsolidity/analysis/ContractLevelChecker.h	/^	void checkFunctionOverride(FunctionDefinition const& function, FunctionDefinition const& super);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(FunctionDefinition const& function, FunctionDefinition const& super)
dev::solidity::ContractLevelChecker::checkHashCollisions	libsolidity/analysis/ContractLevelChecker.h	/^	void checkHashCollisions(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkIllegalOverrides	libsolidity/analysis/ContractLevelChecker.h	/^	void checkIllegalOverrides(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::checkLibraryRequirements	libsolidity/analysis/ContractLevelChecker.h	/^	void checkLibraryRequirements(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(ContractDefinition const& _contract)
dev::solidity::ContractLevelChecker::findDuplicateDefinitions	libsolidity/analysis/ContractLevelChecker.h	/^	void findDuplicateDefinitions(std::map<std::string, std::vector<T>> const& _definitions, std::string _message);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(std::map<std::string, std::vector<T>> const& _definitions, std::string _message)
dev::solidity::ContractLevelChecker::m_errorReporter	libsolidity/analysis/ContractLevelChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ContractLevelChecker	access:private
dev::solidity::ContractLevelChecker::overrideError	libsolidity/analysis/ContractLevelChecker.h	/^	void overrideError(FunctionDefinition const& function, FunctionDefinition const& super, std::string message);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(FunctionDefinition const& function, FunctionDefinition const& super, std::string message)
dev::solidity::ContractType	libsolidity/ast/Types.h	/^class ContractType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::ContractType::ContractType	libsolidity/ast/Types.h	/^	explicit ContractType(ContractDefinition const& _contract, bool _super = false):$/;"	f	class:dev::solidity::ContractType	access:public	signature:(ContractDefinition const& _contract, bool _super = false)
dev::solidity::ContractType::contractDefinition	libsolidity/ast/Types.h	/^	ContractDefinition const& contractDefinition() const { return m_contract; }$/;"	f	class:dev::solidity::ContractType	access:public	signature:() const
dev::solidity::ContractType::isPayable	libsolidity/ast/Types.h	/^	bool isPayable() const;$/;"	p	class:dev::solidity::ContractType	access:public	signature:() const
dev::solidity::ContractType::isSuper	libsolidity/ast/Types.h	/^	bool isSuper() const { return m_super; }$/;"	f	class:dev::solidity::ContractType	access:public	signature:() const
dev::solidity::ContractType::m_constructorType	libsolidity/ast/Types.h	/^	mutable FunctionTypePointer m_constructorType;$/;"	m	class:dev::solidity::ContractType	access:private
dev::solidity::ContractType::m_contract	libsolidity/ast/Types.h	/^	ContractDefinition const& m_contract;$/;"	m	class:dev::solidity::ContractType	access:private
dev::solidity::ContractType::m_super	libsolidity/ast/Types.h	/^	bool m_super = false;$/;"	m	class:dev::solidity::ContractType	access:private
dev::solidity::ContractType::newExpressionType	libsolidity/ast/Types.h	/^	FunctionTypePointer const& newExpressionType() const;$/;"	p	class:dev::solidity::ContractType	access:public	signature:() const
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ContractType	access:public
dev::solidity::ContractType::stateVariables	libsolidity/ast/Types.h	/^	std::vector<std::tuple<VariableDeclaration const*, u256, unsigned>> stateVariables() const;$/;"	p	class:dev::solidity::ContractType	access:public	signature:() const
dev::solidity::ControlFlowAnalyzer	libsolidity/analysis/ControlFlowAnalyzer.h	/^class ControlFlowAnalyzer: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ControlFlowAnalyzer::ControlFlowAnalyzer	libsolidity/analysis/ControlFlowAnalyzer.h	/^	explicit ControlFlowAnalyzer(CFG const& _cfg, langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::ControlFlowAnalyzer	access:public	signature:(CFG const& _cfg, langutil::ErrorReporter& _errorReporter)
dev::solidity::ControlFlowAnalyzer::analyze	libsolidity/analysis/ControlFlowAnalyzer.h	/^	bool analyze(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::ControlFlowAnalyzer	access:public	signature:(ASTNode const& _astRoot)
dev::solidity::ControlFlowAnalyzer::checkUninitializedAccess	libsolidity/analysis/ControlFlowAnalyzer.h	/^	void checkUninitializedAccess(CFGNode const* _entry, CFGNode const* _exit) const;$/;"	p	class:dev::solidity::ControlFlowAnalyzer	access:private	signature:(CFGNode const* _entry, CFGNode const* _exit) const
dev::solidity::ControlFlowAnalyzer::checkUnreachable	libsolidity/analysis/ControlFlowAnalyzer.h	/^	void checkUnreachable(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const;$/;"	p	class:dev::solidity::ControlFlowAnalyzer	access:private	signature:(CFGNode const* _entry, CFGNode const* _exit, CFGNode const* _revert) const
dev::solidity::ControlFlowAnalyzer::m_cfg	libsolidity/analysis/ControlFlowAnalyzer.h	/^	CFG const& m_cfg;$/;"	m	class:dev::solidity::ControlFlowAnalyzer	access:private
dev::solidity::ControlFlowAnalyzer::m_errorReporter	libsolidity/analysis/ControlFlowAnalyzer.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ControlFlowAnalyzer	access:private
dev::solidity::ControlFlowAnalyzer::override	libsolidity/analysis/ControlFlowAnalyzer.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::ControlFlowAnalyzer	access:public
dev::solidity::ControlFlowBuilder	libsolidity/analysis/ControlFlowBuilder.h	/^class ControlFlowBuilder: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ControlFlowBuilder::BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.h	/^	class BreakContinueScope$/;"	c	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::BreakContinueScope::BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.h	/^		BreakContinueScope(ControlFlowBuilder& _parser, CFGNode* _breakJump, CFGNode* _continueJump);$/;"	p	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:public	signature:(ControlFlowBuilder& _parser, CFGNode* _breakJump, CFGNode* _continueJump)
dev::solidity::ControlFlowBuilder::BreakContinueScope::m_origBreakJump	libsolidity/analysis/ControlFlowBuilder.h	/^		CFGNode* m_origBreakJump;$/;"	m	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:private
dev::solidity::ControlFlowBuilder::BreakContinueScope::m_origContinueJump	libsolidity/analysis/ControlFlowBuilder.h	/^		CFGNode* m_origContinueJump;$/;"	m	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:private
dev::solidity::ControlFlowBuilder::BreakContinueScope::m_parser	libsolidity/analysis/ControlFlowBuilder.h	/^		ControlFlowBuilder& m_parser;$/;"	m	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:private
dev::solidity::ControlFlowBuilder::BreakContinueScope::~BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.h	/^		~BreakContinueScope();$/;"	p	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:public	signature:()
dev::solidity::ControlFlowBuilder::ControlFlowBuilder	libsolidity/analysis/ControlFlowBuilder.h	/^	explicit ControlFlowBuilder(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFG::NodeContainer& _nodeContainer, FunctionFlow const& _functionFlow)
dev::solidity::ControlFlowBuilder::appendControlFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	void appendControlFlow(ASTNode const& _node);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(ASTNode const& _node)
dev::solidity::ControlFlowBuilder::connect	libsolidity/analysis/ControlFlowBuilder.h	/^	static void connect(CFGNode* _from, CFGNode* _to);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFGNode* _from, CFGNode* _to)
dev::solidity::ControlFlowBuilder::createFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* createFlow(CFGNode* _entry, ASTNode const& _node);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFGNode* _entry, ASTNode const& _node)
dev::solidity::ControlFlowBuilder::createFunctionFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	static std::unique_ptr<FunctionFlow> createFunctionFlow($/;"	p	class:dev::solidity::ControlFlowBuilder	access:public	signature:( CFG::NodeContainer& _nodeContainer, FunctionDefinition const& _function )
dev::solidity::ControlFlowBuilder::createLabelHere	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* createLabelHere();$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:()
dev::solidity::ControlFlowBuilder::m_breakJump	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_breakJump = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_continueJump	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_continueJump = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_currentNode	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_currentNode = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_nodeContainer	libsolidity/analysis/ControlFlowBuilder.h	/^	CFG::NodeContainer& m_nodeContainer;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_placeholderEntry	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_placeholderEntry = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_placeholderExit	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_placeholderExit = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_returnNode	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_returnNode = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::m_revertNode	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_revertNode = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::mergeFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	void mergeFlow(std::array<CFGNode*, n> const& _nodes, CFGNode* _endNode = nullptr)$/;"	f	class:dev::solidity::ControlFlowBuilder	access:private	signature:(std::array<CFGNode*, n> const& _nodes, CFGNode* _endNode = nullptr)
dev::solidity::ControlFlowBuilder::newLabel	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* newLabel();$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:()
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(BinaryOperation const& _operation) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Break const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Conditional const& _conditional) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Continue const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(FunctionDefinition const& _functionDefinition) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(FunctionTypeName const& _functionTypeName) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(ModifierInvocation const& _modifierInvocation) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(PlaceholderStatement const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Throw const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(VariableDeclaration const& _variableDeclaration) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
dev::solidity::ControlFlowBuilder::override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visitNode(ASTNode const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:protected
dev::solidity::ControlFlowBuilder::placeAndConnectLabel	libsolidity/analysis/ControlFlowBuilder.h	/^	void placeAndConnectLabel(CFGNode *_node);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFGNode *_node)
dev::solidity::ControlFlowBuilder::splitFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	std::array<CFGNode*, n> splitFlow()$/;"	f	class:dev::solidity::ControlFlowBuilder	access:private	signature:()
dev::solidity::ControlFlowPrinter	libsolidity/analysis/ControlFlowPrinter.h	/^class ControlFlowPrinter: private CFGConstVisitor$/;"	c	namespace:dev::solidity	inherits:CFGConstVisitor
dev::solidity::ControlFlowPrinter::ControlFlowPrinter	libsolidity/analysis/ControlFlowPrinter.h	/^	explicit ControlFlowPrinter(CFG const& _cfg):$/;"	f	class:dev::solidity::ControlFlowPrinter	access:public	signature:(CFG const& _cfg)
dev::solidity::ControlFlowPrinter::m_cfg	libsolidity/analysis/ControlFlowPrinter.h	/^	CFG const& m_cfg;$/;"	m	class:dev::solidity::ControlFlowPrinter	access:private
dev::solidity::ControlFlowPrinter::m_ostream	libsolidity/analysis/ControlFlowPrinter.h	/^  std::ostream* m_ostream = nullptr;$/;"	m	class:dev::solidity::ControlFlowPrinter	access:private
dev::solidity::ControlFlowPrinter::override	libsolidity/analysis/ControlFlowPrinter.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::ControlFlowPrinter	access:public
dev::solidity::ControlFlowPrinter::print	libsolidity/analysis/ControlFlowPrinter.h	/^	void print(std::ostream& _stream);$/;"	p	class:dev::solidity::ControlFlowPrinter	access:public	signature:(std::ostream& _stream)
dev::solidity::ControlFlowPrinter::printFunctionFlow	libsolidity/analysis/ControlFlowPrinter.h	/^	void printFunctionFlow(CFGNode const* _entry) const;$/;"	p	class:dev::solidity::ControlFlowPrinter	access:private	signature:(CFGNode const* _entry) const
dev::solidity::ControlFlowPrinter::writeLine	libsolidity/analysis/ControlFlowPrinter.h	/^  void writeLine(std::string const& _line) const;$/;"	p	class:dev::solidity::ControlFlowPrinter	access:private	signature:(std::string const& _line) const
dev::solidity::DEV_SIMPLE_EXCEPTION	libevmasm/Instruction.h	/^DEV_SIMPLE_EXCEPTION(InvalidDeposit);$/;"	p	namespace:dev::solidity	signature:(InvalidDeposit)
dev::solidity::DEV_SIMPLE_EXCEPTION	libevmasm/Instruction.h	/^DEV_SIMPLE_EXCEPTION(InvalidOpcode);$/;"	p	namespace:dev::solidity	signature:(InvalidOpcode)
dev::solidity::DataLocation	libsolidity/ast/Types.h	/^enum class DataLocation { Storage, CallData, Memory };$/;"	c	namespace:dev::solidity
dev::solidity::DataLocation::CallData	libsolidity/ast/Types.h	/^enum class DataLocation { Storage, CallData, Memory };$/;"	m	class:dev::solidity::DataLocation	access:private
dev::solidity::DataLocation::Storage	libsolidity/ast/Types.h	/^enum class DataLocation { Storage, CallData, Memory };$/;"	m	class:dev::solidity::DataLocation	access:private
dev::solidity::Declaration	libsolidity/ast/AST.h	/^class Declaration: public ASTNode, public Scopable$/;"	c	namespace:dev::solidity	inherits:ASTNode,Scopable
dev::solidity::Declaration::Declaration	libsolidity/ast/AST.h	/^	Declaration($/;"	f	class:dev::solidity::Declaration	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, Visibility _visibility = Visibility::Default )
dev::solidity::Declaration::Visibility	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	c	class:dev::solidity::Declaration	access:public
dev::solidity::Declaration::Visibility::Default	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
dev::solidity::Declaration::Visibility::Internal	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
dev::solidity::Declaration::Visibility::Private	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
dev::solidity::Declaration::Visibility::Public	libsolidity/ast/AST.h	/^	enum class Visibility { Default, Private, Internal, Public, External };$/;"	m	class:dev::solidity::Declaration::Visibility	access:private
dev::solidity::Declaration::defaultVisibility	libsolidity/ast/AST.h	/^	virtual Visibility defaultVisibility() const { return Visibility::Public; }$/;"	f	class:dev::solidity::Declaration	access:protected	signature:() const
dev::solidity::Declaration::functionType	libsolidity/ast/AST.h	/^	virtual FunctionTypePointer functionType(bool \/*_internal*\/) const { return {}; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:(bool ) const
dev::solidity::Declaration::isLValue	libsolidity/ast/AST.h	/^	virtual bool isLValue() const { return false; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::isPartOfExternalInterface	libsolidity/ast/AST.h	/^	virtual bool isPartOfExternalInterface() const { return false; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::isPublic	libsolidity/ast/AST.h	/^	bool isPublic() const { return visibility() >= Visibility::Public; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::isVisibleAsLibraryMember	libsolidity/ast/AST.h	/^	bool isVisibleAsLibraryMember() const { return visibility() >= Visibility::Internal; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::isVisibleInContract	libsolidity/ast/AST.h	/^	virtual bool isVisibleInContract() const { return visibility() != Visibility::External; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::isVisibleInDerivedContracts	libsolidity/ast/AST.h	/^	bool isVisibleInDerivedContracts() const { return isVisibleInContract() && visibility() >= Visibility::Internal; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::m_name	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_name;$/;"	m	class:dev::solidity::Declaration	access:private
dev::solidity::Declaration::m_visibility	libsolidity/ast/AST.h	/^	Visibility m_visibility;$/;"	m	class:dev::solidity::Declaration	access:private
dev::solidity::Declaration::name	libsolidity/ast/AST.h	/^	ASTString const& name() const { return *m_name; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::noVisibilitySpecified	libsolidity/ast/AST.h	/^	bool noVisibilitySpecified() const { return m_visibility == Visibility::Default; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::type	libsolidity/ast/AST.h	/^	virtual TypePointer type() const = 0;$/;"	p	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::visibility	libsolidity/ast/AST.h	/^	Visibility visibility() const { return m_visibility == Visibility::Default ? defaultVisibility() : m_visibility; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
dev::solidity::Declaration::visibilityToString	libsolidity/ast/AST.h	/^	static std::string visibilityToString(Declaration::Visibility _visibility)$/;"	f	class:dev::solidity::Declaration	access:public	signature:(Declaration::Visibility _visibility)
dev::solidity::DeclarationContainer	libsolidity/analysis/DeclarationContainer.h	/^class DeclarationContainer$/;"	c	namespace:dev::solidity
dev::solidity::DeclarationContainer::DeclarationContainer	libsolidity/analysis/DeclarationContainer.h	/^	explicit DeclarationContainer($/;"	f	class:dev::solidity::DeclarationContainer	access:public	signature:( ASTNode const* _enclosingNode = nullptr, DeclarationContainer const* _enclosingContainer = nullptr )
dev::solidity::DeclarationContainer::activateVariable	libsolidity/analysis/DeclarationContainer.h	/^	void activateVariable(ASTString const& _name);$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name)
dev::solidity::DeclarationContainer::conflictingDeclaration	libsolidity/analysis/DeclarationContainer.h	/^	Declaration const* conflictingDeclaration(Declaration const& _declaration, ASTString const* _name = nullptr) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(Declaration const& _declaration, ASTString const* _name = nullptr) const
dev::solidity::DeclarationContainer::enclosingContainer	libsolidity/analysis/DeclarationContainer.h	/^	DeclarationContainer const* enclosingContainer() const { return m_enclosingContainer; }$/;"	f	class:dev::solidity::DeclarationContainer	access:public	signature:() const
dev::solidity::DeclarationContainer::enclosingNode	libsolidity/analysis/DeclarationContainer.h	/^	ASTNode const* enclosingNode() const { return m_enclosingNode; }$/;"	f	class:dev::solidity::DeclarationContainer	access:public	signature:() const
dev::solidity::DeclarationContainer::isInvisible	libsolidity/analysis/DeclarationContainer.h	/^	bool isInvisible(ASTString const& _name) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name) const
dev::solidity::DeclarationContainer::m_declarations	libsolidity/analysis/DeclarationContainer.h	/^	std::map<ASTString, std::vector<Declaration const*>> m_declarations;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
dev::solidity::DeclarationContainer::m_enclosingContainer	libsolidity/analysis/DeclarationContainer.h	/^	DeclarationContainer const* m_enclosingContainer;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
dev::solidity::DeclarationContainer::m_enclosingNode	libsolidity/analysis/DeclarationContainer.h	/^	ASTNode const* m_enclosingNode;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
dev::solidity::DeclarationContainer::m_invisibleDeclarations	libsolidity/analysis/DeclarationContainer.h	/^	std::map<ASTString, std::vector<Declaration const*>> m_invisibleDeclarations;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
dev::solidity::DeclarationContainer::registerDeclaration	libsolidity/analysis/DeclarationContainer.h	/^	bool registerDeclaration(Declaration const& _declaration, ASTString const* _name = nullptr, bool _invisible = false, bool _update = false);$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(Declaration const& _declaration, ASTString const* _name = nullptr, bool _invisible = false, bool _update = false)
dev::solidity::DeclarationContainer::resolveName	libsolidity/analysis/DeclarationContainer.h	/^	std::vector<Declaration const*> resolveName(ASTString const& _name, bool _recursive = false, bool _alsoInvisible = false) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name, bool _recursive = false, bool _alsoInvisible = false) const
dev::solidity::DeclarationContainer::similarNames	libsolidity/analysis/DeclarationContainer.h	/^	std::vector<ASTString> similarNames(ASTString const& _name) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name) const
dev::solidity::DeclarationContainer::std::declarations	libsolidity/analysis/DeclarationContainer.h	/^	std::map<ASTString, std::vector<Declaration const*>> const& declarations() const { return m_declarations; }$/;"	f	class:dev::solidity::DeclarationContainer::std	access:public	signature:() const
dev::solidity::DeclarationRegistrationHelper	libsolidity/analysis/NameAndTypeResolver.h	/^class DeclarationRegistrationHelper: private ASTVisitor$/;"	c	namespace:dev::solidity	inherits:ASTVisitor
dev::solidity::DeclarationRegistrationHelper::DeclarationRegistrationHelper	libsolidity/analysis/NameAndTypeResolver.cpp	/^DeclarationRegistrationHelper::DeclarationRegistrationHelper($/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:( map<ASTNode const*, shared_ptr<DeclarationContainer>>& _scopes, ASTNode& _astRoot, ErrorReporter& _errorReporter, ASTNode const* _currentScope )
dev::solidity::DeclarationRegistrationHelper::DeclarationRegistrationHelper	libsolidity/analysis/NameAndTypeResolver.h	/^	DeclarationRegistrationHelper($/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:public	signature:( std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& _scopes, ASTNode& _astRoot, langutil::ErrorReporter& _errorReporter, ASTNode const* _currentScope = nullptr )
dev::solidity::DeclarationRegistrationHelper::closeCurrentScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::closeCurrentScope()$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:()
dev::solidity::DeclarationRegistrationHelper::closeCurrentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void closeCurrentScope();$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:()
dev::solidity::DeclarationRegistrationHelper::currentCanonicalName	libsolidity/analysis/NameAndTypeResolver.cpp	/^string DeclarationRegistrationHelper::currentCanonicalName() const$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:() const
dev::solidity::DeclarationRegistrationHelper::currentCanonicalName	libsolidity/analysis/NameAndTypeResolver.h	/^	std::string currentCanonicalName() const;$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:() const
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(Block&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(Block&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(ContractDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ContractDefinition&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(EnumDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EnumDefinition&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(EventDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EventDefinition&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(ForStatement&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ForStatement&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(FunctionDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionDefinition&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(FunctionTypeName&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionTypeName&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(ModifierDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ModifierDefinition&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(SourceUnit& _sourceUnit)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(SourceUnit& _sourceUnit)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(StructDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(StructDefinition&)
dev::solidity::DeclarationRegistrationHelper::endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(VariableDeclarationStatement& _variableDeclarationStatement)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(VariableDeclarationStatement& _variableDeclarationStatement)
dev::solidity::DeclarationRegistrationHelper::enterNewSubScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::enterNewSubScope(ASTNode& _subScope)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ASTNode& _subScope)
dev::solidity::DeclarationRegistrationHelper::enterNewSubScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void enterNewSubScope(ASTNode& _subScope);$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:(ASTNode& _subScope)
dev::solidity::DeclarationRegistrationHelper::isOverloadedFunction	libsolidity/analysis/NameAndTypeResolver.h	/^	static bool isOverloadedFunction(Declaration const& _declaration1, Declaration const& _declaration2);$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:(Declaration const& _declaration1, Declaration const& _declaration2)
dev::solidity::DeclarationRegistrationHelper::m_currentFunction	libsolidity/analysis/NameAndTypeResolver.h	/^	VariableScope* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::m_currentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	ASTNode const* m_currentScope = nullptr;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::m_errorReporter	libsolidity/analysis/NameAndTypeResolver.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::m_scopes	libsolidity/analysis/NameAndTypeResolver.h	/^	std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& m_scopes;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(Block& _block) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ContractDefinition& _contract) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(EnumDefinition& _enum) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(EnumValue& _value) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(EventDefinition& _event) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ForStatement& _forLoop) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(FunctionDefinition& _function) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(FunctionTypeName& _funTypeName) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ImportDirective& _import) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ModifierDefinition& _modifier) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(SourceUnit& _sourceUnit) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(StructDefinition& _struct) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(VariableDeclaration& _declaration) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(Block& _block) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(ContractDefinition& _contract) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(EnumDefinition& _enum) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(EventDefinition& _event) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(ForStatement& _forLoop) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(FunctionDefinition& _function) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(FunctionTypeName& _funTypeName) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(ModifierDefinition& _modifier) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(SourceUnit& _sourceUnit) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(StructDefinition& _struct) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(VariableDeclarationStatement& _variableDeclarationStatement) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
dev::solidity::DeclarationRegistrationHelper::registerDeclaration	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::registerDeclaration($/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:( DeclarationContainer& _container, Declaration const& _declaration, string const* _name, SourceLocation const* _errorLocation, bool _warnOnShadow, bool _inactive, ErrorReporter& _errorReporter )
dev::solidity::DeclarationRegistrationHelper::registerDeclaration	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::registerDeclaration(Declaration& _declaration, bool _opensScope)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(Declaration& _declaration, bool _opensScope)
dev::solidity::DeclarationRegistrationHelper::registerDeclaration	libsolidity/analysis/NameAndTypeResolver.h	/^	static bool registerDeclaration($/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:public	signature:( DeclarationContainer& _container, Declaration const& _declaration, std::string const* _name, langutil::SourceLocation const* _errorLocation, bool _warnOnShadow, bool _inactive, langutil::ErrorReporter& _errorReporter )
dev::solidity::DeclarationRegistrationHelper::registerDeclaration	libsolidity/analysis/NameAndTypeResolver.h	/^	void registerDeclaration(Declaration& _declaration, bool _opensScope);$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:(Declaration& _declaration, bool _opensScope)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(Block& _block)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(Block& _block)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ContractDefinition& _contract)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ContractDefinition& _contract)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(EnumDefinition& _enum)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EnumDefinition& _enum)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(EnumValue& _value)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EnumValue& _value)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(EventDefinition& _event)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EventDefinition& _event)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ForStatement& _for)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ForStatement& _for)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(FunctionDefinition& _function)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionDefinition& _function)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(FunctionTypeName& _funTypeName)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionTypeName& _funTypeName)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ImportDirective& _import)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ImportDirective& _import)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ModifierDefinition& _modifier)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ModifierDefinition& _modifier)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(SourceUnit& _sourceUnit)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(SourceUnit& _sourceUnit)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(StructDefinition& _struct)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(StructDefinition& _struct)
dev::solidity::DeclarationRegistrationHelper::visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(VariableDeclaration& _declaration)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(VariableDeclaration& _declaration)
dev::solidity::DocStringAnalyser	libsolidity/analysis/DocStringAnalyser.h	/^class DocStringAnalyser: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::DocStringAnalyser::DocStringAnalyser	libsolidity/analysis/DocStringAnalyser.h	/^	DocStringAnalyser(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::DocStringAnalyser	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::DocStringAnalyser::analyseDocStrings	libsolidity/analysis/DocStringAnalyser.h	/^	bool analyseDocStrings(SourceUnit const& _sourceUnit);$/;"	p	class:dev::solidity::DocStringAnalyser	access:public	signature:(SourceUnit const& _sourceUnit)
dev::solidity::DocStringAnalyser::appendError	libsolidity/analysis/DocStringAnalyser.h	/^	void appendError(std::string const& _description);$/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:(std::string const& _description)
dev::solidity::DocStringAnalyser::checkParameters	libsolidity/analysis/DocStringAnalyser.h	/^	void checkParameters($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( CallableDeclaration const& _callable, DocumentedAnnotation& _annotation )
dev::solidity::DocStringAnalyser::handleCallable	libsolidity/analysis/DocStringAnalyser.h	/^	void handleCallable($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
dev::solidity::DocStringAnalyser::handleConstructor	libsolidity/analysis/DocStringAnalyser.h	/^	void handleConstructor($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
dev::solidity::DocStringAnalyser::m_errorOccured	libsolidity/analysis/DocStringAnalyser.h	/^	bool m_errorOccured = false;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
dev::solidity::DocStringAnalyser::m_errorReporter	libsolidity/analysis/DocStringAnalyser.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
dev::solidity::DocStringAnalyser::override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
dev::solidity::DocStringAnalyser::override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(EventDefinition const& _event) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
dev::solidity::DocStringAnalyser::override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
dev::solidity::DocStringAnalyser::override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(ModifierDefinition const& _modifier) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
dev::solidity::DocStringAnalyser::parseDocStrings	libsolidity/analysis/DocStringAnalyser.h	/^	void parseDocStrings($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( Documented const& _node, DocumentedAnnotation& _annotation, std::set<std::string> const& _validTags, std::string const& _nodeName )
dev::solidity::DocStringParser	libsolidity/parsing/DocStringParser.h	/^class DocStringParser$/;"	c	namespace:dev::solidity
dev::solidity::DocStringParser::appendDocTag	libsolidity/parsing/DocStringParser.h	/^	iter appendDocTag(iter _pos, iter _end);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end)
dev::solidity::DocStringParser::appendDocTagParam	libsolidity/parsing/DocStringParser.h	/^	iter appendDocTagParam(iter _pos, iter _end);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end)
dev::solidity::DocStringParser::appendError	libsolidity/parsing/DocStringParser.h	/^	void appendError(std::string const& _description);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(std::string const& _description)
dev::solidity::DocStringParser::m_docTags	libsolidity/parsing/DocStringParser.h	/^	std::multimap<std::string, DocTag> m_docTags;$/;"	m	class:dev::solidity::DocStringParser	access:private
dev::solidity::DocStringParser::m_errorReporter	libsolidity/parsing/DocStringParser.h	/^	langutil::ErrorReporter* m_errorReporter = nullptr;$/;"	m	class:dev::solidity::DocStringParser	access:private
dev::solidity::DocStringParser::m_errorsOccurred	libsolidity/parsing/DocStringParser.h	/^	bool m_errorsOccurred = false;$/;"	m	class:dev::solidity::DocStringParser	access:private
dev::solidity::DocStringParser::m_lastTag	libsolidity/parsing/DocStringParser.h	/^	DocTag* m_lastTag = nullptr;$/;"	m	class:dev::solidity::DocStringParser	access:private
dev::solidity::DocStringParser::newTag	libsolidity/parsing/DocStringParser.h	/^	void newTag(std::string const& _tagName);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(std::string const& _tagName)
dev::solidity::DocStringParser::parse	libsolidity/parsing/DocStringParser.h	/^	bool parse(std::string const& _docString, langutil::ErrorReporter& _errorReporter);$/;"	p	class:dev::solidity::DocStringParser	access:public	signature:(std::string const& _docString, langutil::ErrorReporter& _errorReporter)
dev::solidity::DocStringParser::parseDocString	libsolidity/parsing/DocStringParser.h	/^	void parseDocString(std::string const& _string);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(std::string const& _string)
dev::solidity::DocStringParser::parseDocTag	libsolidity/parsing/DocStringParser.h	/^	iter parseDocTag(iter _pos, iter _end, std::string const& _tag);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end, std::string const& _tag)
dev::solidity::DocStringParser::parseDocTagLine	libsolidity/parsing/DocStringParser.h	/^	iter parseDocTagLine(iter _pos, iter _end, bool _appending);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end, bool _appending)
dev::solidity::DocStringParser::parseDocTagParam	libsolidity/parsing/DocStringParser.h	/^	iter parseDocTagParam(iter _pos, iter _end);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end)
dev::solidity::DocStringParser::resetDev	libsolidity/parsing/DocStringParser.h	/^	void resetDev();$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:()
dev::solidity::DocStringParser::resetUser	libsolidity/parsing/DocStringParser.h	/^	void resetUser();$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:()
dev::solidity::DocStringParser::std::tags	libsolidity/parsing/DocStringParser.h	/^	std::multimap<std::string, DocTag> const& tags() const { return m_docTags; }$/;"	f	class:dev::solidity::DocStringParser::std	access:public	signature:() const
dev::solidity::DocTag	libsolidity/ast/ASTAnnotations.h	/^struct DocTag$/;"	s	namespace:dev::solidity
dev::solidity::DocTag::content	libsolidity/ast/ASTAnnotations.h	/^	std::string content;	\/\/\/< The text content of the tag.$/;"	m	struct:dev::solidity::DocTag	access:public
dev::solidity::DocTag::paramName	libsolidity/ast/ASTAnnotations.h	/^	std::string paramName;	\/\/\/< Only used for @param, stores the parameter name.$/;"	m	struct:dev::solidity::DocTag	access:public
dev::solidity::DocumentationType	solse/CommandLineInterface.h	/^enum class DocumentationType: uint8_t;$/;"	c	namespace:dev::solidity	inherits:uint8_t,CommandLineInterface
dev::solidity::DocumentationType::actOnInput	solse/CommandLineInterface.h	/^	bool actOnInput();$/;"	p	class:dev::solidity::DocumentationType	access:public	signature:()
dev::solidity::DocumentationType::assemble	solse/CommandLineInterface.h	/^	bool assemble(yul::AssemblyStack::Language _language, yul::AssemblyStack::Machine _targetMachine, bool _optimize);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(yul::AssemblyStack::Language _language, yul::AssemblyStack::Machine _targetMachine, bool _optimize)
dev::solidity::DocumentationType::createFile	solse/CommandLineInterface.h	/^	void createFile(std::string const& _fileName, std::string const& _data);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _fileName, std::string const& _data)
dev::solidity::DocumentationType::createJson	solse/CommandLineInterface.h	/^	void createJson(std::string const& _fileName, std::string const& _json);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _fileName, std::string const& _json)
dev::solidity::DocumentationType::handleABI	solse/CommandLineInterface.h	/^	void handleABI(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::handleAst	solse/CommandLineInterface.h	/^	void handleAst(std::string const& _argStr);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _argStr)
dev::solidity::DocumentationType::handleBinary	solse/CommandLineInterface.h	/^	void handleBinary(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::handleBytecode	solse/CommandLineInterface.h	/^	void handleBytecode(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::handleCombinedJSON	solse/CommandLineInterface.h	/^	void handleCombinedJSON();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
dev::solidity::DocumentationType::handleFormal	solse/CommandLineInterface.h	/^	void handleFormal();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
dev::solidity::DocumentationType::handleGasEstimation	solse/CommandLineInterface.h	/^	void handleGasEstimation(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::handleMetadata	solse/CommandLineInterface.h	/^	void handleMetadata(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::handleNatspec	solse/CommandLineInterface.h	/^	void handleNatspec(bool _natspecDev, std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(bool _natspecDev, std::string const& _contract)
dev::solidity::DocumentationType::handleOpcode	solse/CommandLineInterface.h	/^	void handleOpcode(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::handleSignatureHashes	solse/CommandLineInterface.h	/^	void handleSignatureHashes(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
dev::solidity::DocumentationType::libraryPlaceholderHint	solse/CommandLineInterface.h	/^	static std::string libraryPlaceholderHint(std::string const& _libraryName);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _libraryName)
dev::solidity::DocumentationType::link	solse/CommandLineInterface.h	/^	bool link();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
dev::solidity::DocumentationType::m_allowedDirectories	solse/CommandLineInterface.h	/^	std::vector<boost::filesystem::path> m_allowedDirectories;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_args	solse/CommandLineInterface.h	/^	boost::program_options::variables_map m_args;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_coloredOutput	solse/CommandLineInterface.h	/^	bool m_coloredOutput = true;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_compiler	solse/CommandLineInterface.h	/^	std::unique_ptr<dev::solidity::CompilerStack> m_compiler;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_error	solse/CommandLineInterface.h	/^	bool m_error = false; \/\/\/< If true, some error occurred.$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_evmVersion	solse/CommandLineInterface.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_libraries	solse/CommandLineInterface.h	/^	std::map<std::string, h160> m_libraries;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_onlyAssemble	solse/CommandLineInterface.h	/^	bool m_onlyAssemble = false;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_onlyLink	solse/CommandLineInterface.h	/^	bool m_onlyLink = false;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_remappings	solse/CommandLineInterface.h	/^	std::vector<dev::solidity::CompilerStack::Remapping> m_remappings;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::m_sourceCodes	solse/CommandLineInterface.h	/^	std::map<std::string, std::string> m_sourceCodes;$/;"	m	class:dev::solidity::DocumentationType	access:private
dev::solidity::DocumentationType::objectWithLinkRefsHex	solse/CommandLineInterface.h	/^	static std::string objectWithLinkRefsHex(eth::LinkerObject const& _obj);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(eth::LinkerObject const& _obj)
dev::solidity::DocumentationType::outputCompilationResults	solse/CommandLineInterface.h	/^	void outputCompilationResults();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
dev::solidity::DocumentationType::parseArguments	solse/CommandLineInterface.h	/^	bool parseArguments(int _argc, char** _argv);$/;"	p	class:dev::solidity::DocumentationType	access:public	signature:(int _argc, char** _argv)
dev::solidity::DocumentationType::parseLibraryOption	solse/CommandLineInterface.h	/^	bool parseLibraryOption(std::string const& _input);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _input)
dev::solidity::DocumentationType::processInput	solse/CommandLineInterface.h	/^	bool processInput();$/;"	p	class:dev::solidity::DocumentationType	access:public	signature:()
dev::solidity::DocumentationType::readInputFilesAndConfigureRemappings	solse/CommandLineInterface.h	/^	bool readInputFilesAndConfigureRemappings();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
dev::solidity::DocumentationType::writeLinkedFiles	solse/CommandLineInterface.h	/^	void writeLinkedFiles();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
dev::solidity::Documented	libsolidity/ast/AST.h	/^class Documented$/;"	c	namespace:dev::solidity
dev::solidity::Documented::Documented	libsolidity/ast/AST.h	/^	explicit Documented(ASTPointer<ASTString> const& _documentation): m_documentation(_documentation) {}$/;"	f	class:dev::solidity::Documented	access:public	signature:(ASTPointer<ASTString> const& _documentation)
dev::solidity::Documented::documentation	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> const& documentation() const { return m_documentation; }$/;"	f	class:dev::solidity::Documented	access:public	signature:() const
dev::solidity::Documented::m_documentation	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_documentation;$/;"	m	class:dev::solidity::Documented	access:protected
dev::solidity::Documented::~Documented	libsolidity/ast/AST.h	/^	virtual ~Documented() = default;$/;"	p	class:dev::solidity::Documented	access:public	signature:()
dev::solidity::DocumentedAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct DocumentedAnnotation$/;"	s	namespace:dev::solidity
dev::solidity::DocumentedAnnotation::docTags	libsolidity/ast/ASTAnnotations.h	/^	std::multimap<std::string, DocTag> docTags;$/;"	m	struct:dev::solidity::DocumentedAnnotation	access:public
dev::solidity::DocumentedAnnotation::~DocumentedAnnotation	libsolidity/ast/ASTAnnotations.h	/^	virtual ~DocumentedAnnotation() = default;$/;"	p	struct:dev::solidity::DocumentedAnnotation	access:public	signature:()
dev::solidity::ElementaryTypeName	libsolidity/ast/AST.h	/^class ElementaryTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
dev::solidity::ElementaryTypeName::ElementaryTypeName	libsolidity/ast/AST.h	/^	ElementaryTypeName($/;"	f	class:dev::solidity::ElementaryTypeName	access:public	signature:( SourceLocation const& _location, ElementaryTypeNameToken const& _elem, boost::optional<StateMutability> _stateMutability = {} )
dev::solidity::ElementaryTypeName::accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ElementaryTypeName	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ElementaryTypeName::accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ElementaryTypeName	signature:(ASTVisitor& _visitor)
dev::solidity::ElementaryTypeName::boost::stateMutability	libsolidity/ast/AST.h	/^	boost::optional<StateMutability> const& stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::ElementaryTypeName::boost	access:public	signature:() const
dev::solidity::ElementaryTypeName::m_stateMutability	libsolidity/ast/AST.h	/^	boost::optional<StateMutability> m_stateMutability; \/\/\/< state mutability for address type$/;"	m	class:dev::solidity::ElementaryTypeName	access:private
dev::solidity::ElementaryTypeName::m_type	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken m_type;$/;"	m	class:dev::solidity::ElementaryTypeName	access:private
dev::solidity::ElementaryTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ElementaryTypeName	access:public
dev::solidity::ElementaryTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ElementaryTypeName	access:public
dev::solidity::ElementaryTypeName::typeName	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken const& typeName() const { return m_type; }$/;"	f	class:dev::solidity::ElementaryTypeName	access:public	signature:() const
dev::solidity::ElementaryTypeNameExpression	libsolidity/ast/AST.h	/^class ElementaryTypeNameExpression: public PrimaryExpression$/;"	c	namespace:dev::solidity	inherits:PrimaryExpression
dev::solidity::ElementaryTypeNameExpression::ElementaryTypeNameExpression	libsolidity/ast/AST.h	/^	ElementaryTypeNameExpression(SourceLocation const& _location, ElementaryTypeNameToken const& _type):$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	access:public	signature:(SourceLocation const& _location, ElementaryTypeNameToken const& _type)
dev::solidity::ElementaryTypeNameExpression::accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeNameExpression::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ElementaryTypeNameExpression::accept	libsolidity/ast/AST_accept.h	/^void ElementaryTypeNameExpression::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	signature:(ASTVisitor& _visitor)
dev::solidity::ElementaryTypeNameExpression::m_typeToken	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken m_typeToken;$/;"	m	class:dev::solidity::ElementaryTypeNameExpression	access:private
dev::solidity::ElementaryTypeNameExpression::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ElementaryTypeNameExpression	access:public
dev::solidity::ElementaryTypeNameExpression::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ElementaryTypeNameExpression	access:public
dev::solidity::ElementaryTypeNameExpression::typeName	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken const& typeName() const { return m_typeToken; }$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	access:public	signature:() const
dev::solidity::EmitStatement	libsolidity/ast/AST.h	/^class EmitStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::EmitStatement::EmitStatement	libsolidity/ast/AST.h	/^	explicit EmitStatement($/;"	f	class:dev::solidity::EmitStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<FunctionCall> const& _functionCall )
dev::solidity::EmitStatement::accept	libsolidity/ast/AST_accept.h	/^void EmitStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EmitStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::EmitStatement::accept	libsolidity/ast/AST_accept.h	/^void EmitStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EmitStatement	signature:(ASTVisitor& _visitor)
dev::solidity::EmitStatement::eventCall	libsolidity/ast/AST.h	/^	FunctionCall const& eventCall() const { return *m_eventCall; }$/;"	f	class:dev::solidity::EmitStatement	access:public	signature:() const
dev::solidity::EmitStatement::m_eventCall	libsolidity/ast/AST.h	/^	ASTPointer<FunctionCall> m_eventCall;$/;"	m	class:dev::solidity::EmitStatement	access:private
dev::solidity::EmitStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EmitStatement	access:public
dev::solidity::EmitStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EmitStatement	access:public
dev::solidity::EnumDefinition	libsolidity/ast/AST.h	/^class EnumDefinition: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
dev::solidity::EnumDefinition::EnumDefinition	libsolidity/ast/AST.h	/^	EnumDefinition($/;"	f	class:dev::solidity::EnumDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, std::vector<ASTPointer<EnumValue>> const& _members )
dev::solidity::EnumDefinition::accept	libsolidity/ast/AST_accept.h	/^void EnumDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EnumDefinition	signature:(ASTConstVisitor& _visitor) const
dev::solidity::EnumDefinition::accept	libsolidity/ast/AST_accept.h	/^void EnumDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EnumDefinition	signature:(ASTVisitor& _visitor)
dev::solidity::EnumDefinition::m_members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<EnumValue>> m_members;$/;"	m	class:dev::solidity::EnumDefinition	access:private
dev::solidity::EnumDefinition::override	libsolidity/ast/AST.h	/^	TypeDeclarationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
dev::solidity::EnumDefinition::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
dev::solidity::EnumDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
dev::solidity::EnumDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
dev::solidity::EnumDefinition::std::members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<EnumValue>> const& members() const { return m_members; }$/;"	f	class:dev::solidity::EnumDefinition::std	access:public	signature:() const
dev::solidity::EnumType	libsolidity/ast/Types.h	/^class EnumType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::EnumType::EnumType	libsolidity/ast/Types.h	/^	explicit EnumType(EnumDefinition const& _enum): m_enum(_enum) {}$/;"	f	class:dev::solidity::EnumType	access:public	signature:(EnumDefinition const& _enum)
dev::solidity::EnumType::enumDefinition	libsolidity/ast/Types.h	/^	EnumDefinition const& enumDefinition() const { return m_enum; }$/;"	f	class:dev::solidity::EnumType	access:public	signature:() const
dev::solidity::EnumType::m_enum	libsolidity/ast/Types.h	/^	EnumDefinition const& m_enum;$/;"	m	class:dev::solidity::EnumType	access:private
dev::solidity::EnumType::memberValue	libsolidity/ast/Types.h	/^	unsigned int memberValue(ASTString const& _member) const;$/;"	p	class:dev::solidity::EnumType	access:public	signature:(ASTString const& _member) const
dev::solidity::EnumType::numberOfMembers	libsolidity/ast/Types.h	/^	size_t numberOfMembers() const;$/;"	p	class:dev::solidity::EnumType	access:public	signature:() const
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumType::override	libsolidity/ast/Types.h	/^	unsigned storageBytes() const override;$/;"	m	class:dev::solidity::EnumType	access:public
dev::solidity::EnumValue	libsolidity/ast/AST.h	/^class EnumValue: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
dev::solidity::EnumValue::EnumValue	libsolidity/ast/AST.h	/^	EnumValue(SourceLocation const& _location, ASTPointer<ASTString> const& _name):$/;"	f	class:dev::solidity::EnumValue	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _name)
dev::solidity::EnumValue::accept	libsolidity/ast/AST_accept.h	/^void EnumValue::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EnumValue	signature:(ASTConstVisitor& _visitor) const
dev::solidity::EnumValue::accept	libsolidity/ast/AST_accept.h	/^void EnumValue::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EnumValue	signature:(ASTVisitor& _visitor)
dev::solidity::EnumValue::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::EnumValue	access:public
dev::solidity::EnumValue::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EnumValue	access:public
dev::solidity::EnumValue::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EnumValue	access:public
dev::solidity::EventDefinition	libsolidity/ast/AST.h	/^class EventDefinition: public CallableDeclaration, public Documented$/;"	c	namespace:dev::solidity	inherits:CallableDeclaration,Documented
dev::solidity::EventDefinition::EventDefinition	libsolidity/ast/AST.h	/^	EventDefinition($/;"	f	class:dev::solidity::EventDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, ASTPointer<ASTString> const& _documentation, ASTPointer<ParameterList> const& _parameters, bool _anonymous = false )
dev::solidity::EventDefinition::accept	libsolidity/ast/AST_accept.h	/^void EventDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::EventDefinition	signature:(ASTConstVisitor& _visitor) const
dev::solidity::EventDefinition::accept	libsolidity/ast/AST_accept.h	/^void EventDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::EventDefinition	signature:(ASTVisitor& _visitor)
dev::solidity::EventDefinition::isAnonymous	libsolidity/ast/AST.h	/^	bool isAnonymous() const { return m_anonymous; }$/;"	f	class:dev::solidity::EventDefinition	access:public	signature:() const
dev::solidity::EventDefinition::m_anonymous	libsolidity/ast/AST.h	/^	bool m_anonymous = false;$/;"	m	class:dev::solidity::EventDefinition	access:private
dev::solidity::EventDefinition::override	libsolidity/ast/AST.h	/^	EventDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
dev::solidity::EventDefinition::override	libsolidity/ast/AST.h	/^	FunctionTypePointer functionType(bool \/*_internal*\/) const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
dev::solidity::EventDefinition::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
dev::solidity::EventDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
dev::solidity::EventDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EventDefinition	access:public
dev::solidity::EventDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct EventDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
dev::solidity::ExperimentalFeature	libsolidity/ast/ExperimentalFeatures.h	/^enum class ExperimentalFeature$/;"	c	namespace:dev::solidity
dev::solidity::ExperimentalFeature::ABIEncoderV2	libsolidity/ast/ExperimentalFeatures.h	/^	ABIEncoderV2, \/\/ new ABI encoder that makes use of Yul$/;"	m	class:dev::solidity::ExperimentalFeature	access:private
dev::solidity::ExperimentalFeature::SMTChecker	libsolidity/ast/ExperimentalFeatures.h	/^	SMTChecker,$/;"	m	class:dev::solidity::ExperimentalFeature	access:private
dev::solidity::ExperimentalFeature::Test	libsolidity/ast/ExperimentalFeatures.h	/^	Test,$/;"	m	class:dev::solidity::ExperimentalFeature	access:private
dev::solidity::Expression	libsolidity/ast/AST.h	/^class Expression: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::Expression::Expression	libsolidity/ast/AST.h	/^	explicit Expression(SourceLocation const& _location): ASTNode(_location) {}$/;"	f	class:dev::solidity::Expression	access:public	signature:(SourceLocation const& _location)
dev::solidity::Expression::override	libsolidity/ast/AST.h	/^	ExpressionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Expression	access:public
dev::solidity::ExpressionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ExpressionAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
dev::solidity::ExpressionAnnotation::argumentTypes	libsolidity/ast/ASTAnnotations.h	/^	std::shared_ptr<std::vector<TypePointer>> argumentTypes;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
dev::solidity::ExpressionAnnotation::isConstant	libsolidity/ast/ASTAnnotations.h	/^	bool isConstant = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
dev::solidity::ExpressionAnnotation::isLValue	libsolidity/ast/ASTAnnotations.h	/^	bool isLValue = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
dev::solidity::ExpressionAnnotation::isPure	libsolidity/ast/ASTAnnotations.h	/^	bool isPure = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
dev::solidity::ExpressionAnnotation::lValueRequested	libsolidity/ast/ASTAnnotations.h	/^	bool lValueRequested = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
dev::solidity::ExpressionAnnotation::type	libsolidity/ast/ASTAnnotations.h	/^	TypePointer type;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
dev::solidity::ExpressionCompiler	libsolidity/codegen/ExpressionCompiler.h	/^class ExpressionCompiler: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ExpressionCompiler::ExpressionCompiler	libsolidity/codegen/ExpressionCompiler.h	/^	explicit ExpressionCompiler(CompilerContext& _compilerContext, bool _optimiseOrderLiterals):$/;"	f	class:dev::solidity::ExpressionCompiler	access:public	signature:(CompilerContext& _compilerContext, bool _optimiseOrderLiterals)
dev::solidity::ExpressionCompiler::appendAndOrOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendAndOrOperatorCode(BinaryOperation const& _binaryOperation)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(BinaryOperation const& _binaryOperation)
dev::solidity::ExpressionCompiler::appendAndOrOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendAndOrOperatorCode(BinaryOperation const& _binaryOperation);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(BinaryOperation const& _binaryOperation)
dev::solidity::ExpressionCompiler::appendArithmeticOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendArithmeticOperatorCode(Token _operator, Type const& _type)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _type)
dev::solidity::ExpressionCompiler::appendArithmeticOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendArithmeticOperatorCode(Token _operator, Type const& _type);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _type)
dev::solidity::ExpressionCompiler::appendBitOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendBitOperatorCode(Token _operator)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator)
dev::solidity::ExpressionCompiler::appendBitOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendBitOperatorCode(Token _operator);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator)
dev::solidity::ExpressionCompiler::appendCompareOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendCompareOperatorCode(Token _operator, Type const& _type)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _type)
dev::solidity::ExpressionCompiler::appendCompareOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendCompareOperatorCode(Token _operator, Type const& _type);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _type)
dev::solidity::ExpressionCompiler::appendConstStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendConstStateVariableAccessor(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ExpressionCompiler::appendConstStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.h	/^	void appendConstStateVariableAccessor(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ExpressionCompiler::appendExpressionCopyToMemory	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendExpressionCopyToMemory(Type const& _expectedType, Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Type const& _expectedType, Expression const& _expression)
dev::solidity::ExpressionCompiler::appendExpressionCopyToMemory	libsolidity/codegen/ExpressionCompiler.h	/^	void appendExpressionCopyToMemory(Type const& _expectedType, Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Type const& _expectedType, Expression const& _expression)
dev::solidity::ExpressionCompiler::appendExternalFunctionCall	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendExternalFunctionCall($/;"	f	class:dev::solidity::ExpressionCompiler	signature:( FunctionType const& _functionType, vector<ASTPointer<Expression const>> const& _arguments )
dev::solidity::ExpressionCompiler::appendExternalFunctionCall	libsolidity/codegen/ExpressionCompiler.h	/^	void appendExternalFunctionCall($/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:( FunctionType const& _functionType, std::vector<ASTPointer<Expression const>> const& _arguments )
dev::solidity::ExpressionCompiler::appendOrdinaryBinaryOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendOrdinaryBinaryOperatorCode(Token _operator, Type const& _type)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _type)
dev::solidity::ExpressionCompiler::appendOrdinaryBinaryOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendOrdinaryBinaryOperatorCode(Token _operator, Type const& _type);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _type)
dev::solidity::ExpressionCompiler::appendShiftOperatorCode	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendShiftOperatorCode(Token _operator, Type const& _valueType, Type const& _shiftAmountType)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Token _operator, Type const& _valueType, Type const& _shiftAmountType)
dev::solidity::ExpressionCompiler::appendShiftOperatorCode	libsolidity/codegen/ExpressionCompiler.h	/^	void appendShiftOperatorCode(Token _operator, Type const& _valueType, Type const& _shiftAmountType);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Token _operator, Type const& _valueType, Type const& _shiftAmountType)
dev::solidity::ExpressionCompiler::appendStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ExpressionCompiler::appendStateVariableAccessor	libsolidity/codegen/ExpressionCompiler.h	/^	void appendStateVariableAccessor(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ExpressionCompiler::appendStateVariableInitialization	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendStateVariableInitialization(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ExpressionCompiler::appendStateVariableInitialization	libsolidity/codegen/ExpressionCompiler.h	/^	void appendStateVariableInitialization(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(VariableDeclaration const& _varDecl)
dev::solidity::ExpressionCompiler::appendVariable	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::appendVariable(VariableDeclaration const& _variable, Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(VariableDeclaration const& _variable, Expression const& _expression)
dev::solidity::ExpressionCompiler::appendVariable	libsolidity/codegen/ExpressionCompiler.h	/^	void appendVariable(VariableDeclaration const& _variable, Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(VariableDeclaration const& _variable, Expression const& _expression)
dev::solidity::ExpressionCompiler::cleanupNeededForOp	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::cleanupNeededForOp(Type::Category _type, Token _op)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Type::Category _type, Token _op)
dev::solidity::ExpressionCompiler::cleanupNeededForOp	libsolidity/codegen/ExpressionCompiler.h	/^	static bool cleanupNeededForOp(Type::Category _type, Token _op);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Type::Category _type, Token _op)
dev::solidity::ExpressionCompiler::compile	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::compile(Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Expression const& _expression)
dev::solidity::ExpressionCompiler::compile	libsolidity/codegen/ExpressionCompiler.h	/^	void compile(Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:public	signature:(Expression const& _expression)
dev::solidity::ExpressionCompiler::endVisit	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::endVisit(Identifier const& _identifier)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Identifier const& _identifier)
dev::solidity::ExpressionCompiler::endVisit	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::endVisit(Literal const& _literal)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Literal const& _literal)
dev::solidity::ExpressionCompiler::m_context	libsolidity/codegen/ExpressionCompiler.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::m_currentLValue	libsolidity/codegen/ExpressionCompiler.h	/^	std::unique_ptr<LValue> m_currentLValue;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::m_optimiseOrderLiterals	libsolidity/codegen/ExpressionCompiler.h	/^	bool m_optimiseOrderLiterals;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(Assignment const& _assignment) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(BinaryOperation const& _binaryOperation) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(Conditional const& _condition) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(IndexAccess const& _indexAccess) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(NewExpression const& _newExpression) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(TupleExpression const& _tuple) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(UnaryOperation const& _unaryOperation) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	void endVisit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::override	libsolidity/codegen/ExpressionCompiler.h	/^	void endVisit(Literal const& _literal) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
dev::solidity::ExpressionCompiler::setLValue	libsolidity/codegen/ExpressionCompiler.h	/^	void setLValue(Expression const& _expression, _Arguments const&... _arguments);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Expression const& _expression, _Arguments const&... _arguments)
dev::solidity::ExpressionCompiler::setLValue	libsolidity/codegen/ExpressionCompiler.h	/^void ExpressionCompiler::setLValue(Expression const& _expression, _Arguments const&... _arguments)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Expression const& _expression, _Arguments const&... _arguments)
dev::solidity::ExpressionCompiler::setLValueFromDeclaration	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::setLValueFromDeclaration(Declaration const& _declaration, Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Declaration const& _declaration, Expression const& _expression)
dev::solidity::ExpressionCompiler::setLValueFromDeclaration	libsolidity/codegen/ExpressionCompiler.h	/^	void setLValueFromDeclaration(Declaration const& _declaration, Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Declaration const& _declaration, Expression const& _expression)
dev::solidity::ExpressionCompiler::setLValueToStorageItem	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::setLValueToStorageItem(Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Expression const& _expression)
dev::solidity::ExpressionCompiler::setLValueToStorageItem	libsolidity/codegen/ExpressionCompiler.h	/^	void setLValueToStorageItem(Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Expression const& _expression)
dev::solidity::ExpressionCompiler::utils	libsolidity/codegen/ExpressionCompiler.cpp	/^CompilerUtils ExpressionCompiler::utils()$/;"	f	class:dev::solidity::ExpressionCompiler	signature:()
dev::solidity::ExpressionCompiler::utils	libsolidity/codegen/ExpressionCompiler.h	/^	CompilerUtils utils();$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:()
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(Assignment const& _assignment)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Assignment const& _assignment)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(BinaryOperation const& _binaryOperation)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(BinaryOperation const& _binaryOperation)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(Conditional const& _condition)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Conditional const& _condition)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(FunctionCall const& _functionCall)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(FunctionCall const& _functionCall)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(IndexAccess const& _indexAccess)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(MemberAccess const& _memberAccess)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(MemberAccess const& _memberAccess)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(NewExpression const&)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(NewExpression const&)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(TupleExpression const& _tuple)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(TupleExpression const& _tuple)
dev::solidity::ExpressionCompiler::visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(UnaryOperation const& _unaryOperation)
dev::solidity::ExpressionStatement	libsolidity/ast/AST.h	/^class ExpressionStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::ExpressionStatement::ExpressionStatement	libsolidity/ast/AST.h	/^	ExpressionStatement($/;"	f	class:dev::solidity::ExpressionStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> _expression )
dev::solidity::ExpressionStatement::accept	libsolidity/ast/AST_accept.h	/^void ExpressionStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ExpressionStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ExpressionStatement::accept	libsolidity/ast/AST_accept.h	/^void ExpressionStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ExpressionStatement	signature:(ASTVisitor& _visitor)
dev::solidity::ExpressionStatement::expression	libsolidity/ast/AST.h	/^	Expression const& expression() const { return *m_expression; }$/;"	f	class:dev::solidity::ExpressionStatement	access:public	signature:() const
dev::solidity::ExpressionStatement::m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression;$/;"	m	class:dev::solidity::ExpressionStatement	access:private
dev::solidity::ExpressionStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ExpressionStatement	access:public
dev::solidity::ExpressionStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ExpressionStatement	access:public
dev::solidity::FixedBytesType	libsolidity/ast/Types.h	/^class FixedBytesType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::FixedBytesType::FixedBytesType	libsolidity/ast/Types.h	/^	explicit FixedBytesType(unsigned _bytes);$/;"	p	class:dev::solidity::FixedBytesType	access:public	signature:(unsigned _bytes)
dev::solidity::FixedBytesType::m_bytes	libsolidity/ast/Types.h	/^	unsigned m_bytes;$/;"	m	class:dev::solidity::FixedBytesType	access:private
dev::solidity::FixedBytesType::numBytes	libsolidity/ast/Types.h	/^	unsigned numBytes() const { return m_bytes; }$/;"	f	class:dev::solidity::FixedBytesType	access:public	signature:() const
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedBytesType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
dev::solidity::FixedPointType	libsolidity/ast/Types.h	/^class FixedPointType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::FixedPointType::FixedPointType	libsolidity/ast/Types.h	/^	explicit FixedPointType(unsigned _totalBits, unsigned _fractionalDigits, Modifier _modifier = Modifier::Unsigned);$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:(unsigned _totalBits, unsigned _fractionalDigits, Modifier _modifier = Modifier::Unsigned)
dev::solidity::FixedPointType::Modifier	libsolidity/ast/Types.h	/^	enum class Modifier$/;"	c	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::Modifier::Unsigned	libsolidity/ast/Types.h	/^		Unsigned, Signed$/;"	m	class:dev::solidity::FixedPointType::Modifier	access:private
dev::solidity::FixedPointType::asIntegerType	libsolidity/ast/Types.h	/^	std::shared_ptr<IntegerType> asIntegerType() const;$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:() const
dev::solidity::FixedPointType::fractionalDigits	libsolidity/ast/Types.h	/^	unsigned fractionalDigits() const { return m_fractionalDigits; }$/;"	f	class:dev::solidity::FixedPointType	access:public	signature:() const
dev::solidity::FixedPointType::isSigned	libsolidity/ast/Types.h	/^	bool isSigned() const { return m_modifier == Modifier::Signed; }$/;"	f	class:dev::solidity::FixedPointType	access:public	signature:() const
dev::solidity::FixedPointType::m_fractionalDigits	libsolidity/ast/Types.h	/^	unsigned m_fractionalDigits;$/;"	m	class:dev::solidity::FixedPointType	access:private
dev::solidity::FixedPointType::m_modifier	libsolidity/ast/Types.h	/^	Modifier m_modifier;$/;"	m	class:dev::solidity::FixedPointType	access:private
dev::solidity::FixedPointType::m_totalBits	libsolidity/ast/Types.h	/^	unsigned m_totalBits;$/;"	m	class:dev::solidity::FixedPointType	access:private
dev::solidity::FixedPointType::maxIntegerValue	libsolidity/ast/Types.h	/^	bigint maxIntegerValue() const;$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:() const
dev::solidity::FixedPointType::minIntegerValue	libsolidity/ast/Types.h	/^	bigint minIntegerValue() const;$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:() const
dev::solidity::FixedPointType::numBits	libsolidity/ast/Types.h	/^	unsigned numBits() const { return m_totalBits; }$/;"	f	class:dev::solidity::FixedPointType	access:public	signature:() const
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::FixedPointType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
dev::solidity::ForStatement	libsolidity/ast/AST.h	/^class ForStatement: public BreakableStatement, public Scopable$/;"	c	namespace:dev::solidity	inherits:BreakableStatement,Scopable
dev::solidity::ForStatement::ForStatement	libsolidity/ast/AST.h	/^	ForStatement($/;"	f	class:dev::solidity::ForStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Statement> const& _initExpression, ASTPointer<Expression> const& _conditionExpression, ASTPointer<ExpressionStatement> const& _loopExpression, ASTPointer<Statement> const& _body )
dev::solidity::ForStatement::accept	libsolidity/ast/AST_accept.h	/^void ForStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ForStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ForStatement::accept	libsolidity/ast/AST_accept.h	/^void ForStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ForStatement	signature:(ASTVisitor& _visitor)
dev::solidity::ForStatement::body	libsolidity/ast/AST.h	/^	Statement const& body() const { return *m_body; }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
dev::solidity::ForStatement::condition	libsolidity/ast/AST.h	/^	Expression const* condition() const { return m_condExpression.get(); }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
dev::solidity::ForStatement::initializationExpression	libsolidity/ast/AST.h	/^	Statement const* initializationExpression() const { return m_initExpression.get(); }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
dev::solidity::ForStatement::loopExpression	libsolidity/ast/AST.h	/^	ExpressionStatement const* loopExpression() const { return m_loopExpression.get(); }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
dev::solidity::ForStatement::m_body	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_body;$/;"	m	class:dev::solidity::ForStatement	access:private
dev::solidity::ForStatement::m_condExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condExpression;$/;"	m	class:dev::solidity::ForStatement	access:private
dev::solidity::ForStatement::m_initExpression	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_initExpression;$/;"	m	class:dev::solidity::ForStatement	access:private
dev::solidity::ForStatement::m_loopExpression	libsolidity/ast/AST.h	/^	ASTPointer<ExpressionStatement> m_loopExpression;$/;"	m	class:dev::solidity::ForStatement	access:private
dev::solidity::ForStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ForStatement	access:public
dev::solidity::ForStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ForStatement	access:public
dev::solidity::FunctionCall	libsolidity/ast/AST.h	/^class FunctionCall: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::FunctionCall::FunctionCall	libsolidity/ast/AST.h	/^	FunctionCall($/;"	f	class:dev::solidity::FunctionCall	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _expression, std::vector<ASTPointer<Expression>> const& _arguments, std::vector<ASTPointer<ASTString>> const& _names )
dev::solidity::FunctionCall::accept	libsolidity/ast/AST_accept.h	/^void FunctionCall::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::FunctionCall	signature:(ASTConstVisitor& _visitor) const
dev::solidity::FunctionCall::accept	libsolidity/ast/AST_accept.h	/^void FunctionCall::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::FunctionCall	signature:(ASTVisitor& _visitor)
dev::solidity::FunctionCall::arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression const>> arguments() const { return {m_arguments.begin(), m_arguments.end()}; }$/;"	f	class:dev::solidity::FunctionCall	access:public	signature:() const
dev::solidity::FunctionCall::expression	libsolidity/ast/AST.h	/^	Expression const& expression() const { return *m_expression; }$/;"	f	class:dev::solidity::FunctionCall	access:public	signature:() const
dev::solidity::FunctionCall::m_arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> m_arguments;$/;"	m	class:dev::solidity::FunctionCall	access:private
dev::solidity::FunctionCall::m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression;$/;"	m	class:dev::solidity::FunctionCall	access:private
dev::solidity::FunctionCall::m_names	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTString>> m_names;$/;"	m	class:dev::solidity::FunctionCall	access:private
dev::solidity::FunctionCall::override	libsolidity/ast/AST.h	/^	FunctionCallAnnotation& annotation() const override;$/;"	m	class:dev::solidity::FunctionCall	access:public
dev::solidity::FunctionCall::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::FunctionCall	access:public
dev::solidity::FunctionCall::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::FunctionCall	access:public
dev::solidity::FunctionCall::std::names	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTString>> const& names() const { return m_names; }$/;"	f	class:dev::solidity::FunctionCall::std	access:public	signature:() const
dev::solidity::FunctionCallAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct FunctionCallAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
dev::solidity::FunctionCallAnnotation::kind	libsolidity/ast/ASTAnnotations.h	/^	FunctionCallKind kind = FunctionCallKind::Unset;$/;"	m	struct:dev::solidity::FunctionCallAnnotation	access:public
dev::solidity::FunctionCallKind	libsolidity/ast/ASTAnnotations.h	/^enum class FunctionCallKind$/;"	c	namespace:dev::solidity
dev::solidity::FunctionCallKind::FunctionCall	libsolidity/ast/ASTAnnotations.h	/^	FunctionCall,$/;"	m	class:dev::solidity::FunctionCallKind	access:private
dev::solidity::FunctionCallKind::TypeConversion	libsolidity/ast/ASTAnnotations.h	/^	TypeConversion,$/;"	m	class:dev::solidity::FunctionCallKind	access:private
dev::solidity::FunctionCallKind::Unset	libsolidity/ast/ASTAnnotations.h	/^	Unset,$/;"	m	class:dev::solidity::FunctionCallKind	access:private
dev::solidity::FunctionDefinition	libsolidity/ast/AST.h	/^class FunctionDefinition: public CallableDeclaration, public Documented, public ImplementationOptional$/;"	c	namespace:dev::solidity	inherits:CallableDeclaration,Documented,ImplementationOptional
dev::solidity::FunctionDefinition::FunctionDefinition	libsolidity/ast/AST.h	/^	FunctionDefinition($/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, Declaration::Visibility _visibility, StateMutability _stateMutability, bool _isConstructor, ASTPointer<ASTString> const& _documentation, ASTPointer<ParameterList> const& _parameters, std::vector<ASTPointer<ModifierInvocation>> const& _modifiers, ASTPointer<ParameterList> const& _returnParameters, ASTPointer<Block> const& _body )
dev::solidity::FunctionDefinition::accept	libsolidity/ast/AST_accept.h	/^void FunctionDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::FunctionDefinition	signature:(ASTConstVisitor& _visitor) const
dev::solidity::FunctionDefinition::accept	libsolidity/ast/AST_accept.h	/^void FunctionDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::FunctionDefinition	signature:(ASTVisitor& _visitor)
dev::solidity::FunctionDefinition::body	libsolidity/ast/AST.h	/^	Block const& body() const { solAssert(m_body, ""); return *m_body; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::externalSignature	libsolidity/ast/AST.h	/^	std::string externalSignature() const;$/;"	p	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::inContractKind	libsolidity/ast/AST.h	/^	ContractDefinition::ContractKind inContractKind() const;$/;"	p	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::isConstructor	libsolidity/ast/AST.h	/^	bool isConstructor() const { return m_isConstructor; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::isFallback	libsolidity/ast/AST.h	/^	bool isFallback() const { return !m_isConstructor && name().empty(); }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::isPayable	libsolidity/ast/AST.h	/^	bool isPayable() const { return m_stateMutability == StateMutability::Payable; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::m_body	libsolidity/ast/AST.h	/^	ASTPointer<Block> m_body;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
dev::solidity::FunctionDefinition::m_functionModifiers	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ModifierInvocation>> m_functionModifiers;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
dev::solidity::FunctionDefinition::m_isConstructor	libsolidity/ast/AST.h	/^	bool m_isConstructor;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
dev::solidity::FunctionDefinition::m_stateMutability	libsolidity/ast/AST.h	/^	StateMutability m_stateMutability;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
dev::solidity::FunctionDefinition::override	libsolidity/ast/AST.h	/^	FunctionDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
dev::solidity::FunctionDefinition::override	libsolidity/ast/AST.h	/^	FunctionTypePointer functionType(bool \/*_internal*\/) const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
dev::solidity::FunctionDefinition::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
dev::solidity::FunctionDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
dev::solidity::FunctionDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
dev::solidity::FunctionDefinition::stateMutability	libsolidity/ast/AST.h	/^	StateMutability stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
dev::solidity::FunctionDefinition::std::modifiers	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ModifierInvocation>> const& modifiers() const { return m_functionModifiers; }$/;"	f	class:dev::solidity::FunctionDefinition::std	access:public	signature:() const
dev::solidity::FunctionDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct FunctionDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
dev::solidity::FunctionDefinitionAnnotation::superFunction	libsolidity/ast/ASTAnnotations.h	/^	FunctionDefinition const* superFunction = nullptr;$/;"	m	struct:dev::solidity::FunctionDefinitionAnnotation	access:public
dev::solidity::FunctionFlow	libsolidity/analysis/ControlFlowGraph.h	/^struct FunctionFlow$/;"	s	namespace:dev::solidity
dev::solidity::FunctionFlow::entry	libsolidity/analysis/ControlFlowGraph.h	/^	CFGNode* entry = nullptr;$/;"	m	struct:dev::solidity::FunctionFlow	access:public
dev::solidity::FunctionFlow::exit	libsolidity/analysis/ControlFlowGraph.h	/^	CFGNode* exit = nullptr;$/;"	m	struct:dev::solidity::FunctionFlow	access:public
dev::solidity::FunctionFlow::revert	libsolidity/analysis/ControlFlowGraph.h	/^	CFGNode* revert = nullptr;$/;"	m	struct:dev::solidity::FunctionFlow	access:public
dev::solidity::FunctionFlow::~FunctionFlow	libsolidity/analysis/ControlFlowGraph.h	/^	virtual ~FunctionFlow() = default;$/;"	p	struct:dev::solidity::FunctionFlow	access:public	signature:()
dev::solidity::FunctionType	libsolidity/ast/Types.h	/^class FunctionType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::FunctionType::FunctionType	libsolidity/ast/Types.h	/^	FunctionType($/;"	f	class:dev::solidity::FunctionType	access:public	signature:( TypePointers const& _parameterTypes, TypePointers const& _returnParameterTypes, strings _parameterNames = strings(), strings _returnParameterNames = strings(), Kind _kind = Kind::Internal, bool _arbitraryParameters = false, StateMutability _stateMutability = StateMutability::NonPayable, Declaration const* _declaration = nullptr, bool _gasSet = false, bool _valueSet = false, bool _bound = false )
dev::solidity::FunctionType::FunctionType	libsolidity/ast/Types.h	/^	FunctionType($/;"	f	class:dev::solidity::FunctionType	access:public	signature:( strings const& _parameterTypes, strings const& _returnParameterTypes, Kind _kind = Kind::Internal, bool _arbitraryParameters = false, StateMutability _stateMutability = StateMutability::NonPayable )
dev::solidity::FunctionType::FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(EventDefinition const& _event);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(EventDefinition const& _event)
dev::solidity::FunctionType::FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(FunctionDefinition const& _function, bool _isInternal = true);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionDefinition const& _function, bool _isInternal = true)
dev::solidity::FunctionType::FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(FunctionTypeName const& _typeName);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionTypeName const& _typeName)
dev::solidity::FunctionType::FunctionType	libsolidity/ast/Types.h	/^	explicit FunctionType(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(VariableDeclaration const& _varDecl)
dev::solidity::FunctionType::Kind	libsolidity/ast/Types.h	/^	enum class Kind$/;"	c	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::Kind::ABIDecode	libsolidity/ast/Types.h	/^		ABIDecode,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ABIEncode	libsolidity/ast/Types.h	/^		ABIEncode,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ABIEncodePacked	libsolidity/ast/Types.h	/^		ABIEncodePacked,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ABIEncodeWithSelector	libsolidity/ast/Types.h	/^		ABIEncodeWithSelector,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ABIEncodeWithSignature	libsolidity/ast/Types.h	/^		ABIEncodeWithSignature,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::AddMod	libsolidity/ast/Types.h	/^		AddMod, \/\/\/< ADDMOD$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ArrayPop	libsolidity/ast/Types.h	/^		ArrayPop, \/\/\/< .pop() from a dynamically sized array in storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ArrayPush	libsolidity/ast/Types.h	/^		ArrayPush, \/\/\/< .push() to a dynamically sized array in storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Assert	libsolidity/ast/Types.h	/^		Assert, \/\/\/< assert()$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::BareCall	libsolidity/ast/Types.h	/^		BareCall, \/\/\/< CALL without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::BareCallCode	libsolidity/ast/Types.h	/^		BareCallCode, \/\/\/< CALLCODE without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::BareDelegateCall	libsolidity/ast/Types.h	/^		BareDelegateCall, \/\/\/< DELEGATECALL without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::BareStaticCall	libsolidity/ast/Types.h	/^		BareStaticCall, \/\/\/< STATICCALL without function hash$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::BlockHash	libsolidity/ast/Types.h	/^		BlockHash, \/\/\/< BLOCKHASH$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ByteArrayPush	libsolidity/ast/Types.h	/^		ByteArrayPush, \/\/\/< .push() to a dynamically sized byte array in storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Creation	libsolidity/ast/Types.h	/^		Creation, \/\/\/< external call using CREATE$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::DelegateCall	libsolidity/ast/Types.h	/^		DelegateCall, \/\/\/< external call using DELEGATECALL, i.e. not exchanging the storage$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ECRecover	libsolidity/ast/Types.h	/^		ECRecover, \/\/\/< CALL to special contract for ecrecover$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Event	libsolidity/ast/Types.h	/^		Event, \/\/\/< syntactic sugar for LOG*$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::External	libsolidity/ast/Types.h	/^		External, \/\/\/< external call using CALL$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::GasLeft	libsolidity/ast/Types.h	/^		GasLeft, \/\/\/< gasleft()$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Internal	libsolidity/ast/Types.h	/^		Internal, \/\/\/< stack-call using plain JUMP$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::KECCAK256	libsolidity/ast/Types.h	/^		KECCAK256, \/\/\/< KECCAK256$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Log0	libsolidity/ast/Types.h	/^		Log0,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Log1	libsolidity/ast/Types.h	/^		Log1,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Log2	libsolidity/ast/Types.h	/^		Log2,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Log3	libsolidity/ast/Types.h	/^		Log3,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Log4	libsolidity/ast/Types.h	/^		Log4,$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::MulMod	libsolidity/ast/Types.h	/^		MulMod, \/\/\/< MULMOD$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::ObjectCreation	libsolidity/ast/Types.h	/^		ObjectCreation, \/\/\/< array creation using new$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::RIPEMD160	libsolidity/ast/Types.h	/^		RIPEMD160, \/\/\/< CALL to special contract for ripemd160$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Require	libsolidity/ast/Types.h	/^		Require, \/\/\/< require()$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Revert	libsolidity/ast/Types.h	/^		Revert, \/\/\/< REVERT$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::SHA256	libsolidity/ast/Types.h	/^		SHA256, \/\/\/< CALL to special contract for sha256$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Selfdestruct	libsolidity/ast/Types.h	/^		Selfdestruct, \/\/\/< SELFDESTRUCT$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Send	libsolidity/ast/Types.h	/^		Send, \/\/\/< CALL, but without data and gas$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::SetGas	libsolidity/ast/Types.h	/^		SetGas, \/\/\/< modify the default gas value for the function call$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::SetValue	libsolidity/ast/Types.h	/^		SetValue, \/\/\/< modify the default value transfer for the function call$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::Kind::Transfer	libsolidity/ast/Types.h	/^		Transfer, \/\/\/< CALL, but without data and throws on error$/;"	m	class:dev::solidity::FunctionType::Kind	access:private
dev::solidity::FunctionType::asCallableFunction	libsolidity/ast/Types.h	/^	FunctionTypePointer asCallableFunction(bool _inLibrary, bool _bound = false) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(bool _inLibrary, bool _bound = false) const
dev::solidity::FunctionType::bound	libsolidity/ast/Types.h	/^	bool bound() const { return m_bound; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::canTakeArguments	libsolidity/ast/Types.h	/^	bool canTakeArguments(TypePointers const& _arguments, TypePointer const& _selfType = TypePointer()) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(TypePointers const& _arguments, TypePointer const& _selfType = TypePointer()) const
dev::solidity::FunctionType::copyAndSetGasOrValue	libsolidity/ast/Types.h	/^	TypePointer copyAndSetGasOrValue(bool _setGas, bool _setValue) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(bool _setGas, bool _setValue) const
dev::solidity::FunctionType::declaration	libsolidity/ast/Types.h	/^	Declaration const& declaration() const$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::documentation	libsolidity/ast/Types.h	/^	ASTPointer<ASTString> documentation() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::equalExcludingStateMutability	libsolidity/ast/Types.h	/^	bool equalExcludingStateMutability(FunctionType const& _other) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionType const& _other) const
dev::solidity::FunctionType::externalIdentifier	libsolidity/ast/Types.h	/^	u256 externalIdentifier() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::externalSignature	libsolidity/ast/Types.h	/^	std::string externalSignature() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::gasSet	libsolidity/ast/Types.h	/^	bool gasSet() const { return m_gasSet; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::hasDeclaration	libsolidity/ast/Types.h	/^	bool hasDeclaration() const { return !!m_declaration; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::hasEqualParameterTypes	libsolidity/ast/Types.h	/^	bool hasEqualParameterTypes(FunctionType const& _other) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionType const& _other) const
dev::solidity::FunctionType::hasEqualReturnTypes	libsolidity/ast/Types.h	/^	bool hasEqualReturnTypes(FunctionType const& _other) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionType const& _other) const
dev::solidity::FunctionType::interfaceFunctionType	libsolidity/ast/Types.h	/^	FunctionTypePointer interfaceFunctionType() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::isBareCall	libsolidity/ast/Types.h	/^	bool isBareCall() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::isPayable	libsolidity/ast/Types.h	/^	bool isPayable() const { return m_stateMutability == StateMutability::Payable; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::isPure	libsolidity/ast/Types.h	/^	bool isPure() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::kind	libsolidity/ast/Types.h	/^	Kind const& kind() const { return m_kind; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::m_arbitraryParameters	libsolidity/ast/Types.h	/^	bool const m_arbitraryParameters = false;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_bound	libsolidity/ast/Types.h	/^	bool const m_bound = false; \/\/\/< true iff the function is called as arg1.fun(arg2, ..., argn)$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_declaration	libsolidity/ast/Types.h	/^	Declaration const* m_declaration = nullptr;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_gasSet	libsolidity/ast/Types.h	/^	bool const m_gasSet = false; \/\/\/< true iff the gas value to be used is on the stack$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_kind	libsolidity/ast/Types.h	/^	Kind const m_kind;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_parameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> m_parameterNames;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_parameterTypes	libsolidity/ast/Types.h	/^	TypePointers m_parameterTypes;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_returnParameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> m_returnParameterNames;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_returnParameterTypes	libsolidity/ast/Types.h	/^	TypePointers m_returnParameterTypes;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_stateMutability	libsolidity/ast/Types.h	/^	StateMutability m_stateMutability = StateMutability::NonPayable;$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::m_valueSet	libsolidity/ast/Types.h	/^	bool const m_valueSet = false; \/\/\/< true iff the value to be sent is on the stack$/;"	m	class:dev::solidity::FunctionType	access:private
dev::solidity::FunctionType::newExpressionType	libsolidity/ast/Types.h	/^	static FunctionTypePointer newExpressionType(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(ContractDefinition const& _contract)
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	TypePointer encodingType() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	TypePointer interfaceType(bool _inLibrary) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token, TypePointer const&) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize(bool _padded) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::override	libsolidity/ast/Types.h	/^	unsigned storageBytes() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
dev::solidity::FunctionType::padArguments	libsolidity/ast/Types.h	/^	bool padArguments() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::parameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> parameterNames() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::parameterTypes	libsolidity/ast/Types.h	/^	TypePointers parameterTypes() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::parseElementaryTypeVector	libsolidity/ast/Types.h	/^	static TypePointers parseElementaryTypeVector(strings const& _types);$/;"	p	class:dev::solidity::FunctionType	access:private	signature:(strings const& _types)
dev::solidity::FunctionType::returnParameterTypes	libsolidity/ast/Types.h	/^	TypePointers const& returnParameterTypes() const { return m_returnParameterTypes; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::returnParameterTypesWithoutDynamicTypes	libsolidity/ast/Types.h	/^	TypePointers returnParameterTypesWithoutDynamicTypes() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::selfType	libsolidity/ast/Types.h	/^	TypePointer const& selfType() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::stateMutability	libsolidity/ast/Types.h	/^	StateMutability stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::std::returnParameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> const& returnParameterNames() const { return m_returnParameterNames; }$/;"	f	class:dev::solidity::FunctionType::std	access:public	signature:() const
dev::solidity::FunctionType::takesArbitraryParameters	libsolidity/ast/Types.h	/^	bool takesArbitraryParameters() const { return m_arbitraryParameters; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::takesSinglePackedBytesParameter	libsolidity/ast/Types.h	/^	bool takesSinglePackedBytesParameter() const$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionType::valueSet	libsolidity/ast/Types.h	/^	bool valueSet() const { return m_valueSet; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
dev::solidity::FunctionTypeName	libsolidity/ast/AST.h	/^class FunctionTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
dev::solidity::FunctionTypeName::FunctionTypeName	libsolidity/ast/AST.h	/^	FunctionTypeName($/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:( SourceLocation const& _location, ASTPointer<ParameterList> const& _parameterTypes, ASTPointer<ParameterList> const& _returnTypes, Declaration::Visibility _visibility, StateMutability _stateMutability )
dev::solidity::FunctionTypeName::accept	libsolidity/ast/AST_accept.h	/^void FunctionTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::FunctionTypeName	signature:(ASTConstVisitor& _visitor) const
dev::solidity::FunctionTypeName::accept	libsolidity/ast/AST_accept.h	/^void FunctionTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::FunctionTypeName	signature:(ASTVisitor& _visitor)
dev::solidity::FunctionTypeName::isPayable	libsolidity/ast/AST.h	/^	bool isPayable() const { return m_stateMutability == StateMutability::Payable; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
dev::solidity::FunctionTypeName::m_parameterTypes	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_parameterTypes;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
dev::solidity::FunctionTypeName::m_returnTypes	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_returnTypes;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
dev::solidity::FunctionTypeName::m_stateMutability	libsolidity/ast/AST.h	/^	StateMutability m_stateMutability;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
dev::solidity::FunctionTypeName::m_visibility	libsolidity/ast/AST.h	/^	Declaration::Visibility m_visibility;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
dev::solidity::FunctionTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::FunctionTypeName	access:public
dev::solidity::FunctionTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::FunctionTypeName	access:public
dev::solidity::FunctionTypeName::parameterTypeList	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> const& parameterTypeList() const { return m_parameterTypes; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
dev::solidity::FunctionTypeName::returnParameterTypeList	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> const& returnParameterTypeList() const { return m_returnTypes; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
dev::solidity::FunctionTypeName::stateMutability	libsolidity/ast/AST.h	/^	StateMutability stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
dev::solidity::FunctionTypeName::std::parameterTypes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& parameterTypes() const { return m_parameterTypes->parameters(); }$/;"	f	class:dev::solidity::FunctionTypeName::std	access:public	signature:() const
dev::solidity::FunctionTypeName::std::returnParameterTypes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& returnParameterTypes() const { return m_returnTypes->parameters(); }$/;"	f	class:dev::solidity::FunctionTypeName::std	access:public	signature:() const
dev::solidity::FunctionTypeName::visibility	libsolidity/ast/AST.h	/^	Declaration::Visibility visibility() const$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
dev::solidity::GasEstimator	libsolidity/interface/GasEstimator.h	/^struct GasEstimator$/;"	s	namespace:dev::solidity
dev::solidity::GasEstimator::GasEstimator	libsolidity/interface/GasEstimator.h	/^	explicit GasEstimator(langutil::EVMVersion _evmVersion): m_evmVersion(_evmVersion) {}$/;"	f	struct:dev::solidity::GasEstimator	access:public	signature:(langutil::EVMVersion _evmVersion)
dev::solidity::GasEstimator::breakToStatementLevel	libsolidity/interface/GasEstimator.h	/^	static ASTGasConsumption breakToStatementLevel($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( ASTGasConsumptionSelfAccumulated const& _gasCosts, std::vector<ASTNode const*> const& _roots )
dev::solidity::GasEstimator::finestNodesAtLocation	libsolidity/interface/GasEstimator.h	/^	static std::set<ASTNode const*> finestNodesAtLocation(std::vector<ASTNode const*> const& _roots);$/;"	p	struct:dev::solidity::GasEstimator	access:private	signature:(std::vector<ASTNode const*> const& _roots)
dev::solidity::GasEstimator::functionalEstimation	libsolidity/interface/GasEstimator.h	/^	GasConsumption functionalEstimation($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( eth::AssemblyItems const& _items, size_t const& _offset, FunctionDefinition const& _function ) const
dev::solidity::GasEstimator::functionalEstimation	libsolidity/interface/GasEstimator.h	/^	GasConsumption functionalEstimation($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( eth::AssemblyItems const& _items, std::string const& _signature =  ) const
dev::solidity::GasEstimator::m_evmVersion	libsolidity/interface/GasEstimator.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	struct:dev::solidity::GasEstimator	access:private
dev::solidity::GasEstimator::structuralEstimation	libsolidity/interface/GasEstimator.h	/^	ASTGasConsumptionSelfAccumulated structuralEstimation($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( eth::AssemblyItems const& _items, std::vector<ASTNode const*> const& _ast ) const
dev::solidity::GlobalContext	libsolidity/analysis/GlobalContext.h	/^class GlobalContext: private boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
dev::solidity::GlobalContext::GlobalContext	libsolidity/analysis/GlobalContext.cpp	/^GlobalContext::GlobalContext():$/;"	f	class:dev::solidity::GlobalContext	signature:()
dev::solidity::GlobalContext::GlobalContext	libsolidity/analysis/GlobalContext.h	/^	GlobalContext();$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:()
dev::solidity::GlobalContext::currentSuper	libsolidity/analysis/GlobalContext.cpp	/^MagicVariableDeclaration const* GlobalContext::currentSuper() const$/;"	f	class:dev::solidity::GlobalContext	signature:() const
dev::solidity::GlobalContext::currentSuper	libsolidity/analysis/GlobalContext.h	/^	MagicVariableDeclaration const* currentSuper() const;$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:() const
dev::solidity::GlobalContext::currentThis	libsolidity/analysis/GlobalContext.cpp	/^MagicVariableDeclaration const* GlobalContext::currentThis() const$/;"	f	class:dev::solidity::GlobalContext	signature:() const
dev::solidity::GlobalContext::currentThis	libsolidity/analysis/GlobalContext.h	/^	MagicVariableDeclaration const* currentThis() const;$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:() const
dev::solidity::GlobalContext::declarations	libsolidity/analysis/GlobalContext.cpp	/^vector<Declaration const*> GlobalContext::declarations() const$/;"	f	class:dev::solidity::GlobalContext	signature:() const
dev::solidity::GlobalContext::declarations	libsolidity/analysis/GlobalContext.h	/^	std::vector<Declaration const*> declarations() const;$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:() const
dev::solidity::GlobalContext::m_currentContract	libsolidity/analysis/GlobalContext.h	/^	ContractDefinition const* m_currentContract = nullptr;$/;"	m	class:dev::solidity::GlobalContext	access:private
dev::solidity::GlobalContext::m_magicVariables	libsolidity/analysis/GlobalContext.h	/^	std::vector<std::shared_ptr<MagicVariableDeclaration const>> m_magicVariables;$/;"	m	class:dev::solidity::GlobalContext	access:private
dev::solidity::GlobalContext::setCurrentContract	libsolidity/analysis/GlobalContext.cpp	/^void GlobalContext::setCurrentContract(ContractDefinition const& _contract)$/;"	f	class:dev::solidity::GlobalContext	signature:(ContractDefinition const& _contract)
dev::solidity::GlobalContext::setCurrentContract	libsolidity/analysis/GlobalContext.h	/^	void setCurrentContract(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:(ContractDefinition const& _contract)
dev::solidity::GlobalContext::std::m_superPointer	libsolidity/analysis/GlobalContext.h	/^	std::map<ContractDefinition const*, std::shared_ptr<MagicVariableDeclaration const>> mutable m_superPointer;$/;"	m	class:dev::solidity::GlobalContext::std	access:private
dev::solidity::GlobalContext::std::m_thisPointer	libsolidity/analysis/GlobalContext.h	/^	std::map<ContractDefinition const*, std::shared_ptr<MagicVariableDeclaration const>> mutable m_thisPointer;$/;"	m	class:dev::solidity::GlobalContext::std	access:private
dev::solidity::Identifier	libsolidity/ast/AST.h	/^class Identifier: public PrimaryExpression$/;"	c	namespace:dev::solidity	inherits:PrimaryExpression
dev::solidity::Identifier::Identifier	libsolidity/ast/AST.h	/^	Identifier($/;"	f	class:dev::solidity::Identifier	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name )
dev::solidity::Identifier::accept	libsolidity/ast/AST_accept.h	/^void Identifier::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Identifier	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Identifier::accept	libsolidity/ast/AST_accept.h	/^void Identifier::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Identifier	signature:(ASTVisitor& _visitor)
dev::solidity::Identifier::m_name	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_name;$/;"	m	class:dev::solidity::Identifier	access:private
dev::solidity::Identifier::name	libsolidity/ast/AST.h	/^	ASTString const& name() const { return *m_name; }$/;"	f	class:dev::solidity::Identifier	access:public	signature:() const
dev::solidity::Identifier::override	libsolidity/ast/AST.h	/^	IdentifierAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Identifier	access:public
dev::solidity::Identifier::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Identifier	access:public
dev::solidity::Identifier::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Identifier	access:public
dev::solidity::IdentifierAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct IdentifierAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
dev::solidity::IdentifierAnnotation::overloadedDeclarations	libsolidity/ast/ASTAnnotations.h	/^	std::vector<Declaration const*> overloadedDeclarations;$/;"	m	struct:dev::solidity::IdentifierAnnotation	access:public
dev::solidity::IdentifierAnnotation::referencedDeclaration	libsolidity/ast/ASTAnnotations.h	/^	Declaration const* referencedDeclaration = nullptr;$/;"	m	struct:dev::solidity::IdentifierAnnotation	access:public
dev::solidity::IfStatement	libsolidity/ast/AST.h	/^class IfStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::IfStatement::IfStatement	libsolidity/ast/AST.h	/^	IfStatement($/;"	f	class:dev::solidity::IfStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _condition, ASTPointer<Statement> const& _trueBody, ASTPointer<Statement> const& _falseBody )
dev::solidity::IfStatement::accept	libsolidity/ast/AST_accept.h	/^void IfStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::IfStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::IfStatement::accept	libsolidity/ast/AST_accept.h	/^void IfStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::IfStatement	signature:(ASTVisitor& _visitor)
dev::solidity::IfStatement::condition	libsolidity/ast/AST.h	/^	Expression const& condition() const { return *m_condition; }$/;"	f	class:dev::solidity::IfStatement	access:public	signature:() const
dev::solidity::IfStatement::falseStatement	libsolidity/ast/AST.h	/^	Statement const* falseStatement() const { return m_falseBody.get(); }$/;"	f	class:dev::solidity::IfStatement	access:public	signature:() const
dev::solidity::IfStatement::m_condition	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condition;$/;"	m	class:dev::solidity::IfStatement	access:private
dev::solidity::IfStatement::m_falseBody	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_falseBody; \/\/\/< "else" part, optional$/;"	m	class:dev::solidity::IfStatement	access:private
dev::solidity::IfStatement::m_trueBody	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_trueBody;$/;"	m	class:dev::solidity::IfStatement	access:private
dev::solidity::IfStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::IfStatement	access:public
dev::solidity::IfStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::IfStatement	access:public
dev::solidity::IfStatement::trueStatement	libsolidity/ast/AST.h	/^	Statement const& trueStatement() const { return *m_trueBody; }$/;"	f	class:dev::solidity::IfStatement	access:public	signature:() const
dev::solidity::ImplementationOptional	libsolidity/ast/AST.h	/^class ImplementationOptional$/;"	c	namespace:dev::solidity
dev::solidity::ImplementationOptional::ImplementationOptional	libsolidity/ast/AST.h	/^	explicit ImplementationOptional(bool _implemented): m_implemented(_implemented) {}$/;"	f	class:dev::solidity::ImplementationOptional	access:public	signature:(bool _implemented)
dev::solidity::ImplementationOptional::isImplemented	libsolidity/ast/AST.h	/^	bool isImplemented() const { return m_implemented; }$/;"	f	class:dev::solidity::ImplementationOptional	access:public	signature:() const
dev::solidity::ImplementationOptional::m_implemented	libsolidity/ast/AST.h	/^	bool m_implemented;$/;"	m	class:dev::solidity::ImplementationOptional	access:protected
dev::solidity::ImplementationOptional::~ImplementationOptional	libsolidity/ast/AST.h	/^	virtual ~ImplementationOptional() = default;$/;"	p	class:dev::solidity::ImplementationOptional	access:public	signature:()
dev::solidity::ImportAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ImportAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
dev::solidity::ImportAnnotation::absolutePath	libsolidity/ast/ASTAnnotations.h	/^	std::string absolutePath;$/;"	m	struct:dev::solidity::ImportAnnotation	access:public
dev::solidity::ImportAnnotation::sourceUnit	libsolidity/ast/ASTAnnotations.h	/^	SourceUnit const* sourceUnit = nullptr;$/;"	m	struct:dev::solidity::ImportAnnotation	access:public
dev::solidity::ImportDirective	libsolidity/ast/AST.h	/^class ImportDirective: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
dev::solidity::ImportDirective::ImportDirective	libsolidity/ast/AST.h	/^	ImportDirective($/;"	f	class:dev::solidity::ImportDirective	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _path, ASTPointer<ASTString> const& _unitAlias, std::vector<std::pair<ASTPointer<Identifier>, ASTPointer<ASTString>>>&& _symbolAliases )
dev::solidity::ImportDirective::accept	libsolidity/ast/AST_accept.h	/^void ImportDirective::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ImportDirective	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ImportDirective::accept	libsolidity/ast/AST_accept.h	/^void ImportDirective::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ImportDirective	signature:(ASTVisitor& _visitor)
dev::solidity::ImportDirective::m_path	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_path;$/;"	m	class:dev::solidity::ImportDirective	access:private
dev::solidity::ImportDirective::m_symbolAliases	libsolidity/ast/AST.h	/^	std::vector<std::pair<ASTPointer<Identifier>, ASTPointer<ASTString>>> m_symbolAliases;$/;"	m	class:dev::solidity::ImportDirective	access:private
dev::solidity::ImportDirective::override	libsolidity/ast/AST.h	/^	ImportAnnotation& annotation() const override;$/;"	m	class:dev::solidity::ImportDirective	access:public
dev::solidity::ImportDirective::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::ImportDirective	access:public
dev::solidity::ImportDirective::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ImportDirective	access:public
dev::solidity::ImportDirective::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ImportDirective	access:public
dev::solidity::ImportDirective::path	libsolidity/ast/AST.h	/^	ASTString const& path() const { return *m_path; }$/;"	f	class:dev::solidity::ImportDirective	access:public	signature:() const
dev::solidity::ImportDirective::std::symbolAliases	libsolidity/ast/AST.h	/^	std::vector<std::pair<ASTPointer<Identifier>, ASTPointer<ASTString>>> const& symbolAliases() const$/;"	f	class:dev::solidity::ImportDirective::std	access:public	signature:() const
dev::solidity::InaccessibleDynamicType	libsolidity/ast/Types.h	/^class InaccessibleDynamicType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::IndexAccess	libsolidity/ast/AST.h	/^class IndexAccess: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::IndexAccess::IndexAccess	libsolidity/ast/AST.h	/^	IndexAccess($/;"	f	class:dev::solidity::IndexAccess	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> const& _base, ASTPointer<Expression> const& _index )
dev::solidity::IndexAccess::accept	libsolidity/ast/AST_accept.h	/^void IndexAccess::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::IndexAccess	signature:(ASTConstVisitor& _visitor) const
dev::solidity::IndexAccess::accept	libsolidity/ast/AST_accept.h	/^void IndexAccess::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::IndexAccess	signature:(ASTVisitor& _visitor)
dev::solidity::IndexAccess::baseExpression	libsolidity/ast/AST.h	/^	Expression const& baseExpression() const { return *m_base; }$/;"	f	class:dev::solidity::IndexAccess	access:public	signature:() const
dev::solidity::IndexAccess::indexExpression	libsolidity/ast/AST.h	/^	Expression const* indexExpression() const { return m_index.get(); }$/;"	f	class:dev::solidity::IndexAccess	access:public	signature:() const
dev::solidity::IndexAccess::m_base	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_base;$/;"	m	class:dev::solidity::IndexAccess	access:private
dev::solidity::IndexAccess::m_index	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_index;$/;"	m	class:dev::solidity::IndexAccess	access:private
dev::solidity::IndexAccess::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::IndexAccess	access:public
dev::solidity::IndexAccess::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::IndexAccess	access:public
dev::solidity::InheritanceSpecifier	libsolidity/ast/AST.h	/^class InheritanceSpecifier: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::InheritanceSpecifier::InheritanceSpecifier	libsolidity/ast/AST.h	/^	InheritanceSpecifier($/;"	f	class:dev::solidity::InheritanceSpecifier	access:public	signature:( SourceLocation const& _location, ASTPointer<UserDefinedTypeName> const& _baseName, std::unique_ptr<std::vector<ASTPointer<Expression>>> _arguments )
dev::solidity::InheritanceSpecifier::accept	libsolidity/ast/AST_accept.h	/^void InheritanceSpecifier::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::InheritanceSpecifier	signature:(ASTConstVisitor& _visitor) const
dev::solidity::InheritanceSpecifier::accept	libsolidity/ast/AST_accept.h	/^void InheritanceSpecifier::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::InheritanceSpecifier	signature:(ASTVisitor& _visitor)
dev::solidity::InheritanceSpecifier::m_arguments	libsolidity/ast/AST.h	/^	std::unique_ptr<std::vector<ASTPointer<Expression>>> m_arguments;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:private
dev::solidity::InheritanceSpecifier::m_baseName	libsolidity/ast/AST.h	/^	ASTPointer<UserDefinedTypeName> m_baseName;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:private
dev::solidity::InheritanceSpecifier::name	libsolidity/ast/AST.h	/^	UserDefinedTypeName const& name() const { return *m_baseName; }$/;"	f	class:dev::solidity::InheritanceSpecifier	access:public	signature:() const
dev::solidity::InheritanceSpecifier::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:public
dev::solidity::InheritanceSpecifier::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:public
dev::solidity::InheritanceSpecifier::std::arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> const* arguments() const { return m_arguments.get(); }$/;"	f	class:dev::solidity::InheritanceSpecifier::std	access:public	signature:() const
dev::solidity::InlineAssembly	libsolidity/ast/AST.h	/^class InlineAssembly: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::InlineAssembly::InlineAssembly	libsolidity/ast/AST.h	/^	InlineAssembly($/;"	f	class:dev::solidity::InlineAssembly	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, std::shared_ptr<yul::Block> const& _operations )
dev::solidity::InlineAssembly::accept	libsolidity/ast/AST_accept.h	/^void InlineAssembly::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::InlineAssembly	signature:(ASTConstVisitor& _visitor) const
dev::solidity::InlineAssembly::accept	libsolidity/ast/AST_accept.h	/^void InlineAssembly::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::InlineAssembly	signature:(ASTVisitor& _visitor)
dev::solidity::InlineAssembly::m_operations	libsolidity/ast/AST.h	/^	std::shared_ptr<yul::Block> m_operations;$/;"	m	class:dev::solidity::InlineAssembly	access:private
dev::solidity::InlineAssembly::override	libsolidity/ast/AST.h	/^	InlineAssemblyAnnotation& annotation() const override;$/;"	m	class:dev::solidity::InlineAssembly	access:public
dev::solidity::InlineAssembly::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::InlineAssembly	access:public
dev::solidity::InlineAssembly::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::InlineAssembly	access:public
dev::solidity::InlineAssembly::yul::operations	libsolidity/ast/AST.h	/^	yul::Block const& operations() const { return *m_operations; }$/;"	f	class:dev::solidity::InlineAssembly::yul	access:public	signature:() const
dev::solidity::InlineAssemblyAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct InlineAssemblyAnnotation: StatementAnnotation$/;"	s	namespace:dev::solidity	inherits:StatementAnnotation
dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	libsolidity/ast/ASTAnnotations.h	/^	struct ExternalIdentifierInfo$/;"	s	struct:dev::solidity::InlineAssemblyAnnotation	access:public
dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo::declaration	libsolidity/ast/ASTAnnotations.h	/^		Declaration const* declaration = nullptr;$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo::isOffset	libsolidity/ast/ASTAnnotations.h	/^		bool isOffset = false; \/\/\/< Whether the intra-slot offset of a storage variable is queried.$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo::isSlot	libsolidity/ast/ASTAnnotations.h	/^		bool isSlot = false; \/\/\/< Whether the storage slot of a variable is queried.$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo::valueSize	libsolidity/ast/ASTAnnotations.h	/^		size_t valueSize = size_t(-1);$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
dev::solidity::InlineAssemblyAnnotation::analysisInfo	libsolidity/ast/ASTAnnotations.h	/^	std::shared_ptr<yul::AsmAnalysisInfo> analysisInfo;$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation	access:public
dev::solidity::InlineAssemblyAnnotation::externalReferences	libsolidity/ast/ASTAnnotations.h	/^	std::map<yul::Identifier const*, ExternalIdentifierInfo> externalReferences;$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation	access:public
dev::solidity::Instruction	libevmasm/Instruction.h	/^enum class Instruction: uint8_t$/;"	c	namespace:dev::solidity	inherits:uint8_t
dev::solidity::Instruction	libyul/backends/evm/AbstractAssembly.h	/^enum class Instruction: uint8_t;$/;"	c	namespace:dev::solidity	inherits:uint8_t,yul
dev::solidity::Instruction::ADD	libevmasm/Instruction.h	/^	ADD,				\/\/\/< addition operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::ADDMOD	libevmasm/Instruction.h	/^	ADDMOD,				\/\/\/< unsigned modular addition$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::ADDRESS	libevmasm/Instruction.h	/^	ADDRESS = 0x30,		\/\/\/< get address of currently executing account$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::AND	libevmasm/Instruction.h	/^	AND,				\/\/\/< bitwise AND operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::AbstractAssembly	libyul/backends/evm/AbstractAssembly.h	/^class AbstractAssembly$/;"	c	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::AbstractAssembly::appendAssemblySize	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendAssemblySize() = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:()
dev::solidity::Instruction::AbstractAssembly::appendBeginsub	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendBeginsub(LabelID _labelId, int _arguments) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId, int _arguments)
dev::solidity::Instruction::AbstractAssembly::appendConstant	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendConstant(dev::u256 const& _constant) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(dev::u256 const& _constant)
dev::solidity::Instruction::AbstractAssembly::appendData	libyul/backends/evm/AbstractAssembly.h	/^	virtual SubID appendData(dev::bytes const& _data) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(dev::bytes const& _data)
dev::solidity::Instruction::AbstractAssembly::appendDataOffset	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendDataOffset(SubID _sub) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(SubID _sub)
dev::solidity::Instruction::AbstractAssembly::appendDataSize	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendDataSize(SubID _sub) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(SubID _sub)
dev::solidity::Instruction::AbstractAssembly::appendInstruction	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendInstruction(dev::solidity::Instruction _instruction) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(dev::solidity::Instruction _instruction)
dev::solidity::Instruction::AbstractAssembly::appendJump	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJump(int _stackDiffAfter) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(int _stackDiffAfter)
dev::solidity::Instruction::AbstractAssembly::appendJumpTo	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJumpTo(LabelID _labelId, int _stackDiffAfter = 0) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId, int _stackDiffAfter = 0)
dev::solidity::Instruction::AbstractAssembly::appendJumpToIf	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJumpToIf(LabelID _labelId) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId)
dev::solidity::Instruction::AbstractAssembly::appendJumpsub	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendJumpsub(LabelID _labelId, int _arguments, int _returns) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId, int _arguments, int _returns)
dev::solidity::Instruction::AbstractAssembly::appendLabel	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendLabel(LabelID _labelId) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId)
dev::solidity::Instruction::AbstractAssembly::appendLabelReference	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendLabelReference(LabelID _labelId) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(LabelID _labelId)
dev::solidity::Instruction::AbstractAssembly::appendLinkerSymbol	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendLinkerSymbol(std::string const& _name) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(std::string const& _name)
dev::solidity::Instruction::AbstractAssembly::appendReturnsub	libyul/backends/evm/AbstractAssembly.h	/^	virtual void appendReturnsub(int _returns, int _stackDiffAfter = 0) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(int _returns, int _stackDiffAfter = 0)
dev::solidity::Instruction::AbstractAssembly::createSubAssembly	libyul/backends/evm/AbstractAssembly.h	/^	virtual std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:()
dev::solidity::Instruction::AbstractAssembly::namedLabel	libyul/backends/evm/AbstractAssembly.h	/^	virtual LabelID namedLabel(std::string const& _name) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(std::string const& _name)
dev::solidity::Instruction::AbstractAssembly::newLabelId	libyul/backends/evm/AbstractAssembly.h	/^	virtual LabelID newLabelId() = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:()
dev::solidity::Instruction::AbstractAssembly::setSourceLocation	libyul/backends/evm/AbstractAssembly.h	/^	virtual void setSourceLocation(langutil::SourceLocation const& _location) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(langutil::SourceLocation const& _location)
dev::solidity::Instruction::AbstractAssembly::stackHeight	libyul/backends/evm/AbstractAssembly.h	/^	virtual int stackHeight() const = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:() const
dev::solidity::Instruction::BALANCE	libevmasm/Instruction.h	/^	BALANCE,			\/\/\/< get balance of the given account$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::BEGINDATA	libevmasm/Instruction.h	/^	BEGINDATA,          \/\/\/< begin the data section -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::BEGINSUB	libevmasm/Instruction.h	/^	BEGINSUB,           \/\/\/< set a potential jumpsub destination -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::BLOCKHASH	libevmasm/Instruction.h	/^	BLOCKHASH = 0x40,	\/\/\/< get hash of most recent complete block$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::BYTE	libevmasm/Instruction.h	/^	BYTE,				\/\/\/< retrieve single byte from word$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALL	libevmasm/Instruction.h	/^	CALL,				\/\/\/< message-call into an account$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALLCODE	libevmasm/Instruction.h	/^	CALLCODE,			\/\/\/< message-call with another account's code only$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALLDATACOPY	libevmasm/Instruction.h	/^	CALLDATACOPY,		\/\/\/< copy input data in current environment to memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALLDATALOAD	libevmasm/Instruction.h	/^	CALLDATALOAD,		\/\/\/< get input data of current environment$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALLDATASIZE	libevmasm/Instruction.h	/^	CALLDATASIZE,		\/\/\/< get size of input data in current environment$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALLER	libevmasm/Instruction.h	/^	CALLER,				\/\/\/< get caller address$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CALLVALUE	libevmasm/Instruction.h	/^	CALLVALUE,			\/\/\/< get deposited value by the instruction\/transaction responsible for this execution$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CODECOPY	libevmasm/Instruction.h	/^	CODECOPY,			\/\/\/< copy code running in current environment to memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CODESIZE	libevmasm/Instruction.h	/^	CODESIZE,			\/\/\/< get size of code running in current environment$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::COINBASE	libevmasm/Instruction.h	/^	COINBASE,			\/\/\/< get the block's coinbase address$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CREATE	libevmasm/Instruction.h	/^	CREATE = 0xf0,		\/\/\/< create a new account with associated code$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::CREATE2	libevmasm/Instruction.h	/^	CREATE2 = 0xf5,		\/\/\/< create new account with associated code at address `sha3(0xff + sender + salt + init code) % 2**160`$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DELEGATECALL	libevmasm/Instruction.h	/^	DELEGATECALL,		\/\/\/< like CALLCODE but keeps caller's value and sender$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DIFFICULTY	libevmasm/Instruction.h	/^	DIFFICULTY,			\/\/\/< get the block's difficulty$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DIV	libevmasm/Instruction.h	/^	DIV,				\/\/\/< integer division operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP1	libevmasm/Instruction.h	/^	DUP1 = 0x80,		\/\/\/< copies the highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP10	libevmasm/Instruction.h	/^	DUP10,				\/\/\/< copies the 10th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP11	libevmasm/Instruction.h	/^	DUP11,				\/\/\/< copies the 11th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP12	libevmasm/Instruction.h	/^	DUP12,				\/\/\/< copies the 12th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP13	libevmasm/Instruction.h	/^	DUP13,				\/\/\/< copies the 13th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP14	libevmasm/Instruction.h	/^	DUP14,				\/\/\/< copies the 14th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP15	libevmasm/Instruction.h	/^	DUP15,				\/\/\/< copies the 15th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP16	libevmasm/Instruction.h	/^	DUP16,				\/\/\/< copies the 16th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP2	libevmasm/Instruction.h	/^	DUP2,				\/\/\/< copies the second highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP3	libevmasm/Instruction.h	/^	DUP3,				\/\/\/< copies the third highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP4	libevmasm/Instruction.h	/^	DUP4,				\/\/\/< copies the 4th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP5	libevmasm/Instruction.h	/^	DUP5,				\/\/\/< copies the 5th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP6	libevmasm/Instruction.h	/^	DUP6,				\/\/\/< copies the 6th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP7	libevmasm/Instruction.h	/^	DUP7,				\/\/\/< copies the 7th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP8	libevmasm/Instruction.h	/^	DUP8,				\/\/\/< copies the 8th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::DUP9	libevmasm/Instruction.h	/^	DUP9,				\/\/\/< copies the 9th highest item in the stack to the top of the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::EQ	libevmasm/Instruction.h	/^	EQ,					\/\/\/< equality comparison$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::EXP	libevmasm/Instruction.h	/^	EXP,				\/\/\/< exponential operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::EXTCODECOPY	libevmasm/Instruction.h	/^	EXTCODECOPY,		\/\/\/< copy external code (from another contract)$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::EXTCODEHASH	libevmasm/Instruction.h	/^	EXTCODEHASH = 0x3f,	\/\/\/< get external code hash (from another contract)$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::EXTCODESIZE	libevmasm/Instruction.h	/^	EXTCODESIZE,		\/\/\/< get external code size (from another contract)$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::ExternalIdentifierAccess	libyul/backends/evm/AbstractAssembly.h	/^struct ExternalIdentifierAccess$/;"	s	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::GAS	libevmasm/Instruction.h	/^	GAS,				\/\/\/< get the amount of available gas$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::GASLIMIT	libevmasm/Instruction.h	/^	GASLIMIT,			\/\/\/< get the block's gas limit$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::GASPRICE	libevmasm/Instruction.h	/^	GASPRICE,			\/\/\/< get price of gas in current environment$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::GETLOCAL	libevmasm/Instruction.h	/^	GETLOCAL,           \/\/\/< push local variable to top of stack -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::GT	libevmasm/Instruction.h	/^	GT,					\/\/\/< greater-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::INVALID	libevmasm/Instruction.h	/^	INVALID = 0xfe,		\/\/\/< invalid instruction for expressing runtime errors (e.g., division-by-zero)$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::ISZERO	libevmasm/Instruction.h	/^	ISZERO,				\/\/\/< simple not operator$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::IdentifierContext	libyul/backends/evm/AbstractAssembly.h	/^enum class IdentifierContext { LValue, RValue };$/;"	c	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::IdentifierContext::LValue	libyul/backends/evm/AbstractAssembly.h	/^enum class IdentifierContext { LValue, RValue };$/;"	m	class:dev::solidity::Instruction::IdentifierContext	access:private
dev::solidity::Instruction::InstructionInfo	libevmasm/Instruction.h	/^struct InstructionInfo$/;"	s	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::InstructionInfo::additional	libevmasm/Instruction.h	/^	int additional;		\/\/\/< Additional items required in memory for this instructions (only for PUSH).$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
dev::solidity::Instruction::InstructionInfo::args	libevmasm/Instruction.h	/^	int args;			\/\/\/< Number of items required on the stack for this instruction (and, for the purposes of ret, the number taken from the stack).$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
dev::solidity::Instruction::InstructionInfo::gasPriceTier	libevmasm/Instruction.h	/^	Tier gasPriceTier;	\/\/\/< Tier for gas pricing.$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
dev::solidity::Instruction::InstructionInfo::name	libevmasm/Instruction.h	/^	std::string name;	\/\/\/< The name of the instruction.$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
dev::solidity::Instruction::InstructionInfo::ret	libevmasm/Instruction.h	/^	int ret;			\/\/\/< Number of items placed (back) on the stack by this instruction, assuming args items were removed.$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
dev::solidity::Instruction::InstructionInfo::sideEffects	libevmasm/Instruction.h	/^	bool sideEffects;	\/\/\/< false if the only effect on the execution environment (apart from gas usage) is a change to a topmost segment of the stack$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
dev::solidity::Instruction::JUMP	libevmasm/Instruction.h	/^	JUMP,				\/\/\/< alter the program counter$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPDEST	libevmasm/Instruction.h	/^	JUMPDEST,			\/\/\/< set a potential jump destination$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPI	libevmasm/Instruction.h	/^	JUMPI,				\/\/\/< conditionally alter the program counter$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPIF	libevmasm/Instruction.h	/^	JUMPIF,             \/\/\/< conditionally alter the program counter -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPSUB	libevmasm/Instruction.h	/^	JUMPSUB,            \/\/\/< alter the program counter to a beginsub -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPSUBV	libevmasm/Instruction.h	/^	JUMPSUBV,           \/\/\/< alter the program counter to a beginsub -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPTO	libevmasm/Instruction.h	/^	JUMPTO = 0xb0,      \/\/\/< alter the program counter to a jumpdest -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::JUMPV	libevmasm/Instruction.h	/^	JUMPV,              \/\/\/< alter the program counter to a jumpdest -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::KECCAK256	libevmasm/Instruction.h	/^	KECCAK256 = 0x20,		\/\/\/< compute KECCAK-256 hash$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::LOG0	libevmasm/Instruction.h	/^	LOG0 = 0xa0,		\/\/\/< Makes a log entry; no topics.$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::LOG1	libevmasm/Instruction.h	/^	LOG1,				\/\/\/< Makes a log entry; 1 topic.$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::LOG2	libevmasm/Instruction.h	/^	LOG2,				\/\/\/< Makes a log entry; 2 topics.$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::LOG3	libevmasm/Instruction.h	/^	LOG3,				\/\/\/< Makes a log entry; 3 topics.$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::LOG4	libevmasm/Instruction.h	/^	LOG4,				\/\/\/< Makes a log entry; 4 topics.$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::LT	libevmasm/Instruction.h	/^	LT = 0x10,			\/\/\/< less-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MLOAD	libevmasm/Instruction.h	/^	MLOAD,				\/\/\/< load word from memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MOD	libevmasm/Instruction.h	/^	MOD,				\/\/\/< modulo remainder operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MSIZE	libevmasm/Instruction.h	/^	MSIZE,				\/\/\/< get the size of active memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MSTORE	libevmasm/Instruction.h	/^	MSTORE,				\/\/\/< save word to memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MSTORE8	libevmasm/Instruction.h	/^	MSTORE8,			\/\/\/< save byte to memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MUL	libevmasm/Instruction.h	/^	MUL,				\/\/\/< multiplication operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::MULMOD	libevmasm/Instruction.h	/^	MULMOD,				\/\/\/< unsigned modular multiplication$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::NOT	libevmasm/Instruction.h	/^	NOT,				\/\/\/< bitwise NOT operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::NUMBER	libevmasm/Instruction.h	/^	NUMBER,				\/\/\/< get the block's number$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::OR	libevmasm/Instruction.h	/^	OR,					\/\/\/< bitwise OR operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::ORIGIN	libevmasm/Instruction.h	/^	ORIGIN,				\/\/\/< get execution origination address$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PC	libevmasm/Instruction.h	/^	PC,					\/\/\/< get the program counter$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::POP	libevmasm/Instruction.h	/^	POP = 0x50,			\/\/\/< remove item from stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH1	libevmasm/Instruction.h	/^	PUSH1 = 0x60,		\/\/\/< place 1 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH10	libevmasm/Instruction.h	/^	PUSH10,				\/\/\/< place 10 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH11	libevmasm/Instruction.h	/^	PUSH11,				\/\/\/< place 11 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH12	libevmasm/Instruction.h	/^	PUSH12,				\/\/\/< place 12 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH13	libevmasm/Instruction.h	/^	PUSH13,				\/\/\/< place 13 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH14	libevmasm/Instruction.h	/^	PUSH14,				\/\/\/< place 14 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH15	libevmasm/Instruction.h	/^	PUSH15,				\/\/\/< place 15 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH16	libevmasm/Instruction.h	/^	PUSH16,				\/\/\/< place 16 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH17	libevmasm/Instruction.h	/^	PUSH17,				\/\/\/< place 17 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH18	libevmasm/Instruction.h	/^	PUSH18,				\/\/\/< place 18 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH19	libevmasm/Instruction.h	/^	PUSH19,				\/\/\/< place 19 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH2	libevmasm/Instruction.h	/^	PUSH2,				\/\/\/< place 2 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH20	libevmasm/Instruction.h	/^	PUSH20,				\/\/\/< place 20 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH21	libevmasm/Instruction.h	/^	PUSH21,				\/\/\/< place 21 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH22	libevmasm/Instruction.h	/^	PUSH22,				\/\/\/< place 22 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH23	libevmasm/Instruction.h	/^	PUSH23,				\/\/\/< place 23 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH24	libevmasm/Instruction.h	/^	PUSH24,				\/\/\/< place 24 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH25	libevmasm/Instruction.h	/^	PUSH25,				\/\/\/< place 25 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH26	libevmasm/Instruction.h	/^	PUSH26,				\/\/\/< place 26 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH27	libevmasm/Instruction.h	/^	PUSH27,				\/\/\/< place 27 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH28	libevmasm/Instruction.h	/^	PUSH28,				\/\/\/< place 28 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH29	libevmasm/Instruction.h	/^	PUSH29,				\/\/\/< place 29 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH3	libevmasm/Instruction.h	/^	PUSH3,				\/\/\/< place 3 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH30	libevmasm/Instruction.h	/^	PUSH30,				\/\/\/< place 30 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH31	libevmasm/Instruction.h	/^	PUSH31,				\/\/\/< place 31 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH32	libevmasm/Instruction.h	/^	PUSH32,				\/\/\/< place 32 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH4	libevmasm/Instruction.h	/^	PUSH4,				\/\/\/< place 4 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH5	libevmasm/Instruction.h	/^	PUSH5,				\/\/\/< place 5 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH6	libevmasm/Instruction.h	/^	PUSH6,				\/\/\/< place 6 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH7	libevmasm/Instruction.h	/^	PUSH7,				\/\/\/< place 7 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH8	libevmasm/Instruction.h	/^	PUSH8,				\/\/\/< place 8 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUSH9	libevmasm/Instruction.h	/^	PUSH9,				\/\/\/< place 9 byte item on stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::PUTLOCAL	libevmasm/Instruction.h	/^	PUTLOCAL,           \/\/\/< pop top of stack to local variable -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::RETURN	libevmasm/Instruction.h	/^	RETURN,				\/\/\/< halt execution returning output data$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::RETURNDATACOPY	libevmasm/Instruction.h	/^	RETURNDATACOPY = 0x3e,	\/\/\/< copy return data in current environment to memory$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::RETURNDATASIZE	libevmasm/Instruction.h	/^	RETURNDATASIZE = 0x3d,	\/\/\/< get size of return data buffer$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::RETURNSUB	libevmasm/Instruction.h	/^	RETURNSUB,          \/\/\/< return to subroutine jumped from -- not part of Instructions.cpp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::REVERT	libevmasm/Instruction.h	/^	REVERT = 0xfd,		\/\/\/< halt execution, revert state and return output data$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SAR	libevmasm/Instruction.h	/^	SAR,				\/\/\/< bitwise SAR operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SDIV	libevmasm/Instruction.h	/^	SDIV,				\/\/\/< signed integer division operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SELFDESTRUCT	libevmasm/Instruction.h	/^	SELFDESTRUCT = 0xff	\/\/\/< halt execution and register account for later deletion$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SGT	libevmasm/Instruction.h	/^	SGT,				\/\/\/< signed greater-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SHL	libevmasm/Instruction.h	/^	SHL,				\/\/\/< bitwise SHL operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SHR	libevmasm/Instruction.h	/^	SHR,				\/\/\/< bitwise SHR operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SIGNEXTEND	libevmasm/Instruction.h	/^	SIGNEXTEND,			\/\/\/< extend length of signed integer$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SLOAD	libevmasm/Instruction.h	/^	SLOAD,				\/\/\/< load word from storage$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SLT	libevmasm/Instruction.h	/^	SLT,				\/\/\/< signed less-than comparison$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SMOD	libevmasm/Instruction.h	/^	SMOD,				\/\/\/< signed modulo remainder operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SSTORE	libevmasm/Instruction.h	/^	SSTORE,				\/\/\/< save word to storage$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::STATICCALL	libevmasm/Instruction.h	/^	STATICCALL = 0xfa,	\/\/\/< like CALL but disallow state modifications$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::STOP	libevmasm/Instruction.h	/^	STOP = 0x00,		\/\/\/< halts execution$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SUB	libevmasm/Instruction.h	/^	SUB,				\/\/\/< subtraction operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP1	libevmasm/Instruction.h	/^	SWAP1 = 0x90,		\/\/\/< swaps the highest and second highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP10	libevmasm/Instruction.h	/^	SWAP10,				\/\/\/< swaps the highest and 11th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP11	libevmasm/Instruction.h	/^	SWAP11,				\/\/\/< swaps the highest and 12th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP12	libevmasm/Instruction.h	/^	SWAP12,				\/\/\/< swaps the highest and 13th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP13	libevmasm/Instruction.h	/^	SWAP13,				\/\/\/< swaps the highest and 14th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP14	libevmasm/Instruction.h	/^	SWAP14,				\/\/\/< swaps the highest and 15th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP15	libevmasm/Instruction.h	/^	SWAP15,				\/\/\/< swaps the highest and 16th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP16	libevmasm/Instruction.h	/^	SWAP16,				\/\/\/< swaps the highest and 17th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP2	libevmasm/Instruction.h	/^	SWAP2,				\/\/\/< swaps the highest and third highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP3	libevmasm/Instruction.h	/^	SWAP3,				\/\/\/< swaps the highest and 4th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP4	libevmasm/Instruction.h	/^	SWAP4,				\/\/\/< swaps the highest and 5th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP5	libevmasm/Instruction.h	/^	SWAP5,				\/\/\/< swaps the highest and 6th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP6	libevmasm/Instruction.h	/^	SWAP6,				\/\/\/< swaps the highest and 7th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP7	libevmasm/Instruction.h	/^	SWAP7,				\/\/\/< swaps the highest and 8th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP8	libevmasm/Instruction.h	/^	SWAP8,				\/\/\/< swaps the highest and 9th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::SWAP9	libevmasm/Instruction.h	/^	SWAP9,				\/\/\/< swaps the highest and 10th highest value on the stack$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::TIMESTAMP	libevmasm/Instruction.h	/^	TIMESTAMP,			\/\/\/< get the block's timestamp$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::Tier	libevmasm/Instruction.h	/^enum class Tier : unsigned$/;"	c	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::Tier::Balance	libevmasm/Instruction.h	/^	Balance,	\/\/ 400, Balance$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::Base	libevmasm/Instruction.h	/^	Base,		\/\/ 2, Quick$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::Ext	libevmasm/Instruction.h	/^	Ext,		\/\/ 20, Ext$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::ExtCode	libevmasm/Instruction.h	/^	ExtCode,	\/\/ 700, Extcode$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::High	libevmasm/Instruction.h	/^	High,		\/\/ 10, Slow$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::Low	libevmasm/Instruction.h	/^	Low,		\/\/ 5, Fast$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::Mid	libevmasm/Instruction.h	/^	Mid,		\/\/ 8, Mid$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::Special	libevmasm/Instruction.h	/^	Special,	\/\/ multiparam or otherwise special$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::VeryLow	libevmasm/Instruction.h	/^	VeryLow,	\/\/ 3, Fastest$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::Tier::Zero	libevmasm/Instruction.h	/^	Zero = 0,	\/\/ 0, Zero$/;"	m	class:dev::solidity::Instruction::Tier	access:private
dev::solidity::Instruction::XOR	libevmasm/Instruction.h	/^	XOR,				\/\/\/< bitwise XOR operation$/;"	m	class:dev::solidity::Instruction	access:private
dev::solidity::Instruction::disassemble	libevmasm/Instruction.h	/^std::string disassemble(bytes const& _mem);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(bytes const& _mem)
dev::solidity::Instruction::dupInstruction	libevmasm/Instruction.h	/^inline Instruction dupInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
dev::solidity::Instruction::eachInstruction	libevmasm/Instruction.h	/^void eachInstruction(bytes const& _mem, std::function<void(Instruction,u256 const&)> const& _onInstruction);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(bytes const& _mem, std::function<void(Instruction,u256 const&)> const& _onInstruction)
dev::solidity::Instruction::getDupNumber	libevmasm/Instruction.h	/^inline unsigned getDupNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::getLogNumber	libevmasm/Instruction.h	/^inline unsigned getLogNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::getPushNumber	libevmasm/Instruction.h	/^inline unsigned getPushNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::getSwapNumber	libevmasm/Instruction.h	/^inline unsigned getSwapNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::instructionInfo	libevmasm/Instruction.h	/^InstructionInfo instructionInfo(Instruction _inst);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::isDupInstruction	libevmasm/Instruction.h	/^inline bool isDupInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::isLogInstruction	libevmasm/Instruction.h	/^inline bool isLogInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::isPushInstruction	libevmasm/Instruction.h	/^inline bool isPushInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::isSwapInstruction	libevmasm/Instruction.h	/^inline bool isSwapInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::isValidInstruction	libevmasm/Instruction.h	/^bool isValidInstruction(Instruction _inst);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
dev::solidity::Instruction::logInstruction	libevmasm/Instruction.h	/^inline Instruction logInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
dev::solidity::Instruction::pushInstruction	libevmasm/Instruction.h	/^inline Instruction pushInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
dev::solidity::Instruction::swapInstruction	libevmasm/Instruction.h	/^inline Instruction swapInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
dev::solidity::IntegerType	libsolidity/ast/Types.h	/^class IntegerType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::IntegerType::IntegerType	libsolidity/ast/Types.h	/^	explicit IntegerType(unsigned _bits, Modifier _modifier = Modifier::Unsigned);$/;"	p	class:dev::solidity::IntegerType	access:public	signature:(unsigned _bits, Modifier _modifier = Modifier::Unsigned)
dev::solidity::IntegerType::Modifier	libsolidity/ast/Types.h	/^	enum class Modifier$/;"	c	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::Modifier::Unsigned	libsolidity/ast/Types.h	/^		Unsigned, Signed$/;"	m	class:dev::solidity::IntegerType::Modifier	access:private
dev::solidity::IntegerType::isSigned	libsolidity/ast/Types.h	/^	bool isSigned() const { return m_modifier == Modifier::Signed; }$/;"	f	class:dev::solidity::IntegerType	access:public	signature:() const
dev::solidity::IntegerType::m_bits	libsolidity/ast/Types.h	/^	unsigned m_bits;$/;"	m	class:dev::solidity::IntegerType	access:private
dev::solidity::IntegerType::m_modifier	libsolidity/ast/Types.h	/^	Modifier m_modifier;$/;"	m	class:dev::solidity::IntegerType	access:private
dev::solidity::IntegerType::maxValue	libsolidity/ast/Types.h	/^	bigint maxValue() const;$/;"	p	class:dev::solidity::IntegerType	access:public	signature:() const
dev::solidity::IntegerType::minValue	libsolidity/ast/Types.h	/^	bigint minValue() const;$/;"	p	class:dev::solidity::IntegerType	access:public	signature:() const
dev::solidity::IntegerType::numBits	libsolidity/ast/Types.h	/^	unsigned numBits() const { return m_bits; }$/;"	f	class:dev::solidity::IntegerType	access:public	signature:() const
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
dev::solidity::IntegerType::uint256	libsolidity/ast/Types.h	/^	static IntegerType& uint256() { static std::shared_ptr<IntegerType> uint256(std::make_shared<IntegerType>(256)); return *uint256; }$/;"	f	class:dev::solidity::IntegerType	access:public	signature:()
dev::solidity::LValue	libsolidity/codegen/LValue.h	/^class LValue$/;"	c	namespace:dev::solidity
dev::solidity::LValue::LValue	libsolidity/codegen/LValue.h	/^	explicit LValue(CompilerContext& _compilerContext, Type const* _dataType = nullptr):$/;"	f	class:dev::solidity::LValue	access:protected	signature:(CompilerContext& _compilerContext, Type const* _dataType = nullptr)
dev::solidity::LValue::m_context	libsolidity/codegen/LValue.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::LValue	access:protected
dev::solidity::LValue::m_dataType	libsolidity/codegen/LValue.h	/^	Type const* m_dataType;$/;"	m	class:dev::solidity::LValue	access:protected
dev::solidity::LValue::retrieveValue	libsolidity/codegen/LValue.h	/^	virtual void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const = 0;$/;"	p	class:dev::solidity::LValue	access:public	signature:(langutil::SourceLocation const& _location, bool _remove = false) const
dev::solidity::LValue::setToZero	libsolidity/codegen/LValue.h	/^	virtual void setToZero($/;"	p	class:dev::solidity::LValue	access:public	signature:( langutil::SourceLocation const& _location = {}, bool _removeReference = true ) const
dev::solidity::LValue::sizeOnStack	libsolidity/codegen/LValue.h	/^	virtual unsigned sizeOnStack() const { return 1; }$/;"	f	class:dev::solidity::LValue	access:public	signature:() const
dev::solidity::LValue::storeValue	libsolidity/codegen/LValue.h	/^	virtual void storeValue(Type const& _sourceType,$/;"	p	class:dev::solidity::LValue	access:public	signature:(Type const& _sourceType, langutil::SourceLocation const& _location = {}, bool _move = false) const
dev::solidity::LValue::~LValue	libsolidity/codegen/LValue.h	/^	virtual ~LValue() = default;$/;"	p	class:dev::solidity::LValue	access:public	signature:()
dev::solidity::Literal	libsolidity/ast/AST.h	/^class Literal: public PrimaryExpression$/;"	c	namespace:dev::solidity	inherits:PrimaryExpression
dev::solidity::Literal::SubDenomination	libsolidity/ast/AST.h	/^	enum class SubDenomination$/;"	c	class:dev::solidity::Literal	access:public
dev::solidity::Literal::SubDenomination::Day	libsolidity/ast/AST.h	/^		Day = static_cast<int>(Token::SubDay),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Ether	libsolidity/ast/AST.h	/^		Ether = static_cast<int>(Token::SubEther),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Finney	libsolidity/ast/AST.h	/^		Finney = static_cast<int>(Token::SubFinney),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Hour	libsolidity/ast/AST.h	/^		Hour = static_cast<int>(Token::SubHour),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Literal	libsolidity/ast/AST.h	/^	Literal($/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:( SourceLocation const& _location, Token _token, ASTPointer<ASTString> const& _value, SubDenomination _sub = SubDenomination::None )
dev::solidity::Literal::SubDenomination::Minute	libsolidity/ast/AST.h	/^		Minute = static_cast<int>(Token::SubMinute),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::None	libsolidity/ast/AST.h	/^		None = static_cast<int>(Token::Illegal),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Second	libsolidity/ast/AST.h	/^		Second = static_cast<int>(Token::SubSecond),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Szabo	libsolidity/ast/AST.h	/^		Szabo = static_cast<int>(Token::SubSzabo),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Week	libsolidity/ast/AST.h	/^		Week = static_cast<int>(Token::SubWeek),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Wei	libsolidity/ast/AST.h	/^		Wei = static_cast<int>(Token::SubWei),$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::Year	libsolidity/ast/AST.h	/^		Year = static_cast<int>(Token::SubYear)$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::getChecksummedAddress	libsolidity/ast/AST.h	/^	std::string getChecksummedAddress() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::isHexNumber	libsolidity/ast/AST.h	/^	bool isHexNumber() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::looksLikeAddress	libsolidity/ast/AST.h	/^	bool looksLikeAddress() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::m_subDenomination	libsolidity/ast/AST.h	/^	SubDenomination m_subDenomination;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::m_token	libsolidity/ast/AST.h	/^	Token m_token;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::m_value	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_value;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
dev::solidity::Literal::SubDenomination::passesAddressChecksum	libsolidity/ast/AST.h	/^	bool passesAddressChecksum() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::subDenomination	libsolidity/ast/AST.h	/^	SubDenomination subDenomination() const { return m_subDenomination; }$/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::token	libsolidity/ast/AST.h	/^	Token token() const { return m_token; }$/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::value	libsolidity/ast/AST.h	/^	ASTString const& value() const { return *m_value; }$/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::SubDenomination::valueWithoutUnderscores	libsolidity/ast/AST.h	/^	ASTString valueWithoutUnderscores() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
dev::solidity::Literal::accept	libsolidity/ast/AST_accept.h	/^void Literal::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Literal	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Literal::accept	libsolidity/ast/AST_accept.h	/^void Literal::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Literal	signature:(ASTVisitor& _visitor)
dev::solidity::MagicType	libsolidity/ast/Types.h	/^class MagicType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::MagicType::Kind	libsolidity/ast/Types.h	/^	enum class Kind {$/;"	c	class:dev::solidity::MagicType	access:public
dev::solidity::MagicType::Kind::ABI	libsolidity/ast/Types.h	/^		ABI, \/\/\/< "abi"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
dev::solidity::MagicType::Kind::Block	libsolidity/ast/Types.h	/^		Block, \/\/\/< "block"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
dev::solidity::MagicType::Kind::Message	libsolidity/ast/Types.h	/^		Message, \/\/\/< "msg"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
dev::solidity::MagicType::Kind::Transaction	libsolidity/ast/Types.h	/^		Transaction, \/\/\/< "tx"$/;"	m	class:dev::solidity::MagicType::Kind	access:private
dev::solidity::MagicType::MagicType	libsolidity/ast/Types.h	/^	explicit MagicType(Kind _kind): m_kind(_kind) {}$/;"	f	class:dev::solidity::MagicType	access:public	signature:(Kind _kind)
dev::solidity::MagicType::kind	libsolidity/ast/Types.h	/^	Kind kind() const { return m_kind; }$/;"	f	class:dev::solidity::MagicType	access:public	signature:() const
dev::solidity::MagicType::m_kind	libsolidity/ast/Types.h	/^	Kind m_kind;$/;"	m	class:dev::solidity::MagicType	access:private
dev::solidity::MagicType::m_typeArgument	libsolidity/ast/Types.h	/^	TypePointer m_typeArgument;$/;"	m	class:dev::solidity::MagicType	access:private
dev::solidity::MagicType::metaType	libsolidity/ast/Types.h	/^	static std::shared_ptr<MagicType> metaType(TypePointer _type);$/;"	p	class:dev::solidity::MagicType	access:public	signature:(TypePointer _type)
dev::solidity::MagicType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::MagicType	access:public
dev::solidity::MagicType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::MagicType	access:public
dev::solidity::MagicType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::MagicType	access:public
dev::solidity::MagicType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::MagicType	access:public
dev::solidity::MagicType::typeArgument	libsolidity/ast/Types.h	/^	TypePointer typeArgument() const;$/;"	p	class:dev::solidity::MagicType	access:public	signature:() const
dev::solidity::MagicVariableDeclaration	libsolidity/ast/AST.h	/^class MagicVariableDeclaration: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
dev::solidity::MagicVariableDeclaration::MagicVariableDeclaration	libsolidity/ast/AST.h	/^	MagicVariableDeclaration(ASTString const& _name, std::shared_ptr<Type const> const& _type):$/;"	f	class:dev::solidity::MagicVariableDeclaration	access:public	signature:(ASTString const& _name, std::shared_ptr<Type const> const& _type)
dev::solidity::MagicVariableDeclaration::m_type	libsolidity/ast/AST.h	/^	std::shared_ptr<Type const> m_type;$/;"	m	class:dev::solidity::MagicVariableDeclaration	access:private
dev::solidity::Mapping	libsolidity/ast/AST.h	/^class Mapping: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
dev::solidity::Mapping::Mapping	libsolidity/ast/AST.h	/^	Mapping($/;"	f	class:dev::solidity::Mapping	access:public	signature:( SourceLocation const& _location, ASTPointer<ElementaryTypeName> const& _keyType, ASTPointer<TypeName> const& _valueType )
dev::solidity::Mapping::accept	libsolidity/ast/AST_accept.h	/^void Mapping::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Mapping	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Mapping::accept	libsolidity/ast/AST_accept.h	/^void Mapping::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Mapping	signature:(ASTVisitor& _visitor)
dev::solidity::Mapping::keyType	libsolidity/ast/AST.h	/^	ElementaryTypeName const& keyType() const { return *m_keyType; }$/;"	f	class:dev::solidity::Mapping	access:public	signature:() const
dev::solidity::Mapping::m_keyType	libsolidity/ast/AST.h	/^	ASTPointer<ElementaryTypeName> m_keyType;$/;"	m	class:dev::solidity::Mapping	access:private
dev::solidity::Mapping::m_valueType	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_valueType;$/;"	m	class:dev::solidity::Mapping	access:private
dev::solidity::Mapping::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Mapping	access:public
dev::solidity::Mapping::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Mapping	access:public
dev::solidity::Mapping::valueType	libsolidity/ast/AST.h	/^	TypeName const& valueType() const { return *m_valueType; }$/;"	f	class:dev::solidity::Mapping	access:public	signature:() const
dev::solidity::MappingType	libsolidity/ast/Types.h	/^class MappingType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::MappingType::MappingType	libsolidity/ast/Types.h	/^	MappingType(TypePointer const& _keyType, TypePointer const& _valueType):$/;"	f	class:dev::solidity::MappingType	access:public	signature:(TypePointer const& _keyType, TypePointer const& _valueType)
dev::solidity::MappingType::keyType	libsolidity/ast/Types.h	/^	TypePointer const& keyType() const { return m_keyType; }$/;"	f	class:dev::solidity::MappingType	access:public	signature:() const
dev::solidity::MappingType::m_keyType	libsolidity/ast/Types.h	/^	TypePointer m_keyType;$/;"	m	class:dev::solidity::MappingType	access:private
dev::solidity::MappingType::m_valueType	libsolidity/ast/Types.h	/^	TypePointer m_valueType;$/;"	m	class:dev::solidity::MappingType	access:private
dev::solidity::MappingType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::MappingType	access:public
dev::solidity::MappingType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::MappingType	access:public
dev::solidity::MappingType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::MappingType	access:public
dev::solidity::MappingType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::MappingType	access:public
dev::solidity::MappingType::valueType	libsolidity/ast/Types.h	/^	TypePointer const& valueType() const { return m_valueType; }$/;"	f	class:dev::solidity::MappingType	access:public	signature:() const
dev::solidity::MemberAccess	libsolidity/ast/AST.h	/^class MemberAccess: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::MemberAccess::MemberAccess	libsolidity/ast/AST.h	/^	MemberAccess($/;"	f	class:dev::solidity::MemberAccess	access:public	signature:( SourceLocation const& _location, ASTPointer<Expression> _expression, ASTPointer<ASTString> const& _memberName )
dev::solidity::MemberAccess::accept	libsolidity/ast/AST_accept.h	/^void MemberAccess::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::MemberAccess	signature:(ASTConstVisitor& _visitor) const
dev::solidity::MemberAccess::accept	libsolidity/ast/AST_accept.h	/^void MemberAccess::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::MemberAccess	signature:(ASTVisitor& _visitor)
dev::solidity::MemberAccess::expression	libsolidity/ast/AST.h	/^	Expression const& expression() const { return *m_expression; }$/;"	f	class:dev::solidity::MemberAccess	access:public	signature:() const
dev::solidity::MemberAccess::m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression;$/;"	m	class:dev::solidity::MemberAccess	access:private
dev::solidity::MemberAccess::m_memberName	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_memberName;$/;"	m	class:dev::solidity::MemberAccess	access:private
dev::solidity::MemberAccess::memberName	libsolidity/ast/AST.h	/^	ASTString const& memberName() const { return *m_memberName; }$/;"	f	class:dev::solidity::MemberAccess	access:public	signature:() const
dev::solidity::MemberAccess::override	libsolidity/ast/AST.h	/^	MemberAccessAnnotation& annotation() const override;$/;"	m	class:dev::solidity::MemberAccess	access:public
dev::solidity::MemberAccess::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::MemberAccess	access:public
dev::solidity::MemberAccess::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::MemberAccess	access:public
dev::solidity::MemberAccessAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct MemberAccessAnnotation: ExpressionAnnotation$/;"	s	namespace:dev::solidity	inherits:ExpressionAnnotation
dev::solidity::MemberAccessAnnotation::referencedDeclaration	libsolidity/ast/ASTAnnotations.h	/^	Declaration const* referencedDeclaration = nullptr;$/;"	m	struct:dev::solidity::MemberAccessAnnotation	access:public
dev::solidity::MemberList	libsolidity/ast/Types.h	/^class MemberList$/;"	c	namespace:dev::solidity
dev::solidity::MemberList::Member	libsolidity/ast/Types.h	/^	struct Member$/;"	s	class:dev::solidity::MemberList	access:public
dev::solidity::MemberList::Member::Member	libsolidity/ast/Types.h	/^		Member(std::string const& _name, TypePointer const& _type, Declaration const* _declaration = nullptr):$/;"	f	struct:dev::solidity::MemberList::Member	access:public	signature:(std::string const& _name, TypePointer const& _type, Declaration const* _declaration = nullptr)
dev::solidity::MemberList::Member::declaration	libsolidity/ast/Types.h	/^		Declaration const* declaration = nullptr;$/;"	m	struct:dev::solidity::MemberList::Member	access:public
dev::solidity::MemberList::Member::name	libsolidity/ast/Types.h	/^		std::string name;$/;"	m	struct:dev::solidity::MemberList::Member	access:public
dev::solidity::MemberList::Member::type	libsolidity/ast/Types.h	/^		TypePointer type;$/;"	m	struct:dev::solidity::MemberList::Member	access:public
dev::solidity::MemberList::MemberList	libsolidity/ast/Types.h	/^	explicit MemberList(MemberMap const& _members): m_memberTypes(_members) {}$/;"	f	class:dev::solidity::MemberList	access:public	signature:(MemberMap const& _members)
dev::solidity::MemberList::begin	libsolidity/ast/Types.h	/^	MemberMap::const_iterator begin() const { return m_memberTypes.begin(); }$/;"	f	class:dev::solidity::MemberList	access:public	signature:() const
dev::solidity::MemberList::combine	libsolidity/ast/Types.h	/^	void combine(MemberList const& _other);$/;"	p	class:dev::solidity::MemberList	access:public	signature:(MemberList const& _other)
dev::solidity::MemberList::end	libsolidity/ast/Types.h	/^	MemberMap::const_iterator end() const { return m_memberTypes.end(); }$/;"	f	class:dev::solidity::MemberList	access:public	signature:() const
dev::solidity::MemberList::m_memberTypes	libsolidity/ast/Types.h	/^	MemberMap m_memberTypes;$/;"	m	class:dev::solidity::MemberList	access:private
dev::solidity::MemberList::m_storageOffsets	libsolidity/ast/Types.h	/^	mutable std::unique_ptr<StorageOffsets> m_storageOffsets;$/;"	m	class:dev::solidity::MemberList	access:private
dev::solidity::MemberList::memberType	libsolidity/ast/Types.h	/^	TypePointer memberType(std::string const& _name) const$/;"	f	class:dev::solidity::MemberList	access:public	signature:(std::string const& _name) const
dev::solidity::MemberList::membersByName	libsolidity/ast/Types.h	/^	MemberMap membersByName(std::string const& _name) const$/;"	f	class:dev::solidity::MemberList	access:public	signature:(std::string const& _name) const
dev::solidity::MemberList::std::memberStorageOffset	libsolidity/ast/Types.h	/^	std::pair<u256, unsigned> const* memberStorageOffset(std::string const& _name) const;$/;"	p	class:dev::solidity::MemberList::std	access:public	signature:(std::string const& _name) const
dev::solidity::MemberList::storageSize	libsolidity/ast/Types.h	/^	u256 const& storageSize() const;$/;"	p	class:dev::solidity::MemberList	access:public	signature:() const
dev::solidity::MemoryItem	libsolidity/codegen/LValue.h	/^class MemoryItem: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
dev::solidity::MemoryItem::MemoryItem	libsolidity/codegen/LValue.h	/^	MemoryItem(CompilerContext& _compilerContext, Type const& _type, bool _padded = true);$/;"	p	class:dev::solidity::MemoryItem	access:public	signature:(CompilerContext& _compilerContext, Type const& _type, bool _padded = true)
dev::solidity::MemoryItem::m_padded	libsolidity/codegen/LValue.h	/^	bool m_padded = false;$/;"	m	class:dev::solidity::MemoryItem	access:private
dev::solidity::MemoryItem::override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::MemoryItem	access:public
dev::solidity::MemoryItem::override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::MemoryItem	access:public
dev::solidity::ModifierDefinition	libsolidity/ast/AST.h	/^class ModifierDefinition: public CallableDeclaration, public Documented$/;"	c	namespace:dev::solidity	inherits:CallableDeclaration,Documented
dev::solidity::ModifierDefinition::ModifierDefinition	libsolidity/ast/AST.h	/^	ModifierDefinition($/;"	f	class:dev::solidity::ModifierDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, ASTPointer<ASTString> const& _documentation, ASTPointer<ParameterList> const& _parameters, ASTPointer<Block> const& _body )
dev::solidity::ModifierDefinition::accept	libsolidity/ast/AST_accept.h	/^void ModifierDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ModifierDefinition	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ModifierDefinition::accept	libsolidity/ast/AST_accept.h	/^void ModifierDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ModifierDefinition	signature:(ASTVisitor& _visitor)
dev::solidity::ModifierDefinition::body	libsolidity/ast/AST.h	/^	Block const& body() const { return *m_body; }$/;"	f	class:dev::solidity::ModifierDefinition	access:public	signature:() const
dev::solidity::ModifierDefinition::m_body	libsolidity/ast/AST.h	/^	ASTPointer<Block> m_body;$/;"	m	class:dev::solidity::ModifierDefinition	access:private
dev::solidity::ModifierDefinition::override	libsolidity/ast/AST.h	/^	ModifierDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
dev::solidity::ModifierDefinition::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
dev::solidity::ModifierDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
dev::solidity::ModifierDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
dev::solidity::ModifierDefinitionAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ModifierDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
dev::solidity::ModifierInvocation	libsolidity/ast/AST.h	/^class ModifierInvocation: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::ModifierInvocation::ModifierInvocation	libsolidity/ast/AST.h	/^	ModifierInvocation($/;"	f	class:dev::solidity::ModifierInvocation	access:public	signature:( SourceLocation const& _location, ASTPointer<Identifier> const& _name, std::unique_ptr<std::vector<ASTPointer<Expression>>> _arguments )
dev::solidity::ModifierInvocation::accept	libsolidity/ast/AST_accept.h	/^void ModifierInvocation::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ModifierInvocation	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ModifierInvocation::accept	libsolidity/ast/AST_accept.h	/^void ModifierInvocation::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ModifierInvocation	signature:(ASTVisitor& _visitor)
dev::solidity::ModifierInvocation::m_arguments	libsolidity/ast/AST.h	/^	std::unique_ptr<std::vector<ASTPointer<Expression>>> m_arguments;$/;"	m	class:dev::solidity::ModifierInvocation	access:private
dev::solidity::ModifierInvocation::m_modifierName	libsolidity/ast/AST.h	/^	ASTPointer<Identifier> m_modifierName;$/;"	m	class:dev::solidity::ModifierInvocation	access:private
dev::solidity::ModifierInvocation::name	libsolidity/ast/AST.h	/^	ASTPointer<Identifier> const& name() const { return m_modifierName; }$/;"	f	class:dev::solidity::ModifierInvocation	access:public	signature:() const
dev::solidity::ModifierInvocation::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ModifierInvocation	access:public
dev::solidity::ModifierInvocation::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ModifierInvocation	access:public
dev::solidity::ModifierInvocation::std::arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> const* arguments() const { return m_arguments.get(); }$/;"	f	class:dev::solidity::ModifierInvocation::std	access:public	signature:() const
dev::solidity::ModifierType	libsolidity/ast/Types.h	/^class ModifierType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::ModifierType::ModifierType	libsolidity/ast/Types.h	/^	explicit ModifierType(ModifierDefinition const& _modifier);$/;"	p	class:dev::solidity::ModifierType	access:public	signature:(ModifierDefinition const& _modifier)
dev::solidity::ModifierType::m_parameterTypes	libsolidity/ast/Types.h	/^	TypePointers m_parameterTypes;$/;"	m	class:dev::solidity::ModifierType	access:private
dev::solidity::ModifierType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ModifierType	access:public
dev::solidity::ModifierType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ModifierType	access:public
dev::solidity::ModifierType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ModifierType	access:public
dev::solidity::ModifierType::override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::ModifierType	access:public
dev::solidity::ModuleType	libsolidity/ast/Types.h	/^class ModuleType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::ModuleType::ModuleType	libsolidity/ast/Types.h	/^	explicit ModuleType(SourceUnit const& _source): m_sourceUnit(_source) {}$/;"	f	class:dev::solidity::ModuleType	access:public	signature:(SourceUnit const& _source)
dev::solidity::ModuleType::m_sourceUnit	libsolidity/ast/Types.h	/^	SourceUnit const& m_sourceUnit;$/;"	m	class:dev::solidity::ModuleType	access:private
dev::solidity::ModuleType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::ModuleType	access:public
dev::solidity::ModuleType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ModuleType	access:public
dev::solidity::ModuleType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ModuleType	access:public
dev::solidity::ModuleType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ModuleType	access:public
dev::solidity::NameAndTypeResolver	libsolidity/analysis/NameAndTypeResolver.h	/^class NameAndTypeResolver: private boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
dev::solidity::NameAndTypeResolver::NameAndTypeResolver	libsolidity/analysis/NameAndTypeResolver.cpp	/^NameAndTypeResolver::NameAndTypeResolver($/;"	f	class:dev::solidity::NameAndTypeResolver	signature:( vector<Declaration const*> const& _globals, map<ASTNode const*, shared_ptr<DeclarationContainer>>& _scopes, ErrorReporter& _errorReporter )
dev::solidity::NameAndTypeResolver::NameAndTypeResolver	libsolidity/analysis/NameAndTypeResolver.h	/^	NameAndTypeResolver($/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:( std::vector<Declaration const*> const& _globals, std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& _scopes, langutil::ErrorReporter& _errorReporter )
dev::solidity::NameAndTypeResolver::activateVariable	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::activateVariable(string const& _name)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(string const& _name)
dev::solidity::NameAndTypeResolver::activateVariable	libsolidity/analysis/NameAndTypeResolver.h	/^	void activateVariable(std::string const& _name);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(std::string const& _name)
dev::solidity::NameAndTypeResolver::cThreeMerge	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<_T const*> NameAndTypeResolver::cThreeMerge(list<list<_T const*>>& _toMerge)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(list<list<_T const*>>& _toMerge)
dev::solidity::NameAndTypeResolver::cThreeMerge	libsolidity/analysis/NameAndTypeResolver.h	/^	static std::vector<_T const*> cThreeMerge(std::list<std::list<_T const*>>& _toMerge);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(std::list<std::list<_T const*>>& _toMerge)
dev::solidity::NameAndTypeResolver::cleanedDeclarations	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<Declaration const*> NameAndTypeResolver::cleanedDeclarations($/;"	f	class:dev::solidity::NameAndTypeResolver	signature:( Identifier const& _identifier, vector<Declaration const*> const& _declarations )
dev::solidity::NameAndTypeResolver::cleanedDeclarations	libsolidity/analysis/NameAndTypeResolver.h	/^	std::vector<Declaration const*> cleanedDeclarations($/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:( Identifier const& _identifier, std::vector<Declaration const*> const& _declarations )
dev::solidity::NameAndTypeResolver::importInheritedScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::importInheritedScope(ContractDefinition const& _base)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ContractDefinition const& _base)
dev::solidity::NameAndTypeResolver::importInheritedScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void importInheritedScope(ContractDefinition const& _base);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(ContractDefinition const& _base)
dev::solidity::NameAndTypeResolver::linearizeBaseContracts	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ContractDefinition& _contract)
dev::solidity::NameAndTypeResolver::linearizeBaseContracts	libsolidity/analysis/NameAndTypeResolver.h	/^	void linearizeBaseContracts(ContractDefinition& _contract);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(ContractDefinition& _contract)
dev::solidity::NameAndTypeResolver::m_currentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	DeclarationContainer* m_currentScope = nullptr;$/;"	m	class:dev::solidity::NameAndTypeResolver	access:private
dev::solidity::NameAndTypeResolver::m_errorReporter	libsolidity/analysis/NameAndTypeResolver.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::NameAndTypeResolver	access:private
dev::solidity::NameAndTypeResolver::m_scopes	libsolidity/analysis/NameAndTypeResolver.h	/^	std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& m_scopes;$/;"	m	class:dev::solidity::NameAndTypeResolver	access:private
dev::solidity::NameAndTypeResolver::nameFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<Declaration const*> NameAndTypeResolver::nameFromCurrentScope(ASTString const& _name, bool _includeInvisibles) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTString const& _name, bool _includeInvisibles) const
dev::solidity::NameAndTypeResolver::nameFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	std::vector<Declaration const*> nameFromCurrentScope(ASTString const& _name, bool _includeInvisibles = false) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTString const& _name, bool _includeInvisibles = false) const
dev::solidity::NameAndTypeResolver::pathFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^Declaration const* NameAndTypeResolver::pathFromCurrentScope(vector<ASTString> const& _path) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(vector<ASTString> const& _path) const
dev::solidity::NameAndTypeResolver::pathFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	Declaration const* pathFromCurrentScope(std::vector<ASTString> const& _path) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(std::vector<ASTString> const& _path) const
dev::solidity::NameAndTypeResolver::performImports	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::performImports(SourceUnit& _sourceUnit, map<string, SourceUnit const*> const& _sourceUnits)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(SourceUnit& _sourceUnit, map<string, SourceUnit const*> const& _sourceUnits)
dev::solidity::NameAndTypeResolver::performImports	libsolidity/analysis/NameAndTypeResolver.h	/^	bool performImports(SourceUnit& _sourceUnit, std::map<std::string, SourceUnit const*> const& _sourceUnits);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(SourceUnit& _sourceUnit, std::map<std::string, SourceUnit const*> const& _sourceUnits)
dev::solidity::NameAndTypeResolver::registerDeclarations	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::registerDeclarations(SourceUnit& _sourceUnit, ASTNode const* _currentScope)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(SourceUnit& _sourceUnit, ASTNode const* _currentScope)
dev::solidity::NameAndTypeResolver::registerDeclarations	libsolidity/analysis/NameAndTypeResolver.h	/^	bool registerDeclarations(SourceUnit& _sourceUnit, ASTNode const* _currentScope = nullptr);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(SourceUnit& _sourceUnit, ASTNode const* _currentScope = nullptr)
dev::solidity::NameAndTypeResolver::resolveName	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<Declaration const*> NameAndTypeResolver::resolveName(ASTString const& _name, ASTNode const* _scope) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTString const& _name, ASTNode const* _scope) const
dev::solidity::NameAndTypeResolver::resolveName	libsolidity/analysis/NameAndTypeResolver.h	/^	std::vector<Declaration const*> resolveName(ASTString const& _name, ASTNode const* _scope = nullptr) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTString const& _name, ASTNode const* _scope = nullptr) const
dev::solidity::NameAndTypeResolver::resolveNamesAndTypes	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::resolveNamesAndTypes(ASTNode& _node, bool _resolveInsideCode)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTNode& _node, bool _resolveInsideCode)
dev::solidity::NameAndTypeResolver::resolveNamesAndTypes	libsolidity/analysis/NameAndTypeResolver.h	/^	bool resolveNamesAndTypes(ASTNode& _node, bool _resolveInsideCode = true);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTNode& _node, bool _resolveInsideCode = true)
dev::solidity::NameAndTypeResolver::resolveNamesAndTypesInternal	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::resolveNamesAndTypesInternal(ASTNode& _node, bool _resolveInsideCode)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTNode& _node, bool _resolveInsideCode)
dev::solidity::NameAndTypeResolver::resolveNamesAndTypesInternal	libsolidity/analysis/NameAndTypeResolver.h	/^	bool resolveNamesAndTypesInternal(ASTNode& _node, bool _resolveInsideCode = true);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(ASTNode& _node, bool _resolveInsideCode = true)
dev::solidity::NameAndTypeResolver::setScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::setScope(ASTNode const* _node)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTNode const* _node)
dev::solidity::NameAndTypeResolver::setScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void setScope(ASTNode const* _node);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTNode const* _node)
dev::solidity::NameAndTypeResolver::similarNameSuggestions	libsolidity/analysis/NameAndTypeResolver.cpp	/^string NameAndTypeResolver::similarNameSuggestions(ASTString const& _name) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTString const& _name) const
dev::solidity::NameAndTypeResolver::similarNameSuggestions	libsolidity/analysis/NameAndTypeResolver.h	/^	std::string similarNameSuggestions(ASTString const& _name) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTString const& _name) const
dev::solidity::NameAndTypeResolver::updateDeclaration	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::updateDeclaration(Declaration const& _declaration)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(Declaration const& _declaration)
dev::solidity::NameAndTypeResolver::updateDeclaration	libsolidity/analysis/NameAndTypeResolver.h	/^	bool updateDeclaration(Declaration const& _declaration);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(Declaration const& _declaration)
dev::solidity::NameAndTypeResolver::warnVariablesNamedLikeInstructions	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::warnVariablesNamedLikeInstructions()$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:()
dev::solidity::NameAndTypeResolver::warnVariablesNamedLikeInstructions	libsolidity/analysis/NameAndTypeResolver.h	/^	void warnVariablesNamedLikeInstructions();$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:()
dev::solidity::Natspec	libsolidity/interface/Natspec.h	/^class Natspec$/;"	c	namespace:dev::solidity
dev::solidity::Natspec::devDocumentation	libsolidity/interface/Natspec.h	/^	static Json::Value devDocumentation(ContractDefinition const& _contractDef);$/;"	p	class:dev::solidity::Natspec	access:public	signature:(ContractDefinition const& _contractDef)
dev::solidity::Natspec::devDocumentation	libsolidity/interface/Natspec.h	/^	static Json::Value devDocumentation(std::multimap<std::string, DocTag> const& _tags);$/;"	p	class:dev::solidity::Natspec	access:private	signature:(std::multimap<std::string, DocTag> const& _tags)
dev::solidity::Natspec::extractDoc	libsolidity/interface/Natspec.h	/^	static std::string extractDoc(std::multimap<std::string, DocTag> const& _tags, std::string const& _name);$/;"	p	class:dev::solidity::Natspec	access:private	signature:(std::multimap<std::string, DocTag> const& _tags, std::string const& _name)
dev::solidity::Natspec::userDocumentation	libsolidity/interface/Natspec.h	/^	static Json::Value userDocumentation(ContractDefinition const& _contractDef);$/;"	p	class:dev::solidity::Natspec	access:public	signature:(ContractDefinition const& _contractDef)
dev::solidity::NewExpression	libsolidity/ast/AST.h	/^class NewExpression: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::NewExpression::NewExpression	libsolidity/ast/AST.h	/^	NewExpression($/;"	f	class:dev::solidity::NewExpression	access:public	signature:( SourceLocation const& _location, ASTPointer<TypeName> const& _typeName )
dev::solidity::NewExpression::accept	libsolidity/ast/AST_accept.h	/^void NewExpression::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::NewExpression	signature:(ASTConstVisitor& _visitor) const
dev::solidity::NewExpression::accept	libsolidity/ast/AST_accept.h	/^void NewExpression::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::NewExpression	signature:(ASTVisitor& _visitor)
dev::solidity::NewExpression::m_typeName	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_typeName;$/;"	m	class:dev::solidity::NewExpression	access:private
dev::solidity::NewExpression::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::NewExpression	access:public
dev::solidity::NewExpression::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::NewExpression	access:public
dev::solidity::NewExpression::typeName	libsolidity/ast/AST.h	/^	TypeName const& typeName() const { return *m_typeName; }$/;"	f	class:dev::solidity::NewExpression	access:public	signature:() const
dev::solidity::OptimiserSettings	libsolidity/interface/OptimiserSettings.h	/^struct OptimiserSettings$/;"	s	namespace:dev::solidity
dev::solidity::OptimiserSettings::enabled	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings enabled()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
dev::solidity::OptimiserSettings::expectedExecutionsPerDeployment	libsolidity/interface/OptimiserSettings.h	/^	size_t expectedExecutionsPerDeployment = 200;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::full	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings full()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
dev::solidity::OptimiserSettings::minimal	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings minimal()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
dev::solidity::OptimiserSettings::none	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings none()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
dev::solidity::OptimiserSettings::operator ==	libsolidity/interface/OptimiserSettings.h	/^	bool operator==(OptimiserSettings const& _other) const$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:(OptimiserSettings const& _other) const
dev::solidity::OptimiserSettings::runCSE	libsolidity/interface/OptimiserSettings.h	/^	bool runCSE = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::runConstantOptimiser	libsolidity/interface/OptimiserSettings.h	/^	bool runConstantOptimiser = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::runDeduplicate	libsolidity/interface/OptimiserSettings.h	/^	bool runDeduplicate = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::runJumpdestRemover	libsolidity/interface/OptimiserSettings.h	/^	bool runJumpdestRemover = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::runOrderLiterals	libsolidity/interface/OptimiserSettings.h	/^	bool runOrderLiterals = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::runPeephole	libsolidity/interface/OptimiserSettings.h	/^	bool runPeephole = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::OptimiserSettings::runYulOptimiser	libsolidity/interface/OptimiserSettings.h	/^	bool runYulOptimiser = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
dev::solidity::ParameterList	libsolidity/ast/AST.h	/^class ParameterList: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::ParameterList::ParameterList	libsolidity/ast/AST.h	/^	ParameterList($/;"	f	class:dev::solidity::ParameterList	access:public	signature:( SourceLocation const& _location, std::vector<ASTPointer<VariableDeclaration>> const& _parameters )
dev::solidity::ParameterList::accept	libsolidity/ast/AST_accept.h	/^void ParameterList::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::ParameterList	signature:(ASTConstVisitor& _visitor) const
dev::solidity::ParameterList::accept	libsolidity/ast/AST_accept.h	/^void ParameterList::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ParameterList	signature:(ASTVisitor& _visitor)
dev::solidity::ParameterList::m_parameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> m_parameters;$/;"	m	class:dev::solidity::ParameterList	access:private
dev::solidity::ParameterList::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ParameterList	access:public
dev::solidity::ParameterList::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ParameterList	access:public
dev::solidity::ParameterList::std::parameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& parameters() const { return m_parameters; }$/;"	f	class:dev::solidity::ParameterList::std	access:public	signature:() const
dev::solidity::Parser	libsolidity/parsing/Parser.h	/^class Parser: public langutil::ParserBase$/;"	c	namespace:dev::solidity	inherits:langutil::ParserBase
dev::solidity::Parser::ASTNodeFactory	libsolidity/parsing/Parser.cpp	/^class Parser::ASTNodeFactory$/;"	c	class:dev::solidity::Parser	file:
dev::solidity::Parser::ASTNodeFactory::ASTNodeFactory	libsolidity/parsing/Parser.cpp	/^	ASTNodeFactory(Parser const& _parser, ASTPointer<ASTNode> const& _childNode):$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(Parser const& _parser, ASTPointer<ASTNode> const& _childNode)
dev::solidity::Parser::ASTNodeFactory::ASTNodeFactory	libsolidity/parsing/Parser.cpp	/^	explicit ASTNodeFactory(Parser const& _parser):$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(Parser const& _parser)
dev::solidity::Parser::ASTNodeFactory::createNode	libsolidity/parsing/Parser.cpp	/^	ASTPointer<NodeType> createNode(Args&& ... _args)$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(Args&& .... _args)
dev::solidity::Parser::ASTNodeFactory::m_location	libsolidity/parsing/Parser.cpp	/^	SourceLocation m_location;$/;"	m	class:dev::solidity::Parser::ASTNodeFactory	file:	access:private
dev::solidity::Parser::ASTNodeFactory::m_parser	libsolidity/parsing/Parser.cpp	/^	Parser const& m_parser;$/;"	m	class:dev::solidity::Parser::ASTNodeFactory	file:	access:private
dev::solidity::Parser::ASTNodeFactory::markEndPosition	libsolidity/parsing/Parser.cpp	/^	void markEndPosition() { m_location.end = m_parser.endPosition(); }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:()
dev::solidity::Parser::ASTNodeFactory::setEndPositionFromNode	libsolidity/parsing/Parser.cpp	/^	void setEndPositionFromNode(ASTPointer<ASTNode> const& _node) { m_location.end = _node->location().end; }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(ASTPointer<ASTNode> const& _node)
dev::solidity::Parser::ASTNodeFactory::setLocation	libsolidity/parsing/Parser.cpp	/^	void setLocation(SourceLocation const& _location) { m_location = _location; }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(SourceLocation const& _location)
dev::solidity::Parser::ASTNodeFactory::setLocationEmpty	libsolidity/parsing/Parser.cpp	/^	void setLocationEmpty() { m_location.end = m_location.start; }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:()
dev::solidity::Parser::FunctionHeaderParserResult	libsolidity/parsing/Parser.h	/^	struct FunctionHeaderParserResult$/;"	s	class:dev::solidity::Parser	access:private
dev::solidity::Parser::FunctionHeaderParserResult::isConstructor	libsolidity/parsing/Parser.h	/^		bool isConstructor;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::FunctionHeaderParserResult::modifiers	libsolidity/parsing/Parser.h	/^		std::vector<ASTPointer<ModifierInvocation>> modifiers;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::FunctionHeaderParserResult::name	libsolidity/parsing/Parser.h	/^		ASTPointer<ASTString> name;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::FunctionHeaderParserResult::parameters	libsolidity/parsing/Parser.h	/^		ASTPointer<ParameterList> parameters;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::FunctionHeaderParserResult::returnParameters	libsolidity/parsing/Parser.h	/^		ASTPointer<ParameterList> returnParameters;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::FunctionHeaderParserResult::stateMutability	libsolidity/parsing/Parser.h	/^		StateMutability stateMutability = StateMutability::NonPayable;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::FunctionHeaderParserResult::visibility	libsolidity/parsing/Parser.h	/^		Declaration::Visibility visibility = Declaration::Visibility::Default;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
dev::solidity::Parser::IndexAccessedPath	libsolidity/parsing/Parser.h	/^	struct IndexAccessedPath$/;"	s	class:dev::solidity::Parser	access:private
dev::solidity::Parser::IndexAccessedPath::empty	libsolidity/parsing/Parser.cpp	/^bool Parser::IndexAccessedPath::empty() const$/;"	f	class:dev::solidity::Parser::IndexAccessedPath	signature:() const
dev::solidity::Parser::IndexAccessedPath::empty	libsolidity/parsing/Parser.h	/^		bool empty() const;$/;"	p	struct:dev::solidity::Parser::IndexAccessedPath	access:public	signature:() const
dev::solidity::Parser::IndexAccessedPath::indices	libsolidity/parsing/Parser.h	/^		std::vector<std::pair<ASTPointer<Expression>, langutil::SourceLocation>> indices;$/;"	m	struct:dev::solidity::Parser::IndexAccessedPath	access:public
dev::solidity::Parser::IndexAccessedPath::path	libsolidity/parsing/Parser.h	/^		std::vector<ASTPointer<PrimaryExpression>> path;$/;"	m	struct:dev::solidity::Parser::IndexAccessedPath	access:public
dev::solidity::Parser::LookAheadInfo	libsolidity/parsing/Parser.h	/^	enum class LookAheadInfo$/;"	c	class:dev::solidity::Parser	access:private
dev::solidity::Parser::LookAheadInfo::IndexAccessStructure	libsolidity/parsing/Parser.h	/^		IndexAccessStructure, VariableDeclaration, Expression$/;"	m	class:dev::solidity::Parser::LookAheadInfo	access:private
dev::solidity::Parser::LookAheadInfo::VariableDeclaration	libsolidity/parsing/Parser.h	/^		IndexAccessStructure, VariableDeclaration, Expression$/;"	m	class:dev::solidity::Parser::LookAheadInfo	access:private
dev::solidity::Parser::Parser	libsolidity/parsing/Parser.h	/^	explicit Parser(langutil::ErrorReporter& _errorReporter): ParserBase(_errorReporter) {}$/;"	f	class:dev::solidity::Parser	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::Parser::VarDeclParserOptions	libsolidity/parsing/Parser.h	/^	struct VarDeclParserOptions$/;"	s	class:dev::solidity::Parser	access:private
dev::solidity::Parser::VarDeclParserOptions::VarDeclParserOptions	libsolidity/parsing/Parser.h	/^		VarDeclParserOptions() {}$/;"	f	struct:dev::solidity::Parser::VarDeclParserOptions	access:public	signature:()
dev::solidity::Parser::VarDeclParserOptions::allowEmptyName	libsolidity/parsing/Parser.h	/^		bool allowEmptyName = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
dev::solidity::Parser::VarDeclParserOptions::allowIndexed	libsolidity/parsing/Parser.h	/^		bool allowIndexed = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
dev::solidity::Parser::VarDeclParserOptions::allowInitialValue	libsolidity/parsing/Parser.h	/^		bool allowInitialValue = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
dev::solidity::Parser::VarDeclParserOptions::allowLocationSpecifier	libsolidity/parsing/Parser.h	/^		bool allowLocationSpecifier = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
dev::solidity::Parser::VarDeclParserOptions::allowVar	libsolidity/parsing/Parser.h	/^		bool allowVar = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
dev::solidity::Parser::VarDeclParserOptions::isStateVariable	libsolidity/parsing/Parser.h	/^		bool isStateVariable = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
dev::solidity::Parser::createEmptyParameterList	libsolidity/parsing/Parser.cpp	/^ASTPointer<ParameterList> Parser::createEmptyParameterList()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::createEmptyParameterList	libsolidity/parsing/Parser.h	/^	ASTPointer<ParameterList> createEmptyParameterList();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::expectIdentifierToken	libsolidity/parsing/Parser.cpp	/^ASTPointer<ASTString> Parser::expectIdentifierToken()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::expectIdentifierToken	libsolidity/parsing/Parser.h	/^	ASTPointer<ASTString> expectIdentifierToken();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::expressionFromIndexAccessStructure	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::expressionFromIndexAccessStructure($/;"	f	class:dev::solidity::Parser	signature:( Parser::IndexAccessedPath const& _iap )
dev::solidity::Parser::expressionFromIndexAccessStructure	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> expressionFromIndexAccessStructure(IndexAccessedPath const& _pathAndIndices);$/;"	p	class:dev::solidity::Parser	access:private	signature:(IndexAccessedPath const& _pathAndIndices)
dev::solidity::Parser::getLiteralAndAdvance	libsolidity/parsing/Parser.cpp	/^ASTPointer<ASTString> Parser::getLiteralAndAdvance()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::getLiteralAndAdvance	libsolidity/parsing/Parser.h	/^	ASTPointer<ASTString> getLiteralAndAdvance();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::m_insideModifier	libsolidity/parsing/Parser.h	/^	bool m_insideModifier = false;$/;"	m	class:dev::solidity::Parser	access:private
dev::solidity::Parser::parse	libsolidity/parsing/Parser.cpp	/^ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)$/;"	f	class:dev::solidity::Parser	signature:(shared_ptr<Scanner> const& _scanner)
dev::solidity::Parser::parse	libsolidity/parsing/Parser.h	/^	ASTPointer<SourceUnit> parse(std::shared_ptr<langutil::Scanner> const& _scanner);$/;"	p	class:dev::solidity::Parser	access:public	signature:(std::shared_ptr<langutil::Scanner> const& _scanner)
dev::solidity::Parser::parseBinaryExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseBinaryExpression($/;"	f	class:dev::solidity::Parser	signature:( int _minPrecedence, ASTPointer<Expression> const& _partiallyParsedExpression )
dev::solidity::Parser::parseBinaryExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseBinaryExpression(int _minPrecedence = 4,$/;"	p	class:dev::solidity::Parser	access:private	signature:(int _minPrecedence = 4, ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
dev::solidity::Parser::parseBlock	libsolidity/parsing/Parser.cpp	/^ASTPointer<Block> Parser::parseBlock(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseBlock	libsolidity/parsing/Parser.h	/^	ASTPointer<Block> parseBlock(ASTPointer<ASTString> const& _docString = {});$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString = {})
dev::solidity::Parser::parseContractDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<ContractDefinition> Parser::parseContractDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseContractDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<ContractDefinition> parseContractDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseContractKind	libsolidity/parsing/Parser.cpp	/^ContractDefinition::ContractKind Parser::parseContractKind()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseContractKind	libsolidity/parsing/Parser.h	/^	ContractDefinition::ContractKind parseContractKind();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseDoWhileStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<WhileStatement> Parser::parseDoWhileStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseDoWhileStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<WhileStatement> parseDoWhileStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseEmitStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<EmitStatement> Parser::parseEmitStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseEmitStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<EmitStatement> parseEmitStatement(ASTPointer<ASTString> const& docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& docString)
dev::solidity::Parser::parseEnumDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<EnumDefinition> Parser::parseEnumDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseEnumDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<EnumDefinition> parseEnumDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseEnumValue	libsolidity/parsing/Parser.cpp	/^ASTPointer<EnumValue> Parser::parseEnumValue()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseEnumValue	libsolidity/parsing/Parser.h	/^	ASTPointer<EnumValue> parseEnumValue();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseEventDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<EventDefinition> Parser::parseEventDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseEventDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<EventDefinition> parseEventDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseExpression($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<Expression> const& _partiallyParsedExpression )
dev::solidity::Parser::parseExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseExpression($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
dev::solidity::Parser::parseExpressionStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<ExpressionStatement> Parser::parseExpressionStatement($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _partialParserResult )
dev::solidity::Parser::parseExpressionStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<ExpressionStatement> parseExpressionStatement($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
dev::solidity::Parser::parseForStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<ForStatement> Parser::parseForStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseForStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<ForStatement> parseForStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseFunctionCallArguments	libsolidity/parsing/Parser.cpp	/^pair<vector<ASTPointer<Expression>>, vector<ASTPointer<ASTString>>> Parser::parseFunctionCallArguments()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseFunctionCallArguments	libsolidity/parsing/Parser.h	/^	std::pair<std::vector<ASTPointer<Expression>>, std::vector<ASTPointer<ASTString>>> parseFunctionCallArguments();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseFunctionCallListArguments	libsolidity/parsing/Parser.cpp	/^vector<ASTPointer<Expression>> Parser::parseFunctionCallListArguments()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseFunctionCallListArguments	libsolidity/parsing/Parser.h	/^	std::vector<ASTPointer<Expression>> parseFunctionCallListArguments();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseFunctionDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<FunctionDefinition> parseFunctionDefinition(ASTString const* _contractName);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTString const* _contractName)
dev::solidity::Parser::parseFunctionDefinitionOrFunctionTypeStateVariable	libsolidity/parsing/Parser.cpp	/^ASTPointer<ASTNode> Parser::parseFunctionDefinitionOrFunctionTypeStateVariable()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseFunctionDefinitionOrFunctionTypeStateVariable	libsolidity/parsing/Parser.h	/^	ASTPointer<ASTNode> parseFunctionDefinitionOrFunctionTypeStateVariable();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseFunctionHeader	libsolidity/parsing/Parser.cpp	/^Parser::FunctionHeaderParserResult Parser::parseFunctionHeader(bool _forceEmptyName, bool _allowModifiers)$/;"	f	class:dev::solidity::Parser	signature:(bool _forceEmptyName, bool _allowModifiers)
dev::solidity::Parser::parseFunctionHeader	libsolidity/parsing/Parser.h	/^	FunctionHeaderParserResult parseFunctionHeader(bool _forceEmptyName, bool _allowModifiers);$/;"	p	class:dev::solidity::Parser	access:private	signature:(bool _forceEmptyName, bool _allowModifiers)
dev::solidity::Parser::parseFunctionType	libsolidity/parsing/Parser.cpp	/^ASTPointer<FunctionTypeName> Parser::parseFunctionType()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseFunctionType	libsolidity/parsing/Parser.h	/^	ASTPointer<FunctionTypeName> parseFunctionType();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseIdentifier	libsolidity/parsing/Parser.cpp	/^ASTPointer<Identifier> Parser::parseIdentifier()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseIdentifier	libsolidity/parsing/Parser.h	/^	ASTPointer<Identifier> parseIdentifier();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseIfStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<IfStatement> Parser::parseIfStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseIfStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<IfStatement> parseIfStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseImportDirective	libsolidity/parsing/Parser.cpp	/^ASTPointer<ImportDirective> Parser::parseImportDirective()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseImportDirective	libsolidity/parsing/Parser.h	/^	ASTPointer<ImportDirective> parseImportDirective();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseIndexAccessedPath	libsolidity/parsing/Parser.cpp	/^Parser::IndexAccessedPath Parser::parseIndexAccessedPath()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseIndexAccessedPath	libsolidity/parsing/Parser.h	/^	IndexAccessedPath parseIndexAccessedPath();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseInheritanceSpecifier	libsolidity/parsing/Parser.cpp	/^ASTPointer<InheritanceSpecifier> Parser::parseInheritanceSpecifier()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseInheritanceSpecifier	libsolidity/parsing/Parser.h	/^	ASTPointer<InheritanceSpecifier> parseInheritanceSpecifier();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseInlineAssembly	libsolidity/parsing/Parser.cpp	/^ASTPointer<InlineAssembly> Parser::parseInlineAssembly(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseInlineAssembly	libsolidity/parsing/Parser.h	/^	ASTPointer<InlineAssembly> parseInlineAssembly(ASTPointer<ASTString> const& _docString = {});$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString = {})
dev::solidity::Parser::parseLeftHandSideExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseLeftHandSideExpression($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<Expression> const& _partiallyParsedExpression )
dev::solidity::Parser::parseLeftHandSideExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseLeftHandSideExpression($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
dev::solidity::Parser::parseMapping	libsolidity/parsing/Parser.cpp	/^ASTPointer<Mapping> Parser::parseMapping()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseMapping	libsolidity/parsing/Parser.h	/^	ASTPointer<Mapping> parseMapping();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseModifierDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<ModifierDefinition> Parser::parseModifierDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseModifierDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<ModifierDefinition> parseModifierDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseModifierInvocation	libsolidity/parsing/Parser.cpp	/^ASTPointer<ModifierInvocation> Parser::parseModifierInvocation()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseModifierInvocation	libsolidity/parsing/Parser.h	/^	ASTPointer<ModifierInvocation> parseModifierInvocation();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseParameterList	libsolidity/parsing/Parser.cpp	/^ASTPointer<ParameterList> Parser::parseParameterList($/;"	f	class:dev::solidity::Parser	signature:( VarDeclParserOptions const& _options, bool _allowEmpty )
dev::solidity::Parser::parseParameterList	libsolidity/parsing/Parser.h	/^	ASTPointer<ParameterList> parseParameterList($/;"	p	class:dev::solidity::Parser	access:private	signature:( VarDeclParserOptions const& _options = {}, bool _allowEmpty = true )
dev::solidity::Parser::parsePragmaDirective	libsolidity/parsing/Parser.cpp	/^ASTPointer<PragmaDirective> Parser::parsePragmaDirective()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parsePragmaDirective	libsolidity/parsing/Parser.h	/^	ASTPointer<PragmaDirective> parsePragmaDirective();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parsePragmaVersion	libsolidity/parsing/Parser.cpp	/^void Parser::parsePragmaVersion(vector<Token> const& tokens, vector<string> const& literals)$/;"	f	class:dev::solidity::Parser	signature:(vector<Token> const& tokens, vector<string> const& literals)
dev::solidity::Parser::parsePragmaVersion	libsolidity/parsing/Parser.h	/^	void parsePragmaVersion(std::vector<Token> const& tokens, std::vector<std::string> const& literals);$/;"	p	class:dev::solidity::Parser	access:private	signature:(std::vector<Token> const& tokens, std::vector<std::string> const& literals)
dev::solidity::Parser::parsePrimaryExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parsePrimaryExpression()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parsePrimaryExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parsePrimaryExpression();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseSimpleStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<Statement> Parser::parseSimpleStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseSimpleStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<Statement> parseSimpleStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseStateMutability	libsolidity/parsing/Parser.cpp	/^StateMutability Parser::parseStateMutability()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseStateMutability	libsolidity/parsing/Parser.h	/^	StateMutability parseStateMutability();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<Statement> Parser::parseStatement()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<Statement> parseStatement();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseStructDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<StructDefinition> Parser::parseStructDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseStructDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<StructDefinition> parseStructDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseTypeName	libsolidity/parsing/Parser.cpp	/^ASTPointer<TypeName> Parser::parseTypeName(bool _allowVar)$/;"	f	class:dev::solidity::Parser	signature:(bool _allowVar)
dev::solidity::Parser::parseTypeName	libsolidity/parsing/Parser.h	/^	ASTPointer<TypeName> parseTypeName(bool _allowVar);$/;"	p	class:dev::solidity::Parser	access:private	signature:(bool _allowVar)
dev::solidity::Parser::parseTypeNameSuffix	libsolidity/parsing/Parser.cpp	/^ASTPointer<TypeName> Parser::parseTypeNameSuffix(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory)
dev::solidity::Parser::parseTypeNameSuffix	libsolidity/parsing/Parser.h	/^	ASTPointer<TypeName> parseTypeNameSuffix(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory)
dev::solidity::Parser::parseUnaryExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseUnaryExpression($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<Expression> const& _partiallyParsedExpression )
dev::solidity::Parser::parseUnaryExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseUnaryExpression($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
dev::solidity::Parser::parseUserDefinedTypeName	libsolidity/parsing/Parser.cpp	/^ASTPointer<UserDefinedTypeName> Parser::parseUserDefinedTypeName()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseUserDefinedTypeName	libsolidity/parsing/Parser.h	/^	ASTPointer<UserDefinedTypeName> parseUserDefinedTypeName();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseUsingDirective	libsolidity/parsing/Parser.cpp	/^ASTPointer<UsingForDirective> Parser::parseUsingDirective()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseUsingDirective	libsolidity/parsing/Parser.h	/^	ASTPointer<UsingForDirective> parseUsingDirective();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseVariableDeclaration	libsolidity/parsing/Parser.cpp	/^ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration($/;"	f	class:dev::solidity::Parser	signature:( VarDeclParserOptions const& _options, ASTPointer<TypeName> const& _lookAheadArrayType )
dev::solidity::Parser::parseVariableDeclaration	libsolidity/parsing/Parser.h	/^	ASTPointer<VariableDeclaration> parseVariableDeclaration($/;"	p	class:dev::solidity::Parser	access:private	signature:( VarDeclParserOptions const& _options = {}, ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>() )
dev::solidity::Parser::parseVariableDeclarationStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<VariableDeclarationStatement> Parser::parseVariableDeclarationStatement($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<TypeName> const& _lookAheadArrayType )
dev::solidity::Parser::parseVariableDeclarationStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<VariableDeclarationStatement> parseVariableDeclarationStatement($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>() )
dev::solidity::Parser::parseVisibilitySpecifier	libsolidity/parsing/Parser.cpp	/^Declaration::Visibility Parser::parseVisibilitySpecifier()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::parseVisibilitySpecifier	libsolidity/parsing/Parser.h	/^	Declaration::Visibility parseVisibilitySpecifier();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::parseWhileStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<WhileStatement> Parser::parseWhileStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::parseWhileStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<WhileStatement> parseWhileStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
dev::solidity::Parser::peekStatementType	libsolidity/parsing/Parser.cpp	/^Parser::LookAheadInfo Parser::peekStatementType() const$/;"	f	class:dev::solidity::Parser	signature:() const
dev::solidity::Parser::peekStatementType	libsolidity/parsing/Parser.h	/^	LookAheadInfo peekStatementType() const;$/;"	p	class:dev::solidity::Parser	access:private	signature:() const
dev::solidity::Parser::tryParseIndexAccessedPath	libsolidity/parsing/Parser.cpp	/^pair<Parser::LookAheadInfo, Parser::IndexAccessedPath> Parser::tryParseIndexAccessedPath()$/;"	f	class:dev::solidity::Parser	signature:()
dev::solidity::Parser::tryParseIndexAccessedPath	libsolidity/parsing/Parser.h	/^	std::pair<LookAheadInfo, IndexAccessedPath> tryParseIndexAccessedPath();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
dev::solidity::Parser::typeNameFromIndexAccessStructure	libsolidity/parsing/Parser.cpp	/^ASTPointer<TypeName> Parser::typeNameFromIndexAccessStructure(Parser::IndexAccessedPath const& _iap)$/;"	f	class:dev::solidity::Parser	signature:(Parser::IndexAccessedPath const& _iap)
dev::solidity::Parser::typeNameFromIndexAccessStructure	libsolidity/parsing/Parser.h	/^	ASTPointer<TypeName> typeNameFromIndexAccessStructure(IndexAccessedPath const& _pathAndIndices);$/;"	p	class:dev::solidity::Parser	access:private	signature:(IndexAccessedPath const& _pathAndIndices)
dev::solidity::PlaceholderStatement	libsolidity/ast/AST.h	/^class PlaceholderStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::PlaceholderStatement::PlaceholderStatement	libsolidity/ast/AST.h	/^	explicit PlaceholderStatement($/;"	f	class:dev::solidity::PlaceholderStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString )
dev::solidity::PlaceholderStatement::accept	libsolidity/ast/AST_accept.h	/^void PlaceholderStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::PlaceholderStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::PlaceholderStatement::accept	libsolidity/ast/AST_accept.h	/^void PlaceholderStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::PlaceholderStatement	signature:(ASTVisitor& _visitor)
dev::solidity::PlaceholderStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::PlaceholderStatement	access:public
dev::solidity::PlaceholderStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::PlaceholderStatement	access:public
dev::solidity::PostTypeChecker	libsolidity/analysis/PostTypeChecker.h	/^class PostTypeChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::PostTypeChecker::PostTypeChecker	libsolidity/analysis/PostTypeChecker.h	/^	PostTypeChecker(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::PostTypeChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::PostTypeChecker::check	libsolidity/analysis/PostTypeChecker.h	/^	bool check(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::PostTypeChecker	access:public	signature:(ASTNode const& _astRoot)
dev::solidity::PostTypeChecker::findCycle	libsolidity/analysis/PostTypeChecker.h	/^	VariableDeclaration const* findCycle(VariableDeclaration const& _startingFrom);$/;"	p	class:dev::solidity::PostTypeChecker	access:private	signature:(VariableDeclaration const& _startingFrom)
dev::solidity::PostTypeChecker::m_constVariableDependencies	libsolidity/analysis/PostTypeChecker.h	/^	std::map<VariableDeclaration const*, std::set<VariableDeclaration const*>> m_constVariableDependencies;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::m_constVariables	libsolidity/analysis/PostTypeChecker.h	/^	std::vector<VariableDeclaration const*> m_constVariables; \/\/\/< Required for determinism.$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::m_currentConstVariable	libsolidity/analysis/PostTypeChecker.h	/^	VariableDeclaration const* m_currentConstVariable = nullptr;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::m_errorReporter	libsolidity/analysis/PostTypeChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::override	libsolidity/analysis/PostTypeChecker.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::override	libsolidity/analysis/PostTypeChecker.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::override	libsolidity/analysis/PostTypeChecker.h	/^	bool visit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::override	libsolidity/analysis/PostTypeChecker.h	/^	void endVisit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::override	libsolidity/analysis/PostTypeChecker.h	/^	void endVisit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
dev::solidity::PostTypeChecker::typeError	libsolidity/analysis/PostTypeChecker.h	/^	void typeError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::PostTypeChecker	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
dev::solidity::PragmaDirective	libsolidity/ast/AST.h	/^class PragmaDirective: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::PragmaDirective::PragmaDirective	libsolidity/ast/AST.h	/^	PragmaDirective($/;"	f	class:dev::solidity::PragmaDirective	access:public	signature:( SourceLocation const& _location, std::vector<Token> const& _tokens, std::vector<ASTString> const& _literals )
dev::solidity::PragmaDirective::accept	libsolidity/ast/AST_accept.h	/^void PragmaDirective::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::PragmaDirective	signature:(ASTConstVisitor& _visitor) const
dev::solidity::PragmaDirective::accept	libsolidity/ast/AST_accept.h	/^void PragmaDirective::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::PragmaDirective	signature:(ASTVisitor& _visitor)
dev::solidity::PragmaDirective::m_literals	libsolidity/ast/AST.h	/^	std::vector<ASTString> m_literals;$/;"	m	class:dev::solidity::PragmaDirective	access:private
dev::solidity::PragmaDirective::m_tokens	libsolidity/ast/AST.h	/^	std::vector<Token> m_tokens;$/;"	m	class:dev::solidity::PragmaDirective	access:private
dev::solidity::PragmaDirective::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::PragmaDirective	access:public
dev::solidity::PragmaDirective::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::PragmaDirective	access:public
dev::solidity::PragmaDirective::std::literals	libsolidity/ast/AST.h	/^	std::vector<ASTString> const& literals() const { return m_literals; }$/;"	f	class:dev::solidity::PragmaDirective::std	access:public	signature:() const
dev::solidity::PragmaDirective::std::tokens	libsolidity/ast/AST.h	/^	std::vector<Token> const& tokens() const { return m_tokens; }$/;"	f	class:dev::solidity::PragmaDirective::std	access:public	signature:() const
dev::solidity::PrimaryExpression	libsolidity/ast/AST.h	/^class PrimaryExpression: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::PrimaryExpression::PrimaryExpression	libsolidity/ast/AST.h	/^	PrimaryExpression(SourceLocation const& _location): Expression(_location) {}$/;"	f	class:dev::solidity::PrimaryExpression	access:public	signature:(SourceLocation const& _location)
dev::solidity::RationalNumberType	libsolidity/ast/Types.h	/^class RationalNumberType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::RationalNumberType::RationalNumberType	libsolidity/ast/Types.h	/^	explicit RationalNumberType(rational const& _value, TypePointer const& _compatibleBytesType = TypePointer()):$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:(rational const& _value, TypePointer const& _compatibleBytesType = TypePointer())
dev::solidity::RationalNumberType::bigintToReadableString	libsolidity/ast/Types.h	/^	static std::string bigintToReadableString(dev::bigint const& num);$/;"	p	class:dev::solidity::RationalNumberType	access:private	signature:(dev::bigint const& num)
dev::solidity::RationalNumberType::fixedPointType	libsolidity/ast/Types.h	/^	std::shared_ptr<FixedPointType const> fixedPointType() const;$/;"	p	class:dev::solidity::RationalNumberType	access:public	signature:() const
dev::solidity::RationalNumberType::forLiteral	libsolidity/ast/Types.h	/^	static TypePointer forLiteral(Literal const& _literal);$/;"	p	class:dev::solidity::RationalNumberType	access:public	signature:(Literal const& _literal)
dev::solidity::RationalNumberType::integerType	libsolidity/ast/Types.h	/^	std::shared_ptr<IntegerType const> integerType() const;$/;"	p	class:dev::solidity::RationalNumberType	access:public	signature:() const
dev::solidity::RationalNumberType::isFractional	libsolidity/ast/Types.h	/^	bool isFractional() const { return m_value.denominator() != 1; }$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:() const
dev::solidity::RationalNumberType::isNegative	libsolidity/ast/Types.h	/^	bool isNegative() const { return m_value < 0; }$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:() const
dev::solidity::RationalNumberType::isValidLiteral	libsolidity/ast/Types.h	/^	static std::tuple<bool, rational> isValidLiteral(Literal const& _literal);$/;"	p	class:dev::solidity::RationalNumberType	access:private	signature:(Literal const& _literal)
dev::solidity::RationalNumberType::isZero	libsolidity/ast/Types.h	/^	bool isZero() const { return m_value == 0; }$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:() const
dev::solidity::RationalNumberType::m_compatibleBytesType	libsolidity/ast/Types.h	/^	TypePointer m_compatibleBytesType;$/;"	m	class:dev::solidity::RationalNumberType	access:private
dev::solidity::RationalNumberType::m_value	libsolidity/ast/Types.h	/^	rational m_value;$/;"	m	class:dev::solidity::RationalNumberType	access:private
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	TypePointer mobileType() const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::override	libsolidity/ast/Types.h	/^	u256 literalValue(Literal const* _literal) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
dev::solidity::RationalNumberType::parseRational	libsolidity/ast/Types.h	/^	static std::tuple<bool, rational> parseRational(std::string const& _value);$/;"	p	class:dev::solidity::RationalNumberType	access:private	signature:(std::string const& _value)
dev::solidity::ReadCallback	libsolidity/interface/ReadFile.h	/^class ReadCallback: boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
dev::solidity::ReadCallback::Result	libsolidity/interface/ReadFile.h	/^	struct Result$/;"	s	class:dev::solidity::ReadCallback	access:public
dev::solidity::ReadCallback::Result::responseOrErrorMessage	libsolidity/interface/ReadFile.h	/^		std::string responseOrErrorMessage;$/;"	m	struct:dev::solidity::ReadCallback::Result	access:public
dev::solidity::ReadCallback::Result::success	libsolidity/interface/ReadFile.h	/^		bool success;$/;"	m	struct:dev::solidity::ReadCallback::Result	access:public
dev::solidity::ReferenceType	libsolidity/ast/Types.h	/^class ReferenceType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::ReferenceType::ReferenceType	libsolidity/ast/Types.h	/^	explicit ReferenceType(DataLocation _location): m_location(_location) {}$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:(DataLocation _location)
dev::solidity::ReferenceType::copyForLocation	libsolidity/ast/Types.h	/^	virtual TypePointer copyForLocation(DataLocation _location, bool _isPointer) const = 0;$/;"	p	class:dev::solidity::ReferenceType	access:public	signature:(DataLocation _location, bool _isPointer) const
dev::solidity::ReferenceType::copyForLocationIfReference	libsolidity/ast/Types.h	/^	TypePointer copyForLocationIfReference(TypePointer const& _type) const;$/;"	p	class:dev::solidity::ReferenceType	access:protected	signature:(TypePointer const& _type) const
dev::solidity::ReferenceType::copyForLocationIfReference	libsolidity/ast/Types.h	/^	static TypePointer copyForLocationIfReference(DataLocation _location, TypePointer const& _type);$/;"	p	class:dev::solidity::ReferenceType	access:public	signature:(DataLocation _location, TypePointer const& _type)
dev::solidity::ReferenceType::identifierLocationSuffix	libsolidity/ast/Types.h	/^	std::string identifierLocationSuffix() const;$/;"	p	class:dev::solidity::ReferenceType	access:protected	signature:() const
dev::solidity::ReferenceType::isPointer	libsolidity/ast/Types.h	/^	bool isPointer() const { return m_isPointer; }$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:() const
dev::solidity::ReferenceType::location	libsolidity/ast/Types.h	/^	DataLocation location() const { return m_location; }$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:() const
dev::solidity::ReferenceType::m_isPointer	libsolidity/ast/Types.h	/^	bool m_isPointer = true;$/;"	m	class:dev::solidity::ReferenceType	access:protected
dev::solidity::ReferenceType::m_location	libsolidity/ast/Types.h	/^	DataLocation m_location = DataLocation::Storage;$/;"	m	class:dev::solidity::ReferenceType	access:protected
dev::solidity::ReferenceType::operator ==	libsolidity/ast/Types.h	/^	bool operator==(ReferenceType const& _other) const$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:(ReferenceType const& _other) const
dev::solidity::ReferenceType::override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::ReferenceType	access:public
dev::solidity::ReferenceType::stringForReferencePart	libsolidity/ast/Types.h	/^	std::string stringForReferencePart() const;$/;"	p	class:dev::solidity::ReferenceType	access:protected	signature:() const
dev::solidity::ReferencesResolver	libsolidity/analysis/ReferencesResolver.h	/^class ReferencesResolver: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ReferencesResolver::ReferencesResolver	libsolidity/analysis/ReferencesResolver.h	/^	ReferencesResolver($/;"	f	class:dev::solidity::ReferencesResolver	access:public	signature:( langutil::ErrorReporter& _errorReporter, NameAndTypeResolver& _resolver, bool _resolveInsideCode = false )
dev::solidity::ReferencesResolver::declarationError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::declarationError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
dev::solidity::ReferencesResolver::declarationError	libsolidity/analysis/ReferencesResolver.h	/^	void declarationError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(ArrayTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ArrayTypeName const& _typeName)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(Block const& _block)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Block const& _block)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(ForStatement const& _for)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ForStatement const& _for)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(FunctionDefinition const&)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(FunctionDefinition const&)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(FunctionTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(FunctionTypeName const& _typeName)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(Mapping const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Mapping const& _typeName)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(ModifierDefinition const&)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ModifierDefinition const&)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(UserDefinedTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(UserDefinedTypeName const& _typeName)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(VariableDeclaration const& _variable)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(VariableDeclaration const& _variable)
dev::solidity::ReferencesResolver::endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(VariableDeclarationStatement const& _varDeclStatement)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(VariableDeclarationStatement const& _varDeclStatement)
dev::solidity::ReferencesResolver::fatalDeclarationError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::fatalDeclarationError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
dev::solidity::ReferencesResolver::fatalDeclarationError	libsolidity/analysis/ReferencesResolver.h	/^	void fatalDeclarationError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
dev::solidity::ReferencesResolver::fatalTypeError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::fatalTypeError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
dev::solidity::ReferencesResolver::fatalTypeError	libsolidity/analysis/ReferencesResolver.h	/^	void fatalTypeError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
dev::solidity::ReferencesResolver::m_errorOccurred	libsolidity/analysis/ReferencesResolver.h	/^	bool m_errorOccurred = false;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::m_errorReporter	libsolidity/analysis/ReferencesResolver.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::m_resolveInsideCode	libsolidity/analysis/ReferencesResolver.h	/^	bool const m_resolveInsideCode;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::m_resolver	libsolidity/analysis/ReferencesResolver.h	/^	NameAndTypeResolver& m_resolver;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::m_returnParameters	libsolidity/analysis/ReferencesResolver.h	/^	std::vector<ParameterList const*> m_returnParameters;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(Block const& _block) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(ElementaryTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(ForStatement const& _for) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(FunctionDefinition const& _functionDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(ModifierDefinition const& _modifierDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(ArrayTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(Block const& _block) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(ForStatement const& _for) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(FunctionDefinition const& _functionDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(FunctionTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(Mapping const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(ModifierDefinition const& _modifierDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(UserDefinedTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(VariableDeclarationStatement const& _varDeclStatement) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
dev::solidity::ReferencesResolver::resolve	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::resolve(ASTNode const& _root)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ASTNode const& _root)
dev::solidity::ReferencesResolver::resolve	libsolidity/analysis/ReferencesResolver.h	/^	bool resolve(ASTNode const& _root);$/;"	p	class:dev::solidity::ReferencesResolver	access:public	signature:(ASTNode const& _root)
dev::solidity::ReferencesResolver::typeError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::typeError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
dev::solidity::ReferencesResolver::typeError	libsolidity/analysis/ReferencesResolver.h	/^	void typeError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(Block const& _block)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Block const& _block)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(ElementaryTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ElementaryTypeName const& _typeName)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(ForStatement const& _for)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ForStatement const& _for)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(FunctionDefinition const& _functionDefinition)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(FunctionDefinition const& _functionDefinition)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(Identifier const& _identifier)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Identifier const& _identifier)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(InlineAssembly const& _inlineAssembly)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(ModifierDefinition const&)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ModifierDefinition const&)
dev::solidity::ReferencesResolver::visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(Return const& _return)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Return const& _return)
dev::solidity::Return	libsolidity/ast/AST.h	/^class Return: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::Return::Return	libsolidity/ast/AST.h	/^	Return($/;"	f	class:dev::solidity::Return	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> _expression )
dev::solidity::Return::accept	libsolidity/ast/AST_accept.h	/^void Return::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Return	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Return::accept	libsolidity/ast/AST_accept.h	/^void Return::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Return	signature:(ASTVisitor& _visitor)
dev::solidity::Return::expression	libsolidity/ast/AST.h	/^	Expression const* expression() const { return m_expression.get(); }$/;"	f	class:dev::solidity::Return	access:public	signature:() const
dev::solidity::Return::m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression; \/\/\/< value to return, optional$/;"	m	class:dev::solidity::Return	access:private
dev::solidity::Return::override	libsolidity/ast/AST.h	/^	ReturnAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Return	access:public
dev::solidity::Return::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Return	access:public
dev::solidity::Return::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Return	access:public
dev::solidity::ReturnAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct ReturnAnnotation: StatementAnnotation$/;"	s	namespace:dev::solidity	inherits:StatementAnnotation
dev::solidity::ReturnAnnotation::functionReturnParameters	libsolidity/ast/ASTAnnotations.h	/^	ParameterList const* functionReturnParameters = nullptr;$/;"	m	struct:dev::solidity::ReturnAnnotation	access:public
dev::solidity::SMTChecker	libsolidity/formal/SMTChecker.h	/^class SMTChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::SMTChecker::OverflowTarget	libsolidity/formal/SMTChecker.h	/^	struct OverflowTarget$/;"	s	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::OverflowTarget::OverflowTarget	libsolidity/formal/SMTChecker.h	/^		OverflowTarget(Type _type, TypePointer _intType, smt::Expression _value, smt::Expression _path, langutil::SourceLocation const& _location):$/;"	f	struct:dev::solidity::SMTChecker::OverflowTarget	access:public	signature:(Type _type, TypePointer _intType, smt::Expression _value, smt::Expression _path, langutil::SourceLocation const& _location)
dev::solidity::SMTChecker::OverflowTarget::Type	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	c	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
dev::solidity::SMTChecker::OverflowTarget::Type::Overflow	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	m	class:dev::solidity::SMTChecker::OverflowTarget::Type	access:private
dev::solidity::SMTChecker::OverflowTarget::Type::Underflow	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	m	class:dev::solidity::SMTChecker::OverflowTarget::Type	access:private
dev::solidity::SMTChecker::OverflowTarget::intType	libsolidity/formal/SMTChecker.h	/^		TypePointer intType;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
dev::solidity::SMTChecker::OverflowTarget::langutil::location	libsolidity/formal/SMTChecker.h	/^		langutil::SourceLocation const& location;$/;"	m	class:dev::solidity::SMTChecker::OverflowTarget::langutil	access:public
dev::solidity::SMTChecker::OverflowTarget::path	libsolidity/formal/SMTChecker.h	/^		smt::Expression path;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
dev::solidity::SMTChecker::OverflowTarget::type	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	typeref:class:dev::solidity::SMTChecker::OverflowTarget::Type	access:public
dev::solidity::SMTChecker::OverflowTarget::value	libsolidity/formal/SMTChecker.h	/^		smt::Expression value;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
dev::solidity::SMTChecker::SMTChecker	libsolidity/formal/SMTChecker.h	/^	SMTChecker(langutil::ErrorReporter& _errorReporter, std::map<h256, std::string> const& _smtlib2Responses);$/;"	p	class:dev::solidity::SMTChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter, std::map<h256, std::string> const& _smtlib2Responses)
dev::solidity::SMTChecker::abstractFunctionCall	libsolidity/formal/SMTChecker.h	/^	void abstractFunctionCall(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
dev::solidity::SMTChecker::addOverflowTarget	libsolidity/formal/SMTChecker.h	/^	void addOverflowTarget(OverflowTarget::Type _type, TypePointer _intType, smt::Expression _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(OverflowTarget::Type _type, TypePointer _intType, smt::Expression _value, langutil::SourceLocation const& _location)
dev::solidity::SMTChecker::addPathConjoinedExpression	libsolidity/formal/SMTChecker.h	/^	void addPathConjoinedExpression(smt::Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression const& _e)
dev::solidity::SMTChecker::addPathImpliedExpression	libsolidity/formal/SMTChecker.h	/^	void addPathImpliedExpression(smt::Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression const& _e)
dev::solidity::SMTChecker::analyze	libsolidity/formal/SMTChecker.h	/^	void analyze(SourceUnit const& _sources, std::shared_ptr<langutil::Scanner> const& _scanner);$/;"	p	class:dev::solidity::SMTChecker	access:public	signature:(SourceUnit const& _sources, std::shared_ptr<langutil::Scanner> const& _scanner)
dev::solidity::SMTChecker::arithmeticOperation	libsolidity/formal/SMTChecker.h	/^	void arithmeticOperation(BinaryOperation const& _op);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(BinaryOperation const& _op)
dev::solidity::SMTChecker::arrayAssignment	libsolidity/formal/SMTChecker.h	/^	void arrayAssignment();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::arrayIndexAssignment	libsolidity/formal/SMTChecker.h	/^	void arrayIndexAssignment(Assignment const& _assignment);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Assignment const& _assignment)
dev::solidity::SMTChecker::assignment	libsolidity/formal/SMTChecker.h	/^	void assignment(VariableDeclaration const& _variable, Expression const& _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _variable, Expression const& _value, langutil::SourceLocation const& _location)
dev::solidity::SMTChecker::assignment	libsolidity/formal/SMTChecker.h	/^	void assignment(VariableDeclaration const& _variable, smt::Expression const& _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _variable, smt::Expression const& _value, langutil::SourceLocation const& _location)
dev::solidity::SMTChecker::booleanOperation	libsolidity/formal/SMTChecker.h	/^	void booleanOperation(BinaryOperation const& _op);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(BinaryOperation const& _op)
dev::solidity::SMTChecker::checkBooleanNotConstant	libsolidity/formal/SMTChecker.h	/^	void checkBooleanNotConstant($/;"	p	class:dev::solidity::SMTChecker	access:private	signature:( Expression const& _condition, std::string const& _description )
dev::solidity::SMTChecker::checkCondition	libsolidity/formal/SMTChecker.h	/^	void checkCondition($/;"	p	class:dev::solidity::SMTChecker	access:private	signature:( smt::Expression _condition, langutil::SourceLocation const& _location, std::string const& _description, std::string const& _additionalValueName = , smt::Expression* _additionalValue = nullptr )
dev::solidity::SMTChecker::checkOverflow	libsolidity/formal/SMTChecker.h	/^	void checkOverflow(OverflowTarget& _target);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(OverflowTarget& _target)
dev::solidity::SMTChecker::checkSatisfiable	libsolidity/formal/SMTChecker.h	/^	smt::CheckResult checkSatisfiable();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::checkSatisfiableAndGenerateModel	libsolidity/formal/SMTChecker.h	/^	checkSatisfiableAndGenerateModel(std::vector<smt::Expression> const& _expressionsToEvaluate);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::vector<smt::Expression> const& _expressionsToEvaluate)
dev::solidity::SMTChecker::checkUnderOverflow	libsolidity/formal/SMTChecker.h	/^	void checkUnderOverflow();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::checkUnderflow	libsolidity/formal/SMTChecker.h	/^	void checkUnderflow(OverflowTarget& _target);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(OverflowTarget& _target)
dev::solidity::SMTChecker::compareOperation	libsolidity/formal/SMTChecker.h	/^	void compareOperation(BinaryOperation const& _op);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(BinaryOperation const& _op)
dev::solidity::SMTChecker::copyVariableIndices	libsolidity/formal/SMTChecker.h	/^	VariableIndices copyVariableIndices();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::createExpr	libsolidity/formal/SMTChecker.h	/^	void createExpr(Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e)
dev::solidity::SMTChecker::createVariable	libsolidity/formal/SMTChecker.h	/^	bool createVariable(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _varDecl)
dev::solidity::SMTChecker::currentPathConditions	libsolidity/formal/SMTChecker.h	/^	smt::Expression currentPathConditions();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::currentValue	libsolidity/formal/SMTChecker.h	/^	smt::Expression currentValue(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
dev::solidity::SMTChecker::defineExpr	libsolidity/formal/SMTChecker.h	/^	void defineExpr(Expression const& _e, smt::Expression _value);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e, smt::Expression _value)
dev::solidity::SMTChecker::defineGlobalFunction	libsolidity/formal/SMTChecker.h	/^	void defineGlobalFunction(std::string const& _name, Expression const& _expr);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::string const& _name, Expression const& _expr)
dev::solidity::SMTChecker::defineGlobalVariable	libsolidity/formal/SMTChecker.h	/^	void defineGlobalVariable(std::string const& _name, Expression const& _expr, bool _increaseIndex = false);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::string const& _name, Expression const& _expr, bool _increaseIndex = false)
dev::solidity::SMTChecker::division	libsolidity/formal/SMTChecker.h	/^	smt::Expression division(smt::Expression _left, smt::Expression _right, IntegerType const& _type);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression _left, smt::Expression _right, IntegerType const& _type)
dev::solidity::SMTChecker::eraseArrayKnowledge	libsolidity/formal/SMTChecker.h	/^	void eraseArrayKnowledge();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::expr	libsolidity/formal/SMTChecker.h	/^	smt::Expression expr(Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e)
dev::solidity::SMTChecker::initializeFunctionCallParameters	libsolidity/formal/SMTChecker.h	/^	void initializeFunctionCallParameters(FunctionDefinition const& _function, std::vector<smt::Expression> const& _callArgs);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionDefinition const& _function, std::vector<smt::Expression> const& _callArgs)
dev::solidity::SMTChecker::initializeLocalVariables	libsolidity/formal/SMTChecker.h	/^	void initializeLocalVariables(FunctionDefinition const& _function);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionDefinition const& _function)
dev::solidity::SMTChecker::inlineFunctionCall	libsolidity/formal/SMTChecker.h	/^	void inlineFunctionCall(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
dev::solidity::SMTChecker::isRootFunction	libsolidity/formal/SMTChecker.h	/^	bool isRootFunction();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::knownExpr	libsolidity/formal/SMTChecker.h	/^	bool knownExpr(Expression const& _e) const;$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e) const
dev::solidity::SMTChecker::knownGlobalSymbol	libsolidity/formal/SMTChecker.h	/^	bool knownGlobalSymbol(std::string const& _var) const;$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::string const& _var) const
dev::solidity::SMTChecker::knownVariable	libsolidity/formal/SMTChecker.h	/^	bool knownVariable(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
dev::solidity::SMTChecker::m_arrayAssignmentHappened	libsolidity/formal/SMTChecker.h	/^	bool m_arrayAssignmentHappened = false;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_errorReporter	libsolidity/formal/SMTChecker.h	/^	langutil::ErrorReporter m_errorReporter;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_errorReporterReference	libsolidity/formal/SMTChecker.h	/^	langutil::ErrorReporter& m_errorReporterReference;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_expressions	libsolidity/formal/SMTChecker.h	/^	std::unordered_map<Expression const*, std::shared_ptr<SymbolicVariable>> m_expressions;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_functionPath	libsolidity/formal/SMTChecker.h	/^	std::vector<FunctionDefinition const*> m_functionPath;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_globalContext	libsolidity/formal/SMTChecker.h	/^	std::unordered_map<std::string, std::shared_ptr<SymbolicVariable>> m_globalContext;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_interface	libsolidity/formal/SMTChecker.h	/^	std::shared_ptr<smt::SolverInterface> m_interface;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_loopExecutionHappened	libsolidity/formal/SMTChecker.h	/^	bool m_loopExecutionHappened = false;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_noSolverWarning	libsolidity/formal/SMTChecker.h	/^	bool m_noSolverWarning = false;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_overflowTargets	libsolidity/formal/SMTChecker.h	/^	std::vector<OverflowTarget> m_overflowTargets;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_pathConditions	libsolidity/formal/SMTChecker.h	/^	std::vector<smt::Expression> m_pathConditions;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_scanner	libsolidity/formal/SMTChecker.h	/^	std::shared_ptr<langutil::Scanner> m_scanner;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_smtErrors	libsolidity/formal/SMTChecker.h	/^	langutil::ErrorList m_smtErrors;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_uninterpretedTerms	libsolidity/formal/SMTChecker.h	/^	std::set<Expression const*> m_uninterpretedTerms;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_variableUsage	libsolidity/formal/SMTChecker.h	/^	std::shared_ptr<VariableUsage> m_variableUsage;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::m_variables	libsolidity/formal/SMTChecker.h	/^	std::unordered_map<VariableDeclaration const*, std::shared_ptr<SymbolicVariable>> m_variables;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::mergeVariables	libsolidity/formal/SMTChecker.h	/^	void mergeVariables(std::vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse)
dev::solidity::SMTChecker::newValue	libsolidity/formal/SMTChecker.h	/^	smt::Expression newValue(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	bool visit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	bool visit(ForStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	bool visit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	bool visit(IfStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	bool visit(MemberAccess const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	bool visit(WhileStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Assignment const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(BinaryOperation const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(FunctionCall const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Identifier const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(IndexAccess const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Literal const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Return const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(TupleExpression const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(UnaryOperation const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(VariableDeclaration const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::override	libsolidity/formal/SMTChecker.h	/^	void endVisit(VariableDeclarationStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
dev::solidity::SMTChecker::popPathCondition	libsolidity/formal/SMTChecker.h	/^	void popPathCondition();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::pushPathCondition	libsolidity/formal/SMTChecker.h	/^	void pushPathCondition(smt::Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression const& _e)
dev::solidity::SMTChecker::removeLocalVariables	libsolidity/formal/SMTChecker.h	/^	void removeLocalVariables();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::resetStateVariables	libsolidity/formal/SMTChecker.h	/^	void resetStateVariables();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::resetStorageReferences	libsolidity/formal/SMTChecker.h	/^	void resetStorageReferences();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
dev::solidity::SMTChecker::resetVariable	libsolidity/formal/SMTChecker.h	/^	void resetVariable(VariableDeclaration const& _variable);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _variable)
dev::solidity::SMTChecker::resetVariableIndices	libsolidity/formal/SMTChecker.h	/^	void resetVariableIndices(VariableIndices const& _indices);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableIndices const& _indices)
dev::solidity::SMTChecker::resetVariables	libsolidity/formal/SMTChecker.h	/^	void resetVariables(std::function<bool(VariableDeclaration const&)> const& _filter);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::function<bool(VariableDeclaration const&)> const& _filter)
dev::solidity::SMTChecker::resetVariables	libsolidity/formal/SMTChecker.h	/^	void resetVariables(std::vector<VariableDeclaration const*> _variables);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::vector<VariableDeclaration const*> _variables)
dev::solidity::SMTChecker::setUnknownValue	libsolidity/formal/SMTChecker.h	/^	void setUnknownValue(SymbolicVariable& _variable);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(SymbolicVariable& _variable)
dev::solidity::SMTChecker::setUnknownValue	libsolidity/formal/SMTChecker.h	/^	void setUnknownValue(VariableDeclaration const& decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& decl)
dev::solidity::SMTChecker::setZeroValue	libsolidity/formal/SMTChecker.h	/^	void setZeroValue(SymbolicVariable& _variable);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(SymbolicVariable& _variable)
dev::solidity::SMTChecker::setZeroValue	libsolidity/formal/SMTChecker.h	/^	void setZeroValue(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
dev::solidity::SMTChecker::unhandledQueries	libsolidity/formal/SMTChecker.h	/^	std::vector<std::string> unhandledQueries() { return m_interface->unhandledQueries(); }$/;"	f	class:dev::solidity::SMTChecker	access:public	signature:()
dev::solidity::SMTChecker::valueAtIndex	libsolidity/formal/SMTChecker.h	/^	smt::Expression valueAtIndex(VariableDeclaration const& _decl, int _index);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl, int _index)
dev::solidity::SMTChecker::visitAssert	libsolidity/formal/SMTChecker.h	/^	void visitAssert(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
dev::solidity::SMTChecker::visitBranch	libsolidity/formal/SMTChecker.h	/^	VariableIndices visitBranch(Statement const& _statement, smt::Expression _condition);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Statement const& _statement, smt::Expression _condition)
dev::solidity::SMTChecker::visitFunctionIdentifier	libsolidity/formal/SMTChecker.h	/^	void visitFunctionIdentifier(Identifier const& _identifier);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Identifier const& _identifier)
dev::solidity::SMTChecker::visitGasLeft	libsolidity/formal/SMTChecker.h	/^	void visitGasLeft(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
dev::solidity::SMTChecker::visitRequire	libsolidity/formal/SMTChecker.h	/^	void visitRequire(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
dev::solidity::SMTChecker::visitTypeConversion	libsolidity/formal/SMTChecker.h	/^	void visitTypeConversion(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
dev::solidity::SMTChecker::visitedFunction	libsolidity/formal/SMTChecker.h	/^	bool visitedFunction(FunctionDefinition const* _funDef);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionDefinition const* _funDef)
dev::solidity::SSAVariable	libsolidity/formal/SSAVariable.h	/^class SSAVariable$/;"	c	namespace:dev::solidity
dev::solidity::SSAVariable::SSAVariable	libsolidity/formal/SSAVariable.h	/^	SSAVariable();$/;"	p	class:dev::solidity::SSAVariable	access:public	signature:()
dev::solidity::SSAVariable::index	libsolidity/formal/SSAVariable.h	/^	unsigned index() const { return m_currentIndex; }$/;"	f	class:dev::solidity::SSAVariable	access:public	signature:() const
dev::solidity::SSAVariable::index	libsolidity/formal/SSAVariable.h	/^	unsigned& index() { return m_currentIndex; }$/;"	f	class:dev::solidity::SSAVariable	access:public	signature:()
dev::solidity::SSAVariable::m_currentIndex	libsolidity/formal/SSAVariable.h	/^	unsigned m_currentIndex;$/;"	m	class:dev::solidity::SSAVariable	access:private
dev::solidity::SSAVariable::m_nextFreeIndex	libsolidity/formal/SSAVariable.h	/^	std::shared_ptr<unsigned> m_nextFreeIndex;$/;"	m	class:dev::solidity::SSAVariable	access:private
dev::solidity::SSAVariable::operator ++	libsolidity/formal/SSAVariable.h	/^	unsigned operator++()$/;"	f	class:dev::solidity::SSAVariable	access:public	signature:()
dev::solidity::SSAVariable::resetIndex	libsolidity/formal/SSAVariable.h	/^	void resetIndex();$/;"	p	class:dev::solidity::SSAVariable	access:public	signature:()
dev::solidity::Scopable	libsolidity/ast/AST.h	/^class Scopable$/;"	c	namespace:dev::solidity
dev::solidity::Scopable::m_scope	libsolidity/ast/AST.h	/^	ASTNode const* m_scope = nullptr;$/;"	m	class:dev::solidity::Scopable	access:protected
dev::solidity::Scopable::scope	libsolidity/ast/AST.h	/^	ASTNode const* scope() const { return m_scope; }$/;"	f	class:dev::solidity::Scopable	access:public	signature:() const
dev::solidity::Scopable::setScope	libsolidity/ast/AST.h	/^	void setScope(ASTNode const* _scope) { m_scope = _scope; }$/;"	f	class:dev::solidity::Scopable	access:public	signature:(ASTNode const* _scope)
dev::solidity::Scopable::sourceUnit	libsolidity/ast/AST.h	/^	SourceUnit const& sourceUnit() const;$/;"	p	class:dev::solidity::Scopable	access:public	signature:() const
dev::solidity::Scopable::sourceUnitName	libsolidity/ast/AST.h	/^	std::string sourceUnitName() const;$/;"	p	class:dev::solidity::Scopable	access:public	signature:() const
dev::solidity::Scopable::~Scopable	libsolidity/ast/AST.h	/^	virtual ~Scopable() = default;$/;"	p	class:dev::solidity::Scopable	access:public	signature:()
dev::solidity::SemVerError	libsolidity/analysis/SemVerHandler.h	/^class SemVerError: dev::Exception$/;"	c	namespace:dev::solidity	inherits:dev::Exception
dev::solidity::SemVerMatchExpression	libsolidity/analysis/SemVerHandler.h	/^struct SemVerMatchExpression$/;"	s	namespace:dev::solidity
dev::solidity::SemVerMatchExpression::Conjunction	libsolidity/analysis/SemVerHandler.h	/^	struct Conjunction$/;"	s	struct:dev::solidity::SemVerMatchExpression	access:public
dev::solidity::SemVerMatchExpression::Conjunction::components	libsolidity/analysis/SemVerHandler.h	/^		std::vector<MatchComponent> components;$/;"	m	struct:dev::solidity::SemVerMatchExpression::Conjunction	access:public
dev::solidity::SemVerMatchExpression::Conjunction::matches	libsolidity/analysis/SemVerHandler.h	/^		bool matches(SemVerVersion const& _version) const;$/;"	p	struct:dev::solidity::SemVerMatchExpression::Conjunction	access:public	signature:(SemVerVersion const& _version) const
dev::solidity::SemVerMatchExpression::MatchComponent	libsolidity/analysis/SemVerHandler.h	/^	struct MatchComponent$/;"	s	struct:dev::solidity::SemVerMatchExpression	access:public
dev::solidity::SemVerMatchExpression::MatchComponent::levelsPresent	libsolidity/analysis/SemVerHandler.h	/^		unsigned levelsPresent = 1;$/;"	m	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public
dev::solidity::SemVerMatchExpression::MatchComponent::matches	libsolidity/analysis/SemVerHandler.h	/^		bool matches(SemVerVersion const& _version) const;$/;"	p	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public	signature:(SemVerVersion const& _version) const
dev::solidity::SemVerMatchExpression::MatchComponent::prefix	libsolidity/analysis/SemVerHandler.h	/^		Token prefix = Token::Illegal;$/;"	m	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public
dev::solidity::SemVerMatchExpression::MatchComponent::version	libsolidity/analysis/SemVerHandler.h	/^		SemVerVersion version;$/;"	m	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public
dev::solidity::SemVerMatchExpression::isValid	libsolidity/analysis/SemVerHandler.h	/^	bool isValid() const { return !m_disjunction.empty(); }$/;"	f	struct:dev::solidity::SemVerMatchExpression	access:public	signature:() const
dev::solidity::SemVerMatchExpression::m_disjunction	libsolidity/analysis/SemVerHandler.h	/^	std::vector<Conjunction> m_disjunction;$/;"	m	struct:dev::solidity::SemVerMatchExpression	access:public
dev::solidity::SemVerMatchExpression::matches	libsolidity/analysis/SemVerHandler.h	/^	bool matches(SemVerVersion const& _version) const;$/;"	p	struct:dev::solidity::SemVerMatchExpression	access:public	signature:(SemVerVersion const& _version) const
dev::solidity::SemVerMatchExpressionParser	libsolidity/analysis/SemVerHandler.h	/^class SemVerMatchExpressionParser$/;"	c	namespace:dev::solidity
dev::solidity::SemVerMatchExpressionParser::SemVerMatchExpressionParser	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpressionParser(std::vector<Token> const& _tokens, std::vector<std::string> const& _literals):$/;"	f	class:dev::solidity::SemVerMatchExpressionParser	access:public	signature:(std::vector<Token> const& _tokens, std::vector<std::string> const& _literals)
dev::solidity::SemVerMatchExpressionParser::currentChar	libsolidity/analysis/SemVerHandler.h	/^	char currentChar() const;$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:() const
dev::solidity::SemVerMatchExpressionParser::currentToken	libsolidity/analysis/SemVerHandler.h	/^	Token currentToken() const;$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:() const
dev::solidity::SemVerMatchExpressionParser::m_expression	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpression m_expression;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
dev::solidity::SemVerMatchExpressionParser::m_literals	libsolidity/analysis/SemVerHandler.h	/^	std::vector<std::string> m_literals;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
dev::solidity::SemVerMatchExpressionParser::m_pos	libsolidity/analysis/SemVerHandler.h	/^	unsigned m_pos = 0;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
dev::solidity::SemVerMatchExpressionParser::m_posInside	libsolidity/analysis/SemVerHandler.h	/^	unsigned m_posInside = 0;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
dev::solidity::SemVerMatchExpressionParser::m_tokens	libsolidity/analysis/SemVerHandler.h	/^	std::vector<Token> m_tokens;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
dev::solidity::SemVerMatchExpressionParser::nextChar	libsolidity/analysis/SemVerHandler.h	/^	char nextChar();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
dev::solidity::SemVerMatchExpressionParser::nextToken	libsolidity/analysis/SemVerHandler.h	/^	void nextToken();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
dev::solidity::SemVerMatchExpressionParser::parse	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpression parse();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:public	signature:()
dev::solidity::SemVerMatchExpressionParser::parseMatchComponent	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpression::MatchComponent parseMatchComponent();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
dev::solidity::SemVerMatchExpressionParser::parseMatchExpression	libsolidity/analysis/SemVerHandler.h	/^	void parseMatchExpression();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
dev::solidity::SemVerMatchExpressionParser::parseVersionPart	libsolidity/analysis/SemVerHandler.h	/^	unsigned parseVersionPart();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
dev::solidity::SemVerMatchExpressionParser::reset	libsolidity/analysis/SemVerHandler.h	/^	void reset();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
dev::solidity::SemVerVersion	libsolidity/analysis/SemVerHandler.h	/^struct SemVerVersion$/;"	s	namespace:dev::solidity
dev::solidity::SemVerVersion::SemVerVersion	libsolidity/analysis/SemVerHandler.h	/^	explicit SemVerVersion(std::string const& _versionString = "0.0.0");$/;"	p	struct:dev::solidity::SemVerVersion	access:public	signature:(std::string const& _versionString = )
dev::solidity::SemVerVersion::build	libsolidity/analysis/SemVerHandler.h	/^	std::string build;$/;"	m	struct:dev::solidity::SemVerVersion	access:public
dev::solidity::SemVerVersion::isPrerelease	libsolidity/analysis/SemVerHandler.h	/^	bool isPrerelease() const { return !prerelease.empty(); }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
dev::solidity::SemVerVersion::major	libsolidity/analysis/SemVerHandler.h	/^	unsigned major() const { return numbers[0]; }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
dev::solidity::SemVerVersion::minor	libsolidity/analysis/SemVerHandler.h	/^	unsigned minor() const { return numbers[1]; }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
dev::solidity::SemVerVersion::numbers	libsolidity/analysis/SemVerHandler.h	/^	unsigned numbers[3];$/;"	m	struct:dev::solidity::SemVerVersion	access:public
dev::solidity::SemVerVersion::patch	libsolidity/analysis/SemVerHandler.h	/^	unsigned patch() const { return numbers[2]; }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
dev::solidity::SemVerVersion::prerelease	libsolidity/analysis/SemVerHandler.h	/^	std::string prerelease;$/;"	m	struct:dev::solidity::SemVerVersion	access:public
dev::solidity::SimpleASTVisitor	libsolidity/ast/ASTVisitor.h	/^class SimpleASTVisitor: public ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::SimpleASTVisitor::SimpleASTVisitor	libsolidity/ast/ASTVisitor.h	/^	SimpleASTVisitor($/;"	f	class:dev::solidity::SimpleASTVisitor	access:public	signature:( std::function<bool(ASTNode const&)> _onVisit, std::function<void(ASTNode const&)> _onEndVisit )
dev::solidity::SimpleASTVisitor::m_onEndVisit	libsolidity/ast/ASTVisitor.h	/^	std::function<void(ASTNode const&)> m_onEndVisit;$/;"	m	class:dev::solidity::SimpleASTVisitor	access:private
dev::solidity::SimpleASTVisitor::m_onVisit	libsolidity/ast/ASTVisitor.h	/^	std::function<bool(ASTNode const&)> m_onVisit;$/;"	m	class:dev::solidity::SimpleASTVisitor	access:private
dev::solidity::SimplificationRule	libevmasm/SimplificationRule.h	/^struct SimplificationRule$/;"	s	namespace:dev::solidity
dev::solidity::SimplificationRule::action	libevmasm/SimplificationRule.h	/^	std::function<Pattern()> action;$/;"	m	struct:dev::solidity::SimplificationRule	access:public
dev::solidity::SimplificationRule::pattern	libevmasm/SimplificationRule.h	/^	Pattern pattern;$/;"	m	struct:dev::solidity::SimplificationRule	access:public
dev::solidity::SimplificationRule::removesNonConstants	libevmasm/SimplificationRule.h	/^	bool removesNonConstants;$/;"	m	struct:dev::solidity::SimplificationRule	access:public
dev::solidity::SourceUnit	libsolidity/ast/AST.h	/^class SourceUnit: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::SourceUnit::SourceUnit	libsolidity/ast/AST.h	/^	SourceUnit(SourceLocation const& _location, std::vector<ASTPointer<ASTNode>> const& _nodes):$/;"	f	class:dev::solidity::SourceUnit	access:public	signature:(SourceLocation const& _location, std::vector<ASTPointer<ASTNode>> const& _nodes)
dev::solidity::SourceUnit::accept	libsolidity/ast/AST_accept.h	/^void SourceUnit::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::SourceUnit	signature:(ASTConstVisitor& _visitor) const
dev::solidity::SourceUnit::accept	libsolidity/ast/AST_accept.h	/^void SourceUnit::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::SourceUnit	signature:(ASTVisitor& _visitor)
dev::solidity::SourceUnit::m_nodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> m_nodes;$/;"	m	class:dev::solidity::SourceUnit	access:private
dev::solidity::SourceUnit::nodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> nodes() const { return m_nodes; }$/;"	f	class:dev::solidity::SourceUnit	access:public	signature:() const
dev::solidity::SourceUnit::override	libsolidity/ast/AST.h	/^	SourceUnitAnnotation& annotation() const override;$/;"	m	class:dev::solidity::SourceUnit	access:public
dev::solidity::SourceUnit::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::SourceUnit	access:public
dev::solidity::SourceUnit::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::SourceUnit	access:public
dev::solidity::SourceUnit::referencedSourceUnits	libsolidity/ast/AST.h	/^	std::set<SourceUnit const*> referencedSourceUnits(bool _recurse = false, std::set<SourceUnit const*> _skipList = std::set<SourceUnit const*>()) const;$/;"	p	class:dev::solidity::SourceUnit	access:public	signature:(bool _recurse = false, std::set<SourceUnit const*> _skipList = std::set<SourceUnit const*>()) const
dev::solidity::SourceUnitAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct SourceUnitAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
dev::solidity::SourceUnitAnnotation::experimentalFeatures	libsolidity/ast/ASTAnnotations.h	/^	std::set<ExperimentalFeature> experimentalFeatures;$/;"	m	struct:dev::solidity::SourceUnitAnnotation	access:public
dev::solidity::SourceUnitAnnotation::exportedSymbols	libsolidity/ast/ASTAnnotations.h	/^	std::map<ASTString, std::vector<Declaration const*>> exportedSymbols;$/;"	m	struct:dev::solidity::SourceUnitAnnotation	access:public
dev::solidity::SourceUnitAnnotation::path	libsolidity/ast/ASTAnnotations.h	/^	std::string path;$/;"	m	struct:dev::solidity::SourceUnitAnnotation	access:public
dev::solidity::StackVariable	libsolidity/codegen/LValue.h	/^class StackVariable: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
dev::solidity::StackVariable::StackVariable	libsolidity/codegen/LValue.h	/^	StackVariable(CompilerContext& _compilerContext, VariableDeclaration const& _declaration);$/;"	p	class:dev::solidity::StackVariable	access:public	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
dev::solidity::StackVariable::m_baseStackOffset	libsolidity/codegen/LValue.h	/^	unsigned m_baseStackOffset;$/;"	m	class:dev::solidity::StackVariable	access:private
dev::solidity::StackVariable::m_size	libsolidity/codegen/LValue.h	/^	unsigned m_size;$/;"	m	class:dev::solidity::StackVariable	access:private
dev::solidity::StackVariable::override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StackVariable	access:public
dev::solidity::StackVariable::override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StackVariable	access:public
dev::solidity::StandardCompiler	libsolidity/interface/StandardCompiler.h	/^class StandardCompiler: boost::noncopyable$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable
dev::solidity::StandardCompiler::StandardCompiler	libsolidity/interface/StandardCompiler.h	/^	explicit StandardCompiler(ReadCallback::Callback const& _readFile = ReadCallback::Callback())$/;"	f	class:dev::solidity::StandardCompiler	access:public	signature:(ReadCallback::Callback const& _readFile = ReadCallback::Callback())
dev::solidity::StandardCompiler::compileInternal	libsolidity/interface/StandardCompiler.h	/^	Json::Value compileInternal(Json::Value const& _input);$/;"	p	class:dev::solidity::StandardCompiler	access:private	signature:(Json::Value const& _input)
dev::solidity::StandardCompiler::m_compilerStack	libsolidity/interface/StandardCompiler.h	/^	CompilerStack m_compilerStack;$/;"	m	class:dev::solidity::StandardCompiler	access:private
dev::solidity::StandardCompiler::m_readFile	libsolidity/interface/StandardCompiler.h	/^	ReadCallback::Callback m_readFile;$/;"	m	class:dev::solidity::StandardCompiler	access:private
dev::solidity::StandardCompiler::noexcept	libsolidity/interface/StandardCompiler.h	/^	Json::Value compile(Json::Value const& _input) noexcept;$/;"	m	class:dev::solidity::StandardCompiler	access:public
dev::solidity::StandardCompiler::noexcept	libsolidity/interface/StandardCompiler.h	/^	std::string compile(std::string const& _input) noexcept;$/;"	m	class:dev::solidity::StandardCompiler	access:public
dev::solidity::StandardCompiler::parseOptimizerSettings	libsolidity/interface/StandardCompiler.h	/^	boost::optional<Json::Value> parseOptimizerSettings(Json::Value const& _settings);$/;"	p	class:dev::solidity::StandardCompiler	access:private	signature:(Json::Value const& _settings)
dev::solidity::StateMutability	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	c	namespace:dev::solidity
dev::solidity::StateMutability::NonPayable	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	m	class:dev::solidity::StateMutability	access:private
dev::solidity::StateMutability::Pure	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	m	class:dev::solidity::StateMutability	access:private
dev::solidity::StateMutability::View	libsolidity/ast/ASTEnums.h	/^enum class StateMutability { Pure, View, NonPayable, Payable };$/;"	m	class:dev::solidity::StateMutability	access:private
dev::solidity::Statement	libsolidity/ast/AST.h	/^class Statement: public ASTNode, public Documented$/;"	c	namespace:dev::solidity	inherits:ASTNode,Documented
dev::solidity::Statement::Statement	libsolidity/ast/AST.h	/^	explicit Statement($/;"	f	class:dev::solidity::Statement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString )
dev::solidity::Statement::override	libsolidity/ast/AST.h	/^	StatementAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Statement	access:public
dev::solidity::StatementAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct StatementAnnotation: ASTAnnotation, DocumentedAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation,DocumentedAnnotation
dev::solidity::StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.h	/^class StaticAnalyzer: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::StaticAnalyzer::StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.h	/^	explicit StaticAnalyzer(langutil::ErrorReporter& _errorReporter);$/;"	p	class:dev::solidity::StaticAnalyzer	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::StaticAnalyzer::analyze	libsolidity/analysis/StaticAnalyzer.h	/^	bool analyze(SourceUnit const& _sourceUnit);$/;"	p	class:dev::solidity::StaticAnalyzer	access:public	signature:(SourceUnit const& _sourceUnit)
dev::solidity::StaticAnalyzer::m_constructor	libsolidity/analysis/StaticAnalyzer.h	/^	bool m_constructor = false;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::m_constructorUsesAssembly	libsolidity/analysis/StaticAnalyzer.h	/^	std::unique_ptr<ConstructorUsesAssembly> m_constructorUsesAssembly;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::m_currentContract	libsolidity/analysis/StaticAnalyzer.h	/^	ContractDefinition const* m_currentContract = nullptr;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::m_currentFunction	libsolidity/analysis/StaticAnalyzer.h	/^	FunctionDefinition const* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::m_errorReporter	libsolidity/analysis/StaticAnalyzer.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::m_library	libsolidity/analysis/StaticAnalyzer.h	/^	bool m_library = false;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::m_localVarUseCount	libsolidity/analysis/StaticAnalyzer.h	/^	std::map<std::pair<size_t, VariableDeclaration const*>, int> m_localVarUseCount;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(BinaryOperation const& _operation) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(ExpressionStatement const& _statement) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	void endVisit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::override	libsolidity/analysis/StaticAnalyzer.h	/^	void endVisit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
dev::solidity::StaticAnalyzer::structureSizeEstimate	libsolidity/analysis/StaticAnalyzer.h	/^	static bigint structureSizeEstimate(Type const& _type, std::set<StructDefinition const*>& _structsSeen);$/;"	p	class:dev::solidity::StaticAnalyzer	access:private	signature:(Type const& _type, std::set<StructDefinition const*>& _structsSeen)
dev::solidity::StaticAnalyzer::~StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.h	/^	~StaticAnalyzer();$/;"	p	class:dev::solidity::StaticAnalyzer	access:public	signature:()
dev::solidity::StorageArrayLength	libsolidity/codegen/LValue.h	/^class StorageArrayLength: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
dev::solidity::StorageArrayLength::StorageArrayLength	libsolidity/codegen/LValue.h	/^	StorageArrayLength(CompilerContext& _compilerContext, ArrayType const& _arrayType);$/;"	p	class:dev::solidity::StorageArrayLength	access:public	signature:(CompilerContext& _compilerContext, ArrayType const& _arrayType)
dev::solidity::StorageArrayLength::m_arrayType	libsolidity/codegen/LValue.h	/^	ArrayType const& m_arrayType;$/;"	m	class:dev::solidity::StorageArrayLength	access:private
dev::solidity::StorageArrayLength::override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StorageArrayLength	access:public
dev::solidity::StorageArrayLength::override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StorageArrayLength	access:public
dev::solidity::StorageByteArrayElement	libsolidity/codegen/LValue.h	/^class StorageByteArrayElement: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
dev::solidity::StorageByteArrayElement::StorageByteArrayElement	libsolidity/codegen/LValue.h	/^	StorageByteArrayElement(CompilerContext& _compilerContext);$/;"	p	class:dev::solidity::StorageByteArrayElement	access:public	signature:(CompilerContext& _compilerContext)
dev::solidity::StorageByteArrayElement::override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StorageByteArrayElement	access:public
dev::solidity::StorageByteArrayElement::override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StorageByteArrayElement	access:public
dev::solidity::StorageItem	libsolidity/codegen/LValue.h	/^class StorageItem: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
dev::solidity::StorageItem::StorageItem	libsolidity/codegen/LValue.h	/^	StorageItem(CompilerContext& _compilerContext, Type const& _type);$/;"	p	class:dev::solidity::StorageItem	access:public	signature:(CompilerContext& _compilerContext, Type const& _type)
dev::solidity::StorageItem::StorageItem	libsolidity/codegen/LValue.h	/^	StorageItem(CompilerContext& _compilerContext, VariableDeclaration const& _declaration);$/;"	p	class:dev::solidity::StorageItem	access:public	signature:(CompilerContext& _compilerContext, VariableDeclaration const& _declaration)
dev::solidity::StorageItem::override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StorageItem	access:public
dev::solidity::StorageItem::override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StorageItem	access:public
dev::solidity::StorageOffsets	libsolidity/ast/Types.h	/^class StorageOffsets$/;"	c	namespace:dev::solidity
dev::solidity::StorageOffsets::computeOffsets	libsolidity/ast/Types.h	/^	void computeOffsets(TypePointers const& _types);$/;"	p	class:dev::solidity::StorageOffsets	access:public	signature:(TypePointers const& _types)
dev::solidity::StorageOffsets::m_offsets	libsolidity/ast/Types.h	/^	std::map<size_t, std::pair<u256, unsigned>> m_offsets;$/;"	m	class:dev::solidity::StorageOffsets	access:private
dev::solidity::StorageOffsets::m_storageSize	libsolidity/ast/Types.h	/^	u256 m_storageSize;$/;"	m	class:dev::solidity::StorageOffsets	access:private
dev::solidity::StorageOffsets::std::offset	libsolidity/ast/Types.h	/^	std::pair<u256, unsigned> const* offset(size_t _index) const;$/;"	p	class:dev::solidity::StorageOffsets::std	access:public	signature:(size_t _index) const
dev::solidity::StorageOffsets::storageSize	libsolidity/ast/Types.h	/^	u256 const& storageSize() const { return m_storageSize; }$/;"	f	class:dev::solidity::StorageOffsets	access:public	signature:() const
dev::solidity::StringLiteralType	libsolidity/ast/Types.h	/^class StringLiteralType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::StringLiteralType::StringLiteralType	libsolidity/ast/Types.h	/^	explicit StringLiteralType(Literal const& _literal);$/;"	p	class:dev::solidity::StringLiteralType	access:public	signature:(Literal const& _literal)
dev::solidity::StringLiteralType::isValidUTF8	libsolidity/ast/Types.h	/^	bool isValidUTF8() const;$/;"	p	class:dev::solidity::StringLiteralType	access:public	signature:() const
dev::solidity::StringLiteralType::m_value	libsolidity/ast/Types.h	/^	std::string m_value;$/;"	m	class:dev::solidity::StringLiteralType	access:private
dev::solidity::StringLiteralType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
dev::solidity::StringLiteralType::override	libsolidity/ast/Types.h	/^	TypePointer mobileType() const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
dev::solidity::StringLiteralType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
dev::solidity::StringLiteralType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
dev::solidity::StringLiteralType::override	libsolidity/ast/Types.h	/^	std::string toString(bool) const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
dev::solidity::StringLiteralType::std::value	libsolidity/ast/Types.h	/^	std::string const& value() const { return m_value; }$/;"	f	class:dev::solidity::StringLiteralType::std	access:public	signature:() const
dev::solidity::StructDefinition	libsolidity/ast/AST.h	/^class StructDefinition: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
dev::solidity::StructDefinition::StructDefinition	libsolidity/ast/AST.h	/^	StructDefinition($/;"	f	class:dev::solidity::StructDefinition	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _name, std::vector<ASTPointer<VariableDeclaration>> const& _members )
dev::solidity::StructDefinition::accept	libsolidity/ast/AST_accept.h	/^void StructDefinition::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::StructDefinition	signature:(ASTConstVisitor& _visitor) const
dev::solidity::StructDefinition::accept	libsolidity/ast/AST_accept.h	/^void StructDefinition::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::StructDefinition	signature:(ASTVisitor& _visitor)
dev::solidity::StructDefinition::m_members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> m_members;$/;"	m	class:dev::solidity::StructDefinition	access:private
dev::solidity::StructDefinition::override	libsolidity/ast/AST.h	/^	TypeDeclarationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::StructDefinition	access:public
dev::solidity::StructDefinition::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::StructDefinition	access:public
dev::solidity::StructDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::StructDefinition	access:public
dev::solidity::StructDefinition::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::StructDefinition	access:public
dev::solidity::StructDefinition::std::members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& members() const { return m_members; }$/;"	f	class:dev::solidity::StructDefinition::std	access:public	signature:() const
dev::solidity::StructType	libsolidity/ast/Types.h	/^class StructType: public ReferenceType$/;"	c	namespace:dev::solidity	inherits:ReferenceType
dev::solidity::StructType::StructType	libsolidity/ast/Types.h	/^	explicit StructType(StructDefinition const& _struct, DataLocation _location = DataLocation::Storage):$/;"	f	class:dev::solidity::StructType	access:public	signature:(StructDefinition const& _struct, DataLocation _location = DataLocation::Storage)
dev::solidity::StructType::calldataOffsetOfMember	libsolidity/ast/Types.h	/^	unsigned calldataOffsetOfMember(std::string const& _name) const;$/;"	p	class:dev::solidity::StructType	access:public	signature:(std::string const& _name) const
dev::solidity::StructType::constructorType	libsolidity/ast/Types.h	/^	FunctionTypePointer constructorType() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
dev::solidity::StructType::m_recursive	libsolidity/ast/Types.h	/^	mutable boost::optional<bool> m_recursive;$/;"	m	class:dev::solidity::StructType	access:private
dev::solidity::StructType::m_struct	libsolidity/ast/Types.h	/^	StructDefinition const& m_struct;$/;"	m	class:dev::solidity::StructType	access:private
dev::solidity::StructType::membersMissingInMemory	libsolidity/ast/Types.h	/^	std::set<std::string> membersMissingInMemory() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
dev::solidity::StructType::memoryMemberTypes	libsolidity/ast/Types.h	/^	TypePointers memoryMemberTypes() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
dev::solidity::StructType::memoryOffsetOfMember	libsolidity/ast/Types.h	/^	u256 memoryOffsetOfMember(std::string const& _name) const;$/;"	p	class:dev::solidity::StructType	access:public	signature:(std::string const& _name) const
dev::solidity::StructType::memorySize	libsolidity/ast/Types.h	/^	u256 memorySize() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	TypePointer copyForLocation(DataLocation _location, bool _isPointer) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	TypePointer interfaceType(bool _inLibrary) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	bool canBeUsedExternally(bool _inLibrary) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	bool isDynamicallyEncoded() const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	std::string signatureInExternalFunction(bool _structsByName) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::override	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize(bool _padded) const override;$/;"	m	class:dev::solidity::StructType	access:public
dev::solidity::StructType::recursive	libsolidity/ast/Types.h	/^	bool recursive() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
dev::solidity::StructType::std::storageOffsetsOfMember	libsolidity/ast/Types.h	/^	std::pair<u256, unsigned> const& storageOffsetsOfMember(std::string const& _name) const;$/;"	p	class:dev::solidity::StructType::std	access:public	signature:(std::string const& _name) const
dev::solidity::StructType::structDefinition	libsolidity/ast/Types.h	/^	StructDefinition const& structDefinition() const { return m_struct; }$/;"	f	class:dev::solidity::StructType	access:public	signature:() const
dev::solidity::SymbolicAddressVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicAddressVariable: public SymbolicIntVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicIntVariable
dev::solidity::SymbolicAddressVariable::SymbolicAddressVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicAddressVariable($/;"	p	class:dev::solidity::SymbolicAddressVariable	access:public	signature:( std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicBoolVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicBoolVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
dev::solidity::SymbolicBoolVariable::SymbolicBoolVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicBoolVariable($/;"	p	class:dev::solidity::SymbolicBoolVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicFixedBytesVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicFixedBytesVariable: public SymbolicIntVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicIntVariable
dev::solidity::SymbolicFixedBytesVariable::SymbolicFixedBytesVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicFixedBytesVariable($/;"	p	class:dev::solidity::SymbolicFixedBytesVariable	access:public	signature:( unsigned _numBytes, std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicFunctionVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicFunctionVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
dev::solidity::SymbolicFunctionVariable::SymbolicFunctionVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicFunctionVariable($/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicFunctionVariable::increaseIndex	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression increaseIndex();$/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:public	signature:()
dev::solidity::SymbolicFunctionVariable::m_declaration	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression m_declaration;$/;"	m	class:dev::solidity::SymbolicFunctionVariable	access:private
dev::solidity::SymbolicFunctionVariable::operator ()	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression operator()(std::vector<smt::Expression> _arguments) const;$/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:public	signature:(std::vector<smt::Expression> _arguments) const
dev::solidity::SymbolicFunctionVariable::resetDeclaration	libsolidity/formal/SymbolicVariables.h	/^	void resetDeclaration();$/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:private	signature:()
dev::solidity::SymbolicIntVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicIntVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
dev::solidity::SymbolicIntVariable::SymbolicIntVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicIntVariable($/;"	p	class:dev::solidity::SymbolicIntVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicMappingVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicMappingVariable: public SymbolicVariable$/;"	c	namespace:dev::solidity	inherits:SymbolicVariable
dev::solidity::SymbolicMappingVariable::SymbolicMappingVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicMappingVariable($/;"	p	class:dev::solidity::SymbolicMappingVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicVariable	libsolidity/formal/SymbolicVariables.h	/^class SymbolicVariable$/;"	c	namespace:dev::solidity
dev::solidity::SymbolicVariable::SymbolicVariable	libsolidity/formal/SymbolicVariables.h	/^	SymbolicVariable($/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:( TypePointer _type, std::string const& _uniqueName, smt::SolverInterface& _interface )
dev::solidity::SymbolicVariable::currentName	libsolidity/formal/SymbolicVariables.h	/^	std::string currentName() const;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:() const
dev::solidity::SymbolicVariable::currentValue	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression currentValue() const;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:() const
dev::solidity::SymbolicVariable::increaseIndex	libsolidity/formal/SymbolicVariables.h	/^	virtual smt::Expression increaseIndex();$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:()
dev::solidity::SymbolicVariable::index	libsolidity/formal/SymbolicVariables.h	/^	unsigned index() const { return m_ssa->index(); }$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:() const
dev::solidity::SymbolicVariable::index	libsolidity/formal/SymbolicVariables.h	/^	unsigned& index() { return m_ssa->index(); }$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:()
dev::solidity::SymbolicVariable::m_interface	libsolidity/formal/SymbolicVariables.h	/^	smt::SolverInterface& m_interface;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
dev::solidity::SymbolicVariable::m_ssa	libsolidity/formal/SymbolicVariables.h	/^	std::shared_ptr<SSAVariable> m_ssa;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
dev::solidity::SymbolicVariable::m_type	libsolidity/formal/SymbolicVariables.h	/^	TypePointer m_type;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
dev::solidity::SymbolicVariable::m_uniqueName	libsolidity/formal/SymbolicVariables.h	/^	std::string m_uniqueName;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
dev::solidity::SymbolicVariable::operator ()	libsolidity/formal/SymbolicVariables.h	/^	virtual smt::Expression operator()(std::vector<smt::Expression> \/*_arguments*\/) const$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:(std::vector<smt::Expression> ) const
dev::solidity::SymbolicVariable::type	libsolidity/formal/SymbolicVariables.h	/^	TypePointer const& type() const { return m_type; }$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:() const
dev::solidity::SymbolicVariable::uniqueSymbol	libsolidity/formal/SymbolicVariables.h	/^	std::string uniqueSymbol(unsigned _index) const;$/;"	p	class:dev::solidity::SymbolicVariable	access:protected	signature:(unsigned _index) const
dev::solidity::SymbolicVariable::valueAtIndex	libsolidity/formal/SymbolicVariables.h	/^	virtual smt::Expression valueAtIndex(int _index) const;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:(int _index) const
dev::solidity::SymbolicVariable::~SymbolicVariable	libsolidity/formal/SymbolicVariables.h	/^	virtual ~SymbolicVariable() = default;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:()
dev::solidity::SyntaxChecker	libsolidity/analysis/SyntaxChecker.h	/^class SyntaxChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::SyntaxChecker::SyntaxChecker	libsolidity/analysis/SyntaxChecker.h	/^	SyntaxChecker(langutil::ErrorReporter& _errorReporter): m_errorReporter(_errorReporter) {}$/;"	f	class:dev::solidity::SyntaxChecker	access:public	signature:(langutil::ErrorReporter& _errorReporter)
dev::solidity::SyntaxChecker::checkSingleStatementVariableDeclaration	libsolidity/analysis/SyntaxChecker.h	/^	void checkSingleStatementVariableDeclaration(ASTNode const& _statement);$/;"	p	class:dev::solidity::SyntaxChecker	access:private	signature:(ASTNode const& _statement)
dev::solidity::SyntaxChecker::checkSyntax	libsolidity/analysis/SyntaxChecker.h	/^	bool checkSyntax(ASTNode const& _astRoot);$/;"	p	class:dev::solidity::SyntaxChecker	access:public	signature:(ASTNode const& _astRoot)
dev::solidity::SyntaxChecker::m_errorReporter	libsolidity/analysis/SyntaxChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::m_inLoopDepth	libsolidity/analysis/SyntaxChecker.h	/^	int m_inLoopDepth = 0;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::m_isInterface	libsolidity/analysis/SyntaxChecker.h	/^	bool m_isInterface = false;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::m_placeholderFound	libsolidity/analysis/SyntaxChecker.h	/^	bool m_placeholderFound = false;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::m_sourceUnit	libsolidity/analysis/SyntaxChecker.h	/^	SourceUnit const* m_sourceUnit = nullptr;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::m_versionPragmaFound	libsolidity/analysis/SyntaxChecker.h	/^	bool m_versionPragmaFound = false;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Break const& _breakStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Continue const& _continueStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(FunctionTypeName const& _node) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Literal const& _literal) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(ModifierDefinition const& _modifier) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(PlaceholderStatement const& _placeholderStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(PragmaDirective const& _pragma) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(SourceUnit const& _sourceUnit) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(StructDefinition const& _struct) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Throw const& _throwStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(UnaryOperation const& _operation) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(VariableDeclarationStatement const& _statement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(ModifierDefinition const& _modifier) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(SourceUnit const& _sourceUnit) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::SyntaxChecker::override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
dev::solidity::Throw	libsolidity/ast/AST.h	/^class Throw: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::Throw::Throw	libsolidity/ast/AST.h	/^	explicit Throw(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):$/;"	f	class:dev::solidity::Throw	access:public	signature:(SourceLocation const& _location, ASTPointer<ASTString> const& _docString)
dev::solidity::Throw::accept	libsolidity/ast/AST_accept.h	/^void Throw::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::Throw	signature:(ASTConstVisitor& _visitor) const
dev::solidity::Throw::accept	libsolidity/ast/AST_accept.h	/^void Throw::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::Throw	signature:(ASTVisitor& _visitor)
dev::solidity::Throw::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Throw	access:public
dev::solidity::Throw::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Throw	access:public
dev::solidity::TupleExpression	libsolidity/ast/AST.h	/^class TupleExpression: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::TupleExpression::TupleExpression	libsolidity/ast/AST.h	/^	TupleExpression($/;"	f	class:dev::solidity::TupleExpression	access:public	signature:( SourceLocation const& _location, std::vector<ASTPointer<Expression>> const& _components, bool _isArray )
dev::solidity::TupleExpression::accept	libsolidity/ast/AST_accept.h	/^void TupleExpression::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::TupleExpression	signature:(ASTConstVisitor& _visitor) const
dev::solidity::TupleExpression::accept	libsolidity/ast/AST_accept.h	/^void TupleExpression::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::TupleExpression	signature:(ASTVisitor& _visitor)
dev::solidity::TupleExpression::isInlineArray	libsolidity/ast/AST.h	/^	bool isInlineArray() const { return m_isArray; }$/;"	f	class:dev::solidity::TupleExpression	access:public	signature:() const
dev::solidity::TupleExpression::m_components	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> m_components;$/;"	m	class:dev::solidity::TupleExpression	access:private
dev::solidity::TupleExpression::m_isArray	libsolidity/ast/AST.h	/^	bool m_isArray;$/;"	m	class:dev::solidity::TupleExpression	access:private
dev::solidity::TupleExpression::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::TupleExpression	access:public
dev::solidity::TupleExpression::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::TupleExpression	access:public
dev::solidity::TupleExpression::std::components	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> const& components() const { return m_components; }$/;"	f	class:dev::solidity::TupleExpression::std	access:public	signature:() const
dev::solidity::TupleObject	libsolidity/codegen/LValue.h	/^class TupleObject: public LValue$/;"	c	namespace:dev::solidity	inherits:LValue
dev::solidity::TupleObject::TupleObject	libsolidity/codegen/LValue.h	/^	TupleObject(CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues);$/;"	p	class:dev::solidity::TupleObject	access:public	signature:(CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues)
dev::solidity::TupleObject::m_lvalues	libsolidity/codegen/LValue.h	/^	std::vector<std::unique_ptr<LValue>> m_lvalues;$/;"	m	class:dev::solidity::TupleObject	access:private
dev::solidity::TupleObject::override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::TupleObject	access:public
dev::solidity::TupleObject::override	libsolidity/codegen/LValue.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::TupleObject	access:public
dev::solidity::TupleObject::override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::TupleObject	access:public
dev::solidity::TupleType	libsolidity/ast/Types.h	/^class TupleType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::TupleType::TupleType	libsolidity/ast/Types.h	/^	explicit TupleType(std::vector<TypePointer> const& _types = std::vector<TypePointer>()): m_components(_types) {}$/;"	f	class:dev::solidity::TupleType	access:public	signature:(std::vector<TypePointer> const& _types = std::vector<TypePointer>())
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _other) const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	TypePointer closestTemporaryType(TypePointer const& _targetType) const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	TypePointer mobileType() const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	std::string toString(bool) const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::TupleType	access:public
dev::solidity::TupleType::std::components	libsolidity/ast/Types.h	/^	std::vector<TypePointer> const& components() const { return m_components; }$/;"	f	class:dev::solidity::TupleType::std	access:public	signature:() const
dev::solidity::TupleType::std::m_components	libsolidity/ast/Types.h	/^	std::vector<TypePointer> const m_components;$/;"	m	class:dev::solidity::TupleType::std	access:private
dev::solidity::Type	libsolidity/ast/Types.h	/^class Type: private boost::noncopyable, public std::enable_shared_from_this<Type>$/;"	c	namespace:dev::solidity	inherits:boost::noncopyable,std::enable_shared_from_this
dev::solidity::Type::Category	libsolidity/ast/Types.h	/^	enum class Category$/;"	c	class:dev::solidity::Type	access:public
dev::solidity::Type::Category::Address	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Array	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Bool	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Contract	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Enum	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::FixedBytes	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::FixedPoint	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Function	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Integer	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Magic	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Mapping	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Modifier	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Module	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::RationalNumber	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::StringLiteral	libsolidity/ast/Types.h	/^		Address, Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Struct	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::Tuple	libsolidity/ast/Types.h	/^		FixedBytes, Contract, Struct, Function, Enum, Tuple,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::Category::TypeType	libsolidity/ast/Types.h	/^		Mapping, TypeType, Modifier, Magic, Module,$/;"	m	class:dev::solidity::Type::Category	access:private
dev::solidity::Type::binaryOperatorResult	libsolidity/ast/Types.h	/^	virtual TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const$/;"	f	class:dev::solidity::Type	access:public	signature:(Token _operator, TypePointer const& _other) const
dev::solidity::Type::boundFunctions	libsolidity/ast/Types.h	/^	static MemberList::MemberMap boundFunctions(Type const& _type, ContractDefinition const& _scope);$/;"	p	class:dev::solidity::Type	access:private	signature:(Type const& _type, ContractDefinition const& _scope)
dev::solidity::Type::calldataEncodedSize	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize() const { return calldataEncodedSize(true); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::calldataEncodedSize	libsolidity/ast/Types.h	/^	virtual unsigned calldataEncodedSize(bool _padded) const { (void)_padded; return 0; }$/;"	f	class:dev::solidity::Type	access:public	signature:(bool _padded) const
dev::solidity::Type::canBeStored	libsolidity/ast/Types.h	/^	virtual bool canBeStored() const { return true; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::canBeUsedExternally	libsolidity/ast/Types.h	/^	virtual bool canBeUsedExternally(bool _inLibrary) const { return !!interfaceType(_inLibrary); }$/;"	f	class:dev::solidity::Type	access:public	signature:(bool _inLibrary) const
dev::solidity::Type::canLiveOutsideStorage	libsolidity/ast/Types.h	/^	virtual bool canLiveOutsideStorage() const { return true; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::canonicalName	libsolidity/ast/Types.h	/^	virtual std::string canonicalName() const { return toString(true); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::category	libsolidity/ast/Types.h	/^	virtual Category category() const = 0;$/;"	p	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::closestTemporaryType	libsolidity/ast/Types.h	/^	virtual TypePointer closestTemporaryType(TypePointer const& _targetType) const$/;"	f	class:dev::solidity::Type	access:public	signature:(TypePointer const& _targetType) const
dev::solidity::Type::commonType	libsolidity/ast/Types.h	/^	static TypePointer commonType(TypePointer const& _a, TypePointer const& _b);$/;"	p	class:dev::solidity::Type	access:public	signature:(TypePointer const& _a, TypePointer const& _b)
dev::solidity::Type::dataStoredIn	libsolidity/ast/Types.h	/^	virtual bool dataStoredIn(DataLocation) const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:(DataLocation) const
dev::solidity::Type::decodingType	libsolidity/ast/Types.h	/^	virtual TypePointer decodingType() const { return encodingType(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::encodingType	libsolidity/ast/Types.h	/^	virtual TypePointer encodingType() const { return TypePointer(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::escapeIdentifier	libsolidity/ast/Types.h	/^	static std::string escapeIdentifier(std::string const& _identifier);$/;"	p	class:dev::solidity::Type	access:public	signature:(std::string const& _identifier)
dev::solidity::Type::forLiteral	libsolidity/ast/Types.h	/^	static TypePointer forLiteral(Literal const& _literal);$/;"	p	class:dev::solidity::Type	access:public	signature:(Literal const& _literal)
dev::solidity::Type::fromElementaryTypeName	libsolidity/ast/Types.h	/^	static TypePointer fromElementaryTypeName(ElementaryTypeNameToken const& _type);$/;"	p	class:dev::solidity::Type	access:public	signature:(ElementaryTypeNameToken const& _type)
dev::solidity::Type::fromElementaryTypeName	libsolidity/ast/Types.h	/^	static TypePointer fromElementaryTypeName(std::string const& _name);$/;"	p	class:dev::solidity::Type	access:public	signature:(std::string const& _name)
dev::solidity::Type::fullEncodingType	libsolidity/ast/Types.h	/^	TypePointer fullEncodingType(bool _inLibraryCall, bool _encoderV2, bool _packed) const;$/;"	p	class:dev::solidity::Type	access:public	signature:(bool _inLibraryCall, bool _encoderV2, bool _packed) const
dev::solidity::Type::hasSimpleZeroValueInMemory	libsolidity/ast/Types.h	/^	virtual bool hasSimpleZeroValueInMemory() const { return true; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::identifier	libsolidity/ast/Types.h	/^	std::string identifier() const;$/;"	p	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::interfaceType	libsolidity/ast/Types.h	/^	virtual TypePointer interfaceType(bool \/*_inLibrary*\/) const { return TypePointer(); }$/;"	f	class:dev::solidity::Type	access:public	signature:(bool ) const
dev::solidity::Type::isDynamicallyEncoded	libsolidity/ast/Types.h	/^	virtual bool isDynamicallyEncoded() const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::isDynamicallySized	libsolidity/ast/Types.h	/^	virtual bool isDynamicallySized() const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::isExplicitlyConvertibleTo	libsolidity/ast/Types.h	/^	virtual BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _convertTo) const
dev::solidity::Type::isImplicitlyConvertibleTo	libsolidity/ast/Types.h	/^	virtual BoolResult isImplicitlyConvertibleTo(Type const& _other) const { return *this == _other; }$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _other) const
dev::solidity::Type::isValueType	libsolidity/ast/Types.h	/^	virtual bool isValueType() const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::literalValue	libsolidity/ast/Types.h	/^	virtual u256 literalValue(Literal const*) const$/;"	f	class:dev::solidity::Type	access:public	signature:(Literal const*) const
dev::solidity::Type::m_members	libsolidity/ast/Types.h	/^	mutable std::map<ContractDefinition const*, std::unique_ptr<MemberList>> m_members;$/;"	m	class:dev::solidity::Type	access:protected
dev::solidity::Type::memberType	libsolidity/ast/Types.h	/^	TypePointer memberType(std::string const& _name, ContractDefinition const* _currentScope = nullptr) const$/;"	f	class:dev::solidity::Type	access:public	signature:(std::string const& _name, ContractDefinition const* _currentScope = nullptr) const
dev::solidity::Type::members	libsolidity/ast/Types.h	/^	MemberList const& members(ContractDefinition const* _currentScope) const;$/;"	p	class:dev::solidity::Type	access:public	signature:(ContractDefinition const* _currentScope) const
dev::solidity::Type::memoryHeadSize	libsolidity/ast/Types.h	/^	virtual unsigned memoryHeadSize() const { return calldataEncodedSize(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::mobileType	libsolidity/ast/Types.h	/^	virtual TypePointer mobileType() const { return shared_from_this(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::nativeMembers	libsolidity/ast/Types.h	/^	virtual MemberList::MemberMap nativeMembers(ContractDefinition const* \/*_currentScope*\/) const$/;"	f	class:dev::solidity::Type	access:protected	signature:(ContractDefinition const* ) const
dev::solidity::Type::operator !=	libsolidity/ast/Types.h	/^	virtual bool operator!=(Type const& _other) const { return !this->operator ==(_other); }$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _other) const
dev::solidity::Type::operator ==	libsolidity/ast/Types.h	/^	virtual bool operator==(Type const& _other) const { return category() == _other.category(); }$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _other) const
dev::solidity::Type::richIdentifier	libsolidity/ast/Types.h	/^	virtual std::string richIdentifier() const = 0;$/;"	p	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::signatureInExternalFunction	libsolidity/ast/Types.h	/^	virtual std::string signatureInExternalFunction(bool \/*_structsByName*\/) const$/;"	f	class:dev::solidity::Type	access:public	signature:(bool ) const
dev::solidity::Type::sizeOnStack	libsolidity/ast/Types.h	/^	virtual unsigned sizeOnStack() const { return 1; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::storageBytes	libsolidity/ast/Types.h	/^	virtual unsigned storageBytes() const { return 32; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::storageSize	libsolidity/ast/Types.h	/^	virtual u256 storageSize() const { return 1; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::toString	libsolidity/ast/Types.h	/^	std::string toString() const { return toString(false); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
dev::solidity::Type::toString	libsolidity/ast/Types.h	/^	virtual std::string toString(bool _short) const = 0;$/;"	p	class:dev::solidity::Type	access:public	signature:(bool _short) const
dev::solidity::Type::unaryOperatorResult	libsolidity/ast/Types.h	/^	virtual TypeResult unaryOperatorResult(Token) const { return TypePointer(); }$/;"	f	class:dev::solidity::Type	access:public	signature:(Token) const
dev::solidity::Type::~Type	libsolidity/ast/Types.h	/^	virtual ~Type() = default;$/;"	p	class:dev::solidity::Type	access:public	signature:()
dev::solidity::TypeChecker	libsolidity/analysis/TypeChecker.h	/^class TypeChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::TypeChecker::TypeChecker	libsolidity/analysis/TypeChecker.h	/^	TypeChecker(langutil::EVMVersion _evmVersion, langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::TypeChecker	access:public	signature:(langutil::EVMVersion _evmVersion, langutil::ErrorReporter& _errorReporter)
dev::solidity::TypeChecker::checkDoubleStorageAssignment	libsolidity/analysis/TypeChecker.h	/^	void checkDoubleStorageAssignment(Assignment const& _assignment);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Assignment const& _assignment)
dev::solidity::TypeChecker::checkExpressionAssignment	libsolidity/analysis/TypeChecker.h	/^	void checkExpressionAssignment(Type const& _type, Expression const& _expression);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Type const& _type, Expression const& _expression)
dev::solidity::TypeChecker::checkTypeRequirements	libsolidity/analysis/TypeChecker.h	/^	bool checkTypeRequirements(ASTNode const& _contract);$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(ASTNode const& _contract)
dev::solidity::TypeChecker::contractDependenciesAreCyclic	libsolidity/analysis/TypeChecker.h	/^	bool contractDependenciesAreCyclic($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( ContractDefinition const& _contract, std::set<ContractDefinition const*> const& _seenContracts = std::set<ContractDefinition const*>() ) const
dev::solidity::TypeChecker::dereference	libsolidity/analysis/TypeChecker.h	/^	Declaration const& dereference(Identifier const& _identifier) const;$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Identifier const& _identifier) const
dev::solidity::TypeChecker::dereference	libsolidity/analysis/TypeChecker.h	/^	Declaration const& dereference(UserDefinedTypeName const& _typeName) const;$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(UserDefinedTypeName const& _typeName) const
dev::solidity::TypeChecker::expectType	libsolidity/analysis/TypeChecker.h	/^	bool expectType(Expression const& _expression, Type const& _expectedType);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Expression const& _expression, Type const& _expectedType)
dev::solidity::TypeChecker::m_errorReporter	libsolidity/analysis/TypeChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::m_evmVersion	libsolidity/analysis/TypeChecker.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::m_insideEmitStatement	libsolidity/analysis/TypeChecker.h	/^	bool m_insideEmitStatement = false;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::m_insideStruct	libsolidity/analysis/TypeChecker.h	/^	bool m_insideStruct = false;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::m_scope	libsolidity/analysis/TypeChecker.h	/^	ContractDefinition const* m_scope = nullptr;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(Assignment const& _assignment) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(Conditional const& _conditional) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(EventDefinition const& _eventDef) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(IndexAccess const& _indexAccess) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(StructDefinition const& _struct) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(TupleExpression const& _tuple) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(UnaryOperation const& _operation) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(VariableDeclarationStatement const& _variable) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(BinaryOperation const& _operation) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(ElementaryTypeNameExpression const& _expr) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(EmitStatement const& _emit) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(ExpressionStatement const& _statement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(FunctionTypeName const& _funType) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(InheritanceSpecifier const& _inheritance) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(Literal const& _literal) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(NewExpression const& _newExpression) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(Return const& _return) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(UsingForDirective const& _usingFor) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
dev::solidity::TypeChecker::requireLValue	libsolidity/analysis/TypeChecker.h	/^	void requireLValue(Expression const& _expression);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Expression const& _expression)
dev::solidity::TypeChecker::type	libsolidity/analysis/TypeChecker.h	/^	TypePointer const& type(Expression const& _expression) const;$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(Expression const& _expression) const
dev::solidity::TypeChecker::type	libsolidity/analysis/TypeChecker.h	/^	TypePointer const& type(VariableDeclaration const& _variable) const;$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(VariableDeclaration const& _variable) const
dev::solidity::TypeChecker::typeCheckABIDecodeAndRetrieveReturnType	libsolidity/analysis/TypeChecker.h	/^	TypePointers typeCheckABIDecodeAndRetrieveReturnType($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, bool _abiEncoderV2 )
dev::solidity::TypeChecker::typeCheckABIEncodeFunctions	libsolidity/analysis/TypeChecker.h	/^	void typeCheckABIEncodeFunctions($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
dev::solidity::TypeChecker::typeCheckFunctionCall	libsolidity/analysis/TypeChecker.h	/^	void typeCheckFunctionCall($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
dev::solidity::TypeChecker::typeCheckFunctionGeneralChecks	libsolidity/analysis/TypeChecker.h	/^	void typeCheckFunctionGeneralChecks($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
dev::solidity::TypeChecker::typeCheckMetaTypeFunctionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.h	/^	TypePointers typeCheckMetaTypeFunctionAndRetrieveReturnType(FunctionCall const& _functionCall);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(FunctionCall const& _functionCall)
dev::solidity::TypeChecker::typeCheckTypeConversionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.h	/^	TypePointer typeCheckTypeConversionAndRetrieveReturnType($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall )
dev::solidity::TypeChecker::typeSupportedByOldABIEncoder	libsolidity/analysis/TypeChecker.h	/^	static bool typeSupportedByOldABIEncoder(Type const& _type, bool _isLibraryCall);$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(Type const& _type, bool _isLibraryCall)
dev::solidity::TypeChecker::visitManually	libsolidity/analysis/TypeChecker.h	/^	void visitManually(ModifierInvocation const& _modifier, std::vector<ContractDefinition const*> const& _bases);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(ModifierInvocation const& _modifier, std::vector<ContractDefinition const*> const& _bases)
dev::solidity::TypeDeclarationAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct TypeDeclarationAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
dev::solidity::TypeDeclarationAnnotation::canonicalName	libsolidity/ast/ASTAnnotations.h	/^	std::string canonicalName;$/;"	m	struct:dev::solidity::TypeDeclarationAnnotation	access:public
dev::solidity::TypeName	libsolidity/ast/AST.h	/^class TypeName: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::TypeName::TypeName	libsolidity/ast/AST.h	/^	explicit TypeName(SourceLocation const& _location): ASTNode(_location) {}$/;"	f	class:dev::solidity::TypeName	access:protected	signature:(SourceLocation const& _location)
dev::solidity::TypeName::override	libsolidity/ast/AST.h	/^	TypeNameAnnotation& annotation() const override;$/;"	m	class:dev::solidity::TypeName	access:public
dev::solidity::TypeNameAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct TypeNameAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
dev::solidity::TypeNameAnnotation::type	libsolidity/ast/ASTAnnotations.h	/^	TypePointer type;$/;"	m	struct:dev::solidity::TypeNameAnnotation	access:public
dev::solidity::TypeType	libsolidity/ast/Types.h	/^class TypeType: public Type$/;"	c	namespace:dev::solidity	inherits:Type
dev::solidity::TypeType::TypeType	libsolidity/ast/Types.h	/^	explicit TypeType(TypePointer const& _actualType): m_actualType(_actualType) {}$/;"	f	class:dev::solidity::TypeType	access:public	signature:(TypePointer const& _actualType)
dev::solidity::TypeType::actualType	libsolidity/ast/Types.h	/^	TypePointer const& actualType() const { return m_actualType; }$/;"	f	class:dev::solidity::TypeType	access:public	signature:() const
dev::solidity::TypeType::m_actualType	libsolidity/ast/Types.h	/^	TypePointer m_actualType;$/;"	m	class:dev::solidity::TypeType	access:private
dev::solidity::TypeType::override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::TypeType	access:public
dev::solidity::TypeType::override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::TypeType	access:public
dev::solidity::TypeType::override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::TypeType	access:public
dev::solidity::TypeType::override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::TypeType	access:public
dev::solidity::TypeType::override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::TypeType	access:public
dev::solidity::UnaryOperation	libsolidity/ast/AST.h	/^class UnaryOperation: public Expression$/;"	c	namespace:dev::solidity	inherits:Expression
dev::solidity::UnaryOperation::UnaryOperation	libsolidity/ast/AST.h	/^	UnaryOperation($/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:( SourceLocation const& _location, Token _operator, ASTPointer<Expression> const& _subExpression, bool _isPrefix )
dev::solidity::UnaryOperation::accept	libsolidity/ast/AST_accept.h	/^void UnaryOperation::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::UnaryOperation	signature:(ASTConstVisitor& _visitor) const
dev::solidity::UnaryOperation::accept	libsolidity/ast/AST_accept.h	/^void UnaryOperation::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::UnaryOperation	signature:(ASTVisitor& _visitor)
dev::solidity::UnaryOperation::getOperator	libsolidity/ast/AST.h	/^	Token getOperator() const { return m_operator; }$/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:() const
dev::solidity::UnaryOperation::isPrefixOperation	libsolidity/ast/AST.h	/^	bool isPrefixOperation() const { return m_isPrefix; }$/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:() const
dev::solidity::UnaryOperation::m_isPrefix	libsolidity/ast/AST.h	/^	bool m_isPrefix;$/;"	m	class:dev::solidity::UnaryOperation	access:private
dev::solidity::UnaryOperation::m_operator	libsolidity/ast/AST.h	/^	Token m_operator;$/;"	m	class:dev::solidity::UnaryOperation	access:private
dev::solidity::UnaryOperation::m_subExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_subExpression;$/;"	m	class:dev::solidity::UnaryOperation	access:private
dev::solidity::UnaryOperation::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::UnaryOperation	access:public
dev::solidity::UnaryOperation::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::UnaryOperation	access:public
dev::solidity::UnaryOperation::subExpression	libsolidity/ast/AST.h	/^	Expression const& subExpression() const { return *m_subExpression; }$/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:() const
dev::solidity::UserDefinedTypeName	libsolidity/ast/AST.h	/^class UserDefinedTypeName: public TypeName$/;"	c	namespace:dev::solidity	inherits:TypeName
dev::solidity::UserDefinedTypeName::UserDefinedTypeName	libsolidity/ast/AST.h	/^	UserDefinedTypeName(SourceLocation const& _location, std::vector<ASTString> const& _namePath):$/;"	f	class:dev::solidity::UserDefinedTypeName	access:public	signature:(SourceLocation const& _location, std::vector<ASTString> const& _namePath)
dev::solidity::UserDefinedTypeName::accept	libsolidity/ast/AST_accept.h	/^void UserDefinedTypeName::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::UserDefinedTypeName	signature:(ASTConstVisitor& _visitor) const
dev::solidity::UserDefinedTypeName::accept	libsolidity/ast/AST_accept.h	/^void UserDefinedTypeName::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::UserDefinedTypeName	signature:(ASTVisitor& _visitor)
dev::solidity::UserDefinedTypeName::m_namePath	libsolidity/ast/AST.h	/^	std::vector<ASTString> m_namePath;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:private
dev::solidity::UserDefinedTypeName::override	libsolidity/ast/AST.h	/^	UserDefinedTypeNameAnnotation& annotation() const override;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:public
dev::solidity::UserDefinedTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:public
dev::solidity::UserDefinedTypeName::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:public
dev::solidity::UserDefinedTypeName::std::namePath	libsolidity/ast/AST.h	/^	std::vector<ASTString> const& namePath() const { return m_namePath; }$/;"	f	class:dev::solidity::UserDefinedTypeName::std	access:public	signature:() const
dev::solidity::UserDefinedTypeNameAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct UserDefinedTypeNameAnnotation: TypeNameAnnotation$/;"	s	namespace:dev::solidity	inherits:TypeNameAnnotation
dev::solidity::UserDefinedTypeNameAnnotation::contractScope	libsolidity/ast/ASTAnnotations.h	/^	ContractDefinition const* contractScope = nullptr;$/;"	m	struct:dev::solidity::UserDefinedTypeNameAnnotation	access:public
dev::solidity::UserDefinedTypeNameAnnotation::referencedDeclaration	libsolidity/ast/ASTAnnotations.h	/^	Declaration const* referencedDeclaration = nullptr;$/;"	m	struct:dev::solidity::UserDefinedTypeNameAnnotation	access:public
dev::solidity::UsingForDirective	libsolidity/ast/AST.h	/^class UsingForDirective: public ASTNode$/;"	c	namespace:dev::solidity	inherits:ASTNode
dev::solidity::UsingForDirective::UsingForDirective	libsolidity/ast/AST.h	/^	UsingForDirective($/;"	f	class:dev::solidity::UsingForDirective	access:public	signature:( SourceLocation const& _location, ASTPointer<UserDefinedTypeName> const& _libraryName, ASTPointer<TypeName> const& _typeName )
dev::solidity::UsingForDirective::accept	libsolidity/ast/AST_accept.h	/^void UsingForDirective::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::UsingForDirective	signature:(ASTConstVisitor& _visitor) const
dev::solidity::UsingForDirective::accept	libsolidity/ast/AST_accept.h	/^void UsingForDirective::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::UsingForDirective	signature:(ASTVisitor& _visitor)
dev::solidity::UsingForDirective::libraryName	libsolidity/ast/AST.h	/^	UserDefinedTypeName const& libraryName() const { return *m_libraryName; }$/;"	f	class:dev::solidity::UsingForDirective	access:public	signature:() const
dev::solidity::UsingForDirective::m_libraryName	libsolidity/ast/AST.h	/^	ASTPointer<UserDefinedTypeName> m_libraryName;$/;"	m	class:dev::solidity::UsingForDirective	access:private
dev::solidity::UsingForDirective::m_typeName	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_typeName;$/;"	m	class:dev::solidity::UsingForDirective	access:private
dev::solidity::UsingForDirective::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::UsingForDirective	access:public
dev::solidity::UsingForDirective::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::UsingForDirective	access:public
dev::solidity::UsingForDirective::typeName	libsolidity/ast/AST.h	/^	TypeName const* typeName() const { return m_typeName.get(); }$/;"	f	class:dev::solidity::UsingForDirective	access:public	signature:() const
dev::solidity::VariableDeclaration	libsolidity/ast/AST.h	/^class VariableDeclaration: public Declaration$/;"	c	namespace:dev::solidity	inherits:Declaration
dev::solidity::VariableDeclaration::CallData	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
dev::solidity::VariableDeclaration::Location	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	g	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::Memory	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
dev::solidity::VariableDeclaration::Storage	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
dev::solidity::VariableDeclaration::Unspecified	libsolidity/ast/AST.h	/^	enum Location { Unspecified, Storage, Memory, CallData };$/;"	e	enum:dev::solidity::VariableDeclaration::Location
dev::solidity::VariableDeclaration::VariableDeclaration	libsolidity/ast/AST.h	/^	VariableDeclaration($/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:( SourceLocation const& _sourceLocation, ASTPointer<TypeName> const& _type, ASTPointer<ASTString> const& _name, ASTPointer<Expression> _value, Visibility _visibility, bool _isStateVar = false, bool _isIndexed = false, bool _isConstant = false, Location _referenceLocation = Location::Unspecified )
dev::solidity::VariableDeclaration::accept	libsolidity/ast/AST_accept.h	/^void VariableDeclaration::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::VariableDeclaration	signature:(ASTConstVisitor& _visitor) const
dev::solidity::VariableDeclaration::accept	libsolidity/ast/AST_accept.h	/^void VariableDeclaration::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::VariableDeclaration	signature:(ASTVisitor& _visitor)
dev::solidity::VariableDeclaration::allowedDataLocations	libsolidity/ast/AST.h	/^	std::set<Location> allowedDataLocations() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::hasReferenceOrMappingType	libsolidity/ast/AST.h	/^	bool hasReferenceOrMappingType() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isCallableParameter	libsolidity/ast/AST.h	/^	bool isCallableParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isConstant	libsolidity/ast/AST.h	/^	bool isConstant() const { return m_isConstant; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isEventParameter	libsolidity/ast/AST.h	/^	bool isEventParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isExternalCallableParameter	libsolidity/ast/AST.h	/^	bool isExternalCallableParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isIndexed	libsolidity/ast/AST.h	/^	bool isIndexed() const { return m_isIndexed; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isInternalCallableParameter	libsolidity/ast/AST.h	/^	bool isInternalCallableParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isLibraryFunctionParameter	libsolidity/ast/AST.h	/^	bool isLibraryFunctionParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isLocalOrReturn	libsolidity/ast/AST.h	/^	bool isLocalOrReturn() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isLocalVariable	libsolidity/ast/AST.h	/^	bool isLocalVariable() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isReturnParameter	libsolidity/ast/AST.h	/^	bool isReturnParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::isStateVariable	libsolidity/ast/AST.h	/^	bool isStateVariable() const { return m_isStateVariable; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::m_isConstant	libsolidity/ast/AST.h	/^	bool m_isConstant; \/\/\/< Whether the variable is a compile-time constant.$/;"	m	class:dev::solidity::VariableDeclaration	access:private
dev::solidity::VariableDeclaration::m_isIndexed	libsolidity/ast/AST.h	/^	bool m_isIndexed; \/\/\/< Whether this is an indexed variable (used by events).$/;"	m	class:dev::solidity::VariableDeclaration	access:private
dev::solidity::VariableDeclaration::m_isStateVariable	libsolidity/ast/AST.h	/^	bool m_isStateVariable; \/\/\/< Whether or not this is a contract state variable$/;"	m	class:dev::solidity::VariableDeclaration	access:private
dev::solidity::VariableDeclaration::m_location	libsolidity/ast/AST.h	/^	Location m_location; \/\/\/< Location of the variable if it is of reference type.$/;"	m	class:dev::solidity::VariableDeclaration	access:private
dev::solidity::VariableDeclaration::m_typeName	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_typeName; \/\/\/< can be empty ("var")$/;"	m	class:dev::solidity::VariableDeclaration	access:private
dev::solidity::VariableDeclaration::m_value	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_value;$/;"	m	class:dev::solidity::VariableDeclaration	access:private
dev::solidity::VariableDeclaration::override	libsolidity/ast/AST.h	/^	FunctionTypePointer functionType(bool \/*_internal*\/) const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::override	libsolidity/ast/AST.h	/^	VariableDeclarationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::override	libsolidity/ast/AST.h	/^	bool isLValue() const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
dev::solidity::VariableDeclaration::referenceLocation	libsolidity/ast/AST.h	/^	Location referenceLocation() const { return m_location; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::typeName	libsolidity/ast/AST.h	/^	TypeName* typeName() const { return m_typeName.get(); }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclaration::value	libsolidity/ast/AST.h	/^	ASTPointer<Expression> const& value() const { return m_value; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
dev::solidity::VariableDeclarationAnnotation	libsolidity/ast/ASTAnnotations.h	/^struct VariableDeclarationAnnotation: ASTAnnotation$/;"	s	namespace:dev::solidity	inherits:ASTAnnotation
dev::solidity::VariableDeclarationAnnotation::type	libsolidity/ast/ASTAnnotations.h	/^	TypePointer type;$/;"	m	struct:dev::solidity::VariableDeclarationAnnotation	access:public
dev::solidity::VariableDeclarationStatement	libsolidity/ast/AST.h	/^class VariableDeclarationStatement: public Statement$/;"	c	namespace:dev::solidity	inherits:Statement
dev::solidity::VariableDeclarationStatement::VariableDeclarationStatement	libsolidity/ast/AST.h	/^	VariableDeclarationStatement($/;"	f	class:dev::solidity::VariableDeclarationStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, std::vector<ASTPointer<VariableDeclaration>> const& _variables, ASTPointer<Expression> const& _initialValue )
dev::solidity::VariableDeclarationStatement::accept	libsolidity/ast/AST_accept.h	/^void VariableDeclarationStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::VariableDeclarationStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::VariableDeclarationStatement::accept	libsolidity/ast/AST_accept.h	/^void VariableDeclarationStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::VariableDeclarationStatement	signature:(ASTVisitor& _visitor)
dev::solidity::VariableDeclarationStatement::initialValue	libsolidity/ast/AST.h	/^	Expression const* initialValue() const { return m_initialValue.get(); }$/;"	f	class:dev::solidity::VariableDeclarationStatement	access:public	signature:() const
dev::solidity::VariableDeclarationStatement::m_initialValue	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_initialValue;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:private
dev::solidity::VariableDeclarationStatement::m_variables	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> m_variables;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:private
dev::solidity::VariableDeclarationStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:public
dev::solidity::VariableDeclarationStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:public
dev::solidity::VariableDeclarationStatement::std::declarations	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& declarations() const { return m_variables; }$/;"	f	class:dev::solidity::VariableDeclarationStatement::std	access:public	signature:() const
dev::solidity::VariableOccurrence	libsolidity/analysis/ControlFlowGraph.h	/^class VariableOccurrence$/;"	c	namespace:dev::solidity
dev::solidity::VariableOccurrence::Kind	libsolidity/analysis/ControlFlowGraph.h	/^	enum class Kind$/;"	c	class:dev::solidity::VariableOccurrence	access:public
dev::solidity::VariableOccurrence::Kind::Access	libsolidity/analysis/ControlFlowGraph.h	/^		Access,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
dev::solidity::VariableOccurrence::Kind::Assignment	libsolidity/analysis/ControlFlowGraph.h	/^		Assignment,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
dev::solidity::VariableOccurrence::Kind::Declaration	libsolidity/analysis/ControlFlowGraph.h	/^		Declaration,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
dev::solidity::VariableOccurrence::Kind::Return	libsolidity/analysis/ControlFlowGraph.h	/^		Return,$/;"	m	class:dev::solidity::VariableOccurrence::Kind	access:private
dev::solidity::VariableOccurrence::VariableOccurrence	libsolidity/analysis/ControlFlowGraph.h	/^	VariableOccurrence(VariableDeclaration const& _declaration, Kind _kind, ASTNode const* _occurrence):$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:(VariableDeclaration const& _declaration, Kind _kind, ASTNode const* _occurrence)
dev::solidity::VariableOccurrence::declaration	libsolidity/analysis/ControlFlowGraph.h	/^	VariableDeclaration const& declaration() const { return m_declaration; }$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:() const
dev::solidity::VariableOccurrence::kind	libsolidity/analysis/ControlFlowGraph.h	/^	Kind kind() const { return m_occurrenceKind; };$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:() const
dev::solidity::VariableOccurrence::m_declaration	libsolidity/analysis/ControlFlowGraph.h	/^	VariableDeclaration const& m_declaration;$/;"	m	class:dev::solidity::VariableOccurrence	access:private
dev::solidity::VariableOccurrence::m_occurrence	libsolidity/analysis/ControlFlowGraph.h	/^	ASTNode const* m_occurrence = nullptr;$/;"	m	class:dev::solidity::VariableOccurrence	access:private
dev::solidity::VariableOccurrence::m_occurrenceKind	libsolidity/analysis/ControlFlowGraph.h	/^	Kind m_occurrenceKind = Kind::Access;$/;"	m	class:dev::solidity::VariableOccurrence	access:private
dev::solidity::VariableOccurrence::occurrence	libsolidity/analysis/ControlFlowGraph.h	/^	ASTNode const* occurrence() const { return m_occurrence; }$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:() const
dev::solidity::VariableOccurrence::operator <	libsolidity/analysis/ControlFlowGraph.h	/^	bool operator<(VariableOccurrence const& _rhs) const$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:(VariableOccurrence const& _rhs) const
dev::solidity::VariableScope	libsolidity/ast/AST.h	/^class VariableScope$/;"	c	namespace:dev::solidity
dev::solidity::VariableScope::addLocalVariable	libsolidity/ast/AST.h	/^	void addLocalVariable(VariableDeclaration const& _localVariable) { m_localVariables.push_back(&_localVariable); }$/;"	f	class:dev::solidity::VariableScope	access:public	signature:(VariableDeclaration const& _localVariable)
dev::solidity::VariableScope::m_localVariables	libsolidity/ast/AST.h	/^	std::vector<VariableDeclaration const*> m_localVariables;$/;"	m	class:dev::solidity::VariableScope	access:private
dev::solidity::VariableScope::std::localVariables	libsolidity/ast/AST.h	/^	std::vector<VariableDeclaration const*> const& localVariables() const { return m_localVariables; }$/;"	f	class:dev::solidity::VariableScope::std	access:public	signature:() const
dev::solidity::VariableScope::~VariableScope	libsolidity/ast/AST.h	/^	virtual ~VariableScope() = default;$/;"	p	class:dev::solidity::VariableScope	access:public	signature:()
dev::solidity::VariableUsage	libsolidity/formal/VariableUsage.h	/^class VariableUsage$/;"	c	namespace:dev::solidity
dev::solidity::VariableUsage::VariableUsage	libsolidity/formal/VariableUsage.h	/^	explicit VariableUsage(ASTNode const& _node);$/;"	p	class:dev::solidity::VariableUsage	access:public	signature:(ASTNode const& _node)
dev::solidity::VariableUsage::m_children	libsolidity/formal/VariableUsage.h	/^	std::map<ASTNode const*, std::vector<ASTNode const*>> m_children;$/;"	m	class:dev::solidity::VariableUsage	access:private
dev::solidity::VariableUsage::m_touchedVariable	libsolidity/formal/VariableUsage.h	/^	std::map<ASTNode const*, VariableDeclaration const*> m_touchedVariable;$/;"	m	class:dev::solidity::VariableUsage	access:private
dev::solidity::VariableUsage::touchedVariables	libsolidity/formal/VariableUsage.h	/^	std::vector<VariableDeclaration const*> touchedVariables(ASTNode const& _node) const;$/;"	p	class:dev::solidity::VariableUsage	access:public	signature:(ASTNode const& _node) const
dev::solidity::VersionNumber	libsolidity/interface/Version.cpp	/^char const* dev::solidity::VersionNumber = ETH_PROJECT_VERSION;$/;"	m	class:dev::solidity	file:
dev::solidity::VersionString	libsolidity/interface/Version.cpp	/^string const dev::solidity::VersionString =$/;"	m	class:dev::solidity	file:
dev::solidity::VersionStringStrict	libsolidity/interface/Version.cpp	/^string const dev::solidity::VersionStringStrict =$/;"	m	class:dev::solidity	file:
dev::solidity::ViewPureChecker	libsolidity/analysis/ViewPureChecker.h	/^class ViewPureChecker: private ASTConstVisitor$/;"	c	namespace:dev::solidity	inherits:ASTConstVisitor
dev::solidity::ViewPureChecker::MutabilityAndLocation	libsolidity/analysis/ViewPureChecker.h	/^	struct MutabilityAndLocation$/;"	s	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::MutabilityAndLocation::location	libsolidity/analysis/ViewPureChecker.h	/^		langutil::SourceLocation location;$/;"	m	struct:dev::solidity::ViewPureChecker::MutabilityAndLocation	access:public
dev::solidity::ViewPureChecker::MutabilityAndLocation::mutability	libsolidity/analysis/ViewPureChecker.h	/^		StateMutability mutability;$/;"	m	struct:dev::solidity::ViewPureChecker::MutabilityAndLocation	access:public
dev::solidity::ViewPureChecker::ViewPureChecker	libsolidity/analysis/ViewPureChecker.h	/^	ViewPureChecker(std::vector<std::shared_ptr<ASTNode>> const& _ast, langutil::ErrorReporter& _errorReporter):$/;"	f	class:dev::solidity::ViewPureChecker	access:public	signature:(std::vector<std::shared_ptr<ASTNode>> const& _ast, langutil::ErrorReporter& _errorReporter)
dev::solidity::ViewPureChecker::check	libsolidity/analysis/ViewPureChecker.h	/^	bool check();$/;"	p	class:dev::solidity::ViewPureChecker	access:public	signature:()
dev::solidity::ViewPureChecker::m_bestMutabilityAndLocation	libsolidity/analysis/ViewPureChecker.h	/^	MutabilityAndLocation m_bestMutabilityAndLocation = MutabilityAndLocation{StateMutability::Payable, langutil::SourceLocation()};$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::m_currentFunction	libsolidity/analysis/ViewPureChecker.h	/^	FunctionDefinition const* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::m_errorReporter	libsolidity/analysis/ViewPureChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::m_errors	libsolidity/analysis/ViewPureChecker.h	/^	bool m_errors = false;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::m_inferredMutability	libsolidity/analysis/ViewPureChecker.h	/^	std::map<ModifierDefinition const*, MutabilityAndLocation> m_inferredMutability;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	bool visit(FunctionDefinition const& _funDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	bool visit(ModifierDefinition const& _modifierDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(FunctionDefinition const& _funDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(IndexAccess const& _indexAccess) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(ModifierDefinition const& _modifierDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(ModifierInvocation const& _modifier) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
dev::solidity::ViewPureChecker::reportMutability	libsolidity/analysis/ViewPureChecker.h	/^	void reportMutability($/;"	p	class:dev::solidity::ViewPureChecker	access:private	signature:( StateMutability _mutability, langutil::SourceLocation const& _location, boost::optional<langutil::SourceLocation> const& _nestedLocation = {} )
dev::solidity::ViewPureChecker::std::m_ast	libsolidity/analysis/ViewPureChecker.h	/^	std::vector<std::shared_ptr<ASTNode>> const& m_ast;$/;"	m	class:dev::solidity::ViewPureChecker::std	access:private
dev::solidity::WhileStatement	libsolidity/ast/AST.h	/^class WhileStatement: public BreakableStatement$/;"	c	namespace:dev::solidity	inherits:BreakableStatement
dev::solidity::WhileStatement::WhileStatement	libsolidity/ast/AST.h	/^	WhileStatement($/;"	f	class:dev::solidity::WhileStatement	access:public	signature:( SourceLocation const& _location, ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _condition, ASTPointer<Statement> const& _body, bool _isDoWhile )
dev::solidity::WhileStatement::accept	libsolidity/ast/AST_accept.h	/^void WhileStatement::accept(ASTConstVisitor& _visitor) const$/;"	f	class:dev::solidity::WhileStatement	signature:(ASTConstVisitor& _visitor) const
dev::solidity::WhileStatement::accept	libsolidity/ast/AST_accept.h	/^void WhileStatement::accept(ASTVisitor& _visitor)$/;"	f	class:dev::solidity::WhileStatement	signature:(ASTVisitor& _visitor)
dev::solidity::WhileStatement::body	libsolidity/ast/AST.h	/^	Statement const& body() const { return *m_body; }$/;"	f	class:dev::solidity::WhileStatement	access:public	signature:() const
dev::solidity::WhileStatement::condition	libsolidity/ast/AST.h	/^	Expression const& condition() const { return *m_condition; }$/;"	f	class:dev::solidity::WhileStatement	access:public	signature:() const
dev::solidity::WhileStatement::isDoWhile	libsolidity/ast/AST.h	/^	bool isDoWhile() const { return m_isDoWhile; }$/;"	f	class:dev::solidity::WhileStatement	access:public	signature:() const
dev::solidity::WhileStatement::m_body	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_body;$/;"	m	class:dev::solidity::WhileStatement	access:private
dev::solidity::WhileStatement::m_condition	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condition;$/;"	m	class:dev::solidity::WhileStatement	access:private
dev::solidity::WhileStatement::m_isDoWhile	libsolidity/ast/AST.h	/^	bool m_isDoWhile;$/;"	m	class:dev::solidity::WhileStatement	access:private
dev::solidity::WhileStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::WhileStatement	access:public
dev::solidity::WhileStatement::override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::WhileStatement	access:public
dev::solidity::binaryVersion	libsolidity/interface/Version.cpp	/^bytes dev::solidity::binaryVersion()$/;"	f	class:dev::solidity	signature:()
dev::solidity::binaryVersion	libsolidity/interface/Version.h	/^bytes binaryVersion();$/;"	p	namespace:dev::solidity	signature:()
dev::solidity::disassemble	libevmasm/Instruction.cpp	/^string dev::solidity::disassemble(bytes const& _mem)$/;"	f	class:dev::solidity	signature:(bytes const& _mem)
dev::solidity::divWorkaround	libevmasm/RuleList.h	/^template <class S> S divWorkaround(S const& _a, S const& _b)$/;"	f	namespace:dev::solidity	signature:(S const& _a, S const& _b)
dev::solidity::eachInstruction	libevmasm/Instruction.cpp	/^void dev::solidity::eachInstruction($/;"	f	class:dev::solidity	signature:( bytes const& _mem, function<void(Instruction,u256 const&)> const& _onInstruction )
dev::solidity::g_argAbi	solse/CommandLineInterface.cpp	/^static string const g_argAbi = g_strAbi;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAllowPaths	solse/CommandLineInterface.cpp	/^static string const g_argAllowPaths = g_strAllowPaths;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAsm	solse/CommandLineInterface.cpp	/^static string const g_argAsm = g_strAsm;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAsmJson	solse/CommandLineInterface.cpp	/^static string const g_argAsmJson = g_strAsmJson;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAssemble	solse/CommandLineInterface.cpp	/^static string const g_argAssemble = g_strAssemble;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAst	solse/CommandLineInterface.cpp	/^static string const g_argAst = g_strAst;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAstCompactJson	solse/CommandLineInterface.cpp	/^static string const g_argAstCompactJson = g_strAstCompactJson;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argAstJson	solse/CommandLineInterface.cpp	/^static string const g_argAstJson = g_strAstJson;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argBinary	solse/CommandLineInterface.cpp	/^static string const g_argBinary = g_strBinary;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argBinaryRuntime	solse/CommandLineInterface.cpp	/^static string const g_argBinaryRuntime = g_strBinaryRuntime;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argColor	solse/CommandLineInterface.cpp	/^static string const g_argColor = g_strColor;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argCombinedJson	solse/CommandLineInterface.cpp	/^static string const g_argCombinedJson = g_strCombinedJson;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argCompactJSON	solse/CommandLineInterface.cpp	/^static string const g_argCompactJSON = g_strCompactJSON;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argGas	solse/CommandLineInterface.cpp	/^static string const g_argGas = g_strGas;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argHelp	solse/CommandLineInterface.cpp	/^static string const g_argHelp = g_strHelp;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argIgnoreMissingFiles	solse/CommandLineInterface.cpp	/^static string const g_argIgnoreMissingFiles = g_strIgnoreMissingFiles;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argInputFile	solse/CommandLineInterface.cpp	/^static string const g_argInputFile = g_strInputFile;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argLibraries	solse/CommandLineInterface.cpp	/^static string const g_argLibraries = g_strLibraries;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argLink	solse/CommandLineInterface.cpp	/^static string const g_argLink = g_strLink;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argMachine	solse/CommandLineInterface.cpp	/^static string const g_argMachine = g_strMachine;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argMetadata	solse/CommandLineInterface.cpp	/^static string const g_argMetadata = g_strMetadata;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argMetadataLiteral	solse/CommandLineInterface.cpp	/^static string const g_argMetadataLiteral = g_strMetadataLiteral;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argNatspecDev	solse/CommandLineInterface.cpp	/^static string const g_argNatspecDev = g_strNatspecDev;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argNatspecUser	solse/CommandLineInterface.cpp	/^static string const g_argNatspecUser = g_strNatspecUser;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argNewReporter	solse/CommandLineInterface.cpp	/^static string const g_argNewReporter = g_strNewReporter;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argNoColor	solse/CommandLineInterface.cpp	/^static string const g_argNoColor = g_strNoColor;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argOpcodes	solse/CommandLineInterface.cpp	/^static string const g_argOpcodes = g_strOpcodes;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argOptimize	solse/CommandLineInterface.cpp	/^static string const g_argOptimize = g_strOptimize;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argOptimizeRuns	solse/CommandLineInterface.cpp	/^static string const g_argOptimizeRuns = g_strOptimizeRuns;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argOutputDir	solse/CommandLineInterface.cpp	/^static string const g_argOutputDir = g_strOutputDir;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argPrettyJson	solse/CommandLineInterface.cpp	/^static string const g_argPrettyJson = g_strPrettyJson;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argSignatureHashes	solse/CommandLineInterface.cpp	/^static string const g_argSignatureHashes = g_strSignatureHashes;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argStandardJSON	solse/CommandLineInterface.cpp	/^static string const g_argStandardJSON = g_strStandardJSON;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argStrictAssembly	solse/CommandLineInterface.cpp	/^static string const g_argStrictAssembly = g_strStrictAssembly;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argVersion	solse/CommandLineInterface.cpp	/^static string const g_argVersion = g_strVersion;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_argYul	solse/CommandLineInterface.cpp	/^static string const g_argYul = g_strYul;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_hasOutput	solse/CommandLineInterface.cpp	/^bool g_hasOutput = false;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_stdinFileName	solse/CommandLineInterface.cpp	/^static string const g_stdinFileName = g_stdinFileNameStr;$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_stdinFileNameStr	solse/CommandLineInterface.cpp	/^static string const g_stdinFileNameStr = "<stdin>";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAbi	solse/CommandLineInterface.cpp	/^static string const g_strAbi = "abi";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAllowPaths	solse/CommandLineInterface.cpp	/^static string const g_strAllowPaths = "allow-paths";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAsm	solse/CommandLineInterface.cpp	/^static string const g_strAsm = "asm";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAsmJson	solse/CommandLineInterface.cpp	/^static string const g_strAsmJson = "asm-json";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAssemble	solse/CommandLineInterface.cpp	/^static string const g_strAssemble = "assemble";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAst	solse/CommandLineInterface.cpp	/^static string const g_strAst = "ast";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAstCompactJson	solse/CommandLineInterface.cpp	/^static string const g_strAstCompactJson = "ast-compact-json";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strAstJson	solse/CommandLineInterface.cpp	/^static string const g_strAstJson = "ast-json";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strBinary	solse/CommandLineInterface.cpp	/^static string const g_strBinary = "bin";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strBinaryRuntime	solse/CommandLineInterface.cpp	/^static string const g_strBinaryRuntime = "bin-runtime";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strColor	solse/CommandLineInterface.cpp	/^static string const g_strColor = "color";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strCombinedJson	solse/CommandLineInterface.cpp	/^static string const g_strCombinedJson = "combined-json";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strCompactJSON	solse/CommandLineInterface.cpp	/^static string const g_strCompactJSON = "compact-format";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strContracts	solse/CommandLineInterface.cpp	/^static string const g_strContracts = "contracts";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strEVM	solse/CommandLineInterface.cpp	/^static string const g_strEVM = "evm";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strEVM15	solse/CommandLineInterface.cpp	/^static string const g_strEVM15 = "evm15";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strEVMVersion	solse/CommandLineInterface.cpp	/^static string const g_strEVMVersion = "evm-version";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strGas	solse/CommandLineInterface.cpp	/^static string const g_strGas = "gas";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strHelp	solse/CommandLineInterface.cpp	/^static string const g_strHelp = "help";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strIgnoreMissingFiles	solse/CommandLineInterface.cpp	/^static string const g_strIgnoreMissingFiles = "ignore-missing";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strInputFile	solse/CommandLineInterface.cpp	/^static string const g_strInputFile = "input-file";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strInterface	solse/CommandLineInterface.cpp	/^static string const g_strInterface = "interface";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strLibraries	solse/CommandLineInterface.cpp	/^static string const g_strLibraries = "libraries";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strLicense	solse/CommandLineInterface.cpp	/^static string const g_strLicense = "license";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strLink	solse/CommandLineInterface.cpp	/^static string const g_strLink = "link";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strMachine	solse/CommandLineInterface.cpp	/^static string const g_strMachine = "machine";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strMetadata	solse/CommandLineInterface.cpp	/^static string const g_strMetadata = "metadata";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strMetadataLiteral	solse/CommandLineInterface.cpp	/^static string const g_strMetadataLiteral = "metadata-literal";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strNatspecDev	solse/CommandLineInterface.cpp	/^static string const g_strNatspecDev = "devdoc";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strNatspecUser	solse/CommandLineInterface.cpp	/^static string const g_strNatspecUser = "userdoc";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strNewReporter	solse/CommandLineInterface.cpp	/^static string const g_strNewReporter = "new-reporter";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strNoColor	solse/CommandLineInterface.cpp	/^static string const g_strNoColor = "no-color";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strOpcodes	solse/CommandLineInterface.cpp	/^static string const g_strOpcodes = "opcodes";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strOptimize	solse/CommandLineInterface.cpp	/^static string const g_strOptimize = "optimize";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strOptimizeRuns	solse/CommandLineInterface.cpp	/^static string const g_strOptimizeRuns = "optimize-runs";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strOutputDir	solse/CommandLineInterface.cpp	/^static string const g_strOutputDir = "output-dir";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strOverwrite	solse/CommandLineInterface.cpp	/^static string const g_strOverwrite = "overwrite";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strPrettyJson	solse/CommandLineInterface.cpp	/^static string const g_strPrettyJson = "pretty-json";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strSignatureHashes	solse/CommandLineInterface.cpp	/^static string const g_strSignatureHashes = "hashes";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strSourceList	solse/CommandLineInterface.cpp	/^static string const g_strSourceList = "sourceList";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strSources	solse/CommandLineInterface.cpp	/^static string const g_strSources = "sources";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strSrcMap	solse/CommandLineInterface.cpp	/^static string const g_strSrcMap = "srcmap";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strSrcMapRuntime	solse/CommandLineInterface.cpp	/^static string const g_strSrcMapRuntime = "srcmap-runtime";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strStandardJSON	solse/CommandLineInterface.cpp	/^static string const g_strStandardJSON = "standard-json";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strStrictAssembly	solse/CommandLineInterface.cpp	/^static string const g_strStrictAssembly = "strict-assembly";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strVersion	solse/CommandLineInterface.cpp	/^static string const g_strVersion = "version";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_strYul	solse/CommandLineInterface.cpp	/^static string const g_strYul = "yul";$/;"	m	namespace:dev::solidity	file:
dev::solidity::g_streWasm	solse/CommandLineInterface.cpp	/^static string const g_streWasm = "ewasm";$/;"	m	namespace:dev::solidity	file:
dev::solidity::instructionInfo	libevmasm/Instruction.cpp	/^InstructionInfo dev::solidity::instructionInfo(Instruction _inst)$/;"	f	class:dev::solidity	signature:(Instruction _inst)
dev::solidity::isAddress	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isAddress(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isAddress	libsolidity/formal/SymbolicTypes.h	/^bool isAddress(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isBool	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isBool(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isBool	libsolidity/formal/SymbolicTypes.h	/^bool isBool(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isFixedBytes	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isFixedBytes(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isFixedBytes	libsolidity/formal/SymbolicTypes.h	/^bool isFixedBytes(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isFunction	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isFunction(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isFunction	libsolidity/formal/SymbolicTypes.h	/^bool isFunction(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isInteger	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isInteger(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isInteger	libsolidity/formal/SymbolicTypes.h	/^bool isInteger(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isMapping	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isMapping(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isMapping	libsolidity/formal/SymbolicTypes.h	/^bool isMapping(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isNumber	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isNumber(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isNumber	libsolidity/formal/SymbolicTypes.h	/^bool isNumber(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isRational	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isRational(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isRational	libsolidity/formal/SymbolicTypes.h	/^bool isRational(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isSupportedType	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedType(Type const& _type)$/;"	f	class:dev::solidity	signature:(Type const& _type)
dev::solidity::isSupportedType	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedType(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isSupportedType	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedType(Type const& _type);$/;"	p	namespace:dev::solidity	signature:(Type const& _type)
dev::solidity::isSupportedType	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedType(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedTypeDeclaration(Type const& _type)$/;"	f	class:dev::solidity	signature:(Type const& _type)
dev::solidity::isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedTypeDeclaration(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedTypeDeclaration(Type const& _type);$/;"	p	namespace:dev::solidity	signature:(Type const& _type)
dev::solidity::isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedTypeDeclaration(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::isValidInstruction	libevmasm/Instruction.cpp	/^bool dev::solidity::isValidInstruction(Instruction _inst)$/;"	f	class:dev::solidity	signature:(Instruction _inst)
dev::solidity::license	solse/CommandLineInterface.cpp	/^static void license()$/;"	f	namespace:dev::solidity	signature:()
dev::solidity::makeRational	libsolidity/ast/Types.h	/^inline rational makeRational(bigint const& _numerator, bigint const& _denominator)$/;"	f	namespace:dev::solidity	signature:(bigint const& _numerator, bigint const& _denominator)
dev::solidity::maxValue	libsolidity/formal/SymbolicTypes.cpp	/^smt::Expression dev::solidity::maxValue(IntegerType const& _type)$/;"	f	class:dev::solidity	signature:(IntegerType const& _type)
dev::solidity::maxValue	libsolidity/formal/SymbolicTypes.h	/^smt::Expression maxValue(IntegerType const& _type);$/;"	p	namespace:dev::solidity	signature:(IntegerType const& _type)
dev::solidity::minValue	libsolidity/formal/SymbolicTypes.cpp	/^smt::Expression dev::solidity::minValue(IntegerType const& _type)$/;"	f	class:dev::solidity	signature:(IntegerType const& _type)
dev::solidity::minValue	libsolidity/formal/SymbolicTypes.h	/^smt::Expression minValue(IntegerType const& _type);$/;"	p	namespace:dev::solidity	signature:(IntegerType const& _type)
dev::solidity::modWorkaround	libevmasm/RuleList.h	/^template <class S> S modWorkaround(S const& _a, S const& _b)$/;"	f	namespace:dev::solidity	signature:(S const& _a, S const& _b)
dev::solidity::needsHumanTargetedStdout	solse/CommandLineInterface.cpp	/^static bool needsHumanTargetedStdout(po::variables_map const& _args)$/;"	f	namespace:dev::solidity	signature:(po::variables_map const& _args)
dev::solidity::newSymbolicVariable	libsolidity/formal/SymbolicTypes.cpp	/^pair<bool, shared_ptr<SymbolicVariable>> dev::solidity::newSymbolicVariable($/;"	f	class:dev::solidity	signature:( Type const& _type, std::string const& _uniqueName, smt::SolverInterface& _solver )
dev::solidity::newSymbolicVariable	libsolidity/formal/SymbolicTypes.h	/^std::pair<bool, std::shared_ptr<SymbolicVariable>> newSymbolicVariable(Type const& _type, std::string const& _uniqueName, smt::SolverInterface& _solver);$/;"	p	namespace:dev::solidity	signature:(Type const& _type, std::string const& _uniqueName, smt::SolverInterface& _solver)
dev::solidity::serr	solse/CommandLineInterface.cpp	/^std::ostream& serr(bool _used = true)$/;"	f	namespace:dev::solidity	signature:(bool _used = true)
dev::solidity::simplificationRuleList	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleList($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern B, Pattern C, Pattern X, Pattern Y )
dev::solidity::simplificationRuleListPart1	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart1($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern B, Pattern C, Pattern, Pattern )
dev::solidity::simplificationRuleListPart2	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart2($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern Y )
dev::solidity::simplificationRuleListPart3	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart3($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern )
dev::solidity::simplificationRuleListPart4	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart4($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern Y )
dev::solidity::simplificationRuleListPart5	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart5($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern )
dev::solidity::simplificationRuleListPart6	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart6($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern Y )
dev::solidity::simplificationRuleListPart7	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart7($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern B, Pattern, Pattern X, Pattern Y )
dev::solidity::simplificationRuleListPart8	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart8($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern, Pattern, Pattern X, Pattern Y )
dev::solidity::smt	libsolidity/formal/CVC4Interface.h	/^namespace smt$/;"	n	namespace:dev::solidity
dev::solidity::smt	libsolidity/formal/SMTLib2Interface.h	/^namespace smt$/;"	n	namespace:dev::solidity
dev::solidity::smt	libsolidity/formal/SMTPortfolio.h	/^namespace smt$/;"	n	namespace:dev::solidity
dev::solidity::smt	libsolidity/formal/SolverInterface.h	/^namespace smt$/;"	n	namespace:dev::solidity
dev::solidity::smt	libsolidity/formal/SymbolicTypes.h	/^namespace smt$/;"	n	namespace:dev::solidity
dev::solidity::smt	libsolidity/formal/Z3Interface.h	/^namespace smt$/;"	n	namespace:dev::solidity
dev::solidity::smt::ArraySort	libsolidity/formal/SolverInterface.h	/^struct ArraySort: public Sort$/;"	s	namespace:dev::solidity::smt	inherits:Sort
dev::solidity::smt::ArraySort::ArraySort	libsolidity/formal/SolverInterface.h	/^	ArraySort(SortPointer _domain, SortPointer _range):$/;"	f	struct:dev::solidity::smt::ArraySort	access:public	signature:(SortPointer _domain, SortPointer _range)
dev::solidity::smt::ArraySort::domain	libsolidity/formal/SolverInterface.h	/^	SortPointer domain;$/;"	m	struct:dev::solidity::smt::ArraySort	access:public
dev::solidity::smt::ArraySort::range	libsolidity/formal/SolverInterface.h	/^	SortPointer range;$/;"	m	struct:dev::solidity::smt::ArraySort	access:public
dev::solidity::smt::CVC4Interface	libsolidity/formal/CVC4Interface.h	/^class CVC4Interface: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
dev::solidity::smt::CVC4Interface::CVC4Interface	libsolidity/formal/CVC4Interface.h	/^	CVC4Interface();$/;"	p	class:dev::solidity::smt::CVC4Interface	access:public	signature:()
dev::solidity::smt::CVC4Interface::cvc4Sort	libsolidity/formal/CVC4Interface.h	/^	CVC4::Type cvc4Sort(smt::Sort const& _sort);$/;"	p	class:dev::solidity::smt::CVC4Interface	access:private	signature:(smt::Sort const& _sort)
dev::solidity::smt::CVC4Interface::cvc4Sort	libsolidity/formal/CVC4Interface.h	/^	std::vector<CVC4::Type> cvc4Sort(std::vector<smt::SortPointer> const& _sorts);$/;"	p	class:dev::solidity::smt::CVC4Interface	access:private	signature:(std::vector<smt::SortPointer> const& _sorts)
dev::solidity::smt::CVC4Interface::m_context	libsolidity/formal/CVC4Interface.h	/^	CVC4::ExprManager m_context;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:private
dev::solidity::smt::CVC4Interface::m_solver	libsolidity/formal/CVC4Interface.h	/^	CVC4::SmtEngine m_solver;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:private
dev::solidity::smt::CVC4Interface::m_variables	libsolidity/formal/CVC4Interface.h	/^	std::map<std::string, CVC4::Expr> m_variables;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:private
dev::solidity::smt::CVC4Interface::override	libsolidity/formal/CVC4Interface.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
dev::solidity::smt::CVC4Interface::override	libsolidity/formal/CVC4Interface.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
dev::solidity::smt::CVC4Interface::override	libsolidity/formal/CVC4Interface.h	/^	void declareVariable(std::string const&, Sort const&) override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
dev::solidity::smt::CVC4Interface::override	libsolidity/formal/CVC4Interface.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
dev::solidity::smt::CVC4Interface::override	libsolidity/formal/CVC4Interface.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
dev::solidity::smt::CVC4Interface::override	libsolidity/formal/CVC4Interface.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
dev::solidity::smt::CVC4Interface::toCVC4Expr	libsolidity/formal/CVC4Interface.h	/^	CVC4::Expr toCVC4Expr(Expression const& _expr);$/;"	p	class:dev::solidity::smt::CVC4Interface	access:private	signature:(Expression const& _expr)
dev::solidity::smt::CheckResult	libsolidity/formal/SolverInterface.h	/^enum class CheckResult$/;"	c	namespace:dev::solidity::smt
dev::solidity::smt::CheckResult::CONFLICTING	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
dev::solidity::smt::CheckResult::SATISFIABLE	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
dev::solidity::smt::CheckResult::UNKNOWN	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
dev::solidity::smt::CheckResult::UNSATISFIABLE	libsolidity/formal/SolverInterface.h	/^	SATISFIABLE, UNSATISFIABLE, UNKNOWN, CONFLICTING, ERROR$/;"	m	class:dev::solidity::smt::CheckResult	access:private
dev::solidity::smt::DEV_SIMPLE_EXCEPTION	libsolidity/formal/SolverInterface.h	/^DEV_SIMPLE_EXCEPTION(SolverError);$/;"	p	namespace:dev::solidity::smt	signature:(SolverError)
dev::solidity::smt::Expression	libsolidity/formal/SolverInterface.h	/^class Expression$/;"	c	namespace:dev::solidity::smt
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(Expression const&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression const&)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(Expression&&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression&&)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(bigint const& _number): Expression(_number.str(), Kind::Int) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(bigint const& _number)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(size_t _number): Expression(std::to_string(_number), Kind::Int) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(size_t _number)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, Expression _arg, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, Expression _arg, Kind _kind)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, Expression _arg1, Expression _arg2, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, Expression _arg1, Expression _arg2, Kind _kind)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, std::vector<Expression> _arguments, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, std::vector<Expression> _arguments, Kind _kind)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(std::string _name, std::vector<Expression> _arguments, SortPointer _sort):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, std::vector<Expression> _arguments, SortPointer _sort)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	Expression(u256 const& _number): Expression(_number.str(), Kind::Int) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(u256 const& _number)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	explicit Expression(bool _v): Expression(_v ? "true" : "false", Kind::Bool) {}$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(bool _v)
dev::solidity::smt::Expression::Expression	libsolidity/formal/SolverInterface.h	/^	explicit Expression(std::string _name, Kind _kind):$/;"	f	class:dev::solidity::smt::Expression	access:private	signature:(std::string _name, Kind _kind)
dev::solidity::smt::Expression::arguments	libsolidity/formal/SolverInterface.h	/^	std::vector<Expression> arguments;$/;"	m	class:dev::solidity::smt::Expression	access:public
dev::solidity::smt::Expression::hasCorrectArity	libsolidity/formal/SolverInterface.h	/^	bool hasCorrectArity() const$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:() const
dev::solidity::smt::Expression::implies	libsolidity/formal/SolverInterface.h	/^	static Expression implies(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::ite	libsolidity/formal/SolverInterface.h	/^	static Expression ite(Expression _condition, Expression _trueValue, Expression _falseValue)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _condition, Expression _trueValue, Expression _falseValue)
dev::solidity::smt::Expression::name	libsolidity/formal/SolverInterface.h	/^	std::string name;$/;"	m	class:dev::solidity::smt::Expression	access:public
dev::solidity::smt::Expression::operator !	libsolidity/formal/SolverInterface.h	/^	friend Expression operator!(Expression _a)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a)
dev::solidity::smt::Expression::operator !=	libsolidity/formal/SolverInterface.h	/^	friend Expression operator!=(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator %	libsolidity/formal/SolverInterface.h	/^	friend Expression operator%(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator &&	libsolidity/formal/SolverInterface.h	/^	friend Expression operator&&(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator ()	libsolidity/formal/SolverInterface.h	/^	Expression operator()(std::vector<Expression> _arguments) const$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(std::vector<Expression> _arguments) const
dev::solidity::smt::Expression::operator *	libsolidity/formal/SolverInterface.h	/^	friend Expression operator*(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator +	libsolidity/formal/SolverInterface.h	/^	friend Expression operator+(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator -	libsolidity/formal/SolverInterface.h	/^	friend Expression operator-(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator /	libsolidity/formal/SolverInterface.h	/^	friend Expression operator\/(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator <	libsolidity/formal/SolverInterface.h	/^	friend Expression operator<(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator <=	libsolidity/formal/SolverInterface.h	/^	friend Expression operator<=(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator =	libsolidity/formal/SolverInterface.h	/^	Expression& operator=(Expression const&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression const&)
dev::solidity::smt::Expression::operator =	libsolidity/formal/SolverInterface.h	/^	Expression& operator=(Expression&&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression&&)
dev::solidity::smt::Expression::operator ==	libsolidity/formal/SolverInterface.h	/^	friend Expression operator==(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator >	libsolidity/formal/SolverInterface.h	/^	friend Expression operator>(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator >=	libsolidity/formal/SolverInterface.h	/^	friend Expression operator>=(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::operator ||	libsolidity/formal/SolverInterface.h	/^	friend Expression operator||(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
dev::solidity::smt::Expression::select	libsolidity/formal/SolverInterface.h	/^	static Expression select(Expression _array, Expression _index)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _array, Expression _index)
dev::solidity::smt::Expression::sort	libsolidity/formal/SolverInterface.h	/^	SortPointer sort;$/;"	m	class:dev::solidity::smt::Expression	access:public
dev::solidity::smt::Expression::store	libsolidity/formal/SolverInterface.h	/^	static Expression store(Expression _array, Expression _index, Expression _element)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _array, Expression _index, Expression _element)
dev::solidity::smt::FunctionSort	libsolidity/formal/SolverInterface.h	/^struct FunctionSort: public Sort$/;"	s	namespace:dev::solidity::smt	inherits:Sort
dev::solidity::smt::FunctionSort::FunctionSort	libsolidity/formal/SolverInterface.h	/^	FunctionSort(std::vector<SortPointer> _domain, SortPointer _codomain):$/;"	f	struct:dev::solidity::smt::FunctionSort	access:public	signature:(std::vector<SortPointer> _domain, SortPointer _codomain)
dev::solidity::smt::FunctionSort::codomain	libsolidity/formal/SolverInterface.h	/^	SortPointer codomain;$/;"	m	struct:dev::solidity::smt::FunctionSort	access:public
dev::solidity::smt::FunctionSort::domain	libsolidity/formal/SolverInterface.h	/^	std::vector<SortPointer> domain;$/;"	m	struct:dev::solidity::smt::FunctionSort	access:public
dev::solidity::smt::Kind	libsolidity/formal/SolverInterface.h	/^enum class Kind$/;"	c	namespace:dev::solidity::smt
dev::solidity::smt::Kind::Bool	libsolidity/formal/SolverInterface.h	/^	Bool,$/;"	m	class:dev::solidity::smt::Kind	access:private
dev::solidity::smt::Kind::Function	libsolidity/formal/SolverInterface.h	/^	Function,$/;"	m	class:dev::solidity::smt::Kind	access:private
dev::solidity::smt::Kind::Int	libsolidity/formal/SolverInterface.h	/^	Int,$/;"	m	class:dev::solidity::smt::Kind	access:private
dev::solidity::smt::SMTLib2Interface	libsolidity/formal/SMTLib2Interface.h	/^class SMTLib2Interface: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
dev::solidity::smt::SMTLib2Interface::SMTLib2Interface	libsolidity/formal/SMTLib2Interface.h	/^	explicit SMTLib2Interface(std::map<h256, std::string> const& _queryResponses);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:public	signature:(std::map<h256, std::string> const& _queryResponses)
dev::solidity::smt::SMTLib2Interface::checkSatAndGetValuesCommand	libsolidity/formal/SMTLib2Interface.h	/^	std::string checkSatAndGetValuesCommand(std::vector<Expression> const& _expressionsToEvaluate);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::vector<Expression> const& _expressionsToEvaluate)
dev::solidity::smt::SMTLib2Interface::declareFunction	libsolidity/formal/SMTLib2Interface.h	/^	void declareFunction(std::string const&, Sort const&);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string const&, Sort const&)
dev::solidity::smt::SMTLib2Interface::m_accumulatedOutput	libsolidity/formal/SMTLib2Interface.h	/^	std::vector<std::string> m_accumulatedOutput;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:private
dev::solidity::smt::SMTLib2Interface::m_unhandledQueries	libsolidity/formal/SMTLib2Interface.h	/^	std::vector<std::string> m_unhandledQueries;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:private
dev::solidity::smt::SMTLib2Interface::m_variables	libsolidity/formal/SMTLib2Interface.h	/^	std::set<std::string> m_variables;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:private
dev::solidity::smt::SMTLib2Interface::override	libsolidity/formal/SMTLib2Interface.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
dev::solidity::smt::SMTLib2Interface::override	libsolidity/formal/SMTLib2Interface.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
dev::solidity::smt::SMTLib2Interface::override	libsolidity/formal/SMTLib2Interface.h	/^	void declareVariable(std::string const&, Sort const&) override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
dev::solidity::smt::SMTLib2Interface::override	libsolidity/formal/SMTLib2Interface.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
dev::solidity::smt::SMTLib2Interface::override	libsolidity/formal/SMTLib2Interface.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
dev::solidity::smt::SMTLib2Interface::override	libsolidity/formal/SMTLib2Interface.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
dev::solidity::smt::SMTLib2Interface::parseValues	libsolidity/formal/SMTLib2Interface.h	/^	std::vector<std::string> parseValues(std::string::const_iterator _start, std::string::const_iterator _end);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string::const_iterator _start, std::string::const_iterator _end)
dev::solidity::smt::SMTLib2Interface::querySolver	libsolidity/formal/SMTLib2Interface.h	/^	std::string querySolver(std::string const& _input);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string const& _input)
dev::solidity::smt::SMTLib2Interface::std::m_queryResponses	libsolidity/formal/SMTLib2Interface.h	/^	std::map<h256, std::string> const& m_queryResponses;$/;"	m	class:dev::solidity::smt::SMTLib2Interface::std	access:private
dev::solidity::smt::SMTLib2Interface::toSExpr	libsolidity/formal/SMTLib2Interface.h	/^	std::string toSExpr(Expression const& _expr);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(Expression const& _expr)
dev::solidity::smt::SMTLib2Interface::toSmtLibSort	libsolidity/formal/SMTLib2Interface.h	/^	std::string toSmtLibSort(Sort const& _sort);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(Sort const& _sort)
dev::solidity::smt::SMTLib2Interface::toSmtLibSort	libsolidity/formal/SMTLib2Interface.h	/^	std::string toSmtLibSort(std::vector<SortPointer> const& _sort);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::vector<SortPointer> const& _sort)
dev::solidity::smt::SMTLib2Interface::write	libsolidity/formal/SMTLib2Interface.h	/^	void write(std::string _data);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string _data)
dev::solidity::smt::SMTPortfolio	libsolidity/formal/SMTPortfolio.h	/^class SMTPortfolio: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
dev::solidity::smt::SMTPortfolio::SMTPortfolio	libsolidity/formal/SMTPortfolio.h	/^	SMTPortfolio(std::map<h256, std::string> const& _smtlib2Responses);$/;"	p	class:dev::solidity::smt::SMTPortfolio	access:public	signature:(std::map<h256, std::string> const& _smtlib2Responses)
dev::solidity::smt::SMTPortfolio::m_solvers	libsolidity/formal/SMTPortfolio.h	/^	std::vector<std::shared_ptr<smt::SolverInterface>> m_solvers;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:private
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	std::vector<std::string> unhandledQueries() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	void declareVariable(std::string const&, Sort const&) override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::override	libsolidity/formal/SMTPortfolio.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
dev::solidity::smt::SMTPortfolio::solverAnswered	libsolidity/formal/SMTPortfolio.h	/^	static bool solverAnswered(CheckResult result);$/;"	p	class:dev::solidity::smt::SMTPortfolio	access:private	signature:(CheckResult result)
dev::solidity::smt::SolverInterface	libsolidity/formal/SolverInterface.h	/^class SolverInterface$/;"	c	namespace:dev::solidity::smt
dev::solidity::smt::SolverInterface::addAssertion	libsolidity/formal/SolverInterface.h	/^	virtual void addAssertion(Expression const& _expr) = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:(Expression const& _expr)
dev::solidity::smt::SolverInterface::check	libsolidity/formal/SolverInterface.h	/^	check(std::vector<Expression> const& _expressionsToEvaluate) = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:(std::vector<Expression> const& _expressionsToEvaluate)
dev::solidity::smt::SolverInterface::declareVariable	libsolidity/formal/SolverInterface.h	/^	virtual void declareVariable(std::string const& _name, Sort const& _sort) = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:(std::string const& _name, Sort const& _sort)
dev::solidity::smt::SolverInterface::newVariable	libsolidity/formal/SolverInterface.h	/^	Expression newVariable(std::string _name, SortPointer _sort)$/;"	f	class:dev::solidity::smt::SolverInterface	access:public	signature:(std::string _name, SortPointer _sort)
dev::solidity::smt::SolverInterface::pop	libsolidity/formal/SolverInterface.h	/^	virtual void pop() = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
dev::solidity::smt::SolverInterface::push	libsolidity/formal/SolverInterface.h	/^	virtual void push() = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
dev::solidity::smt::SolverInterface::queryTimeout	libsolidity/formal/SolverInterface.h	/^	static int const queryTimeout = 10000;$/;"	m	class:dev::solidity::smt::SolverInterface	access:protected
dev::solidity::smt::SolverInterface::reset	libsolidity/formal/SolverInterface.h	/^	virtual void reset() = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
dev::solidity::smt::SolverInterface::solvers	libsolidity/formal/SolverInterface.h	/^	virtual unsigned solvers() { return 1; }$/;"	f	class:dev::solidity::smt::SolverInterface	access:public	signature:()
dev::solidity::smt::SolverInterface::unhandledQueries	libsolidity/formal/SolverInterface.h	/^	virtual std::vector<std::string> unhandledQueries() { return {}; }$/;"	f	class:dev::solidity::smt::SolverInterface	access:public	signature:()
dev::solidity::smt::SolverInterface::~SolverInterface	libsolidity/formal/SolverInterface.h	/^	virtual ~SolverInterface() = default;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
dev::solidity::smt::Sort	libsolidity/formal/SolverInterface.h	/^struct Sort$/;"	s	namespace:dev::solidity::smt
dev::solidity::smt::Sort::Sort	libsolidity/formal/SolverInterface.h	/^	Sort(Kind _kind):$/;"	f	struct:dev::solidity::smt::Sort	access:public	signature:(Kind _kind)
dev::solidity::smt::Sort::kind	libsolidity/formal/SolverInterface.h	/^	Kind const kind;$/;"	m	struct:dev::solidity::smt::Sort	access:public
dev::solidity::smt::Sort::operator ==	libsolidity/formal/SolverInterface.h	/^	virtual bool operator==(Sort const& _other) const { return kind == _other.kind; }$/;"	f	struct:dev::solidity::smt::Sort	access:public	signature:(Sort const& _other) const
dev::solidity::smt::Sort::~Sort	libsolidity/formal/SolverInterface.h	/^	virtual ~Sort() = default;$/;"	p	struct:dev::solidity::smt::Sort	access:public	signature:()
dev::solidity::smt::Z3Interface	libsolidity/formal/Z3Interface.h	/^class Z3Interface: public SolverInterface, public boost::noncopyable$/;"	c	namespace:dev::solidity::smt	inherits:SolverInterface,boost::noncopyable
dev::solidity::smt::Z3Interface::Z3Interface	libsolidity/formal/Z3Interface.h	/^	Z3Interface();$/;"	p	class:dev::solidity::smt::Z3Interface	access:public	signature:()
dev::solidity::smt::Z3Interface::declareFunction	libsolidity/formal/Z3Interface.h	/^	void declareFunction(std::string const& _name, Sort const& _sort);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(std::string const& _name, Sort const& _sort)
dev::solidity::smt::Z3Interface::m_constants	libsolidity/formal/Z3Interface.h	/^	std::map<std::string, z3::expr> m_constants;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
dev::solidity::smt::Z3Interface::m_context	libsolidity/formal/Z3Interface.h	/^	z3::context m_context;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
dev::solidity::smt::Z3Interface::m_functions	libsolidity/formal/Z3Interface.h	/^	std::map<std::string, z3::func_decl> m_functions;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
dev::solidity::smt::Z3Interface::m_solver	libsolidity/formal/Z3Interface.h	/^	z3::solver m_solver;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
dev::solidity::smt::Z3Interface::override	libsolidity/formal/Z3Interface.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
dev::solidity::smt::Z3Interface::override	libsolidity/formal/Z3Interface.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
dev::solidity::smt::Z3Interface::override	libsolidity/formal/Z3Interface.h	/^	void declareVariable(std::string const& _name, Sort const& _sort) override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
dev::solidity::smt::Z3Interface::override	libsolidity/formal/Z3Interface.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
dev::solidity::smt::Z3Interface::override	libsolidity/formal/Z3Interface.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
dev::solidity::smt::Z3Interface::override	libsolidity/formal/Z3Interface.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
dev::solidity::smt::Z3Interface::toZ3Expr	libsolidity/formal/Z3Interface.h	/^	z3::expr toZ3Expr(Expression const& _expr);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(Expression const& _expr)
dev::solidity::smt::Z3Interface::z3Sort	libsolidity/formal/Z3Interface.h	/^	z3::sort z3Sort(smt::Sort const& _sort);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(smt::Sort const& _sort)
dev::solidity::smt::Z3Interface::z3Sort	libsolidity/formal/Z3Interface.h	/^	z3::sort_vector z3Sort(std::vector<smt::SortPointer> const& _sorts);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(std::vector<smt::SortPointer> const& _sorts)
dev::solidity::smt::setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicUnknownValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicUnknownValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicUnknownValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicUnknownValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicZeroValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicZeroValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicZeroValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
dev::solidity::smt::setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicZeroValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
dev::solidity::smtKind	libsolidity/formal/SymbolicTypes.cpp	/^smt::Kind dev::solidity::smtKind(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
dev::solidity::smtKind	libsolidity/formal/SymbolicTypes.h	/^smt::Kind smtKind(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
dev::solidity::smtSort	libsolidity/formal/SymbolicTypes.cpp	/^smt::SortPointer dev::solidity::smtSort(Type const& _type)$/;"	f	class:dev::solidity	signature:(Type const& _type)
dev::solidity::smtSort	libsolidity/formal/SymbolicTypes.cpp	/^vector<smt::SortPointer> dev::solidity::smtSort(vector<TypePointer> const& _types)$/;"	f	class:dev::solidity	signature:(vector<TypePointer> const& _types)
dev::solidity::smtSort	libsolidity/formal/SymbolicTypes.h	/^smt::SortPointer smtSort(Type const& _type);$/;"	p	namespace:dev::solidity	signature:(Type const& _type)
dev::solidity::smtSort	libsolidity/formal/SymbolicTypes.h	/^std::vector<smt::SortPointer> smtSort(std::vector<TypePointer> const& _types);$/;"	p	namespace:dev::solidity	signature:(std::vector<TypePointer> const& _types)
dev::solidity::sout	solse/CommandLineInterface.cpp	/^std::ostream& sout()$/;"	f	namespace:dev::solidity	signature:()
dev::solidity::stateMutabilityToString	libsolidity/ast/ASTEnums.h	/^inline std::string stateMutabilityToString(StateMutability const& _stateMutability)$/;"	f	namespace:dev::solidity	signature:(StateMutability const& _stateMutability)
dev::solidity::static_assert	libsolidity/ast/Types.h	/^static_assert(std::is_nothrow_move_constructible<MemberList>::value, "MemberList should be noexcept move constructible");$/;"	p	namespace:dev::solidity	signature:(std::is_nothrow_move_constructible<MemberList>::value, )
dev::solidity::std::ExperimentalFeatureNames	libsolidity/ast/ExperimentalFeatures.h	/^static std::map<std::string, ExperimentalFeature> const ExperimentalFeatureNames =$/;"	m	class:dev::solidity::std
dev::solidity::std::ExperimentalFeatureOnlyAnalysis	libsolidity/ast/ExperimentalFeatures.h	/^static std::map<ExperimentalFeature, bool> const ExperimentalFeatureOnlyAnalysis =$/;"	m	class:dev::solidity::std
dev::solidity::version	solse/CommandLineInterface.cpp	/^static void version()$/;"	f	namespace:dev::solidity	signature:()
dev::stringDistance	libdevcore/StringUtils.cpp	/^size_t dev::stringDistance(string const& _str1, string const& _str2)$/;"	f	class:dev	signature:(string const& _str1, string const& _str2)
dev::stringDistance	libdevcore/StringUtils.h	/^size_t stringDistance(std::string const& _str1, std::string const& _str2);$/;"	p	namespace:dev	signature:(std::string const& _str1, std::string const& _str2)
dev::stringWithinDistance	libdevcore/StringUtils.cpp	/^bool dev::stringWithinDistance(string const& _str1, string const& _str2, size_t _maxDistance, size_t _lenThreshold)$/;"	f	class:dev	signature:(string const& _str1, string const& _str2, size_t _maxDistance, size_t _lenThreshold)
dev::stringWithinDistance	libdevcore/StringUtils.h	/^bool stringWithinDistance(std::string const& _str1, std::string const& _str2, size_t _maxDistance, size_t _lenThreshold = 0);$/;"	p	namespace:dev	signature:(std::string const& _str1, std::string const& _str2, size_t _maxDistance, size_t _lenThreshold = 0)
dev::swarmHash	libdevcore/SwarmHash.cpp	/^h256 dev::swarmHash(string const& _input)$/;"	f	class:dev	signature:(string const& _input)
dev::swarmHash	libdevcore/SwarmHash.h	/^h256 swarmHash(std::string const& _input);$/;"	p	namespace:dev	signature:(std::string const& _input)
dev::toBigEndian	libdevcore/CommonData.h	/^inline bytes toBigEndian(u160 _val) { bytes ret(20); toBigEndian(_val, ret); return ret; }$/;"	f	namespace:dev	signature:(u160 _val)
dev::toBigEndian	libdevcore/CommonData.h	/^inline bytes toBigEndian(u256 _val) { bytes ret(32); toBigEndian(_val, ret); return ret; }$/;"	f	namespace:dev	signature:(u256 _val)
dev::toBigEndian	libdevcore/CommonData.h	/^inline void toBigEndian(T _val, Out& o_out)$/;"	f	namespace:dev	signature:(T _val, Out& o_out)
dev::toCompactBigEndian	libdevcore/CommonData.h	/^inline bytes toCompactBigEndian(T _val, unsigned _min = 0)$/;"	f	namespace:dev	signature:(T _val, unsigned _min = 0)
dev::toCompactBigEndian	libdevcore/CommonData.h	/^inline bytes toCompactBigEndian(uint8_t _val, unsigned _min = 0)$/;"	f	namespace:dev	signature:(uint8_t _val, unsigned _min = 0)
dev::toCompactHexWithPrefix	libdevcore/CommonData.h	/^inline std::string toCompactHexWithPrefix(u256 val)$/;"	f	namespace:dev	signature:(u256 val)
dev::toHex	libdevcore/CommonData.cpp	/^string dev::toHex(bytes const& _data, HexPrefix _prefix, HexCase _case)$/;"	f	class:dev	signature:(bytes const& _data, HexPrefix _prefix, HexCase _case)
dev::toHex	libdevcore/CommonData.h	/^inline std::string toHex(u256 val, HexPrefix prefix = HexPrefix::DontAdd)$/;"	f	namespace:dev	signature:(u256 val, HexPrefix prefix = HexPrefix::DontAdd)
dev::toHex	libdevcore/CommonData.h	/^std::string toHex(bytes const& _data, HexPrefix _prefix = HexPrefix::DontAdd, HexCase _case = HexCase::Lower);$/;"	p	namespace:dev	signature:(bytes const& _data, HexPrefix _prefix = HexPrefix::DontAdd, HexCase _case = HexCase::Lower)
dev::toString	libdevcore/CommonIO.h	/^std::string toString(_T const& _t)$/;"	f	namespace:dev	signature:(_T const& _t)
dev::u2s	libdevcore/Common.h	/^inline s256 u2s(u256 _u)$/;"	f	namespace:dev	signature:(u256 _u)
dev::validateUTF8	libdevcore/UTF8.cpp	/^bool validateUTF8(std::string const& _input, size_t& _invalidPosition)$/;"	f	namespace:dev	signature:(std::string const& _input, size_t& _invalidPosition)
dev::validateUTF8	libdevcore/UTF8.h	/^bool validateUTF8(std::string const& _input, size_t& _invalidPosition);$/;"	p	namespace:dev	signature:(std::string const& _input, size_t& _invalidPosition)
dev::validateUTF8	libdevcore/UTF8.h	/^inline bool validateUTF8(std::string const& _input)$/;"	f	namespace:dev	signature:(std::string const& _input)
dev::vector_ref	libdevcore/vector_ref.h	/^class vector_ref$/;"	c	namespace:dev
dev::vector_ref::begin	libdevcore/vector_ref.h	/^	_T const* begin() const { return m_data; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::begin	libdevcore/vector_ref.h	/^	_T* begin() { return m_data; }$/;"	f	class:dev::vector_ref	access:public	signature:()
dev::vector_ref::cropped	libdevcore/vector_ref.h	/^	vector_ref<_T> cropped(size_t _begin) const { if (m_data && _begin <= m_count) return vector_ref<_T>(m_data + _begin, m_count - _begin); else return vector_ref<_T>(); }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _begin) const
dev::vector_ref::cropped	libdevcore/vector_ref.h	/^	vector_ref<_T> cropped(size_t _begin, size_t _count) const { if (m_data && _begin <= m_count && _count <= m_count && _begin + _count <= m_count) return vector_ref<_T>(m_data + _begin, _count == ~size_t(0) ? m_count - _begin : _count); else return vector_ref<_T>(); }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _begin, size_t _count) const
dev::vector_ref::data	libdevcore/vector_ref.h	/^	_T* data() const { return m_data; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::empty	libdevcore/vector_ref.h	/^	bool empty() const { return !m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::end	libdevcore/vector_ref.h	/^	_T const* end() const { return m_data + m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::end	libdevcore/vector_ref.h	/^	_T* end() { return m_data + m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:()
dev::vector_ref::m_count	libdevcore/vector_ref.h	/^	size_t m_count = 0;$/;"	m	class:dev::vector_ref	access:private
dev::vector_ref::m_data	libdevcore/vector_ref.h	/^	_T* m_data = nullptr;$/;"	m	class:dev::vector_ref	access:private
dev::vector_ref::operator !=	libdevcore/vector_ref.h	/^	bool operator!=(vector_ref<_T> const& _cmp) const { return !operator==(_cmp); }$/;"	f	class:dev::vector_ref	access:public	signature:(vector_ref<_T> const& _cmp) const
dev::vector_ref::operator ==	libdevcore/vector_ref.h	/^	bool operator==(vector_ref<_T> const& _cmp) const { return m_data == _cmp.m_data && m_count == _cmp.m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:(vector_ref<_T> const& _cmp) const
dev::vector_ref::operator []	libdevcore/vector_ref.h	/^	_T const& operator[](size_t _i) const { assert(m_data); assert(_i < m_count); return m_data[_i]; }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _i) const
dev::vector_ref::operator []	libdevcore/vector_ref.h	/^	_T& operator[](size_t _i) { assert(m_data); assert(_i < m_count); return m_data[_i]; }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _i)
dev::vector_ref::operator bool	libdevcore/vector_ref.h	/^	explicit operator bool() const { return m_data && m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::operator vector_ref<_T const>	libdevcore/vector_ref.h	/^	operator vector_ref<_T const>() const { return vector_ref<_T const>(m_data, m_count); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::operator vector_ref<_T2>	libdevcore/vector_ref.h	/^	template <class _T2> explicit operator vector_ref<_T2>() const { assert(m_count * sizeof(_T) \/ sizeof(_T2) * sizeof(_T2) \/ sizeof(_T) == m_count); return vector_ref<_T2>(reinterpret_cast<_T2*>(m_data), m_count * sizeof(_T) \/ sizeof(_T2)); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::reset	libdevcore/vector_ref.h	/^	void reset() { m_data = nullptr; m_count = 0; }$/;"	f	class:dev::vector_ref	access:public	signature:()
dev::vector_ref::size	libdevcore/vector_ref.h	/^	size_t size() const { return m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::toBytes	libdevcore/vector_ref.h	/^	std::vector<unsigned char> toBytes() const { return std::vector<unsigned char>(reinterpret_cast<unsigned char const*>(m_data), reinterpret_cast<unsigned char const*>(m_data) + m_count * sizeof(_T)); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::toString	libdevcore/vector_ref.h	/^	std::string toString() const { return std::string((char const*)m_data, ((char const*)m_data) + m_count * sizeof(_T)); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
dev::vector_ref::vector_ref	libdevcore/vector_ref.h	/^	vector_ref(): m_data(nullptr), m_count(0) {}$/;"	f	class:dev::vector_ref	access:public	signature:()
dev::vector_ref::vector_ref	libdevcore/vector_ref.h	/^	vector_ref(_T* _data, size_t _count): m_data(_data), m_count(_count) {}$/;"	f	class:dev::vector_ref	access:public	signature:(_T* _data, size_t _count)
dev::vector_ref::vector_ref	libdevcore/vector_ref.h	/^	vector_ref(string_type& _data): vector_ref(&_data) {}$/;"	f	class:dev::vector_ref	access:public	signature:(string_type& _data)
dev::vector_ref::vector_ref	libdevcore/vector_ref.h	/^	vector_ref(string_type* _data): m_data(reinterpret_cast<_T*>(_data->data())), m_count(_data->size() \/ sizeof(_T)) {}$/;"	f	class:dev::vector_ref	access:public	signature:(string_type* _data)
dev::vector_ref::vector_ref	libdevcore/vector_ref.h	/^	vector_ref(vector_type* _data): m_data(_data->data()), m_count(_data->size()) {}$/;"	f	class:dev::vector_ref	access:public	signature:(vector_type* _data)
devDocumentation	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<Json::Value const> devDocumentation;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
devDocumentation	libsolidity/interface/Natspec.cpp	/^Json::Value Natspec::devDocumentation(ContractDefinition const& _contractDef)$/;"	f	class:Natspec	signature:(ContractDefinition const& _contractDef)
devDocumentation	libsolidity/interface/Natspec.cpp	/^Json::Value Natspec::devDocumentation(std::multimap<std::string, DocTag> const& _tags)$/;"	f	class:Natspec	signature:(std::multimap<std::string, DocTag> const& _tags)
devDocumentation	libsolidity/interface/Natspec.h	/^	static Json::Value devDocumentation(ContractDefinition const& _contractDef);$/;"	p	class:dev::solidity::Natspec	access:public	signature:(ContractDefinition const& _contractDef)
devDocumentation	libsolidity/interface/Natspec.h	/^	static Json::Value devDocumentation(std::multimap<std::string, DocTag> const& _tags);$/;"	p	class:dev::solidity::Natspec	access:private	signature:(std::multimap<std::string, DocTag> const& _tags)
diagColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::diagColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
diagColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized diagColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
disassemble	libevmasm/Instruction.cpp	/^string dev::solidity::disassemble(bytes const& _mem)$/;"	f	class:dev::solidity	signature:(bytes const& _mem)
disassemble	libevmasm/Instruction.h	/^std::string disassemble(bytes const& _mem);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(bytes const& _mem)
divWorkaround	libevmasm/RuleList.h	/^template <class S> S divWorkaround(S const& _a, S const& _b)$/;"	f	namespace:dev::solidity	signature:(S const& _a, S const& _b)
division	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::division(smt::Expression _left, smt::Expression _right, IntegerType const& _type)$/;"	f	class:SMTChecker	signature:(smt::Expression _left, smt::Expression _right, IntegerType const& _type)
division	libsolidity/formal/SMTChecker.h	/^	smt::Expression division(smt::Expression _left, smt::Expression _right, IntegerType const& _type);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression _left, smt::Expression _right, IntegerType const& _type)
docTags	libsolidity/ast/ASTAnnotations.h	/^	std::multimap<std::string, DocTag> docTags;$/;"	m	struct:dev::solidity::DocumentedAnnotation	access:public
docstringParsingError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::docstringParsingError(string const& _description)$/;"	f	class:ErrorReporter	signature:(string const& _description)
docstringParsingError	liblangutil/ErrorReporter.h	/^	void docstringParsingError(std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(std::string const& _description)
documentation	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> const& documentation() const { return m_documentation; }$/;"	f	class:dev::solidity::Documented	access:public	signature:() const
documentation	libsolidity/ast/Types.cpp	/^ASTPointer<ASTString> FunctionType::documentation() const$/;"	f	class:FunctionType	signature:() const
documentation	libsolidity/ast/Types.h	/^	ASTPointer<ASTString> documentation() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
domain	libsolidity/formal/SolverInterface.h	/^	SortPointer domain;$/;"	m	struct:dev::solidity::smt::ArraySort	access:public
domain	libsolidity/formal/SolverInterface.h	/^	std::vector<SortPointer> domain;$/;"	m	struct:dev::solidity::smt::FunctionSort	access:public
dupInstruction	libevmasm/Instruction.h	/^inline Instruction dupInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
dynamicInplace	libsolidity/codegen/ABIFunctions.h	/^		bool dynamicInplace = false;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
eachInstruction	libevmasm/Instruction.cpp	/^void dev::solidity::eachInstruction($/;"	f	class:dev::solidity	signature:( bytes const& _mem, function<void(Instruction,u256 const&)> const& _onInstruction )
eachInstruction	libevmasm/Instruction.h	/^void eachInstruction(bytes const& _mem, std::function<void(Instruction,u256 const&)> const& _onInstruction);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(bytes const& _mem, std::function<void(Instruction,u256 const&)> const& _onInstruction)
efficient_assertions	solse/SymExecEngine.cpp	/^std::vector<z3::expr> efficient_assertions;$/;"	v
efficient_count	solse/SymExecEngine.cpp	/^unsigned efficient_count = 0;$/;"	v
eliminateVariables	libyul/optimiser/StackCompressor.cpp	/^void eliminateVariables(shared_ptr<Dialect> const& _dialect, ASTNode& _node, size_t _numVariables)$/;"	f	namespace:__anon6	signature:(shared_ptr<Dialect> const& _dialect, ASTNode& _node, size_t _numVariables)
empty	libdevcore/vector_ref.h	/^	bool empty() const { return !m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
empty	libsolidity/parsing/Parser.cpp	/^bool Parser::IndexAccessedPath::empty() const$/;"	f	class:dev::solidity::Parser::IndexAccessedPath	signature:() const
empty	libsolidity/parsing/Parser.h	/^		bool empty() const;$/;"	p	struct:dev::solidity::Parser::IndexAccessedPath	access:public	signature:() const
empty	libyul/YulString.h	/^	bool empty() const { return m_handle.id == 0; }$/;"	f	class:yul::YulString	access:public	signature:() const
emptyHash	libyul/YulString.h	/^	static constexpr std::uint64_t emptyHash() { return 14695981039346656037u; }$/;"	f	class:yul::YulStringRepository	access:public	signature:()
enabled	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings enabled()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
enclosingContainer	libsolidity/analysis/DeclarationContainer.h	/^	DeclarationContainer const* enclosingContainer() const { return m_enclosingContainer; }$/;"	f	class:dev::solidity::DeclarationContainer	access:public	signature:() const
enclosingNode	libsolidity/analysis/DeclarationContainer.h	/^	ASTNode const* enclosingNode() const { return m_enclosingNode; }$/;"	f	class:dev::solidity::DeclarationContainer	access:public	signature:() const
encodeAsLibraryTypes	libsolidity/codegen/ABIFunctions.h	/^		bool encodeAsLibraryTypes = false;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
encodeFunctionFromStack	libsolidity/codegen/ABIFunctions.h	/^		bool encodeFunctionFromStack = false;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
encodeToMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::encodeToMemory($/;"	f	class:dev::solidity::CompilerUtils	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _padToWordBoundaries, bool _copyDynamicDataInPlace, bool _encodeAsLibraryTypes )
encodeToMemory	libsolidity/codegen/CompilerUtils.h	/^	void encodeToMemory($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _padToWords, bool _copyDynamicDataInPlace, bool _encodeAsLibraryTypes = false )
encodingType	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::encodingType() const$/;"	f	class:ArrayType	signature:() const
encodingType	libsolidity/ast/Types.cpp	/^TypePointer FunctionType::encodingType() const$/;"	f	class:FunctionType	signature:() const
encodingType	libsolidity/ast/Types.h	/^	virtual TypePointer encodingType() const { return TypePointer(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
end	libdevcore/vector_ref.h	/^	_T const* end() const { return m_data + m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
end	libdevcore/vector_ref.h	/^	_T* end() { return m_data + m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:()
end	libevmasm/BlockDeduplicator.h	/^		AssemblyItems::const_iterator end;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
end	libevmasm/ControlFlowGraph.h	/^	unsigned end = 0;$/;"	m	struct:dev::eth::BasicBlock	access:public
end	liblangutil/SourceLocation.h	/^	int end = -1;$/;"	m	struct:langutil::SourceLocation	access:public
end	libsolidity/ast/Types.h	/^	MemberMap::const_iterator end() const { return m_memberTypes.end(); }$/;"	f	class:dev::solidity::MemberList	access:public	signature:() const
endColumn	liblangutil/SourceReferenceExtractor.h	/^	int endColumn = {-1};     \/\/\/< Highlighting range-end of text field.$/;"	m	struct:langutil::SourceReference	access:public
endPosition	liblangutil/ParserBase.cpp	/^int ParserBase::endPosition() const$/;"	f	class:ParserBase	signature:() const
endPosition	liblangutil/ParserBase.h	/^	int endPosition() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
endState	libevmasm/ControlFlowGraph.h	/^	KnownStatePointer endState;$/;"	m	struct:dev::eth::BasicBlock	access:public
endType	libevmasm/ControlFlowGraph.h	/^	EndType endType = EndType::HANDOVER;$/;"	m	struct:dev::eth::BasicBlock	access:public
endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(BinaryOperation const& _operation)$/;"	f	class:ConstantEvaluator	signature:(BinaryOperation const& _operation)
endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(Identifier const& _identifier)$/;"	f	class:ConstantEvaluator	signature:(Identifier const& _identifier)
endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(Literal const& _literal)$/;"	f	class:ConstantEvaluator	signature:(Literal const& _literal)
endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(TupleExpression const& _tuple)$/;"	f	class:ConstantEvaluator	signature:(TupleExpression const& _tuple)
endVisit	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::endVisit(UnaryOperation const& _operation)$/;"	f	class:ConstantEvaluator	signature:(UnaryOperation const& _operation)
endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(BinaryOperation const& _operation);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(BinaryOperation const& _operation)
endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(Identifier const& _identifier);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(Identifier const& _identifier)
endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(Literal const& _literal);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(Literal const& _literal)
endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(TupleExpression const& _tuple);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(TupleExpression const& _tuple)
endVisit	libsolidity/analysis/ConstantEvaluator.h	/^	virtual void endVisit(UnaryOperation const& _operation);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(UnaryOperation const& _operation)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(Block&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(Block&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(ContractDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ContractDefinition&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(EnumDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EnumDefinition&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(EventDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EventDefinition&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(ForStatement&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ForStatement&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(FunctionDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionDefinition&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(FunctionTypeName&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionTypeName&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(ModifierDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ModifierDefinition&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(SourceUnit& _sourceUnit)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(SourceUnit& _sourceUnit)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(StructDefinition&)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(StructDefinition&)
endVisit	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::endVisit(VariableDeclarationStatement& _variableDeclarationStatement)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(VariableDeclarationStatement& _variableDeclarationStatement)
endVisit	libsolidity/analysis/PostTypeChecker.cpp	/^void PostTypeChecker::endVisit(ContractDefinition const&)$/;"	f	class:PostTypeChecker	signature:(ContractDefinition const&)
endVisit	libsolidity/analysis/PostTypeChecker.cpp	/^void PostTypeChecker::endVisit(VariableDeclaration const& _variable)$/;"	f	class:PostTypeChecker	signature:(VariableDeclaration const& _variable)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(ArrayTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ArrayTypeName const& _typeName)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(Block const& _block)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Block const& _block)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(ForStatement const& _for)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ForStatement const& _for)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(FunctionDefinition const&)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(FunctionDefinition const&)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(FunctionTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(FunctionTypeName const& _typeName)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(Mapping const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Mapping const& _typeName)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(ModifierDefinition const&)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ModifierDefinition const&)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(UserDefinedTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(UserDefinedTypeName const& _typeName)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(VariableDeclaration const& _variable)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(VariableDeclaration const& _variable)
endVisit	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::endVisit(VariableDeclarationStatement const& _varDeclStatement)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(VariableDeclarationStatement const& _varDeclStatement)
endVisit	libsolidity/analysis/StaticAnalyzer.cpp	/^void StaticAnalyzer::endVisit(ContractDefinition const&)$/;"	f	class:StaticAnalyzer	signature:(ContractDefinition const&)
endVisit	libsolidity/analysis/StaticAnalyzer.cpp	/^void StaticAnalyzer::endVisit(FunctionDefinition const&)$/;"	f	class:StaticAnalyzer	signature:(FunctionDefinition const&)
endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(ForStatement const&)$/;"	f	class:SyntaxChecker	signature:(ForStatement const&)
endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(ModifierDefinition const& _modifier)$/;"	f	class:SyntaxChecker	signature:(ModifierDefinition const& _modifier)
endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(SourceUnit const& _sourceUnit)$/;"	f	class:SyntaxChecker	signature:(SourceUnit const& _sourceUnit)
endVisit	libsolidity/analysis/SyntaxChecker.cpp	/^void SyntaxChecker::endVisit(WhileStatement const&)$/;"	f	class:SyntaxChecker	signature:(WhileStatement const&)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(BinaryOperation const& _operation)$/;"	f	class:TypeChecker	signature:(BinaryOperation const& _operation)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(ElementaryTypeNameExpression const& _expr)$/;"	f	class:TypeChecker	signature:(ElementaryTypeNameExpression const& _expr)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(EmitStatement const& _emit)$/;"	f	class:TypeChecker	signature:(EmitStatement const& _emit)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(ExpressionStatement const& _statement)$/;"	f	class:TypeChecker	signature:(ExpressionStatement const& _statement)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(FunctionTypeName const& _funType)$/;"	f	class:TypeChecker	signature:(FunctionTypeName const& _funType)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(InheritanceSpecifier const& _inheritance)$/;"	f	class:TypeChecker	signature:(InheritanceSpecifier const& _inheritance)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(Literal const& _literal)$/;"	f	class:TypeChecker	signature:(Literal const& _literal)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(NewExpression const& _newExpression)$/;"	f	class:TypeChecker	signature:(NewExpression const& _newExpression)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(Return const& _return)$/;"	f	class:TypeChecker	signature:(Return const& _return)
endVisit	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::endVisit(UsingForDirective const& _usingFor)$/;"	f	class:TypeChecker	signature:(UsingForDirective const& _usingFor)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(FunctionCall const& _functionCall)$/;"	f	class:ViewPureChecker	signature:(FunctionCall const& _functionCall)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(FunctionDefinition const& _funDef)$/;"	f	class:ViewPureChecker	signature:(FunctionDefinition const& _funDef)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(Identifier const& _identifier)$/;"	f	class:ViewPureChecker	signature:(Identifier const& _identifier)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(IndexAccess const& _indexAccess)$/;"	f	class:ViewPureChecker	signature:(IndexAccess const& _indexAccess)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(InlineAssembly const& _inlineAssembly)$/;"	f	class:ViewPureChecker	signature:(InlineAssembly const& _inlineAssembly)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(MemberAccess const& _memberAccess)$/;"	f	class:ViewPureChecker	signature:(MemberAccess const& _memberAccess)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(ModifierDefinition const& _modifierDef)$/;"	f	class:ViewPureChecker	signature:(ModifierDefinition const& _modifierDef)
endVisit	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::endVisit(ModifierInvocation const& _modifier)$/;"	f	class:ViewPureChecker	signature:(ModifierInvocation const& _modifier)
endVisit	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::endVisit(EventDefinition const&)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EventDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ArrayTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ArrayTypeName const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Assignment const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Assignment const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(BinaryOperation const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(BinaryOperation const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Block const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Block const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Break const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Break const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Conditional const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Conditional const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Continue const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Continue const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ContractDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ContractDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ElementaryTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeName const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ElementaryTypeNameExpression const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeNameExpression const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EmitStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EmitStatement const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EnumDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EnumValue const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumValue const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(EventDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EventDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ExpressionStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ExpressionStatement const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ForStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ForStatement const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(FunctionCall const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionCall const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(FunctionDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(FunctionTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionTypeName const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Identifier const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Identifier const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(IfStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IfStatement const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ImportDirective const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ImportDirective const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(IndexAccess const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IndexAccess const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(InheritanceSpecifier const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InheritanceSpecifier const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(InlineAssembly const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InlineAssembly const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Literal const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Literal const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Mapping const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Mapping const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(MemberAccess const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(MemberAccess const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ModifierDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ModifierInvocation const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierInvocation const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(NewExpression const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(NewExpression const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(ParameterList const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ParameterList const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(PlaceholderStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PlaceholderStatement const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(PragmaDirective const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PragmaDirective const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Return const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Return const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(StructDefinition const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(StructDefinition const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(Throw const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Throw const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(TupleExpression const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(TupleExpression const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(UnaryOperation const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UnaryOperation const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(UserDefinedTypeName const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UserDefinedTypeName const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(UsingForDirective const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UsingForDirective const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(VariableDeclaration const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclaration const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(VariableDeclarationStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclarationStatement const&)
endVisit	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::endVisit(WhileStatement const&)$/;"	f	class:dev::solidity::ASTPrinter	signature:(WhileStatement const&)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ArrayTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ArrayTypeName const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ArrayTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ArrayTypeName& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Assignment const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Assignment const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Assignment& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Assignment& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(BinaryOperation const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(BinaryOperation const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(BinaryOperation& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(BinaryOperation& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Block const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Block const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Block& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Block& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Break const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Break const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Break& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Break& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Conditional const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Conditional const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Conditional& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Conditional& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Continue const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Continue const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Continue& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Continue& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ContractDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ContractDefinition const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ContractDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ContractDefinition& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeName const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeName& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeNameExpression const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeNameExpression const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ElementaryTypeNameExpression& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeNameExpression& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EmitStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EmitStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EmitStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EmitStatement& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumDefinition const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumDefinition& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumValue const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumValue const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EnumValue& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumValue& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EventDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EventDefinition const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(EventDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EventDefinition& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ExpressionStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ExpressionStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ExpressionStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ExpressionStatement& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ForStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ForStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ForStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ForStatement& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionCall const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionCall const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionCall& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionCall& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionDefinition const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionDefinition& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionTypeName const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(FunctionTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionTypeName& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Identifier const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Identifier const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Identifier& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Identifier& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IfStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IfStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IfStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IfStatement& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ImportDirective const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ImportDirective const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ImportDirective& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ImportDirective& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IndexAccess const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IndexAccess const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(IndexAccess& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IndexAccess& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InheritanceSpecifier const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InheritanceSpecifier const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InheritanceSpecifier& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InheritanceSpecifier& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InlineAssembly const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InlineAssembly const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(InlineAssembly& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InlineAssembly& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Literal const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Literal const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Literal& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Literal& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Mapping const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Mapping const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Mapping& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Mapping& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(MemberAccess const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(MemberAccess const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(MemberAccess& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(MemberAccess& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierDefinition const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierDefinition& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierInvocation const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierInvocation const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ModifierInvocation& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierInvocation& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(NewExpression const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(NewExpression const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(NewExpression& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(NewExpression& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ParameterList const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ParameterList const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(ParameterList& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ParameterList& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PlaceholderStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PlaceholderStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PlaceholderStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PlaceholderStatement& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PragmaDirective const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PragmaDirective const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(PragmaDirective& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PragmaDirective& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Return const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Return const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Return& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Return& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(SourceUnit const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(SourceUnit const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(SourceUnit& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(SourceUnit& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(StructDefinition const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(StructDefinition const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(StructDefinition& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(StructDefinition& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Throw const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Throw const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(Throw& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Throw& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(TupleExpression const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(TupleExpression const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(TupleExpression& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(TupleExpression& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UnaryOperation const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UnaryOperation const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UnaryOperation& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UnaryOperation& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UserDefinedTypeName const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UserDefinedTypeName const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UserDefinedTypeName& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UserDefinedTypeName& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UsingForDirective const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UsingForDirective const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(UsingForDirective& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UsingForDirective& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclaration const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclaration const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclaration& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclaration& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclarationStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclarationStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(VariableDeclarationStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclarationStatement& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(WhileStatement const& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(WhileStatement const& _node)
endVisit	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisit(WhileStatement& _node) { endVisitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(WhileStatement& _node)
endVisit	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::endVisit(Block const& _block)$/;"	f	class:ContractCompiler	signature:(Block const& _block)
endVisit	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::endVisit(Identifier const& _identifier)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Identifier const& _identifier)
endVisit	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::endVisit(Literal const& _literal)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Literal const& _literal)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Assignment const& _assignment)$/;"	f	class:SMTChecker	signature:(Assignment const& _assignment)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(BinaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(BinaryOperation const& _op)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(ContractDefinition const&)$/;"	f	class:SMTChecker	signature:(ContractDefinition const&)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(FunctionDefinition const&)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const&)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Identifier const& _identifier)$/;"	f	class:SMTChecker	signature:(Identifier const& _identifier)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(IndexAccess const& _indexAccess)$/;"	f	class:SMTChecker	signature:(IndexAccess const& _indexAccess)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Literal const& _literal)$/;"	f	class:SMTChecker	signature:(Literal const& _literal)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(Return const& _return)$/;"	f	class:SMTChecker	signature:(Return const& _return)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(TupleExpression const& _tuple)$/;"	f	class:SMTChecker	signature:(TupleExpression const& _tuple)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(UnaryOperation const& _op)$/;"	f	class:SMTChecker	signature:(UnaryOperation const& _op)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(VariableDeclaration const& _varDecl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _varDecl)
endVisit	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::endVisit(VariableDeclarationStatement const& _varDecl)$/;"	f	class:SMTChecker	signature:(VariableDeclarationStatement const& _varDecl)
endVisit	solse/SymExecEngine.cpp	/^endVisit(StructDefinition const&) {$/;"	f	class:SymExecEngine	signature:(StructDefinition const&)
endVisit	solse/SymExecEngine.cpp	/^endVisit(dev::solidity::FunctionDefinition const&){$/;"	f	class:SymExecEngine	signature:(dev::solidity::FunctionDefinition const&)
endVisit	solse/SymExecEngine.cpp	/^void SymExecEngine::endVisit(ContractDefinition const& _node){$/;"	f	class:SymExecEngine	signature:(ContractDefinition const& _node)
endVisitNode	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisitNode(ASTNode const&) { }$/;"	f	class:dev::solidity::ASTConstVisitor	access:protected	signature:(ASTNode const&)
endVisitNode	libsolidity/ast/ASTVisitor.h	/^	virtual void endVisitNode(ASTNode&) { }$/;"	f	class:dev::solidity::ASTVisitor	access:protected	signature:(ASTNode&)
end_time	solse/SymExecEngine.cpp	/^uint64_t end_time;$/;"	v
enterFunction	libyul/optimiser/ASTCopier.h	/^	virtual void enterFunction(FunctionDefinition const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(FunctionDefinition const&)
enterFunction	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::enterFunction(FunctionDefinition const& _function)$/;"	f	class:Disambiguator	signature:(FunctionDefinition const& _function)
enterNewSubScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::enterNewSubScope(ASTNode& _subScope)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ASTNode& _subScope)
enterNewSubScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void enterNewSubScope(ASTNode& _subScope);$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:(ASTNode& _subScope)
enterScope	libyul/optimiser/ASTCopier.h	/^	virtual void enterScope(Block const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(Block const&)
enterScope	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::enterScope(Block const& _block)$/;"	f	class:Disambiguator	signature:(Block const& _block)
enterScopeInternal	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::enterScopeInternal(Scope& _scope)$/;"	f	class:Disambiguator	signature:(Scope& _scope)
enterScopeInternal	libyul/optimiser/Disambiguator.h	/^	void enterScopeInternal(Scope& _scope);$/;"	p	class:yul::Disambiguator	access:protected	signature:(Scope& _scope)
entries	libsolidity/analysis/ControlFlowGraph.h	/^	std::vector<CFGNode*> entries;$/;"	m	struct:dev::solidity::CFGNode	access:public
entry	libsolidity/analysis/ControlFlowGraph.h	/^	CFGNode* entry = nullptr;$/;"	m	struct:dev::solidity::FunctionFlow	access:public
entryLabel	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::FunctionCompilationQueue::entryLabel($/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:( Declaration const& _declaration, CompilerContext& _context )
entryLabel	libsolidity/codegen/CompilerContext.h	/^		eth::AssemblyItem entryLabel(Declaration const& _declaration, CompilerContext& _context);$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:(Declaration const& _declaration, CompilerContext& _context)
entryLabelIfExists	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::FunctionCompilationQueue::entryLabelIfExists(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:(Declaration const& _declaration) const
entryLabelIfExists	libsolidity/codegen/CompilerContext.h	/^		eth::AssemblyItem entryLabelIfExists(Declaration const& _declaration) const;$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:(Declaration const& _declaration) const
enumDefinition	libsolidity/ast/Types.h	/^	EnumDefinition const& enumDefinition() const { return m_enum; }$/;"	f	class:dev::solidity::EnumType	access:public	signature:() const
equalExcludingStateMutability	libsolidity/ast/Types.cpp	/^bool FunctionType::equalExcludingStateMutability(FunctionType const& _other) const$/;"	f	class:FunctionType	signature:(FunctionType const& _other) const
equalExcludingStateMutability	libsolidity/ast/Types.h	/^	bool equalExcludingStateMutability(FunctionType const& _other) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionType const& _other) const
eraseArrayKnowledge	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::eraseArrayKnowledge()$/;"	f	class:SMTChecker	signature:()
eraseArrayKnowledge	libsolidity/formal/SMTChecker.h	/^	void eraseArrayKnowledge();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
error	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::error(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
error	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::error(Error::Type _type, SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, string const& _description)
error	liblangutil/ErrorReporter.h	/^	void error($/;"	p	class:langutil::ErrorReporter	access:private	signature:( Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, std::string const& _description = std::string())
error	liblangutil/ErrorReporter.h	/^	void error($/;"	p	class:langutil::ErrorReporter	access:public	signature:( Error::Type _type, SourceLocation const& _location, std::string const& _description )
error	liblangutil/Scanner.h	/^		ScannerError error = ScannerError::NoError;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
errorColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::errorColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
errorColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized errorColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
errors	liblangutil/ErrorReporter.cpp	/^ErrorList const& ErrorReporter::errors() const$/;"	f	class:ErrorReporter	signature:() const
errors	liblangutil/ErrorReporter.h	/^	ErrorList const& errors() const;$/;"	p	class:langutil::ErrorReporter	access:public	signature:() const
errors	libsolidity/interface/CompilerStack.h	/^	langutil::ErrorList const& errors() const { return m_errorReporter.errors(); }$/;"	f	class:dev::solidity::CompilerStack::langutil	access:public	signature:() const
errors	libyul/AssemblyStack.h	/^	langutil::ErrorList const& errors() const { return m_errors; }$/;"	f	class:yul::AssemblyStack::langutil	access:public	signature:() const
escapeIdentifier	libsolidity/ast/Types.cpp	/^string Type::escapeIdentifier(string const& _identifier)$/;"	f	class:Type	signature:(string const& _identifier)
escapeIdentifier	libsolidity/ast/Types.h	/^	static std::string escapeIdentifier(std::string const& _identifier);$/;"	p	class:dev::solidity::Type	access:public	signature:(std::string const& _identifier)
estimateMax	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::estimateMax(AssemblyItem const& _item, bool _includeExternalCosts)$/;"	f	class:GasMeter	signature:(AssemblyItem const& _item, bool _includeExternalCosts)
estimateMax	libevmasm/GasMeter.h	/^	GasConsumption estimateMax(AssemblyItem const& _item, bool _includeExternalCosts = true);$/;"	p	class:dev::eth::GasMeter	access:public	signature:(AssemblyItem const& _item, bool _includeExternalCosts = true)
estimateMax	libevmasm/PathGasMeter.cpp	/^GasMeter::GasConsumption PathGasMeter::estimateMax($/;"	f	class:PathGasMeter	signature:( size_t _startIndex, shared_ptr<KnownState> const& _state )
estimateMax	libevmasm/PathGasMeter.h	/^	GasMeter::GasConsumption estimateMax(size_t _startIndex, std::shared_ptr<KnownState> const& _state);$/;"	p	class:dev::eth::PathGasMeter	access:public	signature:(size_t _startIndex, std::shared_ptr<KnownState> const& _state)
estimateMax	libevmasm/PathGasMeter.h	/^	static GasMeter::GasConsumption estimateMax($/;"	f	class:dev::eth::PathGasMeter	access:public	signature:( AssemblyItems const& _items, langutil::EVMVersion _evmVersion, size_t _startIndex, std::shared_ptr<KnownState> const& _state )
eth	libevmasm/Assembly.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/AssemblyItem.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/BlockDeduplicator.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/CommonSubexpressionEliminator.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/ConstantOptimiser.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/ControlFlowGraph.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/Exceptions.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/ExpressionClasses.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/GasMeter.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/JumpdestRemover.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/KnownState.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/LinkerObject.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/PathGasMeter.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/PeepholeOptimiser.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/SemanticInformation.h	/^namespace eth$/;"	n	namespace:dev
eth	libevmasm/SimplificationRules.h	/^namespace eth$/;"	n	namespace:dev
eth	libsolidity/codegen/ExpressionCompiler.h	/^namespace eth$/;"	n	namespace:dev
eth	libsolidity/interface/CompilerStack.h	/^namespace eth$/;"	n	namespace:dev
eth	libyul/backends/evm/AsmCodeGen.h	/^namespace eth$/;"	n	namespace:dev
eth::CompilerStack::assemblyItems	libsolidity/interface/CompilerStack.cpp	/^eth::AssemblyItems const* CompilerStack::assemblyItems(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
eth::CompilerStack::object	libsolidity/interface/CompilerStack.cpp	/^eth::LinkerObject const& CompilerStack::object(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
eth::CompilerStack::runtimeAssemblyItems	libsolidity/interface/CompilerStack.cpp	/^eth::AssemblyItems const* CompilerStack::runtimeAssemblyItems(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
eth::CompilerStack::runtimeObject	libsolidity/interface/CompilerStack.cpp	/^eth::LinkerObject const& CompilerStack::runtimeObject(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
evaluate	libsolidity/analysis/ConstantEvaluator.cpp	/^TypePointer ConstantEvaluator::evaluate(Expression const& _expr)$/;"	f	class:ConstantEvaluator	signature:(Expression const& _expr)
evaluate	libsolidity/analysis/ConstantEvaluator.h	/^	TypePointer evaluate(Expression const& _expr);$/;"	p	class:dev::solidity::ConstantEvaluator	access:public	signature:(Expression const& _expr)
eventCall	libsolidity/ast/AST.h	/^	FunctionCall const& eventCall() const { return *m_eventCall; }$/;"	f	class:dev::solidity::EmitStatement	access:public	signature:() const
events	libsolidity/ast/AST.h	/^	std::vector<EventDefinition const*> events() const { return filteredNodes<EventDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
evmVersion	libevmasm/Assembly.h	/^		langutil::EVMVersion evmVersion;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
evmVersion	libevmasm/ConstantOptimiser.h	/^		langutil::EVMVersion evmVersion; \/\/\/< Version of the EVM$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
evmVersion	libsolidity/codegen/CompilerContext.h	/^	langutil::EVMVersion const& evmVersion() const { return m_evmVersion; }$/;"	f	class:dev::solidity::CompilerContext::langutil	access:public	signature:() const
evmVersion	libyul/backends/evm/EVMDialect.h	/^	langutil::EVMVersion evmVersion() const { return m_evmVersion; }$/;"	f	struct:yul::EVMDialect	access:public	signature:() const
execute	libevmasm/ConstantOptimiser.cpp	/^AssemblyItems CodeCopyMethod::execute(Assembly& _assembly) const$/;"	f	class:CodeCopyMethod	signature:(Assembly& _assembly) const
execute	libevmasm/ConstantOptimiser.h	/^	virtual AssemblyItems execute(Assembly& _assembly) const = 0;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(Assembly& _assembly) const
exists	libyul/AsmScope.cpp	/^bool Scope::exists(YulString _name) const$/;"	f	class:Scope	signature:(YulString _name) const
exists	libyul/AsmScope.h	/^	bool exists(YulString _name) const;$/;"	p	struct:yul::Scope	access:public	signature:(YulString _name) const
exit	libsolidity/analysis/ControlFlowGraph.h	/^	CFGNode* exit = nullptr;$/;"	m	struct:dev::solidity::FunctionFlow	access:public
exits	libsolidity/analysis/ControlFlowGraph.h	/^	std::vector<CFGNode*> exits;$/;"	m	struct:dev::solidity::CFGNode	access:public
expByteGas	libevmasm/GasMeter.h	/^	inline unsigned expByteGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
expGas	libevmasm/GasMeter.h	/^	static unsigned const expGas = 10;$/;"	m	namespace:dev::eth::GasCosts
expectAsmIdentifier	libyul/AsmParser.cpp	/^YulString Parser::expectAsmIdentifier()$/;"	f	class:Parser	signature:()
expectAsmIdentifier	libyul/AsmParser.h	/^	YulString expectAsmIdentifier();$/;"	p	class:yul::Parser	access:protected	signature:()
expectDeposit	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::expectDeposit(int _deposit, int _oldHeight, SourceLocation const& _location)$/;"	f	class:AsmAnalyzer	signature:(int _deposit, int _oldHeight, SourceLocation const& _location)
expectDeposit	libyul/AsmAnalysis.h	/^	bool expectDeposit(int _deposit, int _oldHeight, langutil::SourceLocation const& _location);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(int _deposit, int _oldHeight, langutil::SourceLocation const& _location)
expectDeposit	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::expectDeposit(int _deposit, int _oldHeight) const$/;"	f	class:CodeTransform	signature:(int _deposit, int _oldHeight) const
expectDeposit	libyul/backends/evm/EVMCodeTransform.h	/^	void expectDeposit(int _deposit, int _oldHeight) const;$/;"	p	class:yul::CodeTransform	access:private	signature:(int _deposit, int _oldHeight) const
expectExpression	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::expectExpression(Expression const& _expr)$/;"	f	class:AsmAnalyzer	signature:(Expression const& _expr)
expectExpression	libyul/AsmAnalysis.h	/^	bool expectExpression(Expression const& _expr);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(Expression const& _expr)
expectIdentifierToken	libsolidity/parsing/Parser.cpp	/^ASTPointer<ASTString> Parser::expectIdentifierToken()$/;"	f	class:dev::solidity::Parser	signature:()
expectIdentifierToken	libsolidity/parsing/Parser.h	/^	ASTPointer<ASTString> expectIdentifierToken();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
expectToken	liblangutil/ParserBase.cpp	/^void ParserBase::expectToken(Token _value, bool _advance)$/;"	f	class:ParserBase	signature:(Token _value, bool _advance)
expectToken	liblangutil/ParserBase.h	/^	void expectToken(Token _value, bool _advance = true);$/;"	p	class:langutil::ParserBase	access:protected	signature:(Token _value, bool _advance = true)
expectType	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::expectType(Expression const& _expression, Type const& _expectedType)$/;"	f	class:TypeChecker	signature:(Expression const& _expression, Type const& _expectedType)
expectType	libsolidity/analysis/TypeChecker.h	/^	bool expectType(Expression const& _expression, Type const& _expectedType);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Expression const& _expression, Type const& _expectedType)
expectValidType	libyul/AsmAnalysis.cpp	/^void AsmAnalyzer::expectValidType(string const& type, SourceLocation const& _location)$/;"	f	class:AsmAnalyzer	signature:(string const& type, SourceLocation const& _location)
expectValidType	libyul/AsmAnalysis.h	/^	void expectValidType(std::string const& type, langutil::SourceLocation const& _location);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(std::string const& type, langutil::SourceLocation const& _location)
expectedExecutionsPerDeployment	libevmasm/Assembly.h	/^		size_t expectedExecutionsPerDeployment = 200;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
expectedExecutionsPerDeployment	libsolidity/interface/OptimiserSettings.h	/^	size_t expectedExecutionsPerDeployment = 200;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
experimentalFeatureActive	libsolidity/codegen/CompilerContext.h	/^	bool experimentalFeatureActive(ExperimentalFeature _feature) const { return m_experimentalFeatures.count(_feature); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(ExperimentalFeature _feature) const
experimentalFeatures	libsolidity/ast/ASTAnnotations.h	/^	std::set<ExperimentalFeature> experimentalFeatures;$/;"	m	struct:dev::solidity::SourceUnitAnnotation	access:public
exportedSymbols	libsolidity/ast/ASTAnnotations.h	/^	std::map<ASTString, std::vector<Declaration const*>> exportedSymbols;$/;"	m	struct:dev::solidity::SourceUnitAnnotation	access:public
expr	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::expr(Expression const& _e)$/;"	f	class:SMTChecker	signature:(Expression const& _e)
expr	libsolidity/formal/SMTChecker.h	/^	smt::Expression expr(Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e)
expression	libsolidity/ast/AST.h	/^	Expression const& expression() const { return *m_expression; }$/;"	f	class:dev::solidity::ExpressionStatement	access:public	signature:() const
expression	libsolidity/ast/AST.h	/^	Expression const& expression() const { return *m_expression; }$/;"	f	class:dev::solidity::FunctionCall	access:public	signature:() const
expression	libsolidity/ast/AST.h	/^	Expression const& expression() const { return *m_expression; }$/;"	f	class:dev::solidity::MemberAccess	access:public	signature:() const
expression	libsolidity/ast/AST.h	/^	Expression const* expression() const { return m_expression.get(); }$/;"	f	class:dev::solidity::Return	access:public	signature:() const
expression	libyul/AsmData.h	/^struct ExpressionStatement { langutil::SourceLocation location; Expression expression; };$/;"	m	struct:yul::ExpressionStatement	access:public
expression	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	m	struct:yul::Switch	access:public
expressionAlwaysFalse	libyul/optimiser/StructuralSimplifier.cpp	/^bool StructuralSimplifier::expressionAlwaysFalse(Expression const& _expression)$/;"	f	class:StructuralSimplifier	signature:(Expression const& _expression)
expressionAlwaysFalse	libyul/optimiser/StructuralSimplifier.h	/^	bool expressionAlwaysFalse(Expression const& _expression);$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(Expression const& _expression)
expressionAlwaysTrue	libyul/optimiser/StructuralSimplifier.cpp	/^bool StructuralSimplifier::expressionAlwaysTrue(Expression const& _expression)$/;"	f	class:StructuralSimplifier	signature:(Expression const& _expression)
expressionAlwaysTrue	libyul/optimiser/StructuralSimplifier.h	/^	bool expressionAlwaysTrue(Expression const& _expression);$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(Expression const& _expression)
expressionClasses	libevmasm/KnownState.h	/^	ExpressionClasses& expressionClasses() const { return *m_expressionClasses; }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(FunctionCall const& _lhs, FunctionCall const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(FunctionCall const& _lhs, FunctionCall const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(Identifier const& _lhs, Identifier const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Identifier const& _lhs, Identifier const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::expressionEqual(Literal const& _lhs, Literal const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Literal const& _lhs, Literal const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(FunctionCall const& _lhs, FunctionCall const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(FunctionCall const& _lhs, FunctionCall const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(Identifier const& _lhs, Identifier const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Identifier const& _lhs, Identifier const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(Literal const& _lhs, Literal const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Literal const& _lhs, Literal const& _rhs)
expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)$/;"	f	class:yul::SyntacticallyEqual	access:private	signature:(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)
expressionFromIndexAccessStructure	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::expressionFromIndexAccessStructure($/;"	f	class:dev::solidity::Parser	signature:( Parser::IndexAccessedPath const& _iap )
expressionFromIndexAccessStructure	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> expressionFromIndexAccessStructure(IndexAccessedPath const& _pathAndIndices);$/;"	p	class:dev::solidity::Parser	access:private	signature:(IndexAccessedPath const& _pathAndIndices)
extCodeGas	libevmasm/GasMeter.h	/^	inline unsigned extCodeGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
extendedTokenInfo	liblangutil/Scanner.h	/^		std::tuple<unsigned, unsigned> extendedTokenInfo;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
externalIdentifier	libsolidity/ast/Types.cpp	/^u256 FunctionType::externalIdentifier() const$/;"	f	class:FunctionType	signature:() const
externalIdentifier	libsolidity/ast/Types.h	/^	u256 externalIdentifier() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
externalReferences	libsolidity/ast/ASTAnnotations.h	/^	std::map<yul::Identifier const*, ExternalIdentifierInfo> externalReferences;$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation	access:public
externalSignature	libsolidity/ast/AST.cpp	/^string FunctionDefinition::externalSignature() const$/;"	f	class:FunctionDefinition	signature:() const
externalSignature	libsolidity/ast/AST.h	/^	std::string externalSignature() const;$/;"	p	class:dev::solidity::FunctionDefinition	access:public	signature:() const
externalSignature	libsolidity/ast/Types.cpp	/^string FunctionType::externalSignature() const$/;"	f	class:FunctionType	signature:() const
externalSignature	libsolidity/ast/Types.h	/^	std::string externalSignature() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
extract	liblangutil/SourceReferenceExtractor.cpp	/^SourceReference SourceReferenceExtractor::extract(SourceLocation const* _location, std::string message)$/;"	f	class:SourceReferenceExtractor	signature:(SourceLocation const* _location, std::string message)
extract	liblangutil/SourceReferenceExtractor.cpp	/^SourceReferenceExtractor::Message SourceReferenceExtractor::extract(Exception const& _exception, string _category)$/;"	f	class:SourceReferenceExtractor	signature:(Exception const& _exception, string _category)
extract	liblangutil/SourceReferenceExtractor.h	/^	Message extract(dev::Exception const& _exception, std::string _category);$/;"	p	namespace:langutil::SourceReferenceExtractor	signature:(dev::Exception const& _exception, std::string _category)
extract	liblangutil/SourceReferenceExtractor.h	/^	SourceReference extract(SourceLocation const* _location, std::string message = "");$/;"	p	namespace:langutil::SourceReferenceExtractor	signature:(SourceLocation const* _location, std::string message = )
extractDoc	libsolidity/interface/Natspec.cpp	/^string Natspec::extractDoc(multimap<string, DocTag> const& _tags, string const& _name)$/;"	f	class:Natspec	signature:(multimap<string, DocTag> const& _tags, string const& _name)
extractDoc	libsolidity/interface/Natspec.h	/^	static std::string extractDoc(std::multimap<std::string, DocTag> const& _tags, std::string const& _name);$/;"	p	class:dev::solidity::Natspec	access:private	signature:(std::multimap<std::string, DocTag> const& _tags, std::string const& _name)
fallbackFunction	libsolidity/ast/AST.cpp	/^FunctionDefinition const* ContractDefinition::fallbackFunction() const$/;"	f	class:ContractDefinition	signature:() const
fallbackFunction	libsolidity/ast/AST.h	/^	FunctionDefinition const* fallbackFunction() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
falseExpression	libsolidity/ast/AST.h	/^	Expression const& falseExpression() const { return *m_falseExpression; }$/;"	f	class:dev::solidity::Conditional	access:public	signature:() const
falseStatement	libsolidity/ast/AST.h	/^	Statement const* falseStatement() const { return m_falseBody.get(); }$/;"	f	class:dev::solidity::IfStatement	access:public	signature:() const
fatalDeclarationError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalDeclarationError(SourceLocation const& _location, std::string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, std::string const& _description)
fatalDeclarationError	liblangutil/ErrorReporter.h	/^	void fatalDeclarationError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
fatalDeclarationError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::fatalDeclarationError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
fatalDeclarationError	libsolidity/analysis/ReferencesResolver.h	/^	void fatalDeclarationError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
fatalError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalError(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
fatalError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalError(Error::Type _type, SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(Error::Type _type, SourceLocation const& _location, string const& _description)
fatalError	liblangutil/ErrorReporter.h	/^	void fatalError($/;"	p	class:langutil::ErrorReporter	access:private	signature:( Error::Type _type, SourceLocation const& _location = SourceLocation(), std::string const& _description = std::string())
fatalError	liblangutil/ErrorReporter.h	/^	void fatalError($/;"	p	class:langutil::ErrorReporter	access:private	signature:( Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, std::string const& _description = std::string())
fatalParserError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalParserError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
fatalParserError	liblangutil/ErrorReporter.h	/^	void fatalParserError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
fatalParserError	liblangutil/ParserBase.cpp	/^void ParserBase::fatalParserError(string const& _description)$/;"	f	class:ParserBase	signature:(string const& _description)
fatalParserError	liblangutil/ParserBase.h	/^	void fatalParserError(std::string const& _description);$/;"	p	class:langutil::ParserBase	access:protected	signature:(std::string const& _description)
fatalTypeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalTypeError(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
fatalTypeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::fatalTypeError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
fatalTypeError	liblangutil/ErrorReporter.h	/^	void fatalTypeError(SourceLocation const& _location, SecondarySourceLocation const& _secondLocation, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondLocation, std::string const& _description)
fatalTypeError	liblangutil/ErrorReporter.h	/^	void fatalTypeError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
fatalTypeError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::fatalTypeError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
fatalTypeError	libsolidity/analysis/ReferencesResolver.h	/^	void fatalTypeError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
feed	libevmasm/Assembly.cpp	/^	void feed(AssemblyItem const& _item)$/;"	f	class:__anon18::Functionalizer	access:public	signature:(AssemblyItem const& _item)
feedItem	libevmasm/CommonSubexpressionEliminator.cpp	/^void CommonSubexpressionEliminator::feedItem(AssemblyItem const& _item, bool _copyItem)$/;"	f	class:CommonSubexpressionEliminator	signature:(AssemblyItem const& _item, bool _copyItem)
feedItem	libevmasm/CommonSubexpressionEliminator.h	/^	void feedItem(AssemblyItem const& _item, bool _copyItem = false);$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:private	signature:(AssemblyItem const& _item, bool _copyItem = false)
feedItem	libevmasm/KnownState.cpp	/^KnownState::StoreOperation KnownState::feedItem(AssemblyItem const& _item, bool _copyItem)$/;"	f	class:KnownState	signature:(AssemblyItem const& _item, bool _copyItem)
feedItem	libevmasm/KnownState.h	/^	StoreOperation feedItem(AssemblyItem const& _item, bool _copyItem = false);$/;"	p	class:dev::eth::KnownState	access:public	signature:(AssemblyItem const& _item, bool _copyItem = false)
feedItems	libevmasm/CommonSubexpressionEliminator.h	/^	_AssemblyItemIterator feedItems(_AssemblyItemIterator _iterator, _AssemblyItemIterator _end, bool _msizeImportant);$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:public	signature:(_AssemblyItemIterator _iterator, _AssemblyItemIterator _end, bool _msizeImportant)
feedItems	libevmasm/CommonSubexpressionEliminator.h	/^_AssemblyItemIterator CommonSubexpressionEliminator::feedItems($/;"	f	class:dev::eth::CommonSubexpressionEliminator	signature:( _AssemblyItemIterator _iterator, _AssemblyItemIterator _end, bool _msizeImportant )
fetchFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::fetchFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
fetchFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void fetchFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
fieldNames	solse/SymExecEngine.h	/^    std::vector<std::string> fieldNames;$/;"	m	class:StructInfo	access:public
fieldSorts	solse/SymExecEngine.h	/^    std::vector<z3::sort> fieldSorts;$/;"	m	class:StructInfo	access:public
fileno	solse/CommandLineInterface.cpp	61;"	d	file:
filesystemFriendlyName	libsolidity/interface/CompilerStack.cpp	/^std::string const CompilerStack::filesystemFriendlyName(string const& _contractName) const$/;"	f	class:std::CompilerStack	signature:(string const& _contractName) const
filesystemFriendlyName	libsolidity/interface/CompilerStack.h	/^	std::string const filesystemFriendlyName(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
filteredNodes	libsolidity/ast/AST.h	/^	static std::vector<_T const*> filteredNodes(std::vector<ASTPointer<ASTNode>> const& _nodes);$/;"	p	class:dev::solidity::ASTNode	access:public	signature:(std::vector<ASTPointer<ASTNode>> const& _nodes)
filteredNodes	libsolidity/ast/AST.h	/^std::vector<_T const*> ASTNode::filteredNodes(std::vector<ASTPointer<ASTNode>> const& _nodes)$/;"	f	class:dev::solidity::ASTNode	signature:(std::vector<ASTPointer<ASTNode>> const& _nodes)
finalize	libyul/backends/evm/EVMAssembly.cpp	/^eth::LinkerObject EVMAssembly::finalize()$/;"	f	class:EVMAssembly	signature:()
finalize	libyul/backends/evm/EVMAssembly.h	/^	dev::eth::LinkerObject finalize();$/;"	p	class:yul::EVMAssembly	access:public	signature:()
finalize	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::finalize(YulString _variable)$/;"	f	class:RedundantAssignEliminator	signature:(YulString _variable)
finalize	libyul/optimiser/RedundantAssignEliminator.h	/^	void finalize(YulString _variable);$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:(YulString _variable)
finalizeBlock	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::finalizeBlock(Block const& _block, int blockStartStackHeight)$/;"	f	class:CodeTransform	signature:(Block const& _block, int blockStartStackHeight)
finalizeBlock	libyul/backends/evm/EVMCodeTransform.h	/^	void finalizeBlock(Block const& _block, int _blockStartStackHeight);$/;"	p	class:yul::CodeTransform	access:private	signature:(Block const& _block, int _blockStartStackHeight)
find	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::find($/;"	f	class:ExpressionClasses	signature:( AssemblyItem const& _item, Ids const& _arguments, bool _copyItem, unsigned _sequenceNumber )
find	libevmasm/ExpressionClasses.h	/^	Id find($/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:( AssemblyItem const& _item, Ids const& _arguments = {}, bool _copyItem = true, unsigned _sequenceNumber = 0 )
findAnyOf	libdevcore/CommonData.h	/^inline std::string findAnyOf(std::string const& _haystack, std::vector<std::string> const& _needles)$/;"	f	namespace:dev	signature:(std::string const& _haystack, std::vector<std::string> const& _needles)
findCleanName	libyul/optimiser/VarNameCleaner.cpp	/^YulString VarNameCleaner::findCleanName(YulString const& _name) const$/;"	f	class:VarNameCleaner	signature:(YulString const& _name) const
findCleanName	libyul/optimiser/VarNameCleaner.h	/^	YulString findCleanName(YulString const& name) const;$/;"	p	class:yul::VarNameCleaner	access:private	signature:(YulString const& name) const
findCycle	libsolidity/analysis/PostTypeChecker.cpp	/^VariableDeclaration const* PostTypeChecker::findCycle(VariableDeclaration const& _startingFrom)$/;"	f	class:PostTypeChecker	signature:(VariableDeclaration const& _startingFrom)
findCycle	libsolidity/analysis/PostTypeChecker.h	/^	VariableDeclaration const* findCycle(VariableDeclaration const& _startingFrom);$/;"	p	class:dev::solidity::PostTypeChecker	access:private	signature:(VariableDeclaration const& _startingFrom)
findDuplicateDefinitions	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::findDuplicateDefinitions(map<string, vector<T>> const& _definitions, string _message)$/;"	f	class:ContractLevelChecker	signature:(map<string, vector<T>> const& _definitions, string _message)
findDuplicateDefinitions	libsolidity/analysis/ContractLevelChecker.h	/^	void findDuplicateDefinitions(std::map<std::string, std::vector<T>> const& _definitions, std::string _message);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(std::map<std::string, std::vector<T>> const& _definitions, std::string _message)
findFirstMatch	libevmasm/SimplificationRules.cpp	/^SimplificationRule<Pattern> const* Rules::findFirstMatch($/;"	f	class:Rules	signature:( Expression const& _expr, ExpressionClasses const& _classes )
findFirstMatch	libevmasm/SimplificationRules.h	/^	SimplificationRule<Pattern> const* findFirstMatch($/;"	p	class:dev::eth::Rules	access:public	signature:( Expression const& _expr, ExpressionClasses const& _classes )
findFirstMatch	libyul/optimiser/SimplificationRules.cpp	/^SimplificationRule<Pattern> const* SimplificationRules::findFirstMatch($/;"	f	class:SimplificationRules	signature:( Expression const& _expr, Dialect const& _dialect, map<YulString, Expression const*> const& _ssaValues )
findFirstMatch	libyul/optimiser/SimplificationRules.h	/^	static SimplificationRule<Pattern> const* findFirstMatch($/;"	p	class:yul::SimplificationRules	access:public	signature:( Expression const& _expr, Dialect const& _dialect, std::map<YulString, Expression const*> const& _ssaValues )
findLargestTag	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::findLargestTag()$/;"	f	class:ControlFlowGraph	signature:()
findLargestTag	libevmasm/ControlFlowGraph.h	/^	void findLargestTag();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
findRepresentation	libevmasm/ConstantOptimiser.cpp	/^AssemblyItems ComputeMethod::findRepresentation(u256 const& _value)$/;"	f	class:ComputeMethod	signature:(u256 const& _value)
findRepresentation	libevmasm/ConstantOptimiser.h	/^	AssemblyItems findRepresentation(u256 const& _value);$/;"	p	class:dev::eth::ComputeMethod	access:protected	signature:(u256 const& _value)
finestNodesAtLocation	libsolidity/interface/GasEstimator.cpp	/^set<ASTNode const*> GasEstimator::finestNodesAtLocation($/;"	f	class:GasEstimator	signature:( vector<ASTNode const*> const& _roots )
finestNodesAtLocation	libsolidity/interface/GasEstimator.h	/^	static std::set<ASTNode const*> finestNodesAtLocation(std::vector<ASTNode const*> const& _roots);$/;"	p	struct:dev::solidity::GasEstimator	access:private	signature:(std::vector<ASTNode const*> const& _roots)
firstBitSet	libdevcore/FixedHash.h	/^	inline unsigned firstBitSet() const$/;"	f	class:dev::FixedHash	access:public	signature:() const
firstNumber	liblangutil/Token.h	/^	unsigned int firstNumber() const { return m_firstNumber; }$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:() const
firstSpaceOrTab	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator firstSpaceOrTab($/;"	f	namespace:__anon14	signature:( string::const_iterator _pos, string::const_iterator _end )
firstWhitespaceOrNewline	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator firstWhitespaceOrNewline($/;"	f	namespace:__anon14	signature:( string::const_iterator _pos, string::const_iterator _end )
fitsIntegerType	libsolidity/ast/Types.cpp	/^bool fitsIntegerType(bigint const& _value, IntegerType const& _type)$/;"	f	namespace:__anon7	signature:(bigint const& _value, IntegerType const& _type)
fitsIntoBits	libsolidity/ast/Types.cpp	/^bool fitsIntoBits(bigint const& _value, unsigned _bits, bool _signed)$/;"	f	namespace:__anon7	signature:(bigint const& _value, unsigned _bits, bool _signed)
fitsPrecisionBase10	libsolidity/ast/Types.cpp	/^bool fitsPrecisionBase10(bigint const& _mantissa, uint32_t _expBase10)$/;"	f	namespace:__anon7	signature:(bigint const& _mantissa, uint32_t _expBase10)
fitsPrecisionBase2	libsolidity/ast/Types.cpp	/^bool fitsPrecisionBase2(bigint const& _mantissa, uint32_t _expBase2)$/;"	f	namespace:__anon7	signature:(bigint const& _mantissa, uint32_t _expBase2)
fitsPrecisionBaseX	libsolidity/ast/Types.cpp	/^bool fitsPrecisionBaseX($/;"	f	namespace:__anon7	signature:( bigint const& _mantissa, double _log2OfBase, uint32_t _exp )
fitsPrecisionExp	libsolidity/ast/Types.cpp	/^bool fitsPrecisionExp(bigint const& _base, bigint const& _exp)$/;"	f	namespace:__anon7	signature:(bigint const& _base, bigint const& _exp)
fixedPointType	libsolidity/ast/Types.cpp	/^shared_ptr<FixedPointType const> RationalNumberType::fixedPointType() const$/;"	f	class:RationalNumberType	signature:() const
fixedPointType	libsolidity/ast/Types.h	/^	std::shared_ptr<FixedPointType const> fixedPointType() const;$/;"	p	class:dev::solidity::RationalNumberType	access:public	signature:() const
flavour	libyul/Dialect.h	/^	AsmFlavour const flavour = AsmFlavour::Loose;$/;"	m	struct:yul::Dialect	access:public
flush	libevmasm/Assembly.cpp	/^	void flush()$/;"	f	class:__anon18::Functionalizer	access:public	signature:()
foldP	libdevcore/Keccak256.cpp	139;"	d	file:
forLiteral	libsolidity/ast/Types.cpp	/^TypePointer RationalNumberType::forLiteral(Literal const& _literal)$/;"	f	class:RationalNumberType	signature:(Literal const& _literal)
forLiteral	libsolidity/ast/Types.cpp	/^TypePointer Type::forLiteral(Literal const& _literal)$/;"	f	class:Type	signature:(Literal const& _literal)
forLiteral	libsolidity/ast/Types.h	/^	static TypePointer forLiteral(Literal const& _literal);$/;"	p	class:dev::solidity::RationalNumberType	access:public	signature:(Literal const& _literal)
forLiteral	libsolidity/ast/Types.h	/^	static TypePointer forLiteral(Literal const& _literal);$/;"	p	class:dev::solidity::Type	access:public	signature:(Literal const& _literal)
forceEqual	libevmasm/ExpressionClasses.cpp	/^void ExpressionClasses::forceEqual($/;"	f	class:ExpressionClasses	signature:( ExpressionClasses::Id _id, AssemblyItem const& _item, ExpressionClasses::Ids const& _arguments, bool _copyItem )
forceEqual	libevmasm/ExpressionClasses.h	/^	void forceEqual(Id _id, AssemblyItem const& _item, Ids const& _arguments, bool _copyItem = true);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _id, AssemblyItem const& _item, Ids const& _arguments, bool _copyItem = true)
format	libdevcore/IndentedWriter.cpp	/^string IndentedWriter::format() const$/;"	f	class:IndentedWriter	signature:() const
format	libdevcore/IndentedWriter.h	/^	std::string format() const;$/;"	p	class:dev::IndentedWriter	access:public	signature:() const
formatError	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatError($/;"	f	namespace:__anon17	signature:( bool _warning, string const& _type, string const& _component, string const& _message, string const& _formattedMessage = , Json::Value const& _sourceLocation = Json::Value() )
formatErrorWithException	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatErrorWithException($/;"	f	namespace:__anon17	signature:( Exception const& _exception, bool const& _warning, string const& _type, string const& _component, string const& _message )
formatExceptionInformation	liblangutil/SourceReferenceFormatter.h	/^	static std::string formatExceptionInformation($/;"	f	class:langutil::SourceReferenceFormatter	access:public	signature:( dev::Exception const& _exception, std::string const& _name )
formatExceptionInformation	liblangutil/SourceReferenceFormatterHuman.h	/^	static std::string formatExceptionInformation($/;"	f	class:langutil::SourceReferenceFormatterHuman	access:public	signature:( dev::Exception const& _exception, std::string const& _name, bool colored = false )
formatFatalError	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatFatalError(string const& _type, string const& _message)$/;"	f	namespace:__anon17	signature:(string const& _type, string const& _message)
formatLinkReferences	libsolidity/interface/StandardCompiler.cpp	/^Json::Value formatLinkReferences(std::map<size_t, std::string> const& linkReferences)$/;"	f	namespace:__anon17	signature:(std::map<size_t, std::string> const& linkReferences)
formatNumber	libdevcore/CommonData.h	/^inline std::string formatNumber(bigint const& _value)$/;"	f	namespace:dev	signature:(bigint const& _value)
formatNumber	libdevcore/CommonData.h	/^inline std::string formatNumber(u256 const& _value)$/;"	f	namespace:dev	signature:(u256 const& _value)
formatNumberReadable	libdevcore/StringUtils.h	/^inline std::string formatNumberReadable($/;"	f	namespace:dev	signature:( T const& _value, bool _useTruncation = false )
formatType	libsolidity/interface/ABI.cpp	/^Json::Value ABI::formatType(string const& _name, Type const& _type, bool _forLibrary)$/;"	f	class:ABI	signature:(string const& _name, Type const& _type, bool _forLibrary)
formatType	libsolidity/interface/ABI.h	/^	static Json::Value formatType(std::string const& _name, Type const& _type, bool _forLibrary);$/;"	p	class:dev::solidity::ABI	access:private	signature:(std::string const& _name, Type const& _type, bool _forLibrary)
formatTypeList	libsolidity/interface/ABI.cpp	/^Json::Value ABI::formatTypeList($/;"	f	class:ABI	signature:( vector<string> const& _names, vector<TypePointer> const& _types, bool _forLibrary )
formatTypeList	libsolidity/interface/ABI.h	/^	static Json::Value formatTypeList($/;"	p	class:dev::solidity::ABI	access:private	signature:( std::vector<std::string> const& _names, std::vector<TypePointer> const& _types, bool _forLibrary )
formatTypedName	libyul/AsmPrinter.cpp	/^string AsmPrinter::formatTypedName(TypedName _variable) const$/;"	f	class:AsmPrinter	signature:(TypedName _variable) const
formatTypedName	libyul/AsmPrinter.h	/^	std::string formatTypedName(TypedName _variable) const;$/;"	p	class:yul::AsmPrinter	access:private	signature:(TypedName _variable) const
formatting	libdevcore/AnsiColorized.h	/^namespace formatting$/;"	n	namespace:dev
fractionalDigits	libsolidity/ast/Types.h	/^	unsigned fractionalDigits() const { return m_fractionalDigits; }$/;"	f	class:dev::solidity::FixedPointType	access:public	signature:() const
frameColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::frameColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
frameColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized frameColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
freeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^size_t const CompilerUtils::freeMemoryPointer = 64;$/;"	m	class:dev::solidity::CompilerUtils	file:
freeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	static size_t const freeMemoryPointer;$/;"	m	class:dev::solidity::CompilerUtils	access:public
freeUnusedVariables	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::freeUnusedVariables()$/;"	f	class:CodeTransform	signature:()
freeUnusedVariables	libyul/backends/evm/EVMCodeTransform.h	/^	void freeUnusedVariables();$/;"	p	class:yul::CodeTransform	access:protected	signature:()
friendlyName	liblangutil/Token.cpp	/^std::string friendlyName(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
friendlyName	liblangutil/Token.h	/^	std::string friendlyName(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
fromBigEndian	libdevcore/CommonData.h	/^inline T fromBigEndian(_In const& _bytes)$/;"	f	namespace:dev	signature:(_In const& _bytes)
fromElementaryTypeName	libsolidity/ast/Types.cpp	/^TypePointer Type::fromElementaryTypeName(ElementaryTypeNameToken const& _type)$/;"	f	class:Type	signature:(ElementaryTypeNameToken const& _type)
fromElementaryTypeName	libsolidity/ast/Types.cpp	/^TypePointer Type::fromElementaryTypeName(string const& _name)$/;"	f	class:Type	signature:(string const& _name)
fromElementaryTypeName	libsolidity/ast/Types.h	/^	static TypePointer fromElementaryTypeName(ElementaryTypeNameToken const& _type);$/;"	p	class:dev::solidity::Type	access:public	signature:(ElementaryTypeNameToken const& _type)
fromElementaryTypeName	libsolidity/ast/Types.h	/^	static TypePointer fromElementaryTypeName(std::string const& _name);$/;"	p	class:dev::solidity::Type	access:public	signature:(std::string const& _name)
fromHex	libdevcore/CommonData.cpp	/^bytes dev::fromHex(std::string const& _s, WhenError _throw)$/;"	f	class:dev	signature:(std::string const& _s, WhenError _throw)
fromHex	libdevcore/CommonData.cpp	/^int dev::fromHex(char _i, WhenError _throw)$/;"	f	class:dev	signature:(char _i, WhenError _throw)
fromHex	libdevcore/CommonData.h	/^bytes fromHex(std::string const& _s, WhenError _throw = WhenError::DontThrow);$/;"	p	namespace:dev	signature:(std::string const& _s, WhenError _throw = WhenError::DontThrow)
fromHex	libdevcore/CommonData.h	/^int fromHex(char _i, WhenError _throw);$/;"	p	namespace:dev	signature:(char _i, WhenError _throw)
fromIdentifierOrKeyword	liblangutil/Token.cpp	/^tuple<Token, unsigned int, unsigned int> fromIdentifierOrKeyword(string const& _literal)$/;"	f	namespace:langutil::TokenTraits	signature:(string const& _literal)
fromIdentifierOrKeyword	liblangutil/Token.h	/^	std::tuple<Token, unsigned int, unsigned int> fromIdentifierOrKeyword(std::string const& _literal);$/;"	p	namespace:langutil::TokenTraits	signature:(std::string const& _literal)
fromString	liblangutil/EVMVersion.h	/^	static boost::optional<EVMVersion> fromString(std::string const& _version)$/;"	f	class:langutil::EVMVersion	access:public	signature:(std::string const& _version)
full	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings full()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
fullDAGToString	libevmasm/ExpressionClasses.cpp	/^string ExpressionClasses::fullDAGToString(ExpressionClasses::Id _id) const$/;"	f	class:ExpressionClasses	signature:(ExpressionClasses::Id _id) const
fullDAGToString	libevmasm/ExpressionClasses.h	/^	std::string fullDAGToString(Id _id) const;$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _id) const
fullEncodingType	libsolidity/ast/Types.cpp	/^TypePointer Type::fullEncodingType(bool _inLibraryCall, bool _encoderV2, bool) const$/;"	f	class:Type	signature:(bool _inLibraryCall, bool _encoderV2, bool) const
fullEncodingType	libsolidity/ast/Types.h	/^	TypePointer fullEncodingType(bool _inLibraryCall, bool _encoderV2, bool _packed) const;$/;"	p	class:dev::solidity::Type	access:public	signature:(bool _inLibraryCall, bool _encoderV2, bool _packed) const
fullyQualifiedName	libsolidity/ast/AST.h	/^	std::string fullyQualifiedName() const { return sourceUnitName() + ":" + name(); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
funcCallDepthMap	solse/SolidityExprTranslator.h	/^    std::unordered_map<std::string, int> funcCallDepthMap;$/;"	m	class:ContextInfo	access:public
funcScope	solse/SolidityExprTranslator.h	/^    dev::solidity::FunctionDefinition const* funcScope = nullptr;$/;"	m	class:ContextInfo::dev::solidity	access:public
funcVec	solse/SymExecEngine.h	/^    std::vector<dev::solidity::FunctionDefinition const*> funcVec;$/;"	m	class:SymExecEngine	access:private
function	libyul/optimiser/FullInliner.h	/^	FunctionDefinition* function(YulString _name)$/;"	f	class:yul::FullInliner	access:public	signature:(YulString _name)
functionAppTest	solse/main.cpp	/^void functionAppTest();$/;"	p	file:	signature:()
functionAppTest	solse/main.cpp	/^void functionAppTest(){$/;"	f	signature:()
functionCallKind	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::functionCallKind(FunctionCallKind _kind)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionCallKind _kind)
functionCallKind	libsolidity/ast/ASTJsonConverter.h	/^	static std::string functionCallKind(FunctionCallKind _kind);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(FunctionCallKind _kind)
functionEntryID	libyul/backends/evm/EVMCodeTransform.cpp	/^AbstractAssembly::LabelID CodeTransform::functionEntryID(YulString _name, Scope::Function const& _function)$/;"	f	class:CodeTransform	signature:(YulString _name, Scope::Function const& _function)
functionEntryID	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly::LabelID functionEntryID(YulString _name, Scope::Function const& _function);$/;"	p	class:yul::CodeTransform	access:private	signature:(YulString _name, Scope::Function const& _function)
functionEntryIDs	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Function const*, AbstractAssembly::LabelID> functionEntryIDs;$/;"	m	struct:yul::CodeTransformContext	access:public
functionEntryLabel	libsolidity/codegen/Compiler.cpp	/^eth::AssemblyItem Compiler::functionEntryLabel(FunctionDefinition const& _function) const$/;"	f	class:Compiler	signature:(FunctionDefinition const& _function) const
functionEntryLabel	libsolidity/codegen/Compiler.h	/^	eth::AssemblyItem functionEntryLabel(FunctionDefinition const& _function) const;$/;"	p	class:dev::solidity::Compiler	access:public	signature:(FunctionDefinition const& _function) const
functionEntryLabel	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::functionEntryLabel(Declaration const& _declaration)$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration)
functionEntryLabel	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem functionEntryLabel(Declaration const& _declaration);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration)
functionEntryLabelIfExists	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::functionEntryLabelIfExists(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration) const
functionEntryLabelIfExists	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem functionEntryLabelIfExists(Declaration const& _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration) const
functionEntryPoint	libsolidity/interface/CompilerStack.cpp	/^size_t CompilerStack::functionEntryPoint($/;"	f	class:CompilerStack	signature:( std::string const& _contractName, FunctionDefinition const& _function ) const
functionEntryPoint	libsolidity/interface/CompilerStack.h	/^	size_t functionEntryPoint($/;"	p	class:dev::solidity::CompilerStack	access:private	signature:( std::string const& _contractName, FunctionDefinition const& _function ) const
functionFlow	libsolidity/analysis/ControlFlowGraph.cpp	/^FunctionFlow const& CFG::functionFlow(FunctionDefinition const& _function) const$/;"	f	class:CFG	signature:(FunctionDefinition const& _function) const
functionFlow	libsolidity/analysis/ControlFlowGraph.h	/^	FunctionFlow const& functionFlow(FunctionDefinition const& _function) const;$/;"	p	class:dev::solidity::CFG	access:public	signature:(FunctionDefinition const& _function) const
functionModifiers	libsolidity/ast/AST.h	/^	std::vector<ModifierDefinition const*> functionModifiers() const { return filteredNodes<ModifierDefinition>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
functionName	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionCall	access:public
functionName	libyul/backends/evm/EVMCodeTransform.h	/^	YulString functionName;$/;"	m	struct:yul::StackTooDeepError	access:public
functionReturnParameters	libsolidity/ast/ASTAnnotations.h	/^	ParameterList const* functionReturnParameters = nullptr;$/;"	m	struct:dev::solidity::ReturnAnnotation	access:public
functionScope	libyul/AsmScope.h	/^	bool functionScope = false;$/;"	m	struct:yul::Scope	access:public
functionType	libsolidity/ast/AST.cpp	/^FunctionTypePointer EventDefinition::functionType(bool _internal) const$/;"	f	class:EventDefinition	signature:(bool _internal) const
functionType	libsolidity/ast/AST.cpp	/^FunctionTypePointer FunctionDefinition::functionType(bool _internal) const$/;"	f	class:FunctionDefinition	signature:(bool _internal) const
functionType	libsolidity/ast/AST.cpp	/^FunctionTypePointer VariableDeclaration::functionType(bool _internal) const$/;"	f	class:VariableDeclaration	signature:(bool _internal) const
functionType	libsolidity/ast/AST.h	/^	virtual FunctionTypePointer functionType(bool \/*_internal*\/) const { return {}; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:(bool ) const
functionalEstimation	libsolidity/interface/GasEstimator.cpp	/^GasEstimator::GasConsumption GasEstimator::functionalEstimation($/;"	f	class:GasEstimator	signature:( AssemblyItems const& _items, size_t const& _offset, FunctionDefinition const& _function ) const
functionalEstimation	libsolidity/interface/GasEstimator.cpp	/^GasEstimator::GasConsumption GasEstimator::functionalEstimation($/;"	f	class:GasEstimator	signature:( AssemblyItems const& _items, string const& _signature ) const
functionalEstimation	libsolidity/interface/GasEstimator.h	/^	GasConsumption functionalEstimation($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( eth::AssemblyItems const& _items, size_t const& _offset, FunctionDefinition const& _function ) const
functionalEstimation	libsolidity/interface/GasEstimator.h	/^	GasConsumption functionalEstimation($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( eth::AssemblyItems const& _items, std::string const& _signature =  ) const
g_argAbi	solse/CommandLineInterface.cpp	/^static string const g_argAbi = g_strAbi;$/;"	m	namespace:dev::solidity	file:
g_argAllowPaths	solse/CommandLineInterface.cpp	/^static string const g_argAllowPaths = g_strAllowPaths;$/;"	m	namespace:dev::solidity	file:
g_argAsm	solse/CommandLineInterface.cpp	/^static string const g_argAsm = g_strAsm;$/;"	m	namespace:dev::solidity	file:
g_argAsmJson	solse/CommandLineInterface.cpp	/^static string const g_argAsmJson = g_strAsmJson;$/;"	m	namespace:dev::solidity	file:
g_argAssemble	solse/CommandLineInterface.cpp	/^static string const g_argAssemble = g_strAssemble;$/;"	m	namespace:dev::solidity	file:
g_argAst	solse/CommandLineInterface.cpp	/^static string const g_argAst = g_strAst;$/;"	m	namespace:dev::solidity	file:
g_argAstCompactJson	solse/CommandLineInterface.cpp	/^static string const g_argAstCompactJson = g_strAstCompactJson;$/;"	m	namespace:dev::solidity	file:
g_argAstJson	solse/CommandLineInterface.cpp	/^static string const g_argAstJson = g_strAstJson;$/;"	m	namespace:dev::solidity	file:
g_argBinary	solse/CommandLineInterface.cpp	/^static string const g_argBinary = g_strBinary;$/;"	m	namespace:dev::solidity	file:
g_argBinaryRuntime	solse/CommandLineInterface.cpp	/^static string const g_argBinaryRuntime = g_strBinaryRuntime;$/;"	m	namespace:dev::solidity	file:
g_argColor	solse/CommandLineInterface.cpp	/^static string const g_argColor = g_strColor;$/;"	m	namespace:dev::solidity	file:
g_argCombinedJson	solse/CommandLineInterface.cpp	/^static string const g_argCombinedJson = g_strCombinedJson;$/;"	m	namespace:dev::solidity	file:
g_argCompactJSON	solse/CommandLineInterface.cpp	/^static string const g_argCompactJSON = g_strCompactJSON;$/;"	m	namespace:dev::solidity	file:
g_argGas	solse/CommandLineInterface.cpp	/^static string const g_argGas = g_strGas;$/;"	m	namespace:dev::solidity	file:
g_argHelp	solse/CommandLineInterface.cpp	/^static string const g_argHelp = g_strHelp;$/;"	m	namespace:dev::solidity	file:
g_argIgnoreMissingFiles	solse/CommandLineInterface.cpp	/^static string const g_argIgnoreMissingFiles = g_strIgnoreMissingFiles;$/;"	m	namespace:dev::solidity	file:
g_argInputFile	solse/CommandLineInterface.cpp	/^static string const g_argInputFile = g_strInputFile;$/;"	m	namespace:dev::solidity	file:
g_argLibraries	solse/CommandLineInterface.cpp	/^static string const g_argLibraries = g_strLibraries;$/;"	m	namespace:dev::solidity	file:
g_argLink	solse/CommandLineInterface.cpp	/^static string const g_argLink = g_strLink;$/;"	m	namespace:dev::solidity	file:
g_argMachine	solse/CommandLineInterface.cpp	/^static string const g_argMachine = g_strMachine;$/;"	m	namespace:dev::solidity	file:
g_argMetadata	solse/CommandLineInterface.cpp	/^static string const g_argMetadata = g_strMetadata;$/;"	m	namespace:dev::solidity	file:
g_argMetadataLiteral	solse/CommandLineInterface.cpp	/^static string const g_argMetadataLiteral = g_strMetadataLiteral;$/;"	m	namespace:dev::solidity	file:
g_argNatspecDev	solse/CommandLineInterface.cpp	/^static string const g_argNatspecDev = g_strNatspecDev;$/;"	m	namespace:dev::solidity	file:
g_argNatspecUser	solse/CommandLineInterface.cpp	/^static string const g_argNatspecUser = g_strNatspecUser;$/;"	m	namespace:dev::solidity	file:
g_argNewReporter	solse/CommandLineInterface.cpp	/^static string const g_argNewReporter = g_strNewReporter;$/;"	m	namespace:dev::solidity	file:
g_argNoColor	solse/CommandLineInterface.cpp	/^static string const g_argNoColor = g_strNoColor;$/;"	m	namespace:dev::solidity	file:
g_argOpcodes	solse/CommandLineInterface.cpp	/^static string const g_argOpcodes = g_strOpcodes;$/;"	m	namespace:dev::solidity	file:
g_argOptimize	solse/CommandLineInterface.cpp	/^static string const g_argOptimize = g_strOptimize;$/;"	m	namespace:dev::solidity	file:
g_argOptimizeRuns	solse/CommandLineInterface.cpp	/^static string const g_argOptimizeRuns = g_strOptimizeRuns;$/;"	m	namespace:dev::solidity	file:
g_argOutputDir	solse/CommandLineInterface.cpp	/^static string const g_argOutputDir = g_strOutputDir;$/;"	m	namespace:dev::solidity	file:
g_argPrettyJson	solse/CommandLineInterface.cpp	/^static string const g_argPrettyJson = g_strPrettyJson;$/;"	m	namespace:dev::solidity	file:
g_argSignatureHashes	solse/CommandLineInterface.cpp	/^static string const g_argSignatureHashes = g_strSignatureHashes;$/;"	m	namespace:dev::solidity	file:
g_argStandardJSON	solse/CommandLineInterface.cpp	/^static string const g_argStandardJSON = g_strStandardJSON;$/;"	m	namespace:dev::solidity	file:
g_argStrictAssembly	solse/CommandLineInterface.cpp	/^static string const g_argStrictAssembly = g_strStrictAssembly;$/;"	m	namespace:dev::solidity	file:
g_argVersion	solse/CommandLineInterface.cpp	/^static string const g_argVersion = g_strVersion;$/;"	m	namespace:dev::solidity	file:
g_argYul	solse/CommandLineInterface.cpp	/^static string const g_argYul = g_strYul;$/;"	m	namespace:dev::solidity	file:
g_benefits	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_benefits;$/;"	v
g_collude_utilities	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_collude_utilities;$/;"	v
g_hasOutput	solse/CommandLineInterface.cpp	/^bool g_hasOutput = false;$/;"	m	namespace:dev::solidity	file:
g_mechanism	solse/SymExecEngine.cpp	/^Mechanism g_mechanism;$/;"	v
g_optional_benefits	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_optional_benefits;$/;"	v
g_optional_payments	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_optional_payments;$/;"	v
g_payments	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_payments;$/;"	v
g_revenues	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_revenues;$/;"	v
g_stdinFileName	solse/CommandLineInterface.cpp	/^static string const g_stdinFileName = g_stdinFileNameStr;$/;"	m	namespace:dev::solidity	file:
g_stdinFileNameStr	solse/CommandLineInterface.cpp	/^static string const g_stdinFileNameStr = "<stdin>";$/;"	m	namespace:dev::solidity	file:
g_strAbi	solse/CommandLineInterface.cpp	/^static string const g_strAbi = "abi";$/;"	m	namespace:dev::solidity	file:
g_strAllowPaths	solse/CommandLineInterface.cpp	/^static string const g_strAllowPaths = "allow-paths";$/;"	m	namespace:dev::solidity	file:
g_strAsm	solse/CommandLineInterface.cpp	/^static string const g_strAsm = "asm";$/;"	m	namespace:dev::solidity	file:
g_strAsmJson	solse/CommandLineInterface.cpp	/^static string const g_strAsmJson = "asm-json";$/;"	m	namespace:dev::solidity	file:
g_strAssemble	solse/CommandLineInterface.cpp	/^static string const g_strAssemble = "assemble";$/;"	m	namespace:dev::solidity	file:
g_strAst	solse/CommandLineInterface.cpp	/^static string const g_strAst = "ast";$/;"	m	namespace:dev::solidity	file:
g_strAstCompactJson	solse/CommandLineInterface.cpp	/^static string const g_strAstCompactJson = "ast-compact-json";$/;"	m	namespace:dev::solidity	file:
g_strAstJson	solse/CommandLineInterface.cpp	/^static string const g_strAstJson = "ast-json";$/;"	m	namespace:dev::solidity	file:
g_strBinary	solse/CommandLineInterface.cpp	/^static string const g_strBinary = "bin";$/;"	m	namespace:dev::solidity	file:
g_strBinaryRuntime	solse/CommandLineInterface.cpp	/^static string const g_strBinaryRuntime = "bin-runtime";$/;"	m	namespace:dev::solidity	file:
g_strColor	solse/CommandLineInterface.cpp	/^static string const g_strColor = "color";$/;"	m	namespace:dev::solidity	file:
g_strCombinedJson	solse/CommandLineInterface.cpp	/^static string const g_strCombinedJson = "combined-json";$/;"	m	namespace:dev::solidity	file:
g_strCompactJSON	solse/CommandLineInterface.cpp	/^static string const g_strCompactJSON = "compact-format";$/;"	m	namespace:dev::solidity	file:
g_strContracts	solse/CommandLineInterface.cpp	/^static string const g_strContracts = "contracts";$/;"	m	namespace:dev::solidity	file:
g_strEVM	solse/CommandLineInterface.cpp	/^static string const g_strEVM = "evm";$/;"	m	namespace:dev::solidity	file:
g_strEVM15	solse/CommandLineInterface.cpp	/^static string const g_strEVM15 = "evm15";$/;"	m	namespace:dev::solidity	file:
g_strEVMVersion	solse/CommandLineInterface.cpp	/^static string const g_strEVMVersion = "evm-version";$/;"	m	namespace:dev::solidity	file:
g_strGas	solse/CommandLineInterface.cpp	/^static string const g_strGas = "gas";$/;"	m	namespace:dev::solidity	file:
g_strHelp	solse/CommandLineInterface.cpp	/^static string const g_strHelp = "help";$/;"	m	namespace:dev::solidity	file:
g_strIgnoreMissingFiles	solse/CommandLineInterface.cpp	/^static string const g_strIgnoreMissingFiles = "ignore-missing";$/;"	m	namespace:dev::solidity	file:
g_strInputFile	solse/CommandLineInterface.cpp	/^static string const g_strInputFile = "input-file";$/;"	m	namespace:dev::solidity	file:
g_strInterface	solse/CommandLineInterface.cpp	/^static string const g_strInterface = "interface";$/;"	m	namespace:dev::solidity	file:
g_strLibraries	solse/CommandLineInterface.cpp	/^static string const g_strLibraries = "libraries";$/;"	m	namespace:dev::solidity	file:
g_strLicense	solse/CommandLineInterface.cpp	/^static string const g_strLicense = "license";$/;"	m	namespace:dev::solidity	file:
g_strLink	solse/CommandLineInterface.cpp	/^static string const g_strLink = "link";$/;"	m	namespace:dev::solidity	file:
g_strMachine	solse/CommandLineInterface.cpp	/^static string const g_strMachine = "machine";$/;"	m	namespace:dev::solidity	file:
g_strMetadata	solse/CommandLineInterface.cpp	/^static string const g_strMetadata = "metadata";$/;"	m	namespace:dev::solidity	file:
g_strMetadataLiteral	solse/CommandLineInterface.cpp	/^static string const g_strMetadataLiteral = "metadata-literal";$/;"	m	namespace:dev::solidity	file:
g_strNatspecDev	solse/CommandLineInterface.cpp	/^static string const g_strNatspecDev = "devdoc";$/;"	m	namespace:dev::solidity	file:
g_strNatspecUser	solse/CommandLineInterface.cpp	/^static string const g_strNatspecUser = "userdoc";$/;"	m	namespace:dev::solidity	file:
g_strNewReporter	solse/CommandLineInterface.cpp	/^static string const g_strNewReporter = "new-reporter";$/;"	m	namespace:dev::solidity	file:
g_strNoColor	solse/CommandLineInterface.cpp	/^static string const g_strNoColor = "no-color";$/;"	m	namespace:dev::solidity	file:
g_strOpcodes	solse/CommandLineInterface.cpp	/^static string const g_strOpcodes = "opcodes";$/;"	m	namespace:dev::solidity	file:
g_strOptimize	solse/CommandLineInterface.cpp	/^static string const g_strOptimize = "optimize";$/;"	m	namespace:dev::solidity	file:
g_strOptimizeRuns	solse/CommandLineInterface.cpp	/^static string const g_strOptimizeRuns = "optimize-runs";$/;"	m	namespace:dev::solidity	file:
g_strOutputDir	solse/CommandLineInterface.cpp	/^static string const g_strOutputDir = "output-dir";$/;"	m	namespace:dev::solidity	file:
g_strOverwrite	solse/CommandLineInterface.cpp	/^static string const g_strOverwrite = "overwrite";$/;"	m	namespace:dev::solidity	file:
g_strPrettyJson	solse/CommandLineInterface.cpp	/^static string const g_strPrettyJson = "pretty-json";$/;"	m	namespace:dev::solidity	file:
g_strSignatureHashes	solse/CommandLineInterface.cpp	/^static string const g_strSignatureHashes = "hashes";$/;"	m	namespace:dev::solidity	file:
g_strSourceList	solse/CommandLineInterface.cpp	/^static string const g_strSourceList = "sourceList";$/;"	m	namespace:dev::solidity	file:
g_strSources	solse/CommandLineInterface.cpp	/^static string const g_strSources = "sources";$/;"	m	namespace:dev::solidity	file:
g_strSrcMap	solse/CommandLineInterface.cpp	/^static string const g_strSrcMap = "srcmap";$/;"	m	namespace:dev::solidity	file:
g_strSrcMapRuntime	solse/CommandLineInterface.cpp	/^static string const g_strSrcMapRuntime = "srcmap-runtime";$/;"	m	namespace:dev::solidity	file:
g_strStandardJSON	solse/CommandLineInterface.cpp	/^static string const g_strStandardJSON = "standard-json";$/;"	m	namespace:dev::solidity	file:
g_strStrictAssembly	solse/CommandLineInterface.cpp	/^static string const g_strStrictAssembly = "strict-assembly";$/;"	m	namespace:dev::solidity	file:
g_strVersion	solse/CommandLineInterface.cpp	/^static string const g_strVersion = "version";$/;"	m	namespace:dev::solidity	file:
g_strYul	solse/CommandLineInterface.cpp	/^static string const g_strYul = "yul";$/;"	m	namespace:dev::solidity	file:
g_streWasm	solse/CommandLineInterface.cpp	/^static string const g_streWasm = "ewasm";$/;"	m	namespace:dev::solidity	file:
g_utilities	solse/SymExecEngine.cpp	/^std::vector<z3::expr> g_utilities;$/;"	v
gas	libevmasm/PathGasMeter.h	/^	GasMeter::GasConsumption gas;$/;"	m	struct:dev::eth::GasPath	access:public
gasEstimates	libsolidity/interface/CompilerStack.cpp	/^Json::Value CompilerStack::gasEstimates(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
gasEstimates	libsolidity/interface/CompilerStack.h	/^	Json::Value gasEstimates(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName) const
gasNeeded	libevmasm/ConstantOptimiser.cpp	/^bigint CodeCopyMethod::gasNeeded() const$/;"	f	class:CodeCopyMethod	signature:() const
gasNeeded	libevmasm/ConstantOptimiser.cpp	/^bigint ComputeMethod::gasNeeded(AssemblyItems const& _routine) const$/;"	f	class:ComputeMethod	signature:(AssemblyItems const& _routine) const
gasNeeded	libevmasm/ConstantOptimiser.cpp	/^bigint LiteralMethod::gasNeeded() const$/;"	f	class:LiteralMethod	signature:() const
gasNeeded	libevmasm/ConstantOptimiser.h	/^	bigint gasNeeded(AssemblyItems const& _routine) const;$/;"	p	class:dev::eth::ComputeMethod	access:protected	signature:(AssemblyItems const& _routine) const
gasNeeded	libevmasm/ConstantOptimiser.h	/^	virtual bigint gasNeeded() const = 0;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:() const
gasPriceTier	libevmasm/Instruction.h	/^	Tier gasPriceTier;	\/\/\/< Tier for gas pricing.$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
gasSet	libsolidity/ast/Types.h	/^	bool gasSet() const { return m_gasSet; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
gasToJson	libsolidity/interface/CompilerStack.cpp	/^Json::Value gasToJson(GasEstimator::GasConsumption const& _gas)$/;"	f	namespace:__anon16	signature:(GasEstimator::GasConsumption const& _gas)
gatherKnowledge	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::gatherKnowledge()$/;"	f	class:ControlFlowGraph	signature:()
gatherKnowledge	libevmasm/ControlFlowGraph.h	/^	void gatherKnowledge();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
generalPurposeMemoryStart	libsolidity/codegen/CompilerUtils.cpp	/^size_t const CompilerUtils::generalPurposeMemoryStart = CompilerUtils::zeroPointer + 32;$/;"	m	class:dev::solidity::CompilerUtils	file:
generalPurposeMemoryStart	libsolidity/codegen/CompilerUtils.h	/^	static size_t const generalPurposeMemoryStart;$/;"	m	class:dev::solidity::CompilerUtils	access:public
generate	libsolidity/interface/ABI.cpp	/^Json::Value ABI::generate(ContractDefinition const& _contractDef)$/;"	f	class:ABI	signature:(ContractDefinition const& _contractDef)
generate	libsolidity/interface/ABI.h	/^	static Json::Value generate(ContractDefinition const& _contractDef);$/;"	p	class:dev::solidity::ABI	access:public	signature:(ContractDefinition const& _contractDef)
generateAssignment	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::generateAssignment(Identifier const& _variableName)$/;"	f	class:CodeTransform	signature:(Identifier const& _variableName)
generateAssignment	libyul/backends/evm/EVMCodeTransform.h	/^	void generateAssignment(Identifier const& _variableName);$/;"	p	class:yul::CodeTransform	access:private	signature:(Identifier const& _variableName)
generateClassElement	libevmasm/CommonSubexpressionEliminator.cpp	/^void CSECodeGenerator::generateClassElement(Id _c, bool _allowSequenced)$/;"	f	class:CSECodeGenerator	signature:(Id _c, bool _allowSequenced)
generateClassElement	libevmasm/CommonSubexpressionEliminator.h	/^	void generateClassElement(Id _c, bool _allowSequenced = false);$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:(Id _c, bool _allowSequenced = false)
generateCode	libevmasm/CommonSubexpressionEliminator.cpp	/^AssemblyItems CSECodeGenerator::generateCode($/;"	f	class:CSECodeGenerator	signature:( unsigned _initialSequenceNumber, int _initialStackHeight, map<int, Id> const& _initialStack, map<int, Id> const& _targetStackContents )
generateCode	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItems generateCode($/;"	p	class:dev::eth::CSECodeGenerator	access:public	signature:( unsigned _initialSequenceNumber, int _initialStackHeight, std::map<int, Id> const& _initialStack, std::map<int, Id> const& _targetStackContents )
generateCode	libyul/backends/evm/EVMDialect.h	/^	std::function<void(FunctionCall const&, AbstractAssembly&, std::function<void()>)> generateCode;$/;"	m	struct:yul::BuiltinFunctionForEVM	access:public
generateMultiAssignment	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::generateMultiAssignment(vector<Identifier> const& _variableNames)$/;"	f	class:CodeTransform	signature:(vector<Identifier> const& _variableNames)
generateMultiAssignment	libyul/backends/evm/EVMCodeTransform.h	/^	void generateMultiAssignment(std::vector<Identifier> const& _variableNames);$/;"	p	class:yul::CodeTransform	access:private	signature:(std::vector<Identifier> const& _variableNames)
generateNewId	libevmasm/ControlFlowGraph.cpp	/^BlockId ControlFlowGraph::generateNewId()$/;"	f	class:ControlFlowGraph	signature:()
generateNewId	libevmasm/ControlFlowGraph.h	/^	BlockId generateNewId();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
get	libdevcore/Result.h	/^	ResultType const& get() const { return m_value; }$/;"	f	class:dev::Result	access:public	signature:() const
get	liblangutil/CharStream.h	/^	char get(size_t _charsForward = 0) const { return m_source[m_position + _charsForward]; }$/;"	f	class:langutil::CharStream	access:public	signature:(size_t _charsForward = 0) const
getArrayName	solse/SymExecEngine.cpp	/^getArrayName(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo)
getArrayName	solse/SymExecEngine.h	/^    std::string getArrayName(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo)
getChecksummedAddress	libdevcore/CommonData.cpp	/^string dev::getChecksummedAddress(string const& _addr)$/;"	f	class:dev	signature:(string const& _addr)
getChecksummedAddress	libdevcore/CommonData.h	/^std::string getChecksummedAddress(std::string const& _addr);$/;"	p	namespace:dev	signature:(std::string const& _addr)
getChecksummedAddress	libsolidity/ast/AST.cpp	/^string Literal::getChecksummedAddress() const$/;"	f	class:Literal	signature:() const
getChecksummedAddress	libsolidity/ast/AST.h	/^	std::string getChecksummedAddress() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
getContainerIds	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value getContainerIds(Container const& container)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(Container const& container)
getDupNumber	libevmasm/Instruction.h	/^inline unsigned getDupNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
getFuncDefinition	solse/SymExecEngine.cpp	/^getFuncDefinition(std::string funcName){$/;"	f	class:SymExecEngine	signature:(std::string funcName)
getFuncDefinition	solse/SymExecEngine.h	/^    dev::solidity::FunctionDefinition const* getFuncDefinition(std::string funcName);$/;"	p	class:SymExecEngine::dev::solidity	access:protected	signature:(std::string funcName)
getJumpType	libevmasm/AssemblyItem.h	/^	JumpType getJumpType() const { return m_jumpType; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
getJumpTypeAsString	libevmasm/AssemblyItem.cpp	/^string AssemblyItem::getJumpTypeAsString() const$/;"	f	class:AssemblyItem	signature:() const
getJumpTypeAsString	libevmasm/AssemblyItem.h	/^	std::string getJumpTypeAsString() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
getLiteralAndAdvance	libsolidity/parsing/Parser.cpp	/^ASTPointer<ASTString> Parser::getLiteralAndAdvance()$/;"	f	class:dev::solidity::Parser	signature:()
getLiteralAndAdvance	libsolidity/parsing/Parser.h	/^	ASTPointer<ASTString> getLiteralAndAdvance();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
getLogNumber	libevmasm/Instruction.h	/^inline unsigned getLogNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
getOperator	libsolidity/ast/AST.h	/^	Token getOperator() const { return m_operator; }$/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:() const
getOperator	libsolidity/ast/AST.h	/^	Token getOperator() const { return m_operator; }$/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:() const
getOptimizedItems	libevmasm/CommonSubexpressionEliminator.cpp	/^vector<AssemblyItem> CommonSubexpressionEliminator::getOptimizedItems()$/;"	f	class:CommonSubexpressionEliminator	signature:()
getOptimizedItems	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItems getOptimizedItems();$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:public	signature:()
getProjIndex	solse/SymExecEngine.h	/^    int getProjIndex(std::string fName){$/;"	f	class:StructInfo	access:public	signature:(std::string fName)
getPushNumber	libevmasm/Instruction.h	/^inline unsigned getPushNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
getRealFuncCallName	solse/SymExecEngine.cpp	/^getRealFuncCallName(Expression const* funcCall) {$/;"	f	class:SymExecEngine	signature:(Expression const* funcCall)
getRealFuncCallName	solse/SymExecEngine.h	/^    std::string getRealFuncCallName(dev::solidity::Expression const* funcCall);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Expression const* funcCall)
getSwapNumber	libevmasm/Instruction.h	/^inline unsigned getSwapNumber(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
getVarFullName	solse/SymExecEngine.cpp	/^getVarFullName(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo)
getVarFullName	solse/SymExecEngine.cpp	/^getVarFullName(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo) {$/;"	f	class:SymExecEngine	signature:(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo)
getVarFullName	solse/SymExecEngine.h	/^    std::string getVarFullName(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Identifier const* idExp, ContextInfo& ctxInfo)
getVarFullName	solse/SymExecEngine.h	/^    std::string getVarFullName(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::VariableDeclaration const* varDec, ContextInfo& ctxInfo)
goDeeper	libsolidity/ast/ASTPrinter.h	/^	bool goDeeper() { m_indentation++; return true; }$/;"	f	class:dev::solidity::ASTPrinter	access:private	signature:()
goHead	solse/SolidityExprTranslator.h	/^    bool goHead = true;$/;"	m	class:ContextInfo	access:public
handleABI	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleABI(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleABI	solse/CommandLineInterface.h	/^	void handleABI(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
handleArguments	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::handleArguments(vector<Expression>& _arguments)$/;"	f	class:ExpressionJoiner	signature:(vector<Expression>& _arguments)
handleArguments	libyul/optimiser/ExpressionJoiner.h	/^	void handleArguments(std::vector<Expression>& _arguments);$/;"	p	class:yul::ExpressionJoiner	access:private	signature:(std::vector<Expression>& _arguments)
handleAssignment	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::handleAssignment(set<YulString> const& _variables, Expression* _value)$/;"	f	class:DataFlowAnalyzer	signature:(set<YulString> const& _variables, Expression* _value)
handleAssignment	libyul/optimiser/DataFlowAnalyzer.h	/^	void handleAssignment(std::set<YulString> const& _names, Expression* _value);$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(std::set<YulString> const& _names, Expression* _value)
handleAst	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleAst(string const& _argStr)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _argStr)
handleAst	solse/CommandLineInterface.h	/^	void handleAst(std::string const& _argStr);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _argStr)
handleBinary	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleBinary(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleBinary	solse/CommandLineInterface.h	/^	void handleBinary(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
handleBlock	libyul/optimiser/FullInliner.cpp	/^void FullInliner::handleBlock(YulString _currentFunctionName, Block& _block)$/;"	f	class:FullInliner	signature:(YulString _currentFunctionName, Block& _block)
handleBlock	libyul/optimiser/FullInliner.h	/^	void handleBlock(YulString _currentFunctionName, Block& _block);$/;"	p	class:yul::FullInliner	access:private	signature:(YulString _currentFunctionName, Block& _block)
handleBytecode	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleBytecode(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleBytecode	solse/CommandLineInterface.h	/^	void handleBytecode(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
handleCallable	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::handleCallable($/;"	f	class:DocStringAnalyser	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
handleCallable	libsolidity/analysis/DocStringAnalyser.h	/^	void handleCallable($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
handleCombinedJSON	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleCombinedJSON()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
handleCombinedJSON	solse/CommandLineInterface.h	/^	void handleCombinedJSON();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
handleConstructor	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::handleConstructor($/;"	f	class:DocStringAnalyser	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
handleConstructor	libsolidity/analysis/DocStringAnalyser.h	/^	void handleConstructor($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( CallableDeclaration const& _callable, Documented const& _node, DocumentedAnnotation& _annotation )
handleFormal	solse/CommandLineInterface.h	/^	void handleFormal();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
handleGasEstimation	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleGasEstimation(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleGasEstimation	solse/CommandLineInterface.h	/^	void handleGasEstimation(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
handleMetadata	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleMetadata(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleMetadata	solse/CommandLineInterface.h	/^	void handleMetadata(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
handleNatspec	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleNatspec(bool _natspecDev, string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(bool _natspecDev, string const& _contract)
handleNatspec	solse/CommandLineInterface.h	/^	void handleNatspec(bool _natspecDev, std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(bool _natspecDev, std::string const& _contract)
handleOpcode	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleOpcode(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleOpcode	solse/CommandLineInterface.h	/^	void handleOpcode(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
handleQueueItem	libevmasm/PathGasMeter.cpp	/^GasMeter::GasConsumption PathGasMeter::handleQueueItem()$/;"	f	class:PathGasMeter	signature:()
handleQueueItem	libevmasm/PathGasMeter.h	/^	GasMeter::GasConsumption handleQueueItem();$/;"	p	class:dev::eth::PathGasMeter	access:private	signature:()
handleSignatureHashes	solse/CommandLineInterface.cpp	/^void CommandLineInterface::handleSignatureHashes(string const& _contract)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _contract)
handleSignatureHashes	solse/CommandLineInterface.h	/^	void handleSignatureHashes(std::string const& _contract);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _contract)
hasBitwiseShifting	liblangutil/EVMVersion.h	/^	bool hasBitwiseShifting() const { return *this >= constantinople(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
hasCorrectArity	libsolidity/formal/SolverInterface.h	/^	bool hasCorrectArity() const$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:() const
hasCreate2	liblangutil/EVMVersion.h	/^	bool hasCreate2() const { return *this >= constantinople(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
hasDeclaration	libsolidity/ast/Types.h	/^	bool hasDeclaration() const { return !!m_declaration; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
hasEqualParameterTypes	libsolidity/ast/Types.cpp	/^bool FunctionType::hasEqualParameterTypes(FunctionType const& _other) const$/;"	f	class:FunctionType	signature:(FunctionType const& _other) const
hasEqualParameterTypes	libsolidity/ast/Types.h	/^	bool hasEqualParameterTypes(FunctionType const& _other) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionType const& _other) const
hasEqualReturnTypes	libsolidity/ast/Types.cpp	/^bool FunctionType::hasEqualReturnTypes(FunctionType const& _other) const$/;"	f	class:FunctionType	signature:(FunctionType const& _other) const
hasEqualReturnTypes	libsolidity/ast/Types.h	/^	bool hasEqualReturnTypes(FunctionType const& _other) const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(FunctionType const& _other) const
hasErrors	liblangutil/ErrorReporter.h	/^	bool hasErrors() const$/;"	f	class:langutil::ErrorReporter	access:public	signature:() const
hasExtCodeHash	liblangutil/EVMVersion.h	/^	bool hasExtCodeHash() const { return *this >= constantinople(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
hasId	libevmasm/SimplificationRules.h	/^	bool hasId = false;$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
hasLiteralValue	libyul/optimiser/StructuralSimplifier.cpp	/^boost::optional<dev::u256> StructuralSimplifier::hasLiteralValue(Expression const& _expression) const$/;"	f	class:StructuralSimplifier	signature:(Expression const& _expression) const
hasLiteralValue	libyul/optimiser/StructuralSimplifier.h	/^	boost::optional<dev::u256> hasLiteralValue(Expression const& _expression) const;$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(Expression const& _expression) const
hasPayableFunctions	libsolidity/codegen/ContractCompiler.cpp	/^bool hasPayableFunctions(ContractDefinition const& _contract)$/;"	f	namespace:__anon13	signature:(ContractDefinition const& _contract)
hasReferenceOrMappingType	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::hasReferenceOrMappingType() const$/;"	f	class:VariableDeclaration	signature:() const
hasReferenceOrMappingType	libsolidity/ast/AST.h	/^	bool hasReferenceOrMappingType() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
hasSimpleZeroValueInMemory	libsolidity/ast/Types.h	/^	virtual bool hasSimpleZeroValueInMemory() const { return true; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
hasStaticCall	liblangutil/EVMVersion.h	/^	bool hasStaticCall() const { return *this >= byzantium(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
hash	libdevcore/Keccak256.cpp	/^inline void hash($/;"	f	namespace:dev::__anon23	signature:( uint8_t* out, size_t outlen, uint8_t const* in, size_t inlen, size_t rate, uint8_t delim )
hash	libyul/YulString.h	/^		std::uint64_t hash;$/;"	m	struct:yul::YulStringRepository::Handle	access:public
hash	libyul/YulString.h	/^	static std::uint64_t hash(std::string const& v)$/;"	f	class:yul::YulStringRepository	access:public	signature:(std::string const& v)
hashMatchesContent	libsolidity/interface/StandardCompiler.cpp	/^bool hashMatchesContent(string const& _hash, string const& _content)$/;"	f	namespace:__anon17	signature:(string const& _hash, string const& _content)
headSize	libsolidity/codegen/ABIFunctions.cpp	/^size_t ABIFunctions::headSize(TypePointers const& _targetTypes)$/;"	f	class:ABIFunctions	signature:(TypePointers const& _targetTypes)
headSize	libsolidity/codegen/ABIFunctions.h	/^	static size_t headSize(TypePointers const& _targetTypes);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(TypePointers const& _targetTypes)
hex	libdevcore/FixedHash.h	/^	std::string hex() const { return toHex(asBytes()); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
hexValue	liblangutil/Common.h	/^inline int hexValue(char c)$/;"	f	namespace:langutil	signature:(char c)
highlightColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::highlightColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
highlightColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized highlightColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
homestead	liblangutil/EVMVersion.h	/^	static EVMVersion homestead() { return {Version::Homestead}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
i	libevmasm/PeepholeOptimiser.cpp	/^	size_t i;$/;"	m	struct:__anon19::OptimiserState	file:	access:public
id	libevmasm/ExpressionClasses.h	/^		Id id;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
id	libevmasm/SimplificationRules.h	/^	Id id = Id(-1);$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
id	libevmasm/SimplificationRules.h	/^	Id id() const { return matchGroupValue().id; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
id	libsolidity/ast/AST.cpp	/^	size_t id = 0;$/;"	m	class:IDDispenser	file:	access:private
id	libsolidity/ast/AST.h	/^	size_t id() const { return m_id; }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:() const
id	libyul/YulString.h	/^		size_t id;$/;"	m	struct:yul::YulStringRepository::Handle	access:public
idOrNull	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value idOrNull(ASTNode const* _pt)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(ASTNode const* _pt)
idToString	libyul/YulString.h	/^	std::string const& idToString(size_t _id) const	{ return *m_strings.at(_id); }$/;"	f	class:yul::YulStringRepository::std	access:public	signature:(size_t _id) const
identifier	libsolidity/ast/Types.cpp	/^string Type::identifier() const$/;"	f	class:Type	signature:() const
identifier	libsolidity/ast/Types.h	/^	std::string identifier() const;$/;"	p	class:dev::solidity::Type	access:public	signature:() const
identifierList	libsolidity/ast/Types.cpp	/^string identifierList(Range const&& _list)$/;"	f	namespace:__anon8	signature:(Range const&& _list)
identifierList	libsolidity/ast/Types.cpp	/^string identifierList(TypePointer const& _type)$/;"	f	namespace:__anon8	signature:(TypePointer const& _type)
identifierList	libsolidity/ast/Types.cpp	/^string identifierList(TypePointer const& _type1, TypePointer const& _type2)$/;"	f	namespace:__anon8	signature:(TypePointer const& _type1, TypePointer const& _type2)
identifierList	libsolidity/ast/Types.cpp	/^string identifierList(vector<TypePointer> const& _list)$/;"	f	namespace:__anon8	signature:(vector<TypePointer> const& _list)
identifierLocationSuffix	libsolidity/ast/Types.cpp	/^string ReferenceType::identifierLocationSuffix() const$/;"	f	class:ReferenceType	signature:() const
identifierLocationSuffix	libsolidity/ast/Types.h	/^	std::string identifierLocationSuffix() const;$/;"	p	class:dev::solidity::ReferenceType	access:protected	signature:() const
identifiers	libyul/AsmScope.h	/^	std::map<YulString, Identifier> identifiers;$/;"	m	struct:yul::Scope	access:public
identityContractAddress	libsolidity/codegen/CompilerUtils.cpp	/^unsigned const CompilerUtils::identityContractAddress = 4;$/;"	m	class:dev::solidity::CompilerUtils	file:
identityContractAddress	libsolidity/codegen/CompilerUtils.h	/^	static unsigned const identityContractAddress;$/;"	m	class:dev::solidity::CompilerUtils	access:private
implies	libsolidity/formal/SolverInterface.h	/^	static Expression implies(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _a, Expression _b)
importInheritedScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::importInheritedScope(ContractDefinition const& _base)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ContractDefinition const& _base)
importInheritedScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void importInheritedScope(ContractDefinition const& _base);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(ContractDefinition const& _base)
inContractKind	libsolidity/ast/AST.cpp	/^ContractDefinition::ContractKind FunctionDefinition::inContractKind() const$/;"	f	class:FunctionDefinition	signature:() const
inContractKind	libsolidity/ast/AST.h	/^	ContractDefinition::ContractKind inContractKind() const;$/;"	p	class:dev::solidity::FunctionDefinition	access:public	signature:() const
inScope	libyul/optimiser/DataFlowAnalyzer.cpp	/^bool DataFlowAnalyzer::inScope(YulString _variableName) const$/;"	f	class:DataFlowAnalyzer	signature:(YulString _variableName) const
inScope	libyul/optimiser/DataFlowAnalyzer.h	/^	bool inScope(YulString _variableName) const;$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(YulString _variableName) const
increaseIndex	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicFunctionVariable::increaseIndex()$/;"	f	class:SymbolicFunctionVariable	signature:()
increaseIndex	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicVariable::increaseIndex()$/;"	f	class:SymbolicVariable	signature:()
increaseIndex	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression increaseIndex();$/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:public	signature:()
increaseIndex	libsolidity/formal/SymbolicVariables.h	/^	virtual smt::Expression increaseIndex();$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:()
increaseRecursionDepth	liblangutil/ParserBase.cpp	/^void ParserBase::increaseRecursionDepth()$/;"	f	class:ParserBase	signature:()
increaseRecursionDepth	liblangutil/ParserBase.h	/^	void increaseRecursionDepth();$/;"	p	class:langutil::ParserBase	access:protected	signature:()
increaseRefIfFound	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::increaseRefIfFound(YulString _variableName)$/;"	f	class:VariableReferenceCounter	signature:(YulString _variableName)
increaseRefIfFound	libyul/backends/evm/EVMCodeTransform.h	/^	void increaseRefIfFound(YulString _variableName);$/;"	p	class:yul::VariableReferenceCounter	access:private	signature:(YulString _variableName)
incrementByteOffset	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::incrementByteOffset(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const$/;"	f	class:ArrayUtils	signature:(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const
incrementByteOffset	libsolidity/codegen/ArrayUtils.h	/^	void incrementByteOffset(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const;$/;"	p	class:dev::solidity::ArrayUtils	access:private	signature:(unsigned _byteSize, unsigned _byteOffsetPosition, unsigned _storageOffsetPosition) const
incrementDynamicArraySize	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::incrementDynamicArraySize(ArrayType const& _type) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _type) const
incrementDynamicArraySize	libsolidity/codegen/ArrayUtils.h	/^	void incrementDynamicArraySize(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
indent	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::indent()$/;"	f	class:IndentedWriter	signature:()
indent	libdevcore/IndentedWriter.h	/^	void indent();$/;"	p	class:dev::IndentedWriter	access:public	signature:()
indent	libyul/Object.cpp	/^string indent(std::string const& _input)$/;"	f	namespace:__anon3	signature:(std::string const& _input)
indentation	libdevcore/IndentedWriter.h	/^		unsigned indentation;$/;"	m	struct:dev::IndentedWriter::Line	access:public
indentation	libsolidity/ast/ASTPrinter.cpp	/^string ASTPrinter::indentation() const$/;"	f	class:dev::solidity::ASTPrinter	signature:() const
indentation	libsolidity/ast/ASTPrinter.h	/^	std::string indentation() const;$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:() const
index	libevmasm/PathGasMeter.h	/^	size_t index = 0;$/;"	m	struct:dev::eth::GasPath	access:public
index	libsolidity/formal/SSAVariable.h	/^	unsigned index() const { return m_currentIndex; }$/;"	f	class:dev::solidity::SSAVariable	access:public	signature:() const
index	libsolidity/formal/SSAVariable.h	/^	unsigned& index() { return m_currentIndex; }$/;"	f	class:dev::solidity::SSAVariable	access:public	signature:()
index	libsolidity/formal/SymbolicVariables.h	/^	unsigned index() const { return m_ssa->index(); }$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:() const
index	libsolidity/formal/SymbolicVariables.h	/^	unsigned& index() { return m_ssa->index(); }$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:()
indexExpression	libsolidity/ast/AST.h	/^	Expression const* indexExpression() const { return m_index.get(); }$/;"	f	class:dev::solidity::IndexAccess	access:public	signature:() const
indices	libsolidity/parsing/Parser.h	/^		std::vector<std::pair<ASTPointer<Expression>, langutil::SourceLocation>> indices;$/;"	m	struct:dev::solidity::Parser::IndexAccessedPath	access:public
infinite	libevmasm/GasMeter.h	/^		static GasConsumption infinite() { return GasConsumption(0, true); }$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:()
infos	liblangutil/Exceptions.h	/^	std::vector<errorSourceLocationInfo> infos;$/;"	m	class:langutil::SecondarySourceLocation	access:public
inheritableMembers	libsolidity/ast/AST.cpp	/^vector<Declaration const*> const& ContractDefinition::inheritableMembers() const$/;"	f	class:ContractDefinition	signature:() const
inheritableMembers	libsolidity/ast/AST.h	/^	std::vector<Declaration const*> const& inheritableMembers() const;$/;"	p	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
initSuffix	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::initSuffix = "_0_";$/;"	m	class:SymExecEngine	file:
initSuffix	solse/SymExecEngine.h	/^    static const std::string initSuffix;$/;"	m	class:SymExecEngine	access:private
initial	libevmasm/ControlFlowGraph.h	/^	static BlockId initial() { return BlockId(-2); }$/;"	f	class:dev::eth::BlockId	access:public	signature:()
initialValue	libsolidity/ast/AST.h	/^	Expression const* initialValue() const { return m_initialValue.get(); }$/;"	f	class:dev::solidity::VariableDeclarationStatement	access:public	signature:() const
initialiseFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::initialiseFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
initialiseFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void initialiseFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
initializationExpression	libsolidity/ast/AST.h	/^	Statement const* initializationExpression() const { return m_initExpression.get(); }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
initializeContext	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::initializeContext($/;"	f	class:ContractCompiler	signature:( ContractDefinition const& _contract, map<ContractDefinition const*, shared_ptr<Compiler const>> const& _otherCompilers )
initializeContext	libsolidity/codegen/ContractCompiler.h	/^	void initializeContext($/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:( ContractDefinition const& _contract, std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers )
initializeFunctionCallParameters	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::initializeFunctionCallParameters(FunctionDefinition const& _function, vector<smt::Expression> const& _callArgs)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const& _function, vector<smt::Expression> const& _callArgs)
initializeFunctionCallParameters	libsolidity/formal/SMTChecker.h	/^	void initializeFunctionCallParameters(FunctionDefinition const& _function, std::vector<smt::Expression> const& _callArgs);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionDefinition const& _function, std::vector<smt::Expression> const& _callArgs)
initializeLocalVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::initializeLocalVariables(FunctionDefinition const& _function)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const& _function)
initializeLocalVariables	libsolidity/formal/SMTChecker.h	/^	void initializeLocalVariables(FunctionDefinition const& _function);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionDefinition const& _function)
initializeStateVariables	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::initializeStateVariables(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
initializeStateVariables	libsolidity/codegen/ContractCompiler.h	/^	void initializeStateVariables(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
injectStart	libevmasm/Assembly.cpp	/^void Assembly::injectStart(AssemblyItem const& _i)$/;"	f	class:Assembly	signature:(AssemblyItem const& _i)
injectStart	libevmasm/Assembly.h	/^	void injectStart(AssemblyItem const& _i);$/;"	p	class:dev::eth::Assembly	access:public	signature:(AssemblyItem const& _i)
inlinableFunctions	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	std::map<YulString, FunctionDefinition const*> const& inlinableFunctions() const$/;"	f	class:yul::InlinableExpressionFunctionFinder::std	access:public	signature:() const
inlineAssemblyIdentifierToJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value ASTJsonConverter::inlineAssemblyIdentifierToJson(pair<yul::Identifier const* ,InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(pair<yul::Identifier const* ,InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const
inlineAssemblyIdentifierToJson	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value inlineAssemblyIdentifierToJson(std::pair<yul::Identifier const* , InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const;$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(std::pair<yul::Identifier const* , InlineAssemblyAnnotation::ExternalIdentifierInfo> _info) const
inlineFunctionCall	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::inlineFunctionCall(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
inlineFunctionCall	libsolidity/formal/SMTChecker.h	/^	void inlineFunctionCall(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
insideFunction	libyul/AsmScope.cpp	/^bool Scope::insideFunction() const$/;"	f	class:Scope	signature:() const
insideFunction	libyul/AsmScope.h	/^	bool insideFunction() const;$/;"	p	struct:yul::Scope	access:public	signature:() const
instance	libsolidity/ast/AST.cpp	/^	static size_t& instance()$/;"	f	class:IDDispenser	file:	access:private	signature:()
instance	libyul/YulString.h	/^	static YulStringRepository& instance()$/;"	f	class:yul::YulStringRepository	access:public	signature:()
instruction	libevmasm/AssemblyItem.h	/^	Instruction instruction() const { assertThrow(m_type == Operation, Exception, ""); return m_instruction; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
instruction	libevmasm/SimplificationRules.h	/^	Instruction instruction() const$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
instruction	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionalInstruction	access:public
instruction	libyul/AsmData.h	/^struct Instruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; };$/;"	m	struct:yul::Instruction	access:public
instruction	libyul/optimiser/SimplificationRules.cpp	/^solidity::Instruction Pattern::instruction() const$/;"	f	class:Pattern	signature:() const
instruction	libyul/optimiser/SimplificationRules.h	/^	dev::solidity::Instruction instruction() const;$/;"	p	class:yul::Pattern	access:public	signature:() const
instructionInfo	libevmasm/Instruction.cpp	/^InstructionInfo dev::solidity::instructionInfo(Instruction _inst)$/;"	f	class:dev::solidity	signature:(Instruction _inst)
instructionInfo	libevmasm/Instruction.h	/^InstructionInfo instructionInfo(Instruction _inst);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
instructionNames	libyul/AsmParser.cpp	/^std::map<dev::solidity::Instruction, string> const& Parser::instructionNames()$/;"	f	class:std::Parser	signature:()
instructionNames	libyul/AsmParser.h	/^	static std::map<dev::solidity::Instruction, std::string> const& instructionNames();$/;"	p	class:yul::Parser::std	access:protected	signature:()
instructions	libyul/AsmParser.cpp	/^std::map<string, dev::solidity::Instruction> const& Parser::instructions()$/;"	f	class:std::Parser	signature:()
instructions	libyul/AsmParser.h	/^	static std::map<std::string, dev::solidity::Instruction> const& instructions();$/;"	p	class:yul::Parser::std	access:protected	signature:()
intType	libsolidity/formal/SMTChecker.h	/^		TypePointer intType;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
integerType	libsolidity/ast/Types.cpp	/^shared_ptr<IntegerType const> RationalNumberType::integerType() const$/;"	f	class:RationalNumberType	signature:() const
integerType	libsolidity/ast/Types.h	/^	std::shared_ptr<IntegerType const> integerType() const;$/;"	p	class:dev::solidity::RationalNumberType	access:public	signature:() const
interface	liblangutil/UndefMacros.h	37;"	d
interfaceEvents	libsolidity/ast/AST.cpp	/^vector<EventDefinition const*> const& ContractDefinition::interfaceEvents() const$/;"	f	class:ContractDefinition	signature:() const
interfaceEvents	libsolidity/ast/AST.h	/^	std::vector<EventDefinition const*> const& interfaceEvents() const;$/;"	p	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
interfaceFunctionList	libsolidity/ast/AST.cpp	/^vector<pair<FixedHash<4>, FunctionTypePointer>> const& ContractDefinition::interfaceFunctionList() const$/;"	f	class:ContractDefinition	signature:() const
interfaceFunctionList	libsolidity/ast/AST.h	/^	std::vector<std::pair<FixedHash<4>, FunctionTypePointer>> const& interfaceFunctionList() const;$/;"	p	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
interfaceFunctionType	libsolidity/ast/Types.cpp	/^FunctionTypePointer FunctionType::interfaceFunctionType() const$/;"	f	class:FunctionType	signature:() const
interfaceFunctionType	libsolidity/ast/Types.h	/^	FunctionTypePointer interfaceFunctionType() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
interfaceFunctions	libsolidity/ast/AST.cpp	/^map<FixedHash<4>, FunctionTypePointer> ContractDefinition::interfaceFunctions() const$/;"	f	class:ContractDefinition	signature:() const
interfaceFunctions	libsolidity/ast/AST.h	/^	std::map<FixedHash<4>, FunctionTypePointer> interfaceFunctions() const;$/;"	p	class:dev::solidity::ContractDefinition	access:public	signature:() const
interfaceType	libsolidity/ast/Types.cpp	/^TypePointer ArrayType::interfaceType(bool _inLibrary) const$/;"	f	class:ArrayType	signature:(bool _inLibrary) const
interfaceType	libsolidity/ast/Types.cpp	/^TypePointer FunctionType::interfaceType(bool \/*_inLibrary*\/) const$/;"	f	class:FunctionType	signature:(bool ) const
interfaceType	libsolidity/ast/Types.cpp	/^TypePointer StructType::interfaceType(bool _inLibrary) const$/;"	f	class:StructType	signature:(bool _inLibrary) const
interfaceType	libsolidity/ast/Types.h	/^	virtual TypePointer interfaceType(bool \/*_inLibrary*\/) const { return TypePointer(); }$/;"	f	class:dev::solidity::Type	access:public	signature:(bool ) const
intersect	libevmasm/KnownState.cpp	/^template <class _Mapping> void intersect(_Mapping& _this, _Mapping const& _other)$/;"	f	signature:(_Mapping& _this, _Mapping const& _other)
intersects	liblangutil/SourceLocation.h	/^	inline bool intersects(SourceLocation const& _other) const;$/;"	p	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
intersects	liblangutil/SourceLocation.h	/^bool SourceLocation::intersects(SourceLocation const& _other) const$/;"	f	class:langutil::SourceLocation	signature:(SourceLocation const& _other) const
invalid	libevmasm/ControlFlowGraph.h	/^	static BlockId invalid() { return BlockId(-1); }$/;"	f	class:dev::eth::BlockId	access:public	signature:()
invalidInPureFunctions	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidInPureFunctions(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
invalidInPureFunctions	libevmasm/SemanticInformation.h	/^	static bool invalidInPureFunctions(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
invalidInViewFunctions	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidInViewFunctions(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
invalidInViewFunctions	libevmasm/SemanticInformation.h	/^	static bool invalidInViewFunctions(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
invalidatesMemory	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidatesMemory(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
invalidatesMemory	libevmasm/SemanticInformation.h	/^	static bool invalidatesMemory(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
invalidatesStorage	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::invalidatesStorage(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
invalidatesStorage	libevmasm/SemanticInformation.h	/^	static bool invalidatesStorage(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
invariant_types	solse/mechanism.h	/^		std::vector<z3::expr> invariant_types;$/;"	m	class:Mechanism	access:public
isAddress	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isAddress(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isAddress	libsolidity/formal/SymbolicTypes.h	/^bool isAddress(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isAnonymous	libsolidity/ast/AST.h	/^	bool isAnonymous() const { return m_anonymous; }$/;"	f	class:dev::solidity::EventDefinition	access:public	signature:() const
isArithmeticOp	liblangutil/Token.h	/^	constexpr bool isArithmeticOp(Token op) { return Token::Add <= op && op <= Token::Exp; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isArtifactRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isArtifactRequested(Json::Value const& _outputSelection, string const& _artifact)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection, string const& _artifact)
isArtifactRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isArtifactRequested(Json::Value const& _outputSelection, string const& _file, string const& _contract, string const& _artifact)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection, string const& _file, string const& _contract, string const& _artifact)
isArtifactRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isArtifactRequested(Json::Value const& _outputSelection, string const& _file, string const& _contract, vector<string> const& _artifacts)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection, string const& _file, string const& _contract, vector<string> const& _artifacts)
isAssignmentOp	liblangutil/Token.h	/^	constexpr bool isAssignmentOp(Token tok) { return Token::Assign <= tok && tok <= Token::AssignMod; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
isBareCall	libsolidity/ast/Types.cpp	/^bool FunctionType::isBareCall() const$/;"	f	class:FunctionType	signature:() const
isBareCall	libsolidity/ast/Types.h	/^	bool isBareCall() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
isBinaryOp	liblangutil/Token.h	/^	constexpr bool isBinaryOp(Token op) { return Token::Comma <= op && op <= Token::Exp; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isBinaryRequested	libsolidity/interface/StandardCompiler.cpp	/^bool isBinaryRequested(Json::Value const& _outputSelection)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection)
isBitOp	liblangutil/Token.h	/^	constexpr bool isBitOp(Token op) { return (Token::BitOr <= op && op <= Token::BitAnd) || op == Token::BitNot; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isBool	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isBool(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isBool	libsolidity/formal/SymbolicTypes.h	/^bool isBool(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isBooleanOp	liblangutil/Token.h	/^	constexpr bool isBooleanOp(Token op) { return (Token::Or <= op && op <= Token::And) || op == Token::Not; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isByteArray	libsolidity/ast/Types.h	/^	bool isByteArray() const { return m_arrayKind != ArrayKind::Ordinary; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
isCallableParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isCallableParameter() const$/;"	f	class:VariableDeclaration	signature:() const
isCallableParameter	libsolidity/ast/AST.h	/^	bool isCallableParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isCommutativeOp	liblangutil/Token.h	/^	constexpr bool isCommutativeOp(Token op) { return op == Token::BitOr || op == Token::BitXor || op == Token::BitAnd ||$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isCommutativeOperation	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isCommutativeOperation(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
isCommutativeOperation	libevmasm/SemanticInformation.h	/^	static bool isCommutativeOperation(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
isCompareOp	liblangutil/Token.h	/^	constexpr bool isCompareOp(Token op) { return Token::Equal <= op && op <= Token::GreaterThanOrEqual; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isConstant	libsolidity/ast/AST.h	/^	bool isConstant() const { return m_isConstant; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isConstant	libsolidity/ast/ASTAnnotations.h	/^	bool isConstant = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
isConstructor	libsolidity/ast/AST.h	/^	bool isConstructor() const { return m_isConstructor; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
isConstructor	libsolidity/parsing/Parser.h	/^		bool isConstructor;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
isCountOp	liblangutil/Token.h	/^	constexpr bool isCountOp(Token op) { return op == Token::Inc || op == Token::Dec; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isCreation	libevmasm/Assembly.h	/^		bool isCreation = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
isCreation	libevmasm/ConstantOptimiser.h	/^		bool isCreation; \/\/\/< Whether this is called during contract creation or runtime.$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
isDecimalDigit	liblangutil/Common.h	/^inline bool isDecimalDigit(char c)$/;"	f	namespace:langutil	signature:(char c)
isDeterministic	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isDeterministic(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
isDeterministic	libevmasm/SemanticInformation.h	/^	static bool isDeterministic(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
isDoWhile	libsolidity/ast/AST.h	/^	bool isDoWhile() const { return m_isDoWhile; }$/;"	f	class:dev::solidity::WhileStatement	access:public	signature:() const
isDupInstruction	libevmasm/Instruction.h	/^inline bool isDupInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
isDupInstruction	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isDupInstruction(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
isDupInstruction	libevmasm/SemanticInformation.h	/^	static bool isDupInstruction(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
isDynamicallyEncoded	libsolidity/ast/Types.cpp	/^bool ArrayType::isDynamicallyEncoded() const$/;"	f	class:ArrayType	signature:() const
isDynamicallyEncoded	libsolidity/ast/Types.cpp	/^bool StructType::isDynamicallyEncoded() const$/;"	f	class:StructType	signature:() const
isDynamicallyEncoded	libsolidity/ast/Types.h	/^	virtual bool isDynamicallyEncoded() const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
isDynamicallySized	libsolidity/ast/Types.h	/^	virtual bool isDynamicallySized() const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
isElementaryTypeName	liblangutil/Token.h	/^	constexpr bool isElementaryTypeName(Token tok) { return Token::Int <= tok && tok < Token::TypesEnd; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
isEmpty	liblangutil/SourceLocation.h	/^	bool isEmpty() const { return start == -1 && end == -1; }$/;"	f	struct:langutil::SourceLocation	access:public	signature:() const
isEtherSubdenomination	liblangutil/Token.h	/^	constexpr bool isEtherSubdenomination(Token op) { return op == Token::SubWei || op == Token::SubSzabo || op == Token::SubFinney || op == Token::SubEther; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isEventParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isEventParameter() const$/;"	f	class:VariableDeclaration	signature:() const
isEventParameter	libsolidity/ast/AST.h	/^	bool isEventParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult AddressType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:AddressType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ArrayType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ArrayType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ContractType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ContractType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult EnumType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:EnumType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedBytesType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedBytesType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedPointType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedPointType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FunctionType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FunctionType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult IntegerType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:IntegerType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult RationalNumberType::isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:RationalNumberType	signature:(Type const& _convertTo) const
isExplicitlyConvertibleTo	libsolidity/ast/Types.h	/^	virtual BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _convertTo) const
isExternalCallableParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isExternalCallableParameter() const$/;"	f	class:VariableDeclaration	signature:() const
isExternalCallableParameter	libsolidity/ast/AST.h	/^	bool isExternalCallableParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isFallback	libsolidity/ast/AST.h	/^	bool isFallback() const { return !m_isConstructor && name().empty(); }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
isFixedBytes	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isFixedBytes(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isFixedBytes	libsolidity/formal/SymbolicTypes.h	/^bool isFixedBytes(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isFractional	libsolidity/ast/Types.h	/^	bool isFractional() const { return m_value.denominator() != 1; }$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:() const
isFunction	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isFunction(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isFunction	libsolidity/formal/SymbolicTypes.h	/^bool isFunction(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isFunction	libyul/optimiser/DataFlowAnalyzer.h	/^		bool isFunction;$/;"	m	struct:yul::DataFlowAnalyzer::Scope	access:public
isHexDigit	liblangutil/Common.h	/^inline bool isHexDigit(char c)$/;"	f	namespace:langutil	signature:(char c)
isHexNumber	libsolidity/ast/AST.cpp	/^bool Literal::isHexNumber() const$/;"	f	class:Literal	signature:() const
isHexNumber	libsolidity/ast/AST.h	/^	bool isHexNumber() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
isIdentifierPart	liblangutil/Common.h	/^inline bool isIdentifierPart(char c)$/;"	f	namespace:langutil	signature:(char c)
isIdentifierStart	liblangutil/Common.h	/^inline bool isIdentifierStart(char c)$/;"	f	namespace:langutil	signature:(char c)
isImplemented	libsolidity/ast/AST.h	/^	bool isImplemented() const { return m_implemented; }$/;"	f	class:dev::solidity::ImplementationOptional	access:public	signature:() const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult AddressType::isImplicitlyConvertibleTo(Type const& _other) const$/;"	f	class:AddressType	signature:(Type const& _other) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ArrayType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ArrayType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult ContractType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:ContractType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedBytesType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedBytesType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FixedPointType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FixedPointType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult FunctionType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:FunctionType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult IntegerType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:IntegerType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult RationalNumberType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:RationalNumberType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult StringLiteralType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:StringLiteralType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult StructType::isImplicitlyConvertibleTo(Type const& _convertTo) const$/;"	f	class:StructType	signature:(Type const& _convertTo) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.cpp	/^BoolResult TupleType::isImplicitlyConvertibleTo(Type const& _other) const$/;"	f	class:TupleType	signature:(Type const& _other) const
isImplicitlyConvertibleTo	libsolidity/ast/Types.h	/^	virtual BoolResult isImplicitlyConvertibleTo(Type const& _other) const { return *this == _other; }$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _other) const
isInStructDefinition	solse/SymExecEngine.h	/^    bool isInStructDefinition;$/;"	m	class:SymExecEngine	access:private
isIndexed	libsolidity/ast/AST.h	/^	bool isIndexed() const { return m_isIndexed; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isInfinite	libevmasm/GasMeter.h	/^		bool isInfinite;$/;"	m	struct:dev::eth::GasMeter::GasConsumption	access:public
isInitialized	libevmasm/SimplificationRules.cpp	/^bool Rules::isInitialized() const$/;"	f	class:Rules	signature:() const
isInitialized	libevmasm/SimplificationRules.h	/^	bool isInitialized() const;$/;"	p	class:dev::eth::Rules	access:public	signature:() const
isInitialized	libyul/optimiser/SimplificationRules.cpp	/^bool SimplificationRules::isInitialized() const$/;"	f	class:SimplificationRules	signature:() const
isInitialized	libyul/optimiser/SimplificationRules.h	/^	bool isInitialized() const;$/;"	p	class:yul::SimplificationRules	access:public	signature:() const
isInlineArray	libsolidity/ast/AST.h	/^	bool isInlineArray() const { return m_isArray; }$/;"	f	class:dev::solidity::TupleExpression	access:public	signature:() const
isInteger	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isInteger(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isInteger	libsolidity/formal/SymbolicTypes.h	/^bool isInteger(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isInterface	libsolidity/ast/AST.h	/^	bool isInterface() const { return m_contractKind == ContractKind::Interface; }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
isInternalCallableParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isInternalCallableParameter() const$/;"	f	class:VariableDeclaration	signature:() const
isInternalCallableParameter	libsolidity/ast/AST.h	/^	bool isInternalCallableParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isInvisible	libsolidity/analysis/DeclarationContainer.cpp	/^bool DeclarationContainer::isInvisible(ASTString const& _name) const$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name) const
isInvisible	libsolidity/analysis/DeclarationContainer.h	/^	bool isInvisible(ASTString const& _name) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name) const
isJumpInstruction	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isJumpInstruction(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
isJumpInstruction	libevmasm/SemanticInformation.h	/^	static bool isJumpInstruction(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
isLValue	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLValue() const$/;"	f	class:VariableDeclaration	signature:() const
isLValue	libsolidity/ast/AST.h	/^	virtual bool isLValue() const { return false; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
isLValue	libsolidity/ast/ASTAnnotations.h	/^	bool isLValue = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
isLatestStatementVarDeclJoinable	libyul/optimiser/ExpressionJoiner.cpp	/^bool ExpressionJoiner::isLatestStatementVarDeclJoinable(Identifier const& _identifier)$/;"	f	class:ExpressionJoiner	signature:(Identifier const& _identifier)
isLatestStatementVarDeclJoinable	libyul/optimiser/ExpressionJoiner.h	/^	bool isLatestStatementVarDeclJoinable(Identifier const& _identifier);$/;"	p	class:yul::ExpressionJoiner	access:private	signature:(Identifier const& _identifier)
isLibrary	libsolidity/ast/AST.h	/^	bool isLibrary() const { return m_contractKind == ContractKind::Library; }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
isLibrary	libsolidity/interface/CompilerStack.h	/^		bool isLibrary = false;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
isLibraryFunctionParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLibraryFunctionParameter() const$/;"	f	class:VariableDeclaration	signature:() const
isLibraryFunctionParameter	libsolidity/ast/AST.h	/^	bool isLibraryFunctionParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isLineTerminator	liblangutil/Common.h	/^inline bool isLineTerminator(char c)$/;"	f	namespace:langutil	signature:(char c)
isLocalOrReturn	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLocalOrReturn() const$/;"	f	class:VariableDeclaration	signature:() const
isLocalOrReturn	libsolidity/ast/AST.h	/^	bool isLocalOrReturn() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isLocalVariable	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isLocalVariable() const$/;"	f	class:VariableDeclaration	signature:() const
isLocalVariable	libsolidity/ast/AST.h	/^	bool isLocalVariable() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isLocalVariable	libsolidity/codegen/CompilerContext.cpp	/^bool CompilerContext::isLocalVariable(Declaration const* _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const* _declaration) const
isLocalVariable	libsolidity/codegen/CompilerContext.h	/^	bool isLocalVariable(Declaration const* _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const* _declaration) const
isLocationSpecifier	liblangutil/Token.h	/^	constexpr bool isLocationSpecifier(Token op) { return op == Token::Memory || op == Token::Storage || op == Token::CallData; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isLogInstruction	libevmasm/Instruction.h	/^inline bool isLogInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
isMapping	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isMapping(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isMapping	libsolidity/formal/SymbolicTypes.h	/^bool isMapping(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isNegative	libsolidity/ast/Types.h	/^	bool isNegative() const { return m_value < 0; }$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:() const
isNumber	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isNumber(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isNumber	libsolidity/formal/SymbolicTypes.h	/^bool isNumber(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isOffset	libsolidity/ast/ASTAnnotations.h	/^		bool isOffset = false; \/\/\/< Whether the intra-slot offset of a storage variable is queried.$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
isOverloadedFunction	libsolidity/analysis/NameAndTypeResolver.h	/^	static bool isOverloadedFunction(Declaration const& _declaration1, Declaration const& _declaration2);$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:(Declaration const& _declaration1, Declaration const& _declaration2)
isPartOfExternalInterface	libsolidity/ast/AST.h	/^	virtual bool isPartOfExternalInterface() const { return false; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
isPastEndOfInput	liblangutil/CharStream.h	/^	bool isPastEndOfInput(size_t _charsForward = 0) const { return (m_position + _charsForward) >= m_source.size(); }$/;"	f	class:langutil::CharStream	access:public	signature:(size_t _charsForward = 0) const
isPayable	libsolidity/ast/AST.h	/^	bool isPayable() const { return m_stateMutability == StateMutability::Payable; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
isPayable	libsolidity/ast/AST.h	/^	bool isPayable() const { return m_stateMutability == StateMutability::Payable; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
isPayable	libsolidity/ast/Types.cpp	/^bool ContractType::isPayable() const$/;"	f	class:ContractType	signature:() const
isPayable	libsolidity/ast/Types.h	/^	bool isPayable() const { return m_stateMutability == StateMutability::Payable; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
isPayable	libsolidity/ast/Types.h	/^	bool isPayable() const;$/;"	p	class:dev::solidity::ContractType	access:public	signature:() const
isPointer	libsolidity/ast/Types.h	/^	bool isPointer() const { return m_isPointer; }$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:() const
isPrefixOperation	libsolidity/ast/AST.h	/^	bool isPrefixOperation() const { return m_isPrefix; }$/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:() const
isPrerelease	libsolidity/analysis/SemVerHandler.h	/^	bool isPrerelease() const { return !prerelease.empty(); }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
isPublic	libsolidity/ast/AST.h	/^	bool isPublic() const { return visibility() >= Visibility::Public; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
isPure	libsolidity/ast/ASTAnnotations.h	/^	bool isPure = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
isPure	libsolidity/ast/Types.cpp	/^bool FunctionType::isPure() const$/;"	f	class:FunctionType	signature:() const
isPure	libsolidity/ast/Types.h	/^	bool isPure() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
isPushInstruction	libevmasm/Instruction.h	/^inline bool isPushInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
isRational	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isRational(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isRational	libsolidity/formal/SymbolicTypes.h	/^bool isRational(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isRequestedContract	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::isRequestedContract(ContractDefinition const& _contract) const$/;"	f	class:CompilerStack	signature:(ContractDefinition const& _contract) const
isRequestedContract	libsolidity/interface/CompilerStack.h	/^	bool isRequestedContract(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(ContractDefinition const& _contract) const
isReservedKeyword	liblangutil/Token.h	/^	constexpr bool isReservedKeyword(Token op) { return (Token::Abstract <= op && op <= Token::Unchecked); }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isReturnParameter	libsolidity/ast/AST.cpp	/^bool VariableDeclaration::isReturnParameter() const$/;"	f	class:VariableDeclaration	signature:() const
isReturnParameter	libsolidity/ast/AST.h	/^	bool isReturnParameter() const;$/;"	p	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isRootFunction	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::isRootFunction()$/;"	f	class:SMTChecker	signature:()
isRootFunction	libsolidity/formal/SMTChecker.h	/^	bool isRootFunction();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
isShiftOp	liblangutil/Token.h	/^	constexpr bool isShiftOp(Token op) { return (Token::SHL <= op) && (op <= Token::SHR); }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isSigned	libsolidity/ast/Types.h	/^	bool isSigned() const { return m_modifier == Modifier::Signed; }$/;"	f	class:dev::solidity::FixedPointType	access:public	signature:() const
isSigned	libsolidity/ast/Types.h	/^	bool isSigned() const { return m_modifier == Modifier::Signed; }$/;"	f	class:dev::solidity::IntegerType	access:public	signature:() const
isSlot	libsolidity/ast/ASTAnnotations.h	/^		bool isSlot = false; \/\/\/< Whether the storage slot of a variable is queried.$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
isSourcePastEndOfInput	liblangutil/Scanner.h	/^	bool isSourcePastEndOfInput() const { return m_source->isPastEndOfInput(); }$/;"	f	class:langutil::Scanner	access:private	signature:() const
isStateMutabilitySpecifier	liblangutil/Token.h	/^	constexpr bool isStateMutabilitySpecifier(Token op, bool _allowConstant = true)$/;"	f	namespace:langutil::TokenTraits	signature:(Token op, bool _allowConstant = true)
isStateVariable	libsolidity/ast/AST.h	/^	bool isStateVariable() const { return m_isStateVariable; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
isStateVariable	libsolidity/codegen/CompilerContext.h	/^	bool isStateVariable(Declaration const* _declaration) const { return m_stateVariables.count(_declaration) != 0; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const* _declaration) const
isStateVariable	libsolidity/parsing/Parser.h	/^		bool isStateVariable = false;$/;"	m	struct:dev::solidity::Parser::VarDeclParserOptions	access:public
isString	libsolidity/ast/Types.h	/^	bool isString() const { return m_arrayKind == ArrayKind::String; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
isSuper	libsolidity/ast/Types.h	/^	bool isSuper() const { return m_super; }$/;"	f	class:dev::solidity::ContractType	access:public	signature:() const
isSupportedType	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedType(Type const& _type)$/;"	f	class:dev::solidity	signature:(Type const& _type)
isSupportedType	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedType(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isSupportedType	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedType(Type const& _type);$/;"	p	namespace:dev::solidity	signature:(Type const& _type)
isSupportedType	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedType(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedTypeDeclaration(Type const& _type)$/;"	f	class:dev::solidity	signature:(Type const& _type)
isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.cpp	/^bool dev::solidity::isSupportedTypeDeclaration(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedTypeDeclaration(Type const& _type);$/;"	p	namespace:dev::solidity	signature:(Type const& _type)
isSupportedTypeDeclaration	libsolidity/formal/SymbolicTypes.h	/^bool isSupportedTypeDeclaration(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
isSwapInstruction	libevmasm/Instruction.h	/^inline bool isSwapInstruction(Instruction _inst)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
isSwapInstruction	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::isSwapInstruction(AssemblyItem const& _item)$/;"	f	class:SemanticInformation	signature:(AssemblyItem const& _item)
isSwapInstruction	libevmasm/SemanticInformation.h	/^	static bool isSwapInstruction(AssemblyItem const& _item);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(AssemblyItem const& _item)
isTimeSubdenomination	liblangutil/Token.h	/^	constexpr bool isTimeSubdenomination(Token op) { return op == Token::SubSecond || op == Token::SubMinute || op == Token::SubHour || op == Token::SubDay || op == Token::SubWeek || op == Token::SubYear; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isUnaryOp	liblangutil/Token.h	/^	constexpr bool isUnaryOp(Token op) { return (Token::Not <= op && op <= Token::Delete) || op == Token::Add || op == Token::Sub; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isUnicodeLinebreak	liblangutil/Scanner.cpp	/^bool Scanner::isUnicodeLinebreak()$/;"	f	class:langutil::Scanner	signature:()
isUnicodeLinebreak	liblangutil/Scanner.h	/^	bool isUnicodeLinebreak();$/;"	p	class:langutil::Scanner	access:private	signature:()
isUsedName	libyul/optimiser/VarNameCleaner.cpp	/^bool VarNameCleaner::isUsedName(YulString const& _name) const$/;"	f	class:VarNameCleaner	signature:(YulString const& _name) const
isUsedName	libyul/optimiser/VarNameCleaner.h	/^	bool isUsedName(YulString const& _name) const;$/;"	p	class:yul::VarNameCleaner	access:private	signature:(YulString const& _name) const
isValid	libevmasm/KnownState.h	/^		bool isValid() const { return target != Invalid; }$/;"	f	struct:dev::eth::KnownState::StoreOperation	access:public	signature:() const
isValid	libsolidity/analysis/SemVerHandler.h	/^	bool isValid() const { return !m_disjunction.empty(); }$/;"	f	struct:dev::solidity::SemVerMatchExpression	access:public	signature:() const
isValidDecimal	libdevcore/CommonData.cpp	/^bool dev::isValidDecimal(string const& _string)$/;"	f	class:dev	signature:(string const& _string)
isValidDecimal	libdevcore/CommonData.h	/^bool isValidDecimal(std::string const& _string);$/;"	p	namespace:dev	signature:(std::string const& _string)
isValidHex	libdevcore/CommonData.cpp	/^bool dev::isValidHex(string const& _string)$/;"	f	class:dev	signature:(string const& _string)
isValidHex	libdevcore/CommonData.h	/^bool isValidHex(std::string const& _string);$/;"	p	namespace:dev	signature:(std::string const& _string)
isValidInstruction	libevmasm/Instruction.cpp	/^bool dev::solidity::isValidInstruction(Instruction _inst)$/;"	f	class:dev::solidity	signature:(Instruction _inst)
isValidInstruction	libevmasm/Instruction.h	/^bool isValidInstruction(Instruction _inst);$/;"	p	class:dev::solidity::Instruction	access:private	signature:(Instruction _inst)
isValidLiteral	libsolidity/ast/Types.cpp	/^tuple<bool, rational> RationalNumberType::isValidLiteral(Literal const& _literal)$/;"	f	class:RationalNumberType	signature:(Literal const& _literal)
isValidLiteral	libsolidity/ast/Types.h	/^	static std::tuple<bool, rational> isValidLiteral(Literal const& _literal);$/;"	p	class:dev::solidity::RationalNumberType	access:private	signature:(Literal const& _literal)
isValidNumberLiteral	libyul/AsmParser.cpp	/^bool Parser::isValidNumberLiteral(string const& _literal)$/;"	f	class:Parser	signature:(string const& _literal)
isValidNumberLiteral	libyul/AsmParser.h	/^	static bool isValidNumberLiteral(std::string const& _literal);$/;"	p	class:yul::Parser	access:protected	signature:(std::string const& _literal)
isValidShiftAndAmountType	libsolidity/ast/Types.cpp	/^bool isValidShiftAndAmountType(Token _operator, Type const& _shiftAmountType)$/;"	f	namespace:__anon9	signature:(Token _operator, Type const& _shiftAmountType)
isValidUTF8	libsolidity/ast/Types.cpp	/^bool StringLiteralType::isValidUTF8() const$/;"	f	class:StringLiteralType	signature:() const
isValidUTF8	libsolidity/ast/Types.h	/^	bool isValidUTF8() const;$/;"	p	class:dev::solidity::StringLiteralType	access:public	signature:() const
isValueType	libsolidity/ast/Types.h	/^	virtual bool isValueType() const { return false; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
isVariableVisibilitySpecifier	liblangutil/Token.h	/^	constexpr bool isVariableVisibilitySpecifier(Token op) { return op == Token::Public || op == Token::Private || op == Token::Internal; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isVisibilitySpecifier	liblangutil/Token.h	/^	constexpr bool isVisibilitySpecifier(Token op) { return isVariableVisibilitySpecifier(op) || op == Token::External; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
isVisibleAsLibraryMember	libsolidity/ast/AST.h	/^	bool isVisibleAsLibraryMember() const { return visibility() >= Visibility::Internal; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
isVisibleInContract	libsolidity/ast/AST.h	/^	virtual bool isVisibleInContract() const { return visibility() != Visibility::External; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
isVisibleInDerivedContracts	libsolidity/ast/AST.h	/^	bool isVisibleInDerivedContracts() const { return isVisibleInContract() && visibility() >= Visibility::Internal; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
isWellFormed	libdevcore/UTF8.cpp	/^bool isWellFormed(unsigned char byte1, unsigned char byte2)$/;"	f	namespace:dev::__anon21	signature:(unsigned char byte1, unsigned char byte2)
isWhiteSpace	liblangutil/Common.h	/^inline bool isWhiteSpace(char c)$/;"	f	namespace:langutil	signature:(char c)
isZero	libsolidity/ast/Types.h	/^	bool isZero() const { return m_value == 0; }$/;"	f	class:dev::solidity::RationalNumberType	access:public	signature:() const
isatty	solse/CommandLineInterface.cpp	60;"	d	file:
it	libevmasm/BlockDeduplicator.h	/^		AssemblyItems::const_iterator it;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
ite	libsolidity/formal/SolverInterface.h	/^	static Expression ite(Expression _condition, Expression _trueValue, Expression _falseValue)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _condition, Expression _trueValue, Expression _falseValue)
item	libevmasm/ExpressionClasses.h	/^		AssemblyItem const* item = nullptr;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
item	libevmasm/SimplificationRules.h	/^	AssemblyItem item = UndefinedItem;$/;"	m	struct:dev::eth::ExpressionTemplate	access:public
items	libevmasm/Assembly.h	/^	AssemblyItems const& items() const { return m_items; }$/;"	f	class:dev::eth::Assembly	access:public	signature:() const
items	libevmasm/Assembly.h	/^	AssemblyItems& items() { return m_items; }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
items	libevmasm/PeepholeOptimiser.cpp	/^	AssemblyItems const& items;$/;"	m	struct:__anon19::OptimiserState	file:	access:public
iterateReplacing	libdevcore/CommonData.h	/^void iterateReplacing(std::vector<T>& _vector, F const& _f)$/;"	f	namespace:dev	signature:(std::vector<T>& _vector, F const& _f)
iterateReplacingWindow	libdevcore/CommonData.h	/^void iterateReplacingWindow(std::vector<T>& _vector, F const& _f)$/;"	f	namespace:dev	signature:(std::vector<T>& _vector, F const& _f)
iterateReplacingWindow	libdevcore/CommonData.h	/^void iterateReplacingWindow(std::vector<T>& _vector, F const& _f, std::index_sequence<I...>)$/;"	f	namespace:dev::detail	signature:(std::vector<T>& _vector, F const& _f, std::index_sequence<I...>)
join	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::join(RedundantAssignEliminator& _other)$/;"	f	class:RedundantAssignEliminator	signature:(RedundantAssignEliminator& _other)
join	libyul/optimiser/RedundantAssignEliminator.h	/^		static inline void join(State& _a, State const& _b)$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(State& _a, State const& _b)
join	libyul/optimiser/RedundantAssignEliminator.h	/^	void join(RedundantAssignEliminator& _other);$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:(RedundantAssignEliminator& _other)
joinHumanReadable	libdevcore/StringUtils.h	/^std::string joinHumanReadable$/;"	f	namespace:dev	signature:( T const& _list, std::string const& _separator = , std::string const& _lastSeparator =  )
joinMap	libyul/optimiser/RedundantAssignEliminator.cpp	/^void joinMap(std::map<K, V>& _a, std::map<K, V>&& _b, F _conflictSolver)$/;"	f	signature:(std::map<K, V>& _a, std::map<K, V>&& _b, F _conflictSolver)
joinMaps	libdevcore/Whiskers.cpp	/^Whiskers::StringMap Whiskers::joinMaps($/;"	f	class:Whiskers	signature:( Whiskers::StringMap const& _a, Whiskers::StringMap const& _b )
joinMaps	libdevcore/Whiskers.h	/^	static StringMap joinMaps(StringMap const& _a, StringMap const& _b);$/;"	p	class:dev::Whiskers	access:private	signature:(StringMap const& _a, StringMap const& _b)
jsonCompactPrint	libdevcore/JSON.cpp	/^string jsonCompactPrint(Json::Value const& _input)$/;"	f	namespace:dev	signature:(Json::Value const& _input)
jsonCompactPrint	libdevcore/JSON.h	/^std::string jsonCompactPrint(Json::Value const& _input);$/;"	p	namespace:dev	signature:(Json::Value const& _input)
jsonParse	libdevcore/JSON.cpp	/^bool jsonParse(string const& _input, Json::Value& _json, string *_errs \/* = nullptr *\/)$/;"	f	namespace:dev	signature:(string const& _input, Json::Value& _json, string *_errs )
jsonParse	libdevcore/JSON.h	/^bool jsonParse(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr);$/;"	p	namespace:dev	signature:(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr)
jsonParseFile	libdevcore/JSON.cpp	/^bool jsonParseFile(string const& _fileName, Json::Value& _json, string *_errs \/* = nullptr *\/)$/;"	f	namespace:dev	signature:(string const& _fileName, Json::Value& _json, string *_errs )
jsonParseFile	libdevcore/JSON.h	/^bool jsonParseFile(std::string const& _fileName, Json::Value& _json, std::string* _errs = nullptr);$/;"	p	namespace:dev	signature:(std::string const& _fileName, Json::Value& _json, std::string* _errs = nullptr)
jsonParseStrict	libdevcore/JSON.cpp	/^bool jsonParseStrict(string const& _input, Json::Value& _json, string* _errs \/* = nullptr *\/)$/;"	f	namespace:dev	signature:(string const& _input, Json::Value& _json, string* _errs )
jsonParseStrict	libdevcore/JSON.h	/^bool jsonParseStrict(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr);$/;"	p	namespace:dev	signature:(std::string const& _input, Json::Value& _json, std::string* _errs = nullptr)
jsonPrettyPrint	libdevcore/JSON.cpp	/^string jsonPrettyPrint(Json::Value const& _input)$/;"	f	namespace:dev	signature:(Json::Value const& _input)
jsonPrettyPrint	libdevcore/JSON.h	/^std::string jsonPrettyPrint(Json::Value const& _input);$/;"	p	namespace:dev	signature:(Json::Value const& _input)
jumpdestGas	libevmasm/GasMeter.h	/^	static unsigned const jumpdestGas = 1;$/;"	m	namespace:dev::eth::GasCosts
keccak256	libdevcore/Keccak256.cpp	/^h256 keccak256(bytesConstRef _input)$/;"	f	namespace:dev	signature:(bytesConstRef _input)
keccak256	libdevcore/Keccak256.h	/^h256 keccak256(bytesConstRef _input);$/;"	p	namespace:dev	signature:(bytesConstRef _input)
keccak256	libdevcore/Keccak256.h	/^inline h256 keccak256(bytes const& _input) { return keccak256(bytesConstRef(&_input)); }$/;"	f	namespace:dev	signature:(bytes const& _input)
keccak256	libdevcore/Keccak256.h	/^inline h256 keccak256(std::string const& _input) { return keccak256(bytesConstRef(_input)); }$/;"	f	namespace:dev	signature:(std::string const& _input)
keccak256	libdevcore/Keccak256.h	/^template<unsigned N> inline h256 keccak256(FixedHash<N> const& _input) { return keccak256(_input.ref()); }$/;"	f	namespace:dev	signature:(FixedHash<N> const& _input)
keccak256	libsolidity/interface/CompilerStack.cpp	/^h256 const& CompilerStack::Source::keccak256() const$/;"	f	class:CompilerStack::Source	signature:() const
keccak256	libsolidity/interface/CompilerStack.h	/^		h256 const& keccak256() const;$/;"	p	struct:dev::solidity::CompilerStack::Source	access:public	signature:() const
keccak256Gas	libevmasm/GasMeter.h	/^	static unsigned const keccak256Gas = 30;$/;"	m	namespace:dev::eth::GasCosts
keccak256HashCached	libsolidity/interface/CompilerStack.h	/^		h256 mutable keccak256HashCached;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
keccak256WordGas	libevmasm/GasMeter.h	/^	static unsigned const keccak256WordGas = 6;$/;"	m	namespace:dev::eth::GasCosts
keccakf	libdevcore/Keccak256.cpp	/^static inline void keccakf(void* state) {$/;"	f	namespace:dev::__anon23	signature:(void* state)
keyType	libsolidity/ast/AST.h	/^	ElementaryTypeName const& keyType() const { return *m_keyType; }$/;"	f	class:dev::solidity::Mapping	access:public	signature:() const
keyType	libsolidity/ast/Types.h	/^	TypePointer const& keyType() const { return m_keyType; }$/;"	f	class:dev::solidity::MappingType	access:public	signature:() const
keywordByName	liblangutil/Token.cpp	/^static Token keywordByName(string const& _name)$/;"	f	namespace:langutil::TokenTraits	signature:(string const& _name)
kind	libsolidity/analysis/ControlFlowGraph.h	/^	Kind kind() const { return m_occurrenceKind; };$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:() const
kind	libsolidity/ast/ASTAnnotations.h	/^	FunctionCallKind kind = FunctionCallKind::Unset;$/;"	m	struct:dev::solidity::FunctionCallAnnotation	access:public
kind	libsolidity/ast/Types.h	/^	Kind const& kind() const { return m_kind; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
kind	libsolidity/ast/Types.h	/^	Kind kind() const { return m_kind; }$/;"	f	class:dev::solidity::MagicType	access:public	signature:() const
kind	libsolidity/formal/SolverInterface.h	/^	Kind const kind;$/;"	m	struct:dev::solidity::smt::Sort	access:public
kind	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
knownConstant	libevmasm/ExpressionClasses.cpp	/^u256 const* ExpressionClasses::knownConstant(Id _c)$/;"	f	class:ExpressionClasses	signature:(Id _c)
knownConstant	libevmasm/ExpressionClasses.h	/^	u256 const* knownConstant(Id _c);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _c)
knownExpr	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::knownExpr(Expression const& _e) const$/;"	f	class:SMTChecker	signature:(Expression const& _e) const
knownExpr	libsolidity/formal/SMTChecker.h	/^	bool knownExpr(Expression const& _e) const;$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Expression const& _e) const
knownGlobalSymbol	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::knownGlobalSymbol(string const& _var) const$/;"	f	class:SMTChecker	signature:(string const& _var) const
knownGlobalSymbol	libsolidity/formal/SMTChecker.h	/^	bool knownGlobalSymbol(std::string const& _var) const;$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::string const& _var) const
knownNonZero	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownNonZero(Id _c)$/;"	f	class:ExpressionClasses	signature:(Id _c)
knownNonZero	libevmasm/ExpressionClasses.h	/^	bool knownNonZero(Id _c);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _c)
knownToBeDifferent	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownToBeDifferent(ExpressionClasses::Id _a, ExpressionClasses::Id _b)$/;"	f	class:ExpressionClasses	signature:(ExpressionClasses::Id _a, ExpressionClasses::Id _b)
knownToBeDifferent	libevmasm/ExpressionClasses.h	/^	bool knownToBeDifferent(Id _a, Id _b);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _a, Id _b)
knownToBeDifferentBy32	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownToBeDifferentBy32(ExpressionClasses::Id _a, ExpressionClasses::Id _b)$/;"	f	class:ExpressionClasses	signature:(ExpressionClasses::Id _a, ExpressionClasses::Id _b)
knownToBeDifferentBy32	libevmasm/ExpressionClasses.h	/^	bool knownToBeDifferentBy32(Id _a, Id _b);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _a, Id _b)
knownVariable	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::knownVariable(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
knownVariable	libsolidity/formal/SMTChecker.h	/^	bool knownVariable(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
knownZero	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::knownZero(Id _c)$/;"	f	class:ExpressionClasses	signature:(Id _c)
knownZero	libevmasm/ExpressionClasses.h	/^	bool knownZero(Id _c);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(Id _c)
lValueRequested	libsolidity/ast/ASTAnnotations.h	/^	bool lValueRequested = false;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
labelFromIdentifier	libyul/backends/evm/EVMCodeTransform.cpp	/^AbstractAssembly::LabelID CodeTransform::labelFromIdentifier(Identifier const& _identifier)$/;"	f	class:CodeTransform	signature:(Identifier const& _identifier)
labelFromIdentifier	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly::LabelID labelFromIdentifier(Identifier const& _identifier);$/;"	p	class:yul::CodeTransform	access:private	signature:(Identifier const& _identifier)
labelID	libyul/backends/evm/EVMCodeTransform.cpp	/^AbstractAssembly::LabelID CodeTransform::labelID(Scope::Label const& _label)$/;"	f	class:CodeTransform	signature:(Scope::Label const& _label)
labelID	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly::LabelID labelID(Scope::Label const& _label);$/;"	p	class:yul::CodeTransform	access:private	signature:(Scope::Label const& _label)
labelIDs	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Label const*, AbstractAssembly::LabelID> labelIDs;$/;"	m	struct:yul::CodeTransformContext	access:public
labelReferenceSize	libyul/backends/evm/EVMAssembly.cpp	/^size_t constexpr labelReferenceSize = 4;$/;"	m	namespace:__anon4	file:
languageToDialect	libyul/AssemblyStack.cpp	/^shared_ptr<Dialect> languageToDialect(AssemblyStack::Language _language, EVMVersion _version)$/;"	f	namespace:__anon1	signature:(AssemblyStack::Language _language, EVMVersion _version)
langutil	libevmasm/CommonSubexpressionEliminator.h	/^namespace langutil$/;"	n
langutil	libevmasm/ExpressionClasses.h	/^namespace langutil$/;"	n
langutil	libevmasm/KnownState.h	/^namespace langutil$/;"	n
langutil	libevmasm/SimplificationRules.h	/^namespace langutil$/;"	n
langutil	liblangutil/CharStream.h	/^namespace langutil$/;"	n
langutil	liblangutil/Common.h	/^namespace langutil$/;"	n
langutil	liblangutil/EVMVersion.h	/^namespace langutil$/;"	n
langutil	liblangutil/ErrorReporter.h	/^namespace langutil$/;"	n
langutil	liblangutil/Exceptions.h	/^namespace langutil$/;"	n
langutil	liblangutil/ParserBase.h	/^namespace langutil$/;"	n
langutil	liblangutil/Scanner.cpp	/^namespace langutil$/;"	n	file:
langutil	liblangutil/Scanner.h	/^namespace langutil$/;"	n
langutil	liblangutil/SourceLocation.h	/^namespace langutil$/;"	n
langutil	liblangutil/SourceReferenceExtractor.h	/^namespace langutil$/;"	n
langutil	liblangutil/SourceReferenceFormatter.h	/^namespace langutil$/;"	n
langutil	liblangutil/SourceReferenceFormatterHuman.h	/^namespace langutil$/;"	n
langutil	liblangutil/Token.cpp	/^namespace langutil$/;"	n	file:
langutil	liblangutil/Token.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/ConstantEvaluator.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/ContractLevelChecker.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/DocStringAnalyser.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/NameAndTypeResolver.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/PostTypeChecker.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/ReferencesResolver.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/StaticAnalyzer.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/SyntaxChecker.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/TypeChecker.h	/^namespace langutil$/;"	n
langutil	libsolidity/analysis/ViewPureChecker.h	/^namespace langutil$/;"	n
langutil	libsolidity/ast/ASTJsonConverter.h	/^namespace langutil$/;"	n
langutil	libsolidity/formal/SMTChecker.h	/^namespace langutil$/;"	n
langutil	libsolidity/interface/CompilerStack.h	/^namespace langutil$/;"	n
langutil	libsolidity/parsing/DocStringParser.h	/^namespace langutil$/;"	n
langutil	libsolidity/parsing/Parser.h	/^namespace langutil$/;"	n
langutil	libyul/AsmAnalysis.h	/^namespace langutil$/;"	n
langutil	libyul/AsmScopeFiller.h	/^namespace langutil$/;"	n
langutil	libyul/AssemblyStack.h	/^namespace langutil$/;"	n
langutil	libyul/ObjectParser.h	/^namespace langutil$/;"	n
langutil	libyul/backends/evm/AbstractAssembly.h	/^namespace langutil$/;"	n
langutil	libyul/backends/evm/EVMAssembly.h	/^namespace langutil$/;"	n
langutil	libyul/backends/evm/EVMCodeTransform.h	/^namespace langutil$/;"	n
langutil	libyul/backends/evm/NoOutputAssembly.h	/^namespace langutil$/;"	n
langutil::CharStream	liblangutil/CharStream.h	/^class CharStream$/;"	c	namespace:langutil
langutil::CharStream::CharStream	liblangutil/CharStream.h	/^	CharStream() = default;$/;"	p	class:langutil::CharStream	access:public	signature:()
langutil::CharStream::CharStream	liblangutil/CharStream.h	/^	explicit CharStream(std::string const& _source, std::string const& name):$/;"	f	class:langutil::CharStream	access:public	signature:(std::string const& _source, std::string const& name)
langutil::CharStream::advanceAndGet	liblangutil/CharStream.h	/^	char advanceAndGet(size_t _chars = 1);$/;"	p	class:langutil::CharStream	access:public	signature:(size_t _chars = 1)
langutil::CharStream::get	liblangutil/CharStream.h	/^	char get(size_t _charsForward = 0) const { return m_source[m_position + _charsForward]; }$/;"	f	class:langutil::CharStream	access:public	signature:(size_t _charsForward = 0) const
langutil::CharStream::isPastEndOfInput	liblangutil/CharStream.h	/^	bool isPastEndOfInput(size_t _charsForward = 0) const { return (m_position + _charsForward) >= m_source.size(); }$/;"	f	class:langutil::CharStream	access:public	signature:(size_t _charsForward = 0) const
langutil::CharStream::lineAtPosition	liblangutil/CharStream.h	/^	std::string lineAtPosition(int _position) const;$/;"	p	class:langutil::CharStream	access:public	signature:(int _position) const
langutil::CharStream::m_name	liblangutil/CharStream.h	/^	std::string m_name;$/;"	m	class:langutil::CharStream	access:private
langutil::CharStream::m_source	liblangutil/CharStream.h	/^	std::string m_source;$/;"	m	class:langutil::CharStream	access:private
langutil::CharStream::position	liblangutil/CharStream.h	/^	int position() const { return m_position; }$/;"	f	class:langutil::CharStream	access:public	signature:() const
langutil::CharStream::reset	liblangutil/CharStream.h	/^	void reset() { m_position = 0; }$/;"	f	class:langutil::CharStream	access:public	signature:()
langutil::CharStream::rollback	liblangutil/CharStream.h	/^	char rollback(size_t _amount);$/;"	p	class:langutil::CharStream	access:public	signature:(size_t _amount)
langutil::CharStream::translatePositionToLineColumn	liblangutil/CharStream.h	/^	std::tuple<int, int> translatePositionToLineColumn(int _position) const;$/;"	p	class:langutil::CharStream	access:public	signature:(int _position) const
langutil::CompilerError	liblangutil/Exceptions.h	/^struct CompilerError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
langutil::EVMVersion	liblangutil/EVMVersion.h	/^class EVMVersion:$/;"	c	namespace:langutil	inherits:boost::less_than_comparable,boost::equality_comparable
langutil::EVMVersion::EVMVersion	liblangutil/EVMVersion.h	/^	EVMVersion() = default;$/;"	p	class:langutil::EVMVersion	access:public	signature:()
langutil::EVMVersion::EVMVersion	liblangutil/EVMVersion.h	/^	EVMVersion(Version _version): m_version(_version) {}$/;"	f	class:langutil::EVMVersion	access:private	signature:(Version _version)
langutil::EVMVersion::Version	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	c	class:langutil::EVMVersion	access:private
langutil::EVMVersion::Version::Byzantium	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
langutil::EVMVersion::Version::Constantinople	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
langutil::EVMVersion::Version::Homestead	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
langutil::EVMVersion::Version::SpuriousDragon	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
langutil::EVMVersion::Version::TangerineWhistle	liblangutil/EVMVersion.h	/^	enum class Version { Homestead, TangerineWhistle, SpuriousDragon, Byzantium, Constantinople, Petersburg };$/;"	m	class:langutil::EVMVersion::Version	access:private
langutil::EVMVersion::byzantium	liblangutil/EVMVersion.h	/^	static EVMVersion byzantium() { return {Version::Byzantium}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
langutil::EVMVersion::canOverchargeGasForCall	liblangutil/EVMVersion.h	/^	bool canOverchargeGasForCall() const { return *this >= tangerineWhistle(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::constantinople	liblangutil/EVMVersion.h	/^	static EVMVersion constantinople() { return {Version::Constantinople}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
langutil::EVMVersion::fromString	liblangutil/EVMVersion.h	/^	static boost::optional<EVMVersion> fromString(std::string const& _version)$/;"	f	class:langutil::EVMVersion	access:public	signature:(std::string const& _version)
langutil::EVMVersion::hasBitwiseShifting	liblangutil/EVMVersion.h	/^	bool hasBitwiseShifting() const { return *this >= constantinople(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::hasCreate2	liblangutil/EVMVersion.h	/^	bool hasCreate2() const { return *this >= constantinople(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::hasExtCodeHash	liblangutil/EVMVersion.h	/^	bool hasExtCodeHash() const { return *this >= constantinople(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::hasStaticCall	liblangutil/EVMVersion.h	/^	bool hasStaticCall() const { return *this >= byzantium(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::homestead	liblangutil/EVMVersion.h	/^	static EVMVersion homestead() { return {Version::Homestead}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
langutil::EVMVersion::m_version	liblangutil/EVMVersion.h	/^	Version m_version = Version::Petersburg;$/;"	m	class:langutil::EVMVersion	access:private
langutil::EVMVersion::name	liblangutil/EVMVersion.h	/^	std::string name() const$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::operator <	liblangutil/EVMVersion.h	/^	bool operator<(EVMVersion const& _other) const { return m_version < _other.m_version; }$/;"	f	class:langutil::EVMVersion	access:public	signature:(EVMVersion const& _other) const
langutil::EVMVersion::operator ==	liblangutil/EVMVersion.h	/^	bool operator==(EVMVersion const& _other) const { return m_version == _other.m_version; }$/;"	f	class:langutil::EVMVersion	access:public	signature:(EVMVersion const& _other) const
langutil::EVMVersion::petersburg	liblangutil/EVMVersion.h	/^	static EVMVersion petersburg() { return {Version::Petersburg}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
langutil::EVMVersion::spuriousDragon	liblangutil/EVMVersion.h	/^	static EVMVersion spuriousDragon() { return {Version::SpuriousDragon}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
langutil::EVMVersion::supportsReturndata	liblangutil/EVMVersion.h	/^	bool supportsReturndata() const { return *this >= byzantium(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
langutil::EVMVersion::tangerineWhistle	liblangutil/EVMVersion.h	/^	static EVMVersion tangerineWhistle() { return {Version::TangerineWhistle}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
langutil::ElementaryTypeNameToken	liblangutil/Token.h	/^class ElementaryTypeNameToken$/;"	c	namespace:langutil
langutil::ElementaryTypeNameToken::ElementaryTypeNameToken	liblangutil/Token.h	/^	ElementaryTypeNameToken(Token _token, unsigned const& _firstNumber, unsigned const& _secondNumber)$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:(Token _token, unsigned const& _firstNumber, unsigned const& _secondNumber)
langutil::ElementaryTypeNameToken::assertDetails	liblangutil/Token.cpp	/^void ElementaryTypeNameToken::assertDetails(Token _baseType, unsigned const& _first, unsigned const& _second)$/;"	f	class:langutil::ElementaryTypeNameToken	signature:(Token _baseType, unsigned const& _first, unsigned const& _second)
langutil::ElementaryTypeNameToken::assertDetails	liblangutil/Token.h	/^	void assertDetails(Token _baseType, unsigned const& _first, unsigned const& _second);$/;"	p	class:langutil::ElementaryTypeNameToken	access:private	signature:(Token _baseType, unsigned const& _first, unsigned const& _second)
langutil::ElementaryTypeNameToken::firstNumber	liblangutil/Token.h	/^	unsigned int firstNumber() const { return m_firstNumber; }$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:() const
langutil::ElementaryTypeNameToken::m_firstNumber	liblangutil/Token.h	/^	unsigned int m_firstNumber;$/;"	m	class:langutil::ElementaryTypeNameToken	access:private
langutil::ElementaryTypeNameToken::m_secondNumber	liblangutil/Token.h	/^	unsigned int m_secondNumber;$/;"	m	class:langutil::ElementaryTypeNameToken	access:private
langutil::ElementaryTypeNameToken::m_token	liblangutil/Token.h	/^	Token m_token;$/;"	m	class:langutil::ElementaryTypeNameToken	access:private
langutil::ElementaryTypeNameToken::secondNumber	liblangutil/Token.h	/^	unsigned int secondNumber() const { return m_secondNumber; }$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:() const
langutil::ElementaryTypeNameToken::toString	liblangutil/Token.h	/^	std::string toString(bool const& tokenValue = false) const$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:(bool const& tokenValue = false) const
langutil::ElementaryTypeNameToken::token	liblangutil/Token.h	/^	Token token() const { return m_token; }$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:() const
langutil::Error	liblangutil/Exceptions.h	/^class Error: virtual public dev::Exception$/;"	c	namespace:langutil	inherits:dev::Exception
langutil::Error::Error	liblangutil/Exceptions.h	/^	Error(Type _type, std::string const& _description, SourceLocation const& _location = SourceLocation());$/;"	p	class:langutil::Error	access:public	signature:(Type _type, std::string const& _description, SourceLocation const& _location = SourceLocation())
langutil::Error::Error	liblangutil/Exceptions.h	/^	explicit Error($/;"	p	class:langutil::Error	access:public	signature:( Type _type, SourceLocation const& _location = SourceLocation(), std::string const& _description = std::string() )
langutil::Error::Type	liblangutil/Exceptions.h	/^	enum class Type$/;"	c	class:langutil::Error	access:public
langutil::Error::Type::DeclarationError	liblangutil/Exceptions.h	/^		DeclarationError,$/;"	m	class:langutil::Error::Type	access:private
langutil::Error::Type::DocstringParsingError	liblangutil/Exceptions.h	/^		DocstringParsingError,$/;"	m	class:langutil::Error::Type	access:private
langutil::Error::Type::ParserError	liblangutil/Exceptions.h	/^		ParserError,$/;"	m	class:langutil::Error::Type	access:private
langutil::Error::Type::SyntaxError	liblangutil/Exceptions.h	/^		SyntaxError,$/;"	m	class:langutil::Error::Type	access:private
langutil::Error::Type::TypeError	liblangutil/Exceptions.h	/^		TypeError,$/;"	m	class:langutil::Error::Type	access:private
langutil::Error::containsErrorOfType	liblangutil/Exceptions.h	/^	static Error const* containsErrorOfType(ErrorList const& _list, Error::Type _type)$/;"	f	class:langutil::Error	access:public	signature:(ErrorList const& _list, Error::Type _type)
langutil::Error::containsOnlyWarnings	liblangutil/Exceptions.h	/^	static bool containsOnlyWarnings(ErrorList const& _list)$/;"	f	class:langutil::Error	access:public	signature:(ErrorList const& _list)
langutil::Error::m_type	liblangutil/Exceptions.h	/^	Type m_type;$/;"	m	class:langutil::Error	access:private
langutil::Error::m_typeName	liblangutil/Exceptions.h	/^	std::string m_typeName;$/;"	m	class:langutil::Error	access:private
langutil::Error::std::typeName	liblangutil/Exceptions.h	/^	std::string const& typeName() const { return m_typeName; }$/;"	f	class:langutil::Error::std	access:public	signature:() const
langutil::Error::type	liblangutil/Exceptions.h	/^	Type type() const { return m_type; }$/;"	f	class:langutil::Error	access:public	signature:() const
langutil::ErrorReporter	liblangutil/ErrorReporter.h	/^class ErrorReporter$/;"	c	namespace:langutil
langutil::ErrorReporter::ErrorReporter	liblangutil/ErrorReporter.h	/^	explicit ErrorReporter(ErrorList& _errors):$/;"	f	class:langutil::ErrorReporter	access:public	signature:(ErrorList& _errors)
langutil::ErrorReporter::append	liblangutil/ErrorReporter.h	/^	void append(ErrorList const& _errorList)$/;"	f	class:langutil::ErrorReporter	access:public	signature:(ErrorList const& _errorList)
langutil::ErrorReporter::c_maxErrorsAllowed	liblangutil/ErrorReporter.h	/^	unsigned const c_maxErrorsAllowed = 256;$/;"	m	class:langutil::ErrorReporter	access:private
langutil::ErrorReporter::c_maxWarningsAllowed	liblangutil/ErrorReporter.h	/^	unsigned const c_maxWarningsAllowed = 256;$/;"	m	class:langutil::ErrorReporter	access:private
langutil::ErrorReporter::checkForExcessiveErrors	liblangutil/ErrorReporter.h	/^	bool checkForExcessiveErrors(Error::Type _type);$/;"	p	class:langutil::ErrorReporter	access:private	signature:(Error::Type _type)
langutil::ErrorReporter::clear	liblangutil/ErrorReporter.h	/^	void clear();$/;"	p	class:langutil::ErrorReporter	access:public	signature:()
langutil::ErrorReporter::declarationError	liblangutil/ErrorReporter.h	/^	void declarationError($/;"	p	class:langutil::ErrorReporter	access:public	signature:( SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, std::string const& _description )
langutil::ErrorReporter::declarationError	liblangutil/ErrorReporter.h	/^	void declarationError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::docstringParsingError	liblangutil/ErrorReporter.h	/^	void docstringParsingError(std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(std::string const& _description)
langutil::ErrorReporter::error	liblangutil/ErrorReporter.h	/^	void error($/;"	p	class:langutil::ErrorReporter	access:private	signature:( Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, std::string const& _description = std::string())
langutil::ErrorReporter::error	liblangutil/ErrorReporter.h	/^	void error($/;"	p	class:langutil::ErrorReporter	access:public	signature:( Error::Type _type, SourceLocation const& _location, std::string const& _description )
langutil::ErrorReporter::errors	liblangutil/ErrorReporter.h	/^	ErrorList const& errors() const;$/;"	p	class:langutil::ErrorReporter	access:public	signature:() const
langutil::ErrorReporter::fatalDeclarationError	liblangutil/ErrorReporter.h	/^	void fatalDeclarationError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::fatalError	liblangutil/ErrorReporter.h	/^	void fatalError($/;"	p	class:langutil::ErrorReporter	access:private	signature:( Error::Type _type, SourceLocation const& _location = SourceLocation(), std::string const& _description = std::string())
langutil::ErrorReporter::fatalError	liblangutil/ErrorReporter.h	/^	void fatalError($/;"	p	class:langutil::ErrorReporter	access:private	signature:( Error::Type _type, SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, std::string const& _description = std::string())
langutil::ErrorReporter::fatalParserError	liblangutil/ErrorReporter.h	/^	void fatalParserError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::fatalTypeError	liblangutil/ErrorReporter.h	/^	void fatalTypeError(SourceLocation const& _location, SecondarySourceLocation const& _secondLocation, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondLocation, std::string const& _description)
langutil::ErrorReporter::fatalTypeError	liblangutil/ErrorReporter.h	/^	void fatalTypeError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::hasErrors	liblangutil/ErrorReporter.h	/^	bool hasErrors() const$/;"	f	class:langutil::ErrorReporter	access:public	signature:() const
langutil::ErrorReporter::m_errorCount	liblangutil/ErrorReporter.h	/^	unsigned m_errorCount = 0;$/;"	m	class:langutil::ErrorReporter	access:private
langutil::ErrorReporter::m_errorList	liblangutil/ErrorReporter.h	/^		m_errorList(_errorReporter.m_errorList) { }$/;"	f	class:langutil::ErrorReporter	access:public	signature:(_errorReporter.m_errorList)
langutil::ErrorReporter::m_errorList	liblangutil/ErrorReporter.h	/^	ErrorList& m_errorList;$/;"	m	class:langutil::ErrorReporter	access:private
langutil::ErrorReporter::m_warningCount	liblangutil/ErrorReporter.h	/^	unsigned m_warningCount = 0;$/;"	m	class:langutil::ErrorReporter	access:private
langutil::ErrorReporter::operator =	liblangutil/ErrorReporter.h	/^	ErrorReporter& operator=(ErrorReporter const& _errorReporter);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(ErrorReporter const& _errorReporter)
langutil::ErrorReporter::parserError	liblangutil/ErrorReporter.h	/^	void parserError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::syntaxError	liblangutil/ErrorReporter.h	/^	void syntaxError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::typeError	liblangutil/ErrorReporter.h	/^	void typeError($/;"	p	class:langutil::ErrorReporter	access:public	signature:( SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation = SecondarySourceLocation(), std::string const& _description = std::string() )
langutil::ErrorReporter::typeError	liblangutil/ErrorReporter.h	/^	void typeError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::typeErrorConcatenateDescriptions	liblangutil/ErrorReporter.h	/^	void typeErrorConcatenateDescriptions(SourceLocation const& _location, Strings const&... _descriptions)$/;"	f	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, Strings const&... _descriptions)
langutil::ErrorReporter::warning	liblangutil/ErrorReporter.h	/^	void warning($/;"	p	class:langutil::ErrorReporter	access:public	signature:( SourceLocation const& _location, std::string const& _description, SecondarySourceLocation const& _secondaryLocation )
langutil::ErrorReporter::warning	liblangutil/ErrorReporter.h	/^	void warning(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
langutil::ErrorReporter::warning	liblangutil/ErrorReporter.h	/^	void warning(std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(std::string const& _description)
langutil::FatalError	liblangutil/Exceptions.h	/^struct FatalError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
langutil::InternalCompilerError	liblangutil/Exceptions.h	/^struct InternalCompilerError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
langutil::LITERAL_TYPE_COMMENT	liblangutil/Scanner.cpp	/^	LITERAL_TYPE_COMMENT$/;"	e	enum:langutil::LiteralType	file:
langutil::LITERAL_TYPE_NUMBER	liblangutil/Scanner.cpp	/^	LITERAL_TYPE_NUMBER, \/\/ not really different from string type in behaviour$/;"	e	enum:langutil::LiteralType	file:
langutil::LITERAL_TYPE_STRING	liblangutil/Scanner.cpp	/^	LITERAL_TYPE_STRING,$/;"	e	enum:langutil::LiteralType	file:
langutil::LineColumn	liblangutil/SourceReferenceExtractor.h	/^struct LineColumn$/;"	s	namespace:langutil
langutil::LineColumn::LineColumn	liblangutil/SourceReferenceExtractor.h	/^	LineColumn() = default;$/;"	p	struct:langutil::LineColumn	access:public	signature:()
langutil::LineColumn::LineColumn	liblangutil/SourceReferenceExtractor.h	/^	LineColumn(std::tuple<int, int> const& _t): line{std::get<0>(_t)}, column{std::get<1>(_t)} {}$/;"	f	struct:langutil::LineColumn	access:public	signature:(std::tuple<int, int> const& _t)
langutil::LineColumn::column	liblangutil/SourceReferenceExtractor.h	/^	int column = {-1};$/;"	m	struct:langutil::LineColumn	access:public
langutil::LineColumn::line	liblangutil/SourceReferenceExtractor.h	/^	int line = {-1};$/;"	m	struct:langutil::LineColumn	access:public
langutil::LiteralScope	liblangutil/Scanner.cpp	/^class LiteralScope$/;"	c	namespace:langutil	file:
langutil::LiteralScope::LiteralScope	liblangutil/Scanner.cpp	/^	explicit LiteralScope(Scanner* _self, enum LiteralType _type): m_type(_type)$/;"	f	class:langutil::LiteralScope	access:public	signature:(Scanner* _self, enum LiteralType _type)
langutil::LiteralScope::complete	liblangutil/Scanner.cpp	/^	void complete() { m_complete = true; }$/;"	f	class:langutil::LiteralScope	access:public	signature:()
langutil::LiteralScope::m_complete	liblangutil/Scanner.cpp	/^	bool m_complete;$/;"	m	class:langutil::LiteralScope	file:	access:private
langutil::LiteralScope::m_scanner	liblangutil/Scanner.cpp	/^	Scanner* m_scanner;$/;"	m	class:langutil::LiteralScope	file:	access:private
langutil::LiteralScope::m_type	liblangutil/Scanner.cpp	/^	enum LiteralType m_type;$/;"	m	class:langutil::LiteralScope	typeref:enum:langutil::LiteralScope::LiteralType	file:	access:private
langutil::LiteralScope::~LiteralScope	liblangutil/Scanner.cpp	/^	~LiteralScope()$/;"	f	class:langutil::LiteralScope	access:public	signature:()
langutil::LiteralType	liblangutil/Scanner.cpp	/^enum LiteralType {$/;"	g	namespace:langutil	file:
langutil::ParserBase	liblangutil/ParserBase.h	/^class ParserBase$/;"	c	namespace:langutil
langutil::ParserBase::ParserBase	liblangutil/ParserBase.h	/^	explicit ParserBase(ErrorReporter& errorReporter): m_errorReporter(errorReporter) {}$/;"	f	class:langutil::ParserBase	access:public	signature:(ErrorReporter& errorReporter)
langutil::ParserBase::RecursionGuard	liblangutil/ParserBase.h	/^	class RecursionGuard$/;"	c	class:langutil::ParserBase	access:protected
langutil::ParserBase::RecursionGuard::RecursionGuard	liblangutil/ParserBase.h	/^		explicit RecursionGuard(ParserBase& _parser): m_parser(_parser)$/;"	f	class:langutil::ParserBase::RecursionGuard	access:public	signature:(ParserBase& _parser)
langutil::ParserBase::RecursionGuard::m_parser	liblangutil/ParserBase.h	/^		ParserBase& m_parser;$/;"	m	class:langutil::ParserBase::RecursionGuard	access:private
langutil::ParserBase::RecursionGuard::~RecursionGuard	liblangutil/ParserBase.h	/^		~RecursionGuard() { m_parser.decreaseRecursionDepth(); }$/;"	f	class:langutil::ParserBase::RecursionGuard	access:public	signature:()
langutil::ParserBase::advance	liblangutil/ParserBase.h	/^	Token advance();$/;"	p	class:langutil::ParserBase	access:protected	signature:()
langutil::ParserBase::currentLiteral	liblangutil/ParserBase.h	/^	std::string currentLiteral() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
langutil::ParserBase::currentToken	liblangutil/ParserBase.h	/^	Token currentToken() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
langutil::ParserBase::decreaseRecursionDepth	liblangutil/ParserBase.h	/^	void decreaseRecursionDepth();$/;"	p	class:langutil::ParserBase	access:protected	signature:()
langutil::ParserBase::endPosition	liblangutil/ParserBase.h	/^	int endPosition() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
langutil::ParserBase::expectToken	liblangutil/ParserBase.h	/^	void expectToken(Token _value, bool _advance = true);$/;"	p	class:langutil::ParserBase	access:protected	signature:(Token _value, bool _advance = true)
langutil::ParserBase::fatalParserError	liblangutil/ParserBase.h	/^	void fatalParserError(std::string const& _description);$/;"	p	class:langutil::ParserBase	access:protected	signature:(std::string const& _description)
langutil::ParserBase::increaseRecursionDepth	liblangutil/ParserBase.h	/^	void increaseRecursionDepth();$/;"	p	class:langutil::ParserBase	access:protected	signature:()
langutil::ParserBase::m_errorReporter	liblangutil/ParserBase.h	/^	ErrorReporter& m_errorReporter;$/;"	m	class:langutil::ParserBase	access:protected
langutil::ParserBase::m_recursionDepth	liblangutil/ParserBase.h	/^	size_t m_recursionDepth = 0;$/;"	m	class:langutil::ParserBase	access:protected
langutil::ParserBase::m_scanner	liblangutil/ParserBase.h	/^	std::shared_ptr<Scanner> m_scanner;$/;"	m	class:langutil::ParserBase	access:protected
langutil::ParserBase::parserError	liblangutil/ParserBase.h	/^	void parserError(std::string const& _description);$/;"	p	class:langutil::ParserBase	access:protected	signature:(std::string const& _description)
langutil::ParserBase::peekNextToken	liblangutil/ParserBase.h	/^	Token peekNextToken() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
langutil::ParserBase::position	liblangutil/ParserBase.h	/^	int position() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
langutil::ParserBase::source	liblangutil/ParserBase.h	/^	std::shared_ptr<CharStream> source() const { return m_scanner->charStream(); }$/;"	f	class:langutil::ParserBase	access:public	signature:() const
langutil::Scanner	liblangutil/Scanner.h	/^class Scanner$/;"	c	namespace:langutil
langutil::Scanner::Scanner	liblangutil/Scanner.h	/^	explicit Scanner(CharStream _source = CharStream()) { reset(std::move(_source)); }$/;"	f	class:langutil::Scanner	access:public	signature:(CharStream _source = CharStream())
langutil::Scanner::Scanner	liblangutil/Scanner.h	/^	explicit Scanner(std::shared_ptr<CharStream> _source) { reset(std::move(_source)); }$/;"	f	class:langutil::Scanner	access:public	signature:(std::shared_ptr<CharStream> _source)
langutil::Scanner::TokenDesc	liblangutil/Scanner.h	/^	struct TokenDesc$/;"	s	class:langutil::Scanner	access:private
langutil::Scanner::TokenDesc::error	liblangutil/Scanner.h	/^		ScannerError error = ScannerError::NoError;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
langutil::Scanner::TokenDesc::extendedTokenInfo	liblangutil/Scanner.h	/^		std::tuple<unsigned, unsigned> extendedTokenInfo;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
langutil::Scanner::TokenDesc::literal	liblangutil/Scanner.h	/^		std::string literal;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
langutil::Scanner::TokenDesc::location	liblangutil/Scanner.h	/^		SourceLocation location;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
langutil::Scanner::TokenDesc::token	liblangutil/Scanner.h	/^		Token token;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
langutil::Scanner::addCommentLiteralChar	liblangutil/Scanner.h	/^	inline void addCommentLiteralChar(char c) { m_nextSkippedComment.literal.push_back(c); }$/;"	f	class:langutil::Scanner	access:private	signature:(char c)
langutil::Scanner::addLiteralChar	liblangutil/Scanner.h	/^	inline void addLiteralChar(char c) { m_nextToken.literal.push_back(c); }$/;"	f	class:langutil::Scanner	access:private	signature:(char c)
langutil::Scanner::addLiteralCharAndAdvance	liblangutil/Scanner.h	/^	inline void addLiteralCharAndAdvance() { addLiteralChar(m_char); advance(); }$/;"	f	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::addUnicodeAsUTF8	liblangutil/Scanner.cpp	/^void Scanner::addUnicodeAsUTF8(unsigned codepoint)$/;"	f	class:langutil::Scanner	signature:(unsigned codepoint)
langutil::Scanner::addUnicodeAsUTF8	liblangutil/Scanner.h	/^	void addUnicodeAsUTF8(unsigned codepoint);$/;"	p	class:langutil::Scanner	access:private	signature:(unsigned codepoint)
langutil::Scanner::advance	liblangutil/Scanner.h	/^	bool advance() { m_char = m_source->advanceAndGet(); return !m_source->isPastEndOfInput(); }$/;"	f	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::clearCurrentCommentLiteral	liblangutil/Scanner.h	/^	void clearCurrentCommentLiteral() { m_skippedComment.literal.clear(); }$/;"	f	class:langutil::Scanner	access:public	signature:()
langutil::Scanner::currentCommentLocation	liblangutil/Scanner.h	/^	SourceLocation currentCommentLocation() const { return m_skippedComment.location; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
langutil::Scanner::currentElementaryTypeNameToken	liblangutil/Scanner.h	/^	ElementaryTypeNameToken currentElementaryTypeNameToken() const$/;"	f	class:langutil::Scanner	access:public	signature:() const
langutil::Scanner::currentLocation	liblangutil/Scanner.h	/^	SourceLocation currentLocation() const { return m_currentToken.location; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
langutil::Scanner::currentToken	liblangutil/Scanner.h	/^	Token currentToken() const$/;"	f	class:langutil::Scanner	access:public	signature:() const
langutil::Scanner::isSourcePastEndOfInput	liblangutil/Scanner.h	/^	bool isSourcePastEndOfInput() const { return m_source->isPastEndOfInput(); }$/;"	f	class:langutil::Scanner	access:private	signature:() const
langutil::Scanner::isUnicodeLinebreak	liblangutil/Scanner.cpp	/^bool Scanner::isUnicodeLinebreak()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::isUnicodeLinebreak	liblangutil/Scanner.h	/^	bool isUnicodeLinebreak();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::lineAtPosition	liblangutil/Scanner.h	/^	std::string lineAtPosition(int _position) const { return m_source->lineAtPosition(_position); }$/;"	f	class:langutil::Scanner	access:public	signature:(int _position) const
langutil::Scanner::m_char	liblangutil/Scanner.h	/^	char m_char;$/;"	m	class:langutil::Scanner	access:private
langutil::Scanner::m_currentToken	liblangutil/Scanner.h	/^	TokenDesc m_currentToken;  \/\/ desc for current token (as returned by Next())$/;"	m	class:langutil::Scanner	access:private
langutil::Scanner::m_nextSkippedComment	liblangutil/Scanner.h	/^	TokenDesc m_nextSkippedComment; \/\/ desc for next skipped comment$/;"	m	class:langutil::Scanner	access:private
langutil::Scanner::m_nextToken	liblangutil/Scanner.h	/^	TokenDesc m_nextToken;     \/\/ desc for next token (one token look-ahead)$/;"	m	class:langutil::Scanner	access:private
langutil::Scanner::m_skippedComment	liblangutil/Scanner.h	/^	TokenDesc m_skippedComment;  \/\/ desc for current skipped comment$/;"	m	class:langutil::Scanner	access:private
langutil::Scanner::m_source	liblangutil/Scanner.h	/^	std::shared_ptr<CharStream> m_source;$/;"	m	class:langutil::Scanner	access:private
langutil::Scanner::next	liblangutil/Scanner.cpp	/^Token Scanner::next()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::next	liblangutil/Scanner.h	/^	Token next();$/;"	p	class:langutil::Scanner	access:public	signature:()
langutil::Scanner::peekLocation	liblangutil/Scanner.h	/^	SourceLocation peekLocation() const { return m_nextToken.location; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
langutil::Scanner::peekNextToken	liblangutil/Scanner.h	/^	Token peekNextToken() const { return m_nextToken.token; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
langutil::Scanner::reset	liblangutil/Scanner.cpp	/^void Scanner::reset()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::reset	liblangutil/Scanner.cpp	/^void Scanner::reset(CharStream _source)$/;"	f	class:langutil::Scanner	signature:(CharStream _source)
langutil::Scanner::reset	liblangutil/Scanner.cpp	/^void Scanner::reset(std::shared_ptr<CharStream> _source)$/;"	f	class:langutil::Scanner	signature:(std::shared_ptr<CharStream> _source)
langutil::Scanner::reset	liblangutil/Scanner.h	/^	void reset();$/;"	p	class:langutil::Scanner	access:public	signature:()
langutil::Scanner::reset	liblangutil/Scanner.h	/^	void reset(CharStream _source);$/;"	p	class:langutil::Scanner	access:public	signature:(CharStream _source)
langutil::Scanner::reset	liblangutil/Scanner.h	/^	void reset(std::shared_ptr<CharStream> _source);$/;"	p	class:langutil::Scanner	access:public	signature:(std::shared_ptr<CharStream> _source)
langutil::Scanner::rollback	liblangutil/Scanner.h	/^	void rollback(int _amount) { m_char = m_source->rollback(_amount); }$/;"	f	class:langutil::Scanner	access:private	signature:(int _amount)
langutil::Scanner::scanDecimalDigits	liblangutil/Scanner.cpp	/^void Scanner::scanDecimalDigits()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanDecimalDigits	liblangutil/Scanner.h	/^	void scanDecimalDigits();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanEscape	liblangutil/Scanner.cpp	/^bool Scanner::scanEscape()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanEscape	liblangutil/Scanner.h	/^	bool scanEscape();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanHexByte	liblangutil/Scanner.cpp	/^bool Scanner::scanHexByte(char& o_scannedByte)$/;"	f	class:langutil::Scanner	signature:(char& o_scannedByte)
langutil::Scanner::scanHexByte	liblangutil/Scanner.h	/^	bool scanHexByte(char& o_scannedByte);$/;"	p	class:langutil::Scanner	access:private	signature:(char& o_scannedByte)
langutil::Scanner::scanHexString	liblangutil/Scanner.cpp	/^Token Scanner::scanHexString()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanHexString	liblangutil/Scanner.h	/^	Token scanHexString();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanIdentifierOrKeyword	liblangutil/Scanner.cpp	/^tuple<Token, unsigned, unsigned> Scanner::scanIdentifierOrKeyword()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanIdentifierOrKeyword	liblangutil/Scanner.h	/^	std::tuple<Token, unsigned, unsigned> scanIdentifierOrKeyword();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanMultiLineDocComment	liblangutil/Scanner.cpp	/^Token Scanner::scanMultiLineDocComment()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanMultiLineDocComment	liblangutil/Scanner.h	/^	Token scanMultiLineDocComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanNumber	liblangutil/Scanner.cpp	/^Token Scanner::scanNumber(char _charSeen)$/;"	f	class:langutil::Scanner	signature:(char _charSeen)
langutil::Scanner::scanNumber	liblangutil/Scanner.h	/^	Token scanNumber(char _charSeen = 0);$/;"	p	class:langutil::Scanner	access:private	signature:(char _charSeen = 0)
langutil::Scanner::scanSingleLineDocComment	liblangutil/Scanner.cpp	/^Token Scanner::scanSingleLineDocComment()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanSingleLineDocComment	liblangutil/Scanner.h	/^	Token scanSingleLineDocComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanSlash	liblangutil/Scanner.cpp	/^Token Scanner::scanSlash()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanSlash	liblangutil/Scanner.h	/^	Token scanSlash();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanString	liblangutil/Scanner.cpp	/^Token Scanner::scanString()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanString	liblangutil/Scanner.h	/^	Token scanString();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanToken	liblangutil/Scanner.cpp	/^void Scanner::scanToken()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::scanToken	liblangutil/Scanner.h	/^	void scanToken();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::scanUnicode	liblangutil/Scanner.cpp	/^bool Scanner::scanUnicode(unsigned & o_codepoint)$/;"	f	class:langutil::Scanner	signature:(unsigned & o_codepoint)
langutil::Scanner::scanUnicode	liblangutil/Scanner.h	/^	bool scanUnicode(unsigned& o_codepoint);$/;"	p	class:langutil::Scanner	access:private	signature:(unsigned& o_codepoint)
langutil::Scanner::selectErrorToken	liblangutil/Scanner.h	/^	inline Token selectErrorToken(ScannerError _err) { advance(); return setError(_err); }$/;"	f	class:langutil::Scanner	access:private	signature:(ScannerError _err)
langutil::Scanner::selectToken	liblangutil/Scanner.cpp	/^Token Scanner::selectToken(char _next, Token _then, Token _else)$/;"	f	class:langutil::Scanner	signature:(char _next, Token _then, Token _else)
langutil::Scanner::selectToken	liblangutil/Scanner.h	/^	inline Token selectToken(Token _tok) { advance(); return _tok; }$/;"	f	class:langutil::Scanner	access:private	signature:(Token _tok)
langutil::Scanner::selectToken	liblangutil/Scanner.h	/^	inline Token selectToken(char _next, Token _then, Token _else);$/;"	p	class:langutil::Scanner	access:private	signature:(char _next, Token _then, Token _else)
langutil::Scanner::skipMultiLineComment	liblangutil/Scanner.cpp	/^Token Scanner::skipMultiLineComment()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::skipMultiLineComment	liblangutil/Scanner.h	/^	Token skipMultiLineComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::skipSingleLineComment	liblangutil/Scanner.cpp	/^Token Scanner::skipSingleLineComment()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::skipSingleLineComment	liblangutil/Scanner.h	/^	Token skipSingleLineComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::skipWhitespace	liblangutil/Scanner.cpp	/^bool Scanner::skipWhitespace()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::skipWhitespace	liblangutil/Scanner.h	/^	bool skipWhitespace();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::skipWhitespaceExceptUnicodeLinebreak	liblangutil/Scanner.cpp	/^void Scanner::skipWhitespaceExceptUnicodeLinebreak()$/;"	f	class:langutil::Scanner	signature:()
langutil::Scanner::skipWhitespaceExceptUnicodeLinebreak	liblangutil/Scanner.h	/^	void skipWhitespaceExceptUnicodeLinebreak();$/;"	p	class:langutil::Scanner	access:private	signature:()
langutil::Scanner::sourceAt	liblangutil/Scanner.h	/^	std::string sourceAt(SourceLocation const& _location) const$/;"	f	class:langutil::Scanner	access:public	signature:(SourceLocation const& _location) const
langutil::Scanner::sourcePos	liblangutil/Scanner.h	/^	int sourcePos() const { return m_source->position(); }$/;"	f	class:langutil::Scanner	access:private	signature:() const
langutil::Scanner::std::currentCommentLiteral	liblangutil/Scanner.h	/^	std::string const& currentCommentLiteral() const { return m_skippedComment.literal; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
langutil::Scanner::std::currentLiteral	liblangutil/Scanner.h	/^	std::string const& currentLiteral() const { return m_currentToken.literal; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
langutil::Scanner::std::currentTokenInfo	liblangutil/Scanner.h	/^	std::tuple<unsigned, unsigned> const& currentTokenInfo() const { return m_currentToken.extendedTokenInfo; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
langutil::Scanner::std::peekLiteral	liblangutil/Scanner.h	/^	std::string const& peekLiteral() const { return m_nextToken.literal; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
langutil::Scanner::translatePositionToLineColumn	liblangutil/Scanner.h	/^	std::tuple<int, int> translatePositionToLineColumn(int _position) const { return m_source->translatePositionToLineColumn(_position); }$/;"	f	class:langutil::Scanner	access:public	signature:(int _position) const
langutil::ScannerError	liblangutil/Scanner.h	/^enum class ScannerError$/;"	c	namespace:langutil
langutil::ScannerError::IllegalCommentTerminator	liblangutil/Scanner.h	/^	IllegalCommentTerminator,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalEscapeSequence	liblangutil/Scanner.h	/^	IllegalEscapeSequence,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalExponent	liblangutil/Scanner.h	/^	IllegalExponent,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalHexDigit	liblangutil/Scanner.h	/^	IllegalHexDigit,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalHexString	liblangutil/Scanner.h	/^	IllegalHexString,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalNumberEnd	liblangutil/Scanner.h	/^	IllegalNumberEnd,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalNumberSeparator	liblangutil/Scanner.h	/^	IllegalNumberSeparator,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalStringEndQuote	liblangutil/Scanner.h	/^	IllegalStringEndQuote,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::IllegalToken	liblangutil/Scanner.h	/^	IllegalToken,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::NoError	liblangutil/Scanner.h	/^	NoError,$/;"	m	class:langutil::ScannerError	access:private
langutil::ScannerError::OctalNotAllowed	liblangutil/Scanner.h	/^	OctalNotAllowed,$/;"	m	class:langutil::ScannerError	access:private
langutil::SecondarySourceLocation	liblangutil/Exceptions.h	/^class SecondarySourceLocation$/;"	c	namespace:langutil
langutil::SecondarySourceLocation::append	liblangutil/Exceptions.h	/^	SecondarySourceLocation& append(std::string const& _errMsg, SourceLocation const& _sourceLocation)$/;"	f	class:langutil::SecondarySourceLocation	access:public	signature:(std::string const& _errMsg, SourceLocation const& _sourceLocation)
langutil::SecondarySourceLocation::infos	liblangutil/Exceptions.h	/^	std::vector<errorSourceLocationInfo> infos;$/;"	m	class:langutil::SecondarySourceLocation	access:public
langutil::SecondarySourceLocation::limitSize	liblangutil/Exceptions.h	/^	void limitSize(std::string& _message)$/;"	f	class:langutil::SecondarySourceLocation	access:public	signature:(std::string& _message)
langutil::SourceLocation	liblangutil/SourceLocation.h	/^struct SourceLocation$/;"	s	namespace:langutil
langutil::SourceLocation::contains	liblangutil/SourceLocation.h	/^	inline bool contains(SourceLocation const& _other) const;$/;"	p	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
langutil::SourceLocation::contains	liblangutil/SourceLocation.h	/^bool SourceLocation::contains(SourceLocation const& _other) const$/;"	f	class:langutil::SourceLocation	signature:(SourceLocation const& _other) const
langutil::SourceLocation::end	liblangutil/SourceLocation.h	/^	int end = -1;$/;"	m	struct:langutil::SourceLocation	access:public
langutil::SourceLocation::intersects	liblangutil/SourceLocation.h	/^	inline bool intersects(SourceLocation const& _other) const;$/;"	p	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
langutil::SourceLocation::intersects	liblangutil/SourceLocation.h	/^bool SourceLocation::intersects(SourceLocation const& _other) const$/;"	f	class:langutil::SourceLocation	signature:(SourceLocation const& _other) const
langutil::SourceLocation::isEmpty	liblangutil/SourceLocation.h	/^	bool isEmpty() const { return start == -1 && end == -1; }$/;"	f	struct:langutil::SourceLocation	access:public	signature:() const
langutil::SourceLocation::operator !=	liblangutil/SourceLocation.h	/^	bool operator!=(SourceLocation const& _other) const { return !operator==(_other); }$/;"	f	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
langutil::SourceLocation::operator <	liblangutil/SourceLocation.h	/^	inline bool operator<(SourceLocation const& _other) const;$/;"	p	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
langutil::SourceLocation::operator <	liblangutil/SourceLocation.h	/^bool SourceLocation::operator<(SourceLocation const& _other) const$/;"	f	class:langutil::SourceLocation	signature:(SourceLocation const& _other) const
langutil::SourceLocation::operator ==	liblangutil/SourceLocation.h	/^	bool operator==(SourceLocation const& _other) const$/;"	f	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
langutil::SourceLocation::smallestCovering	liblangutil/SourceLocation.h	/^	static SourceLocation smallestCovering(SourceLocation _a, SourceLocation const& _b)$/;"	f	struct:langutil::SourceLocation	access:public	signature:(SourceLocation _a, SourceLocation const& _b)
langutil::SourceLocation::source	liblangutil/SourceLocation.h	/^	std::shared_ptr<CharStream> source;$/;"	m	struct:langutil::SourceLocation	access:public
langutil::SourceLocation::start	liblangutil/SourceLocation.h	/^	int start = -1;$/;"	m	struct:langutil::SourceLocation	access:public
langutil::SourceReference	liblangutil/SourceReferenceExtractor.h	/^struct SourceReference$/;"	s	namespace:langutil
langutil::SourceReference::MessageOnly	liblangutil/SourceReferenceExtractor.h	/^	static SourceReference MessageOnly(std::string _msg)$/;"	f	struct:langutil::SourceReference	access:public	signature:(std::string _msg)
langutil::SourceReference::endColumn	liblangutil/SourceReferenceExtractor.h	/^	int endColumn = {-1};     \/\/\/< Highlighting range-end of text field.$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReference::message	liblangutil/SourceReferenceExtractor.h	/^	std::string message;      \/\/\/< A message that relates to this source reference (such as a warning or an error message).$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReference::multiline	liblangutil/SourceReferenceExtractor.h	/^	bool multiline = {false}; \/\/\/< Indicates whether the actual SourceReference is truncated to one line.$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReference::position	liblangutil/SourceReferenceExtractor.h	/^	LineColumn position;      \/\/\/< Actual (error) position this source reference is surrounding.$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReference::sourceName	liblangutil/SourceReferenceExtractor.h	/^	std::string sourceName;   \/\/\/< Underlying source name (for example the filename).$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReference::startColumn	liblangutil/SourceReferenceExtractor.h	/^	int startColumn = {-1};   \/\/\/< Highlighting range-start of text field.$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReference::text	liblangutil/SourceReferenceExtractor.h	/^	std::string text;         \/\/\/< Extracted source code text (potentially truncated if multiline or too long).$/;"	m	struct:langutil::SourceReference	access:public
langutil::SourceReferenceExtractor	liblangutil/SourceReferenceExtractor.h	/^namespace SourceReferenceExtractor$/;"	n	namespace:langutil
langutil::SourceReferenceExtractor::Message	liblangutil/SourceReferenceExtractor.h	/^	struct Message$/;"	s	namespace:langutil::SourceReferenceExtractor
langutil::SourceReferenceExtractor::Message::category	liblangutil/SourceReferenceExtractor.h	/^		std::string category; \/\/ "Error", "Warning", ...$/;"	m	struct:langutil::SourceReferenceExtractor::Message	access:public
langutil::SourceReferenceExtractor::Message::primary	liblangutil/SourceReferenceExtractor.h	/^		SourceReference primary;$/;"	m	struct:langutil::SourceReferenceExtractor::Message	access:public
langutil::SourceReferenceExtractor::Message::secondary	liblangutil/SourceReferenceExtractor.h	/^		std::vector<SourceReference> secondary;$/;"	m	struct:langutil::SourceReferenceExtractor::Message	access:public
langutil::SourceReferenceExtractor::extract	liblangutil/SourceReferenceExtractor.h	/^	Message extract(dev::Exception const& _exception, std::string _category);$/;"	p	namespace:langutil::SourceReferenceExtractor	signature:(dev::Exception const& _exception, std::string _category)
langutil::SourceReferenceExtractor::extract	liblangutil/SourceReferenceExtractor.h	/^	SourceReference extract(SourceLocation const* _location, std::string message = "");$/;"	p	namespace:langutil::SourceReferenceExtractor	signature:(SourceLocation const* _location, std::string message = )
langutil::SourceReferenceFormatter	liblangutil/SourceReferenceFormatter.h	/^class SourceReferenceFormatter$/;"	c	namespace:langutil
langutil::SourceReferenceFormatter::SourceReferenceFormatter	liblangutil/SourceReferenceFormatter.h	/^	explicit SourceReferenceFormatter(std::ostream& _stream):$/;"	f	class:langutil::SourceReferenceFormatter	access:public	signature:(std::ostream& _stream)
langutil::SourceReferenceFormatter::formatExceptionInformation	liblangutil/SourceReferenceFormatter.h	/^	static std::string formatExceptionInformation($/;"	f	class:langutil::SourceReferenceFormatter	access:public	signature:( dev::Exception const& _exception, std::string const& _name )
langutil::SourceReferenceFormatter::m_stream	liblangutil/SourceReferenceFormatter.h	/^	std::ostream& m_stream;$/;"	m	class:langutil::SourceReferenceFormatter	access:protected
langutil::SourceReferenceFormatter::printExceptionInformation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printExceptionInformation(SourceReferenceExtractor::Message const& _msg);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(SourceReferenceExtractor::Message const& _msg)
langutil::SourceReferenceFormatter::printExceptionInformation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printExceptionInformation(dev::Exception const& _error, std::string const& _category);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(dev::Exception const& _error, std::string const& _category)
langutil::SourceReferenceFormatter::printSourceLocation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printSourceLocation(SourceLocation const* _location);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(SourceLocation const* _location)
langutil::SourceReferenceFormatter::printSourceLocation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printSourceLocation(SourceReference const& _ref);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(SourceReference const& _ref)
langutil::SourceReferenceFormatter::printSourceName	liblangutil/SourceReferenceFormatter.h	/^	void printSourceName(SourceReference const& _ref);$/;"	p	class:langutil::SourceReferenceFormatter	access:protected	signature:(SourceReference const& _ref)
langutil::SourceReferenceFormatter::~SourceReferenceFormatter	liblangutil/SourceReferenceFormatter.h	/^	virtual ~SourceReferenceFormatter() = default;$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:()
langutil::SourceReferenceFormatterHuman	liblangutil/SourceReferenceFormatterHuman.h	/^class SourceReferenceFormatterHuman: public SourceReferenceFormatter$/;"	c	namespace:langutil	inherits:SourceReferenceFormatter
langutil::SourceReferenceFormatterHuman::SourceReferenceFormatterHuman	liblangutil/SourceReferenceFormatterHuman.h	/^	SourceReferenceFormatterHuman(std::ostream& _stream, bool colored):$/;"	f	class:langutil::SourceReferenceFormatterHuman	access:public	signature:(std::ostream& _stream, bool colored)
langutil::SourceReferenceFormatterHuman::diagColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized diagColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::SourceReferenceFormatterHuman::errorColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized errorColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::SourceReferenceFormatterHuman::formatExceptionInformation	liblangutil/SourceReferenceFormatterHuman.h	/^	static std::string formatExceptionInformation($/;"	f	class:langutil::SourceReferenceFormatterHuman	access:public	signature:( dev::Exception const& _exception, std::string const& _name, bool colored = false )
langutil::SourceReferenceFormatterHuman::frameColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized frameColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::SourceReferenceFormatterHuman::highlightColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized highlightColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::SourceReferenceFormatterHuman::m_colored	liblangutil/SourceReferenceFormatterHuman.h	/^	bool m_colored;$/;"	m	class:langutil::SourceReferenceFormatterHuman	access:private
langutil::SourceReferenceFormatterHuman::messageColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized messageColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::SourceReferenceFormatterHuman::normalColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized normalColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::SourceReferenceFormatterHuman::override	liblangutil/SourceReferenceFormatterHuman.h	/^	void printExceptionInformation(SourceReferenceExtractor::Message const& _msg) override;$/;"	m	class:langutil::SourceReferenceFormatterHuman	access:public
langutil::SourceReferenceFormatterHuman::override	liblangutil/SourceReferenceFormatterHuman.h	/^	void printSourceLocation(SourceReference const& _ref) override;$/;"	m	class:langutil::SourceReferenceFormatterHuman	access:public
langutil::SourceReferenceFormatterHuman::secondaryColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized secondaryColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
langutil::Token	liblangutil/Token.h	/^enum class Token : unsigned int {$/;"	c	namespace:langutil
langutil::TokenTraits	liblangutil/Token.cpp	/^namespace TokenTraits$/;"	n	namespace:langutil	file:
langutil::TokenTraits	liblangutil/Token.h	/^namespace TokenTraits$/;"	n	namespace:langutil
langutil::TokenTraits::AssignmentToBinaryOp	liblangutil/Token.h	/^	inline Token AssignmentToBinaryOp(Token op)$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::count	liblangutil/Token.h	/^	constexpr size_t count() { return static_cast<size_t>(Token::NUM_TOKENS); }$/;"	f	namespace:langutil::TokenTraits	signature:()
langutil::TokenTraits::friendlyName	liblangutil/Token.cpp	/^std::string friendlyName(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::friendlyName	liblangutil/Token.h	/^	std::string friendlyName(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::fromIdentifierOrKeyword	liblangutil/Token.cpp	/^tuple<Token, unsigned int, unsigned int> fromIdentifierOrKeyword(string const& _literal)$/;"	f	namespace:langutil::TokenTraits	signature:(string const& _literal)
langutil::TokenTraits::fromIdentifierOrKeyword	liblangutil/Token.h	/^	std::tuple<Token, unsigned int, unsigned int> fromIdentifierOrKeyword(std::string const& _literal);$/;"	p	namespace:langutil::TokenTraits	signature:(std::string const& _literal)
langutil::TokenTraits::isArithmeticOp	liblangutil/Token.h	/^	constexpr bool isArithmeticOp(Token op) { return Token::Add <= op && op <= Token::Exp; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isAssignmentOp	liblangutil/Token.h	/^	constexpr bool isAssignmentOp(Token tok) { return Token::Assign <= tok && tok <= Token::AssignMod; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::isBinaryOp	liblangutil/Token.h	/^	constexpr bool isBinaryOp(Token op) { return Token::Comma <= op && op <= Token::Exp; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isBitOp	liblangutil/Token.h	/^	constexpr bool isBitOp(Token op) { return (Token::BitOr <= op && op <= Token::BitAnd) || op == Token::BitNot; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isBooleanOp	liblangutil/Token.h	/^	constexpr bool isBooleanOp(Token op) { return (Token::Or <= op && op <= Token::And) || op == Token::Not; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isCommutativeOp	liblangutil/Token.h	/^	constexpr bool isCommutativeOp(Token op) { return op == Token::BitOr || op == Token::BitXor || op == Token::BitAnd ||$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isCompareOp	liblangutil/Token.h	/^	constexpr bool isCompareOp(Token op) { return Token::Equal <= op && op <= Token::GreaterThanOrEqual; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isCountOp	liblangutil/Token.h	/^	constexpr bool isCountOp(Token op) { return op == Token::Inc || op == Token::Dec; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isElementaryTypeName	liblangutil/Token.h	/^	constexpr bool isElementaryTypeName(Token tok) { return Token::Int <= tok && tok < Token::TypesEnd; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::isEtherSubdenomination	liblangutil/Token.h	/^	constexpr bool isEtherSubdenomination(Token op) { return op == Token::SubWei || op == Token::SubSzabo || op == Token::SubFinney || op == Token::SubEther; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isLocationSpecifier	liblangutil/Token.h	/^	constexpr bool isLocationSpecifier(Token op) { return op == Token::Memory || op == Token::Storage || op == Token::CallData; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isReservedKeyword	liblangutil/Token.h	/^	constexpr bool isReservedKeyword(Token op) { return (Token::Abstract <= op && op <= Token::Unchecked); }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isShiftOp	liblangutil/Token.h	/^	constexpr bool isShiftOp(Token op) { return (Token::SHL <= op) && (op <= Token::SHR); }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isStateMutabilitySpecifier	liblangutil/Token.h	/^	constexpr bool isStateMutabilitySpecifier(Token op, bool _allowConstant = true)$/;"	f	namespace:langutil::TokenTraits	signature:(Token op, bool _allowConstant = true)
langutil::TokenTraits::isTimeSubdenomination	liblangutil/Token.h	/^	constexpr bool isTimeSubdenomination(Token op) { return op == Token::SubSecond || op == Token::SubMinute || op == Token::SubHour || op == Token::SubDay || op == Token::SubWeek || op == Token::SubYear; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isUnaryOp	liblangutil/Token.h	/^	constexpr bool isUnaryOp(Token op) { return (Token::Not <= op && op <= Token::Delete) || op == Token::Add || op == Token::Sub; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isVariableVisibilitySpecifier	liblangutil/Token.h	/^	constexpr bool isVariableVisibilitySpecifier(Token op) { return op == Token::Public || op == Token::Private || op == Token::Internal; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::isVisibilitySpecifier	liblangutil/Token.h	/^	constexpr bool isVisibilitySpecifier(Token op) { return isVariableVisibilitySpecifier(op) || op == Token::External; }$/;"	f	namespace:langutil::TokenTraits	signature:(Token op)
langutil::TokenTraits::keywordByName	liblangutil/Token.cpp	/^static Token keywordByName(string const& _name)$/;"	f	namespace:langutil::TokenTraits	signature:(string const& _name)
langutil::TokenTraits::name	liblangutil/Token.cpp	/^char const* name(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::name	liblangutil/Token.h	/^	char const* name(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::parseSize	liblangutil/Token.cpp	/^int parseSize(string::const_iterator _begin, string::const_iterator _end)$/;"	f	namespace:langutil::TokenTraits	signature:(string::const_iterator _begin, string::const_iterator _end)
langutil::TokenTraits::precedence	liblangutil/Token.cpp	/^int precedence(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::precedence	liblangutil/Token.h	/^	int precedence(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::toString	liblangutil/Token.cpp	/^char const* toString(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::TokenTraits::toString	liblangutil/Token.h	/^	char const* toString(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
langutil::UnimplementedFeatureError	liblangutil/Exceptions.h	/^struct UnimplementedFeatureError: virtual dev::Exception {};$/;"	s	namespace:langutil	inherits:dev::Exception
langutil::count	liblangutil/Scanner.cpp	/^BOOST_STATIC_ASSERT(TokenTraits::count() <= 0x100);$/;"	p	namespace:langutil	file:	signature:()
langutil::hexValue	liblangutil/Common.h	/^inline int hexValue(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::isDecimalDigit	liblangutil/Common.h	/^inline bool isDecimalDigit(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::isHexDigit	liblangutil/Common.h	/^inline bool isHexDigit(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::isIdentifierPart	liblangutil/Common.h	/^inline bool isIdentifierPart(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::isIdentifierStart	liblangutil/Common.h	/^inline bool isIdentifierStart(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::isLineTerminator	liblangutil/Common.h	/^inline bool isLineTerminator(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::isWhiteSpace	liblangutil/Common.h	/^inline bool isWhiteSpace(char c)$/;"	f	namespace:langutil	signature:(char c)
langutil::operator <<	liblangutil/Scanner.cpp	/^std::ostream& operator<<(std::ostream& os, ScannerError _errorCode)$/;"	f	namespace:langutil	signature:(std::ostream& os, ScannerError _errorCode)
langutil::operator <<	liblangutil/Scanner.h	/^std::ostream& operator<<(std::ostream& os, ScannerError _errorCode);$/;"	p	namespace:langutil	signature:(std::ostream& os, ScannerError _errorCode)
langutil::operator <<	liblangutil/SourceLocation.h	/^inline std::ostream& operator<<(std::ostream& _out, SourceLocation const& _location)$/;"	f	namespace:langutil	signature:(std::ostream& _out, SourceLocation const& _location)
langutil::operator <<	liblangutil/Token.h	/^inline std::ostream& operator<<(std::ostream& os, Token token)$/;"	f	namespace:langutil	signature:(std::ostream& os, Token token)
langutil::to_string	liblangutil/Scanner.cpp	/^std::string to_string(ScannerError _errorCode)$/;"	f	namespace:langutil	signature:(ScannerError _errorCode)
langutil::to_string	liblangutil/Scanner.h	/^std::string to_string(ScannerError _errorCode);$/;"	p	namespace:langutil	signature:(ScannerError _errorCode)
largestMemoryAccess	libevmasm/GasMeter.h	/^	u256 const& largestMemoryAccess() const { return m_largestMemoryAccess; }$/;"	f	class:dev::eth::GasMeter	access:public	signature:() const
largestMemoryAccess	libevmasm/PathGasMeter.h	/^	u256 largestMemoryAccess;$/;"	m	struct:dev::eth::GasPath	access:public
lastContractName	libsolidity/interface/CompilerStack.cpp	/^string const CompilerStack::lastContractName() const$/;"	f	class:CompilerStack	signature:() const
lastContractName	libsolidity/interface/CompilerStack.h	/^	std::string const lastContractName() const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:() const
latestStatement	libyul/optimiser/ExpressionJoiner.cpp	/^Statement* ExpressionJoiner::latestStatement()$/;"	f	class:ExpressionJoiner	signature:()
latestStatement	libyul/optimiser/ExpressionJoiner.h	/^	Statement* latestStatement();$/;"	p	class:yul::ExpressionJoiner	access:private	signature:()
leaveFunction	libyul/optimiser/ASTCopier.h	/^	virtual void leaveFunction(FunctionDefinition const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(FunctionDefinition const&)
leaveFunction	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::leaveFunction(FunctionDefinition const& _function)$/;"	f	class:Disambiguator	signature:(FunctionDefinition const& _function)
leaveScope	libyul/optimiser/ASTCopier.h	/^	virtual void leaveScope(Block const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(Block const&)
leaveScope	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::leaveScope(Block const& _block)$/;"	f	class:Disambiguator	signature:(Block const& _block)
leaveScopeInternal	libyul/optimiser/Disambiguator.cpp	/^void Disambiguator::leaveScopeInternal(Scope& _scope)$/;"	f	class:Disambiguator	signature:(Scope& _scope)
leaveScopeInternal	libyul/optimiser/Disambiguator.h	/^	void leaveScopeInternal(Scope& _scope);$/;"	p	class:yul::Disambiguator	access:protected	signature:(Scope& _scope)
leftAlignFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::leftAlignFunction(Type const& _type)$/;"	f	class:ABIFunctions	signature:(Type const& _type)
leftAlignFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string leftAlignFunction(Type const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(Type const& _type)
leftExpression	libsolidity/ast/AST.h	/^	Expression const& leftExpression() const { return *m_left; }$/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:() const
leftHandSide	libsolidity/ast/AST.h	/^	Expression const& leftHandSide() const { return *m_leftHandSide; }$/;"	f	class:dev::solidity::Assignment	access:public	signature:() const
leftShiftNumberOnStack	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::leftShiftNumberOnStack(unsigned _bits)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _bits)
leftShiftNumberOnStack	libsolidity/codegen/CompilerUtils.h	/^	void leftShiftNumberOnStack(unsigned _bits);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _bits)
length	libsolidity/ast/AST.h	/^	Expression const* length() const { return m_length.get(); }$/;"	f	class:dev::solidity::ArrayTypeName	access:public	signature:() const
length	libsolidity/ast/Types.h	/^	u256 const& length() const { return m_length; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
levelsPresent	libsolidity/analysis/SemVerHandler.h	/^		unsigned levelsPresent = 1;$/;"	m	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public
libraryName	libsolidity/ast/AST.h	/^	UserDefinedTypeName const& libraryName() const { return *m_libraryName; }$/;"	f	class:dev::solidity::UsingForDirective	access:public	signature:() const
libraryPlaceholder	libevmasm/LinkerObject.cpp	/^string LinkerObject::libraryPlaceholder(string const& _libraryName)$/;"	f	class:LinkerObject	signature:(string const& _libraryName)
libraryPlaceholder	libevmasm/LinkerObject.h	/^	static std::string libraryPlaceholder(std::string const& _libraryName);$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:(std::string const& _libraryName)
libraryPlaceholderHint	solse/CommandLineInterface.cpp	/^string CommandLineInterface::libraryPlaceholderHint(string const& _libraryName)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _libraryName)
libraryPlaceholderHint	solse/CommandLineInterface.h	/^	static std::string libraryPlaceholderHint(std::string const& _libraryName);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _libraryName)
license	solse/CommandLineInterface.cpp	/^static void license()$/;"	f	namespace:dev::solidity	signature:()
limitSize	liblangutil/Exceptions.h	/^	void limitSize(std::string& _message)$/;"	f	class:langutil::SecondarySourceLocation	access:public	signature:(std::string& _message)
line	liblangutil/SourceReferenceExtractor.h	/^	int line = {-1};$/;"	m	struct:langutil::LineColumn	access:public
lineAtPosition	liblangutil/CharStream.cpp	/^string CharStream::lineAtPosition(int _position) const$/;"	f	class:CharStream	signature:(int _position) const
lineAtPosition	liblangutil/CharStream.h	/^	std::string lineAtPosition(int _position) const;$/;"	p	class:langutil::CharStream	access:public	signature:(int _position) const
lineAtPosition	liblangutil/Scanner.h	/^	std::string lineAtPosition(int _position) const { return m_source->lineAtPosition(_position); }$/;"	f	class:langutil::Scanner	access:public	signature:(int _position) const
lineInfo	libdevcore/Exceptions.cpp	/^string Exception::lineInfo() const$/;"	f	class:Exception	signature:() const
lineInfo	libdevcore/Exceptions.h	/^	std::string lineInfo() const;$/;"	p	struct:dev::Exception	access:public	signature:() const
linearizeBaseContracts	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ContractDefinition& _contract)
linearizeBaseContracts	libsolidity/analysis/NameAndTypeResolver.h	/^	void linearizeBaseContracts(ContractDefinition& _contract);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(ContractDefinition& _contract)
linearizedBaseContracts	libsolidity/ast/ASTAnnotations.h	/^	std::vector<ContractDefinition const*> linearizedBaseContracts;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
link	libevmasm/LinkerObject.cpp	/^void LinkerObject::link(map<string, h160> const& _libraryAddresses)$/;"	f	class:LinkerObject	signature:(map<string, h160> const& _libraryAddresses)
link	libevmasm/LinkerObject.h	/^	void link(std::map<std::string, h160> const& _libraryAddresses);$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:(std::map<std::string, h160> const& _libraryAddresses)
link	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::link()$/;"	f	class:CompilerStack	signature:()
link	libsolidity/interface/CompilerStack.h	/^	void link();$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:()
link	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::link()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
link	solse/CommandLineInterface.h	/^	bool link();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
linkReferences	libevmasm/LinkerObject.h	/^	std::map<size_t, std::string> linkReferences;$/;"	m	struct:dev::eth::LinkerObject	access:public
listAccept	libsolidity/ast/AST.h	/^	static void listAccept(std::vector<T> const& _list, ASTConstVisitor& _visitor)$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(std::vector<T> const& _list, ASTConstVisitor& _visitor)
listAccept	libsolidity/ast/AST.h	/^	static void listAccept(std::vector<T> const& _list, ASTVisitor& _visitor)$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(std::vector<T> const& _list, ASTVisitor& _visitor)
literal	liblangutil/Scanner.h	/^		std::string literal;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
literalArguments	libyul/Dialect.h	/^	bool literalArguments = false;$/;"	m	struct:yul::BuiltinFunction	access:public
literalTokenKind	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::literalTokenKind(Token _token)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Token _token)
literalTokenKind	libsolidity/ast/ASTJsonConverter.h	/^	static std::string literalTokenKind(Token _token);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(Token _token)
literalValue	libsolidity/ast/Types.cpp	/^u256 AddressType::literalValue(Literal const* _literal) const$/;"	f	class:AddressType	signature:(Literal const* _literal) const
literalValue	libsolidity/ast/Types.cpp	/^u256 BoolType::literalValue(Literal const* _literal) const$/;"	f	class:BoolType	signature:(Literal const* _literal) const
literalValue	libsolidity/ast/Types.cpp	/^u256 RationalNumberType::literalValue(Literal const*) const$/;"	f	class:RationalNumberType	signature:(Literal const*) const
literalValue	libsolidity/ast/Types.h	/^	virtual u256 literalValue(Literal const*) const$/;"	f	class:dev::solidity::Type	access:public	signature:(Literal const*) const
literals	libsolidity/ast/AST.h	/^	std::vector<ASTString> const& literals() const { return m_literals; }$/;"	f	class:dev::solidity::PragmaDirective::std	access:public	signature:() const
loadFromMemory	libevmasm/KnownState.cpp	/^ExpressionClasses::Id KnownState::loadFromMemory(Id _slot, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(Id _slot, SourceLocation const& _location)
loadFromMemory	libevmasm/KnownState.h	/^	Id loadFromMemory(Id _slot, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, langutil::SourceLocation const& _location)
loadFromMemory	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::loadFromMemory($/;"	f	class:dev::solidity::CompilerUtils	signature:( unsigned _offset, Type const& _type, bool _fromCalldata, bool _padToWordBoundaries )
loadFromMemory	libsolidity/codegen/CompilerUtils.h	/^	unsigned loadFromMemory($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( unsigned _offset, Type const& _type = IntegerType::uint256(), bool _fromCalldata = false, bool _padToWords = false )
loadFromMemoryDynamic	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::loadFromMemoryDynamic($/;"	f	class:dev::solidity::CompilerUtils	signature:( Type const& _type, bool _fromCalldata, bool _padToWordBoundaries, bool _keepUpdatedMemoryOffset )
loadFromMemoryDynamic	libsolidity/codegen/CompilerUtils.h	/^	void loadFromMemoryDynamic($/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:( Type const& _type, bool _fromCalldata = false, bool _padToWords = true, bool _keepUpdatedMemoryOffset = true )
loadFromMemoryHelper	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::loadFromMemoryHelper(Type const& _type, bool _fromCalldata, bool _padToWords)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type, bool _fromCalldata, bool _padToWords)
loadFromMemoryHelper	libsolidity/codegen/CompilerUtils.h	/^	unsigned loadFromMemoryHelper(Type const& _type, bool _fromCalldata, bool _padToWords);$/;"	p	class:dev::solidity::CompilerUtils	access:private	signature:(Type const& _type, bool _fromCalldata, bool _padToWords)
loadFromStorage	libevmasm/KnownState.cpp	/^ExpressionClasses::Id KnownState::loadFromStorage(Id _slot, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(Id _slot, SourceLocation const& _location)
loadFromStorage	libevmasm/KnownState.h	/^	Id loadFromStorage(Id _slot, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, langutil::SourceLocation const& _location)
loadMissingSources	libsolidity/interface/CompilerStack.cpp	/^StringMap CompilerStack::loadMissingSources(SourceUnit const& _ast, std::string const& _sourcePath)$/;"	f	class:CompilerStack	signature:(SourceUnit const& _ast, std::string const& _sourcePath)
loadMissingSources	libsolidity/interface/CompilerStack.h	/^	StringMap loadMissingSources(SourceUnit const& _ast, std::string const& _path);$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(SourceUnit const& _ast, std::string const& _path)
localVarValueZ3ExprMap	solse/SolidityExprTranslator.h	/^    std::unordered_map<std::string, z3::expr> localVarValueZ3ExprMap;$/;"	m	class:ContextInfo	access:public
localVarValuesZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> localVarValuesZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
localVarZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> localVarZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
localVariables	libsolidity/ast/AST.h	/^	std::vector<VariableDeclaration const*> const& localVariables() const { return m_localVariables; }$/;"	f	class:dev::solidity::VariableScope::std	access:public	signature:() const
local_variable_records	solse/SymExecEngine.cpp	/^std::unordered_map<std::string, std::vector<std::string>> local_variable_records;$/;"	v
location	libevmasm/AssemblyItem.h	/^	langutil::SourceLocation const& location() const { return m_location; }$/;"	f	class:dev::eth::AssemblyItem::langutil	access:public	signature:() const
location	liblangutil/Scanner.h	/^		SourceLocation location;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
location	libsolidity/analysis/ControlFlowGraph.h	/^	langutil::SourceLocation location;$/;"	m	struct:dev::solidity::CFGNode	access:public
location	libsolidity/analysis/ViewPureChecker.h	/^		langutil::SourceLocation location;$/;"	m	struct:dev::solidity::ViewPureChecker::MutabilityAndLocation	access:public
location	libsolidity/ast/AST.h	/^	SourceLocation const& location() const { return m_location; }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:() const
location	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::location(VariableDeclaration::Location _location)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclaration::Location _location)
location	libsolidity/ast/ASTJsonConverter.h	/^	static std::string location(VariableDeclaration::Location _location);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(VariableDeclaration::Location _location)
location	libsolidity/ast/Types.h	/^	DataLocation location() const { return m_location; }$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:() const
location	libsolidity/formal/SMTChecker.h	/^		langutil::SourceLocation const& location;$/;"	m	class:dev::solidity::SMTChecker::OverflowTarget::langutil	access:public
location	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::Assignment	access:public
location	libyul/AsmData.h	/^struct Block { langutil::SourceLocation location; std::vector<Statement> statements; };$/;"	m	struct:yul::Block	access:public
location	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	m	struct:yul::Case	access:public
location	libyul/AsmData.h	/^struct ExpressionStatement { langutil::SourceLocation location; Expression expression; };$/;"	m	struct:yul::ExpressionStatement	access:public
location	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
location	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionCall	access:public
location	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
location	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionalInstruction	access:public
location	libyul/AsmData.h	/^struct Identifier { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Identifier	access:public
location	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	m	struct:yul::If	access:public
location	libyul/AsmData.h	/^struct Instruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; };$/;"	m	struct:yul::Instruction	access:public
location	libyul/AsmData.h	/^struct Label { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Label	access:public
location	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
location	libyul/AsmData.h	/^struct StackAssignment { langutil::SourceLocation location; Identifier variableName; };$/;"	m	struct:yul::StackAssignment	access:public
location	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	m	struct:yul::Switch	access:public
location	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	m	struct:yul::TypedName	access:public
location	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::VariableDeclaration	access:public
location	libyul/AsmParser.h	/^	langutil::SourceLocation location() const { return {position(), endPosition(), m_scanner->charStream()}; }$/;"	f	class:yul::Parser	access:protected	signature:() const
locationFromSources	libevmasm/Assembly.cpp	/^string locationFromSources(StringMap const& _sourceCodes, SourceLocation const& _location)$/;"	f	namespace:__anon18	signature:(StringMap const& _sourceCodes, SourceLocation const& _location)
locationOf	libyul/AsmData.h	/^template <class T> inline langutil::SourceLocation locationOf(T const& _node)$/;"	f	namespace:yul	signature:(T const& _node)
logDataGas	libevmasm/GasMeter.h	/^	static unsigned const logDataGas = 8;$/;"	m	namespace:dev::eth::GasCosts
logGas	libevmasm/GasMeter.h	/^	static unsigned const logGas = 375;$/;"	m	namespace:dev::eth::GasCosts
logInstruction	libevmasm/Instruction.h	/^inline Instruction logInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
logTopicGas	libevmasm/GasMeter.h	/^	static unsigned const logTopicGas = 375;$/;"	m	namespace:dev::eth::GasCosts
looksLikeAddress	libsolidity/ast/AST.cpp	/^bool Literal::looksLikeAddress() const$/;"	f	class:Literal	signature:() const
looksLikeAddress	libsolidity/ast/AST.h	/^	bool looksLikeAddress() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
lookup	libyul/AsmScope.cpp	/^Scope::Identifier* Scope::lookup(YulString _name)$/;"	f	class:Scope	signature:(YulString _name)
lookup	libyul/AsmScope.h	/^	Identifier* lookup(YulString _name);$/;"	p	struct:yul::Scope	access:public	signature:(YulString _name)
lookup	libyul/AsmScope.h	/^	bool lookup(YulString _name, V const& _visitor)$/;"	f	struct:yul::Scope	access:public	signature:(YulString _name, V const& _visitor)
loopExpression	libsolidity/ast/AST.h	/^	ExpressionStatement const* loopExpression() const { return m_loopExpression.get(); }$/;"	f	class:dev::solidity::ForStatement	access:public	signature:() const
looseAssemblyForEVM	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<EVMDialect> EVMDialect::looseAssemblyForEVM(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
looseAssemblyForEVM	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> looseAssemblyForEVM(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
lowLevelFunctionTag	libsolidity/codegen/CompilerContext.cpp	/^eth::AssemblyItem CompilerContext::lowLevelFunctionTag($/;"	f	class:dev::solidity::CompilerContext	signature:( string const& _name, unsigned _inArgs, unsigned _outArgs, function<void(CompilerContext&)> const& _generator )
lowLevelFunctionTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem lowLevelFunctionTag($/;"	p	class:dev::solidity::CompilerContext	access:public	signature:( std::string const& _name, unsigned _inArgs, unsigned _outArgs, std::function<void(CompilerContext&)> const& _generator )
m_abiFunctions	libsolidity/codegen/CompilerContext.h	/^	ABIFunctions m_abiFunctions;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_accumulatedOutput	libsolidity/formal/SMTLib2Interface.h	/^	std::vector<std::string> m_accumulatedOutput;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:private
m_activeVariables	libyul/AsmAnalysis.h	/^	std::set<Scope::Variable const*> m_activeVariables;$/;"	m	class:yul::AsmAnalyzer	access:private
m_actualType	libsolidity/ast/Types.h	/^	TypePointer m_actualType;$/;"	m	class:dev::solidity::TypeType	access:private
m_allowStackOpt	libyul/backends/evm/EVMCodeTransform.h	/^	bool const m_allowStackOpt = true;$/;"	m	class:yul::CodeTransform	access:private
m_allowedDirectories	solse/CommandLineInterface.h	/^	std::vector<boost::filesystem::path> m_allowedDirectories;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_alreadyCompiledFunctions	libsolidity/codegen/CompilerContext.h	/^		std::set<Declaration const*> m_alreadyCompiledFunctions;$/;"	m	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public
m_analysisSuccessful	libyul/AssemblyStack.h	/^	bool m_analysisSuccessful = false;$/;"	m	class:yul::AssemblyStack	access:private
m_annotation	libsolidity/ast/AST.h	/^	mutable ASTAnnotation* m_annotation = nullptr;$/;"	m	class:dev::solidity::ASTNode	access:protected
m_anonymous	libsolidity/ast/AST.h	/^	bool m_anonymous = false;$/;"	m	class:dev::solidity::EventDefinition	access:private
m_arbitraryParameters	libsolidity/ast/Types.h	/^	bool const m_arbitraryParameters = false;$/;"	m	class:dev::solidity::FunctionType	access:private
m_args	solse/CommandLineInterface.h	/^	boost::program_options::variables_map m_args;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_arguments	libevmasm/SimplificationRules.h	/^	std::vector<Pattern> m_arguments;$/;"	m	class:dev::eth::Pattern	access:private
m_arguments	libsolidity/ast/AST.h	/^	std::unique_ptr<std::vector<ASTPointer<Expression>>> m_arguments;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:private
m_arguments	libsolidity/ast/AST.h	/^	std::unique_ptr<std::vector<ASTPointer<Expression>>> m_arguments;$/;"	m	class:dev::solidity::ModifierInvocation	access:private
m_arguments	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> m_arguments;$/;"	m	class:dev::solidity::FunctionCall	access:private
m_arguments	libyul/optimiser/SimplificationRules.h	/^	std::vector<Pattern> m_arguments;$/;"	m	class:yul::Pattern	access:private
m_arrayAssignmentHappened	libsolidity/formal/SMTChecker.h	/^	bool m_arrayAssignmentHappened = false;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_arrayKind	libsolidity/ast/Types.h	/^	ArrayKind m_arrayKind = ArrayKind::Ordinary;$/;"	m	class:dev::solidity::ArrayType	access:private
m_arrayType	libsolidity/codegen/LValue.h	/^	ArrayType const& m_arrayType;$/;"	m	class:dev::solidity::StorageArrayLength	access:private
m_asm	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyPointer m_asm;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_assembledObject	libevmasm/Assembly.h	/^	mutable LinkerObject m_assembledObject;$/;"	m	class:dev::eth::Assembly	access:protected
m_assembly	libyul/backends/evm/AsmCodeGen.h	/^	dev::eth::Assembly& m_assembly;$/;"	m	class:yul::EthAssemblyAdapter	access:private
m_assembly	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly& m_assembly;$/;"	m	class:yul::CodeTransform	access:private
m_assembly	libyul/backends/evm/EVMObjectCompiler.h	/^	AbstractAssembly& m_assembly;$/;"	m	class:yul::EVMObjectCompiler	access:private
m_assemblySizePositions	libyul/backends/evm/EVMAssembly.h	/^	std::vector<size_t> m_assemblySizePositions;$/;"	m	class:yul::EVMAssembly	access:private
m_assigmentOperator	libsolidity/ast/AST.h	/^	Token m_assigmentOperator;$/;"	m	class:dev::solidity::Assignment	access:private
m_assignmentCounter	libyul/optimiser/SSAReverser.h	/^	AssignmentCounter const& m_assignmentCounter;$/;"	m	class:yul::SSAReverser	access:private
m_assignmentCounters	libyul/optimiser/Metrics.h	/^	std::map<YulString, size_t> m_assignmentCounters;$/;"	m	class:yul::AssignmentCounter	access:private
m_assignments	libyul/optimiser/RedundantAssignEliminator.h	/^	std::map<YulString, std::map<Assignment const*, State>> m_assignments;$/;"	m	class:yul::RedundantAssignEliminator	access:private
m_assignmentsToRemove	libyul/optimiser/RedundantAssignEliminator.h	/^	std::set<Assignment const*> m_assignmentsToRemove;$/;"	m	class:yul::RedundantAssignEliminator	access:private
m_ast	libsolidity/analysis/ViewPureChecker.h	/^	std::vector<std::shared_ptr<ASTNode>> const& m_ast;$/;"	m	class:dev::solidity::ViewPureChecker::std	access:private
m_ast	libsolidity/ast/ASTPrinter.h	/^	ASTNode const* m_ast;$/;"	m	class:dev::solidity::ASTPrinter	access:private
m_ast	libyul/optimiser/FullInliner.h	/^	Block& m_ast;$/;"	m	class:yul::FullInliner	access:private
m_auxiliaryData	libevmasm/Assembly.h	/^	bytes m_auxiliaryData;$/;"	m	class:dev::eth::Assembly	access:protected
m_base	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_base;$/;"	m	class:dev::solidity::IndexAccess	access:private
m_baseArguments	libsolidity/codegen/ContractCompiler.h	/^	std::map<FunctionDefinition const*, ASTNode const*> const* m_baseArguments;$/;"	m	class:dev::solidity::ContractCompiler::std	access:private
m_baseContracts	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<InheritanceSpecifier>> m_baseContracts;$/;"	m	class:dev::solidity::ContractDefinition	access:private
m_baseName	libsolidity/ast/AST.h	/^	ASTPointer<UserDefinedTypeName> m_baseName;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:private
m_baseStackOffset	libsolidity/codegen/LValue.h	/^	unsigned m_baseStackOffset;$/;"	m	class:dev::solidity::StackVariable	access:private
m_baseType	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_baseType;$/;"	m	class:dev::solidity::ArrayTypeName	access:private
m_baseType	libsolidity/ast/Types.h	/^	TypePointer m_baseType;$/;"	m	class:dev::solidity::ArrayType	access:private
m_bestMutabilityAndLocation	libsolidity/analysis/ViewPureChecker.h	/^	MutabilityAndLocation m_bestMutabilityAndLocation = MutabilityAndLocation{StateMutability::Payable, langutil::SourceLocation()};$/;"	m	class:dev::solidity::ViewPureChecker	access:private
m_bits	libsolidity/ast/Types.h	/^	unsigned m_bits;$/;"	m	class:dev::solidity::IntegerType	access:private
m_blacklist	libyul/optimiser/VarNameCleaner.h	/^	std::set<YulString> m_blacklist;$/;"	m	class:yul::VarNameCleaner	access:private
m_block	libyul/optimiser/ExpressionInliner.h	/^	Block& m_block;$/;"	m	class:yul::ExpressionInliner	access:private
m_blocks	libevmasm/ControlFlowGraph.h	/^	std::map<BlockId, BasicBlock> m_blocks;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
m_body	libsolidity/ast/AST.h	/^	ASTPointer<Block> m_body;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
m_body	libsolidity/ast/AST.h	/^	ASTPointer<Block> m_body;$/;"	m	class:dev::solidity::ModifierDefinition	access:private
m_body	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_body;$/;"	m	class:dev::solidity::ForStatement	access:private
m_body	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_body;$/;"	m	class:dev::solidity::WhileStatement	access:private
m_bound	libsolidity/ast/Types.h	/^	bool const m_bound = false; \/\/\/< true iff the function is called as arg1.fun(arg2, ..., argn)$/;"	m	class:dev::solidity::FunctionType	access:private
m_breakJump	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_breakJump = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_breakTags	libsolidity/codegen/ContractCompiler.h	/^	std::vector<std::pair<eth::AssemblyItem, unsigned>> m_breakTags;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_breakingItem	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItem const* m_breakingItem = nullptr;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
m_bytecode	libyul/backends/evm/EVMAssembly.h	/^	dev::bytes m_bytecode;$/;"	m	class:yul::EVMAssembly	access:private
m_bytes	libsolidity/ast/Types.h	/^	unsigned m_bytes;$/;"	m	class:dev::solidity::FixedBytesType	access:private
m_candidates	libyul/optimiser/EquivalentFunctionDetector.h	/^	std::map<RoughHeuristic, std::vector<FunctionDefinition const*>> m_candidates;$/;"	m	class:yul::EquivalentFunctionDetector	access:private
m_cfg	libsolidity/analysis/ControlFlowAnalyzer.h	/^	CFG const& m_cfg;$/;"	m	class:dev::solidity::ControlFlowAnalyzer	access:private
m_cfg	libsolidity/analysis/ControlFlowPrinter.h	/^	CFG const& m_cfg;$/;"	m	class:dev::solidity::ControlFlowPrinter	access:private
m_char	liblangutil/Scanner.h	/^	char m_char;$/;"	m	class:langutil::Scanner	access:private
m_children	libsolidity/formal/VariableUsage.h	/^	std::map<ASTNode const*, std::vector<ASTNode const*>> m_children;$/;"	m	class:dev::solidity::VariableUsage	access:private
m_classPositions	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<Id, std::set<int>> m_classPositions;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_codeSize	libyul/optimiser/EquivalentFunctionDetector.h	/^		mutable boost::optional<std::size_t> m_codeSize;$/;"	m	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:private
m_codes	libdevcore/AnsiColorized.h	/^	std::vector<char const*> m_codes;$/;"	m	class:dev::AnsiColorized	access:private
m_colored	liblangutil/SourceReferenceFormatterHuman.h	/^	bool m_colored;$/;"	m	class:langutil::SourceReferenceFormatterHuman	access:private
m_coloredOutput	solse/CommandLineInterface.h	/^	bool m_coloredOutput = true;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_compatibleBytesType	libsolidity/ast/Types.h	/^	TypePointer m_compatibleBytesType;$/;"	m	class:dev::solidity::RationalNumberType	access:private
m_compiler	solse/CommandLineInterface.h	/^	std::unique_ptr<dev::solidity::CompilerStack> m_compiler;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_compilerStack	libsolidity/interface/StandardCompiler.h	/^	CompilerStack m_compilerStack;$/;"	m	class:dev::solidity::StandardCompiler	access:private
m_complete	liblangutil/Scanner.cpp	/^	bool m_complete;$/;"	m	class:langutil::LiteralScope	file:	access:private
m_components	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Expression>> m_components;$/;"	m	class:dev::solidity::TupleExpression	access:private
m_components	libsolidity/ast/Types.h	/^	std::vector<TypePointer> const m_components;$/;"	m	class:dev::solidity::TupleType::std	access:private
m_condExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condExpression;$/;"	m	class:dev::solidity::ForStatement	access:private
m_condition	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condition;$/;"	m	class:dev::solidity::Conditional	access:private
m_condition	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condition;$/;"	m	class:dev::solidity::IfStatement	access:private
m_condition	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_condition;$/;"	m	class:dev::solidity::WhileStatement	access:private
m_constVariableDependencies	libsolidity/analysis/PostTypeChecker.h	/^	std::map<VariableDeclaration const*, std::set<VariableDeclaration const*>> m_constVariableDependencies;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
m_constVariables	libsolidity/analysis/PostTypeChecker.h	/^	std::vector<VariableDeclaration const*> m_constVariables; \/\/\/< Required for determinism.$/;"	m	class:dev::solidity::PostTypeChecker	access:private
m_constants	libsolidity/formal/Z3Interface.h	/^	std::map<std::string, z3::expr> m_constants;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
m_constants	libyul/optimiser/FullInliner.h	/^	std::set<YulString> m_constants;$/;"	m	class:yul::FullInliner	access:private
m_constructor	libsolidity/analysis/StaticAnalyzer.h	/^	bool m_constructor = false;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_constructorType	libsolidity/ast/Types.h	/^	mutable FunctionTypePointer m_constructorType;$/;"	m	class:dev::solidity::ContractType	access:private
m_constructorUsesAssembly	libsolidity/analysis/StaticAnalyzer.h	/^	std::unique_ptr<ConstructorUsesAssembly> m_constructorUsesAssembly;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_context	libsolidity/codegen/ArrayUtils.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::ArrayUtils	access:private
m_context	libsolidity/codegen/Compiler.h	/^	CompilerContext m_context;$/;"	m	class:dev::solidity::Compiler	access:private
m_context	libsolidity/codegen/CompilerUtils.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::CompilerUtils	access:private
m_context	libsolidity/codegen/ContractCompiler.cpp	/^	CompilerContext const& m_context;$/;"	m	class:__anon12::StackHeightChecker	file:	access:private
m_context	libsolidity/codegen/ContractCompiler.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_context	libsolidity/codegen/ExpressionCompiler.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
m_context	libsolidity/codegen/LValue.h	/^	CompilerContext& m_context;$/;"	m	class:dev::solidity::LValue	access:protected
m_context	libsolidity/formal/CVC4Interface.h	/^	CVC4::ExprManager m_context;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:private
m_context	libsolidity/formal/Z3Interface.h	/^	z3::context m_context;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
m_context	libyul/backends/evm/EVMCodeTransform.h	/^	CodeTransformContext& m_context;$/;"	m	class:yul::VariableReferenceCounter	access:private
m_context	libyul/backends/evm/EVMCodeTransform.h	/^	std::shared_ptr<Context> m_context;$/;"	m	class:yul::CodeTransform	access:private
m_continueJump	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_continueJump = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_continueTags	libsolidity/codegen/ContractCompiler.h	/^	std::vector<std::pair<eth::AssemblyItem, unsigned>> m_continueTags;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_contract	libsolidity/ast/Types.h	/^	ContractDefinition const& m_contract;$/;"	m	class:dev::solidity::ContractType	access:private
m_contractKind	libsolidity/ast/AST.h	/^	ContractKind m_contractKind;$/;"	m	class:dev::solidity::ContractDefinition	access:private
m_contracts	libsolidity/interface/CompilerStack.h	/^	std::map<std::string const, Contract> m_contracts;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_cost	libyul/optimiser/Metrics.h	/^	size_t m_cost = 0;$/;"	m	class:yul::CodeCost	access:private
m_count	libdevcore/vector_ref.h	/^	size_t m_count = 0;$/;"	m	class:dev::vector_ref	access:private
m_counter	libyul/optimiser/NameDispenser.h	/^	size_t m_counter = 0;$/;"	m	class:yul::NameDispenser	access:private
m_currentBlock	libyul/optimiser/ExpressionJoiner.h	/^	Block* m_currentBlock = nullptr;		\/\/\/< Pointer to current block holding the statement being visited.$/;"	m	class:yul::ExpressionJoiner	access:private
m_currentConstVariable	libsolidity/analysis/PostTypeChecker.h	/^	VariableDeclaration const* m_currentConstVariable = nullptr;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
m_currentContract	libsolidity/analysis/GlobalContext.h	/^	ContractDefinition const* m_currentContract = nullptr;$/;"	m	class:dev::solidity::GlobalContext	access:private
m_currentContract	libsolidity/analysis/StaticAnalyzer.h	/^	ContractDefinition const* m_currentContract = nullptr;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_currentFunction	libsolidity/analysis/NameAndTypeResolver.h	/^	VariableScope* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
m_currentFunction	libsolidity/analysis/StaticAnalyzer.h	/^	FunctionDefinition const* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_currentFunction	libsolidity/analysis/ViewPureChecker.h	/^	FunctionDefinition const* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
m_currentFunction	libsolidity/codegen/ContractCompiler.h	/^	FunctionDefinition const* m_currentFunction = nullptr;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_currentFunction	libyul/optimiser/FullInliner.h	/^	YulString m_currentFunction;$/;"	m	class:yul::InlineModifier	access:private
m_currentFunctions	libyul/optimiser/ExpressionInliner.h	/^	std::set<YulString> m_currentFunctions;$/;"	m	class:yul::ExpressionInliner	access:private
m_currentIndex	libsolidity/formal/SSAVariable.h	/^	unsigned m_currentIndex;$/;"	m	class:dev::solidity::SSAVariable	access:private
m_currentLValue	libsolidity/codegen/ExpressionCompiler.h	/^	std::unique_ptr<LValue> m_currentLValue;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
m_currentNode	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_currentNode = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_currentObject	libyul/backends/evm/EVMDialect.h	/^	Object const* m_currentObject = nullptr;$/;"	m	struct:yul::EVMDialect	access:protected
m_currentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	ASTNode const* m_currentScope = nullptr;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
m_currentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	DeclarationContainer* m_currentScope = nullptr;$/;"	m	class:dev::solidity::NameAndTypeResolver	access:private
m_currentScope	libyul/AsmAnalysis.h	/^	Scope* m_currentScope = nullptr;$/;"	m	class:yul::AsmAnalyzer	access:private
m_currentScope	libyul/AsmScopeFiller.h	/^	Scope* m_currentScope = nullptr;$/;"	m	class:yul::ScopeFiller	access:private
m_currentSourceLocation	libevmasm/Assembly.h	/^	langutil::SourceLocation m_currentSourceLocation;$/;"	m	class:dev::eth::Assembly	access:protected
m_currentToken	liblangutil/Scanner.h	/^	TokenDesc m_currentToken;  \/\/ desc for current token (as returned by Next())$/;"	m	class:langutil::Scanner	access:private
m_currentValue	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value m_currentValue;$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
m_currentVariableValues	libyul/optimiser/SSATransform.h	/^	std::map<YulString, YulString> m_currentVariableValues;$/;"	m	class:yul::SSATransform	access:private
m_data	libdevcore/FixedHash.h	/^	std::array<uint8_t, N> m_data;		\/\/\/< The binary data.$/;"	m	class:dev::FixedHash	access:private
m_data	libdevcore/vector_ref.h	/^	_T* m_data = nullptr;$/;"	m	class:dev::vector_ref	access:private
m_data	libevmasm/Assembly.h	/^	std::map<h256, bytes> m_data;$/;"	m	class:dev::eth::Assembly	access:protected
m_data	libevmasm/AssemblyItem.h	/^	std::shared_ptr<u256> m_data; \/\/\/< Only valid if m_type != Operation$/;"	m	class:dev::eth::AssemblyItem	access:private
m_data	libevmasm/SimplificationRules.h	/^	std::shared_ptr<u256> m_data; \/\/\/< Only valid if m_type is not Operation$/;"	m	class:dev::eth::Pattern	access:private
m_data	libyul/optimiser/SimplificationRules.h	/^	std::shared_ptr<dev::u256> m_data; \/\/\/< Only valid if m_kind is Constant$/;"	m	class:yul::Pattern	access:private
m_dataHashBySubId	libyul/backends/evm/AsmCodeGen.h	/^	std::map<SubID, dev::u256> m_dataHashBySubId;$/;"	m	class:yul::EthAssemblyAdapter	access:private
m_dataType	libsolidity/codegen/LValue.h	/^	Type const* m_dataType;$/;"	m	class:dev::solidity::LValue	access:protected
m_declaration	libsolidity/analysis/ControlFlowGraph.h	/^	VariableDeclaration const& m_declaration;$/;"	m	class:dev::solidity::VariableOccurrence	access:private
m_declaration	libsolidity/ast/Types.h	/^	Declaration const* m_declaration = nullptr;$/;"	m	class:dev::solidity::FunctionType	access:private
m_declaration	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression m_declaration;$/;"	m	class:dev::solidity::SymbolicFunctionVariable	access:private
m_declarations	libsolidity/analysis/DeclarationContainer.h	/^	std::map<ASTString, std::vector<Declaration const*>> m_declarations;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
m_declaredVariables	libyul/optimiser/RedundantAssignEliminator.h	/^	std::set<YulString> m_declaredVariables;$/;"	m	class:yul::RedundantAssignEliminator	access:private
m_deposit	libevmasm/Assembly.h	/^	int m_deposit = 0;$/;"	m	class:dev::eth::Assembly	access:protected
m_depth	libdevcore/Algorithms.h	/^	size_t m_depth = 0;$/;"	m	class:dev::CycleDetector	access:private
m_depth	libsolidity/analysis/ConstantEvaluator.h	/^	size_t m_depth = 0;$/;"	m	class:dev::solidity::ConstantEvaluator	access:private
m_dialect	libyul/AsmAnalysis.h	/^	std::shared_ptr<Dialect> m_dialect;$/;"	m	class:yul::AsmAnalyzer	access:private
m_dialect	libyul/AsmParser.h	/^	std::shared_ptr<Dialect> m_dialect;$/;"	m	class:yul::Parser	access:private
m_dialect	libyul/ObjectParser.h	/^	std::shared_ptr<Dialect> m_dialect;$/;"	m	class:yul::ObjectParser	access:private
m_dialect	libyul/backends/evm/EVMCodeTransform.h	/^	EVMDialect const& m_dialect;$/;"	m	class:yul::CodeTransform	access:private
m_dialect	libyul/backends/evm/EVMObjectCompiler.h	/^	EVMDialect& m_dialect;$/;"	m	class:yul::EVMObjectCompiler	access:private
m_dialect	libyul/optimiser/DataFlowAnalyzer.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
m_dialect	libyul/optimiser/Disambiguator.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::Disambiguator	access:protected
m_dialect	libyul/optimiser/ExpressionInliner.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::ExpressionInliner	access:private
m_dialect	libyul/optimiser/ExpressionSplitter.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::ExpressionSplitter	access:private
m_dialect	libyul/optimiser/NameDispenser.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::NameDispenser	access:private
m_dialect	libyul/optimiser/RedundantAssignEliminator.h	/^	Dialect const* m_dialect;$/;"	m	class:yul::RedundantAssignEliminator	access:private
m_dialect	libyul/optimiser/Semantics.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::MovableChecker	access:private
m_dialect	libyul/optimiser/UnusedPruner.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::UnusedPruner	access:private
m_dialect	libyul/optimiser/VarNameCleaner.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::VarNameCleaner	access:private
m_disallowedIdentifiers	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	std::set<YulString> m_disallowedIdentifiers;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:private
m_disjunction	libsolidity/analysis/SemVerHandler.h	/^	std::vector<Conjunction> m_disjunction;$/;"	m	struct:dev::solidity::SemVerMatchExpression	access:public
m_docTags	libsolidity/parsing/DocStringParser.h	/^	std::multimap<std::string, DocTag> m_docTags;$/;"	m	class:dev::solidity::DocStringParser	access:private
m_documentation	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_documentation;$/;"	m	class:dev::solidity::Documented	access:protected
m_driver	libyul/optimiser/FullInliner.h	/^	FullInliner& m_driver;$/;"	m	class:yul::InlineModifier	access:private
m_duplicates	libyul/optimiser/EquivalentFunctionCombiner.h	/^	std::map<YulString, FunctionDefinition const*> m_duplicates;$/;"	m	class:yul::EquivalentFunctionCombiner	access:private
m_duplicates	libyul/optimiser/EquivalentFunctionDetector.h	/^	std::map<YulString, FunctionDefinition const*> m_duplicates;$/;"	m	class:yul::EquivalentFunctionDetector	access:private
m_enabled	libdevcore/AnsiColorized.h	/^	bool m_enabled;$/;"	m	class:dev::AnsiColorized	access:private
m_enclosingContainer	libsolidity/analysis/DeclarationContainer.h	/^	DeclarationContainer const* m_enclosingContainer;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
m_enclosingNode	libsolidity/analysis/DeclarationContainer.h	/^	ASTNode const* m_enclosingNode;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
m_entryLabels	libsolidity/codegen/CompilerContext.h	/^		std::map<Declaration const*, eth::AssemblyItem> m_entryLabels;$/;"	m	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public
m_enum	libsolidity/ast/Types.h	/^	EnumDefinition const& m_enum;$/;"	m	class:dev::solidity::EnumType	access:private
m_error	solse/CommandLineInterface.h	/^	bool m_error = false; \/\/\/< If true, some error occurred.$/;"	m	class:dev::solidity::DocumentationType	access:private
m_errorCount	liblangutil/ErrorReporter.h	/^	unsigned m_errorCount = 0;$/;"	m	class:langutil::ErrorReporter	access:private
m_errorList	liblangutil/ErrorReporter.h	/^		m_errorList(_errorReporter.m_errorList) { }$/;"	f	class:langutil::ErrorReporter	access:public	signature:(_errorReporter.m_errorList)
m_errorList	liblangutil/ErrorReporter.h	/^	ErrorList& m_errorList;$/;"	m	class:langutil::ErrorReporter	access:private
m_errorList	libsolidity/interface/CompilerStack.h	/^	langutil::ErrorList m_errorList;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_errorOccured	libsolidity/analysis/DocStringAnalyser.h	/^	bool m_errorOccured = false;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
m_errorOccurred	libsolidity/analysis/ReferencesResolver.h	/^	bool m_errorOccurred = false;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
m_errorReporter	liblangutil/ParserBase.h	/^	ErrorReporter& m_errorReporter;$/;"	m	class:langutil::ParserBase	access:protected
m_errorReporter	libsolidity/analysis/ConstantEvaluator.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ConstantEvaluator	access:private
m_errorReporter	libsolidity/analysis/ContractLevelChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ContractLevelChecker	access:private
m_errorReporter	libsolidity/analysis/ControlFlowAnalyzer.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ControlFlowAnalyzer	access:private
m_errorReporter	libsolidity/analysis/ControlFlowGraph.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::CFG	access:private
m_errorReporter	libsolidity/analysis/DocStringAnalyser.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
m_errorReporter	libsolidity/analysis/NameAndTypeResolver.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
m_errorReporter	libsolidity/analysis/NameAndTypeResolver.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::NameAndTypeResolver	access:private
m_errorReporter	libsolidity/analysis/PostTypeChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
m_errorReporter	libsolidity/analysis/ReferencesResolver.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
m_errorReporter	libsolidity/analysis/StaticAnalyzer.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_errorReporter	libsolidity/analysis/SyntaxChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
m_errorReporter	libsolidity/analysis/TypeChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::TypeChecker	access:private
m_errorReporter	libsolidity/analysis/ViewPureChecker.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
m_errorReporter	libsolidity/formal/SMTChecker.h	/^	langutil::ErrorReporter m_errorReporter;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_errorReporter	libsolidity/interface/CompilerStack.h	/^	langutil::ErrorReporter m_errorReporter;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_errorReporter	libsolidity/parsing/DocStringParser.h	/^	langutil::ErrorReporter* m_errorReporter = nullptr;$/;"	m	class:dev::solidity::DocStringParser	access:private
m_errorReporter	libyul/AsmAnalysis.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:yul::AsmAnalyzer	access:private
m_errorReporter	libyul/AsmScopeFiller.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:yul::ScopeFiller	access:private
m_errorReporter	libyul/AssemblyStack.h	/^	langutil::ErrorReporter m_errorReporter;$/;"	m	class:yul::AssemblyStack	access:private
m_errorReporterReference	libsolidity/formal/SMTChecker.h	/^	langutil::ErrorReporter& m_errorReporterReference;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_errorTypeForLoose	libyul/AsmAnalysis.h	/^	boost::optional<langutil::Error::Type> m_errorTypeForLoose;$/;"	m	class:yul::AsmAnalyzer	access:private
m_errors	libsolidity/analysis/ViewPureChecker.h	/^	bool m_errors = false;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
m_errors	libyul/AssemblyStack.h	/^	langutil::ErrorList m_errors;$/;"	m	class:yul::AssemblyStack	access:private
m_errorsOccurred	libsolidity/parsing/DocStringParser.h	/^	bool m_errorsOccurred = false;$/;"	m	class:dev::solidity::DocStringParser	access:private
m_eventCall	libsolidity/ast/AST.h	/^	ASTPointer<FunctionCall> m_eventCall;$/;"	m	class:dev::solidity::EmitStatement	access:private
m_evm15	libyul/backends/evm/EVMAssembly.h	/^	bool m_evm15 = false; \/\/\/< if true, switch to evm1.5 mode$/;"	m	class:yul::EVMAssembly	access:private
m_evm15	libyul/backends/evm/EVMCodeTransform.h	/^	bool const m_evm15 = false;$/;"	m	class:yul::CodeTransform	access:private
m_evm15	libyul/backends/evm/EVMObjectCompiler.h	/^	bool m_evm15 = false;$/;"	m	class:yul::EVMObjectCompiler	access:private
m_evm15	libyul/backends/evm/NoOutputAssembly.h	/^	bool m_evm15 = false; \/\/\/< if true, switch to evm1.5 mode$/;"	m	class:yul::NoOutputAssembly	access:private
m_evmVersion	libevmasm/GasMeter.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::eth::GasMeter	access:private
m_evmVersion	libevmasm/PathGasMeter.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::eth::PathGasMeter	access:private
m_evmVersion	libsolidity/analysis/TypeChecker.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::TypeChecker	access:private
m_evmVersion	libsolidity/codegen/ABIFunctions.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::ABIFunctions	access:private
m_evmVersion	libsolidity/codegen/CompilerContext.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_evmVersion	libsolidity/interface/CompilerStack.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_evmVersion	libsolidity/interface/GasEstimator.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	struct:dev::solidity::GasEstimator	access:private
m_evmVersion	libyul/AsmAnalysis.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:yul::AsmAnalyzer	access:private
m_evmVersion	libyul/AssemblyStack.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:yul::AssemblyStack	access:private
m_evmVersion	libyul/backends/evm/EVMDialect.cpp	/^	Dialect{_flavour}, m_objectAccess(_objectAccess), m_evmVersion(_evmVersion)$/;"	f	signature:(_evmVersion)
m_evmVersion	libyul/backends/evm/EVMDialect.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	struct:yul::EVMDialect	access:protected
m_evmVersion	solse/CommandLineInterface.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_experimentalFeatures	libsolidity/codegen/CompilerContext.h	/^	std::set<ExperimentalFeature> m_experimentalFeatures;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_expression	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpression m_expression;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression; \/\/\/< value to return, optional$/;"	m	class:dev::solidity::Return	access:private
m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression;$/;"	m	class:dev::solidity::ExpressionStatement	access:private
m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression;$/;"	m	class:dev::solidity::FunctionCall	access:private
m_expression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_expression;$/;"	m	class:dev::solidity::MemberAccess	access:private
m_expressionClasses	libevmasm/CommonSubexpressionEliminator.h	/^	ExpressionClasses& m_expressionClasses;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_expressionClasses	libevmasm/KnownState.h	/^	std::shared_ptr<ExpressionClasses> m_expressionClasses;$/;"	m	class:dev::eth::KnownState	access:private
m_expressions	libevmasm/ExpressionClasses.h	/^	std::set<Expression> m_expressions;$/;"	m	class:dev::eth::ExpressionClasses	access:private
m_expressions	libsolidity/formal/SMTChecker.h	/^	std::unordered_map<Expression const*, std::shared_ptr<SymbolicVariable>> m_expressions;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_externallyUsedFunctions	libsolidity/codegen/ABIFunctions.h	/^	std::set<std::string> m_externallyUsedFunctions;$/;"	m	class:dev::solidity::ABIFunctions	access:private
m_externallyUsedIdentifiers	libyul/optimiser/Disambiguator.h	/^	std::set<YulString> const& m_externallyUsedIdentifiers;$/;"	m	class:yul::Disambiguator::std	access:protected
m_f	libdevcore/Common.h	/^	std::function<void(void)> m_f;$/;"	m	class:dev::ScopeGuard	access:private
m_falseBody	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_falseBody; \/\/\/< "else" part, optional$/;"	m	class:dev::solidity::IfStatement	access:private
m_falseExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_falseExpression;$/;"	m	class:dev::solidity::Conditional	access:private
m_finalClasses	libevmasm/CommonSubexpressionEliminator.h	/^	std::set<Id> m_finalClasses;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_firstCycleVertex	libdevcore/Algorithms.h	/^	V const* m_firstCycleVertex = nullptr;$/;"	m	class:dev::CycleDetector	access:private
m_firstNumber	liblangutil/Token.h	/^	unsigned int m_firstNumber;$/;"	m	class:langutil::ElementaryTypeNameToken	access:private
m_foundDisallowedIdentifier	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	bool m_foundDisallowedIdentifier = false;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:private
m_fractionalDigits	libsolidity/ast/Types.h	/^	unsigned m_fractionalDigits;$/;"	m	class:dev::solidity::FixedPointType	access:private
m_fun	libyul/optimiser/EquivalentFunctionDetector.h	/^		FunctionDefinition const& m_fun;$/;"	m	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:private
m_functionCompilationQueue	libsolidity/codegen/CompilerContext.h	/^	} m_functionCompilationQueue;$/;"	m	class:dev::solidity::CompilerContext	typeref:struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:private
m_functionControlFlow	libsolidity/analysis/ControlFlowGraph.h	/^	std::map<FunctionDefinition const*, std::unique_ptr<FunctionFlow>> m_functionControlFlow;$/;"	m	class:dev::solidity::CFG	access:private
m_functionModifiers	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ModifierInvocation>> m_functionModifiers;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
m_functionPath	libsolidity/formal/SMTChecker.h	/^	std::vector<FunctionDefinition const*> m_functionPath;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_functionSizes	libyul/optimiser/FullInliner.h	/^	std::map<YulString, size_t> m_functionSizes;$/;"	m	class:yul::FullInliner	access:private
m_functions	libsolidity/formal/Z3Interface.h	/^	std::map<std::string, z3::func_decl> m_functions;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
m_functions	libyul/backends/evm/EVMDialect.h	/^	std::map<YulString, BuiltinFunctionForEVM> m_functions;$/;"	m	struct:yul::EVMDialect	access:protected
m_functions	libyul/optimiser/FullInliner.h	/^	std::map<YulString, FunctionDefinition*> m_functions;$/;"	m	class:yul::FullInliner	access:private
m_functions	libyul/optimiser/FunctionHoister.h	/^	std::vector<Statement> m_functions;$/;"	m	class:yul::FunctionHoister	access:private
m_functionsToCompile	libsolidity/codegen/CompilerContext.h	/^		mutable std::queue<Declaration const*> m_functionsToCompile;$/;"	m	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public
m_gasCosts	libsolidity/ast/ASTPrinter.h	/^	GasEstimator::ASTGasConsumption m_gasCosts;$/;"	m	class:dev::solidity::ASTPrinter	access:private
m_gasSet	libsolidity/ast/Types.h	/^	bool const m_gasSet = false; \/\/\/< true iff the gas value to be used is on the stack$/;"	m	class:dev::solidity::FunctionType	access:private
m_generatedItems	libevmasm/CommonSubexpressionEliminator.h	/^	AssemblyItems m_generatedItems;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_globalContext	libsolidity/formal/SMTChecker.h	/^	std::unordered_map<std::string, std::shared_ptr<SymbolicVariable>> m_globalContext;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_globalContext	libsolidity/interface/CompilerStack.h	/^	std::shared_ptr<GlobalContext> m_globalContext;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_hasDynamicLength	libsolidity/ast/Types.h	/^	bool m_hasDynamicLength = true;$/;"	m	class:dev::solidity::ArrayType	access:private
m_hashToID	libyul/YulString.h	/^	std::unordered_multimap<std::uint64_t, size_t> m_hashToID = {{emptyHash(), 0}};$/;"	m	class:yul::YulStringRepository	access:private
m_highestGasUsagePerJumpdest	libevmasm/PathGasMeter.h	/^	std::map<size_t, GasMeter::GasConsumption> m_highestGasUsagePerJumpdest;$/;"	m	class:dev::eth::PathGasMeter	access:private
m_id	libevmasm/ControlFlowGraph.h	/^	unsigned m_id;$/;"	m	class:dev::eth::BlockId	access:private
m_id	libsolidity/ast/AST.h	/^	size_t const m_id = 0;$/;"	m	class:dev::solidity::ASTNode	access:protected
m_identifierAccess	libyul/backends/evm/EVMCodeTransform.h	/^	ExternalIdentifierAccess m_identifierAccess;$/;"	m	class:yul::CodeTransform	access:private
m_identifiersLHS	libyul/optimiser/SyntacticalEquality.h	/^	std::map<YulString, std::size_t> m_identifiersLHS;$/;"	m	class:yul::SyntacticallyEqual	access:private
m_identifiersRHS	libyul/optimiser/SyntacticalEquality.h	/^	std::map<YulString, std::size_t> m_identifiersRHS;$/;"	m	class:yul::SyntacticallyEqual	access:private
m_idsUsed	libyul/optimiser/SyntacticalEquality.h	/^	std::size_t m_idsUsed = 0;$/;"	m	class:yul::SyntacticallyEqual	access:private
m_ignoreFunctions	libyul/optimiser/Metrics.h	/^	bool m_ignoreFunctions;$/;"	m	class:yul::CodeSize	access:private
m_implemented	libsolidity/ast/AST.h	/^	bool m_implemented;$/;"	m	class:dev::solidity::ImplementationOptional	access:protected
m_inEvent	libsolidity/ast/ASTJsonConverter.h	/^	bool m_inEvent = false; \/\/\/< whether we are currently inside an event or not$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
m_inLoopDepth	libsolidity/analysis/SyntaxChecker.h	/^	int m_inLoopDepth = 0;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
m_indentation	libsolidity/ast/ASTPrinter.h	/^	int m_indentation;$/;"	m	class:dev::solidity::ASTPrinter	access:private
m_index	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_index;$/;"	m	class:dev::solidity::IndexAccess	access:private
m_inferredMutability	libsolidity/analysis/ViewPureChecker.h	/^	std::map<ModifierDefinition const*, MutabilityAndLocation> m_inferredMutability;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
m_info	libyul/AsmAnalysis.h	/^	AsmAnalysisInfo& m_info;$/;"	m	class:yul::AsmAnalyzer	access:private
m_info	libyul/AsmScopeFiller.h	/^	AsmAnalysisInfo& m_info;$/;"	m	class:yul::ScopeFiller	access:private
m_info	libyul/backends/evm/EVMCodeTransform.h	/^	AsmAnalysisInfo const& m_info;$/;"	m	class:yul::VariableReferenceCounter	access:private
m_info	libyul/backends/evm/EVMCodeTransform.h	/^	AsmAnalysisInfo& m_info;$/;"	m	class:yul::CodeTransform	access:private
m_info	libyul/optimiser/Disambiguator.h	/^	AsmAnalysisInfo const& m_info;$/;"	m	class:yul::Disambiguator	access:protected
m_inheritableMembers	libsolidity/ast/AST.h	/^	mutable std::unique_ptr<std::vector<Declaration const*>> m_inheritableMembers;$/;"	m	class:dev::solidity::ContractDefinition	access:private
m_inheritanceHierarchy	libsolidity/codegen/CompilerContext.h	/^	std::vector<ContractDefinition const*> m_inheritanceHierarchy;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_initExpression	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_initExpression;$/;"	m	class:dev::solidity::ForStatement	access:private
m_initialState	libevmasm/CommonSubexpressionEliminator.h	/^	KnownState m_initialState;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
m_initialValue	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_initialValue;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:private
m_inlinableFunctions	libyul/optimiser/ExpressionInliner.h	/^	std::map<YulString, FunctionDefinition const*> m_inlinableFunctions;$/;"	m	class:yul::ExpressionInliner	access:private
m_inlinableFunctions	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	std::map<YulString, FunctionDefinition const*> m_inlinableFunctions;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:private
m_insideEmitStatement	libsolidity/analysis/TypeChecker.h	/^	bool m_insideEmitStatement = false;$/;"	m	class:dev::solidity::TypeChecker	access:private
m_insideFunction	libyul/optimiser/VarNameCleaner.h	/^	bool m_insideFunction = false;$/;"	m	class:yul::VarNameCleaner	access:private
m_insideModifier	libsolidity/parsing/Parser.h	/^	bool m_insideModifier = false;$/;"	m	class:dev::solidity::Parser	access:private
m_insideStruct	libsolidity/analysis/TypeChecker.h	/^	bool m_insideStruct = false;$/;"	m	class:dev::solidity::TypeChecker	access:private
m_instruction	libevmasm/AssemblyItem.h	/^	Instruction m_instruction; \/\/\/< Only valid if m_type == Operation$/;"	m	class:dev::eth::AssemblyItem	access:private
m_instruction	libevmasm/SimplificationRules.h	/^	Instruction m_instruction; \/\/\/< Only valid if m_type is Operation$/;"	m	class:dev::eth::Pattern	access:private
m_instruction	libyul/optimiser/SimplificationRules.h	/^	dev::solidity::Instruction m_instruction; \/\/\/< Only valid if m_kind is Operation$/;"	m	class:yul::Pattern	access:private
m_interface	libsolidity/formal/SMTChecker.h	/^	std::shared_ptr<smt::SolverInterface> m_interface;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_interface	libsolidity/formal/SymbolicVariables.h	/^	smt::SolverInterface& m_interface;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
m_interfaceEvents	libsolidity/ast/AST.h	/^	mutable std::unique_ptr<std::vector<EventDefinition const*>> m_interfaceEvents;$/;"	m	class:dev::solidity::ContractDefinition	access:private
m_interfaceFunctionList	libsolidity/ast/AST.h	/^	mutable std::unique_ptr<std::vector<std::pair<FixedHash<4>, FunctionTypePointer>>> m_interfaceFunctionList;$/;"	m	class:dev::solidity::ContractDefinition	access:private
m_invisibleDeclarations	libsolidity/analysis/DeclarationContainer.h	/^	std::map<ASTString, std::vector<Declaration const*>> m_invisibleDeclarations;$/;"	m	class:dev::solidity::DeclarationContainer	access:private
m_isArray	libsolidity/ast/AST.h	/^	bool m_isArray;$/;"	m	class:dev::solidity::TupleExpression	access:private
m_isConstant	libsolidity/ast/AST.h	/^	bool m_isConstant; \/\/\/< Whether the variable is a compile-time constant.$/;"	m	class:dev::solidity::VariableDeclaration	access:private
m_isConstructor	libsolidity/ast/AST.h	/^	bool m_isConstructor;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
m_isDoWhile	libsolidity/ast/AST.h	/^	bool m_isDoWhile;$/;"	m	class:dev::solidity::WhileStatement	access:private
m_isIndexed	libsolidity/ast/AST.h	/^	bool m_isIndexed; \/\/\/< Whether this is an indexed variable (used by events).$/;"	m	class:dev::solidity::VariableDeclaration	access:private
m_isInterface	libsolidity/analysis/SyntaxChecker.h	/^	bool m_isInterface = false;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
m_isPointer	libsolidity/ast/Types.h	/^	bool m_isPointer = true;$/;"	m	class:dev::solidity::ReferenceType	access:protected
m_isPrefix	libsolidity/ast/AST.h	/^	bool m_isPrefix;$/;"	m	class:dev::solidity::UnaryOperation	access:private
m_isStateVariable	libsolidity/ast/AST.h	/^	bool m_isStateVariable; \/\/\/< Whether or not this is a contract state variable$/;"	m	class:dev::solidity::VariableDeclaration	access:private
m_isTopLevel	libyul/optimiser/FunctionHoister.h	/^	bool m_isTopLevel = true;$/;"	m	class:yul::FunctionHoister	access:private
m_items	libevmasm/Assembly.h	/^	AssemblyItems m_items;$/;"	m	class:dev::eth::Assembly	access:protected
m_items	libevmasm/BlockDeduplicator.h	/^	AssemblyItems& m_items;$/;"	m	class:dev::eth::BlockDeduplicator	access:private
m_items	libevmasm/ControlFlowGraph.h	/^	AssemblyItems const& m_items;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
m_items	libevmasm/JumpdestRemover.h	/^	AssemblyItems& m_items;$/;"	m	class:dev::eth::JumpdestRemover	access:private
m_items	libevmasm/PathGasMeter.h	/^	AssemblyItems const& m_items;$/;"	m	class:dev::eth::PathGasMeter	access:private
m_items	libevmasm/PeepholeOptimiser.h	/^	AssemblyItems& m_items;$/;"	m	class:dev::eth::PeepholeOptimiser	access:private
m_joinKnowledge	libevmasm/ControlFlowGraph.h	/^	bool m_joinKnowledge = true;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
m_jumpType	libevmasm/AssemblyItem.h	/^	JumpType m_jumpType = JumpType::Ordinary;$/;"	m	class:dev::eth::AssemblyItem	access:private
m_keyType	libsolidity/ast/AST.h	/^	ASTPointer<ElementaryTypeName> m_keyType;$/;"	m	class:dev::solidity::Mapping	access:private
m_keyType	libsolidity/ast/Types.h	/^	TypePointer m_keyType;$/;"	m	class:dev::solidity::MappingType	access:private
m_kind	libsolidity/ast/Types.h	/^	Kind const m_kind;$/;"	m	class:dev::solidity::FunctionType	access:private
m_kind	libsolidity/ast/Types.h	/^	Kind m_kind;$/;"	m	class:dev::solidity::MagicType	access:private
m_kind	libyul/optimiser/SimplificationRules.h	/^	PatternKind m_kind = PatternKind::Any;$/;"	m	class:yul::Pattern	access:private
m_knownKeccak256Hashes	libevmasm/KnownState.h	/^	std::map<std::vector<Id>, Id> m_knownKeccak256Hashes;$/;"	m	class:dev::eth::KnownState	access:private
m_labelPositions	libyul/backends/evm/EVMAssembly.h	/^	std::map<LabelID, size_t> m_labelPositions;$/;"	m	class:yul::EVMAssembly	access:private
m_labelReferences	libyul/backends/evm/EVMAssembly.h	/^	std::map<size_t, LabelID> m_labelReferences;$/;"	m	class:yul::EVMAssembly	access:private
m_language	libyul/AssemblyStack.h	/^	Language m_language = Language::Assembly;$/;"	m	class:yul::AssemblyStack	access:private
m_largestMemoryAccess	libevmasm/GasMeter.h	/^	u256 m_largestMemoryAccess;$/;"	m	class:dev::eth::GasMeter	access:private
m_lastTag	libsolidity/parsing/DocStringParser.h	/^	DocTag* m_lastTag = nullptr;$/;"	m	class:dev::solidity::DocStringParser	access:private
m_lastUsedId	libevmasm/ControlFlowGraph.h	/^	unsigned m_lastUsedId = 0;$/;"	m	class:dev::eth::ControlFlowGraph	access:private
m_latestStatementInBlock	libyul/optimiser/ExpressionJoiner.h	/^	size_t m_latestStatementInBlock = 0;		\/\/\/< Offset to m_currentBlock's statements of the last visited statement.$/;"	m	class:yul::ExpressionJoiner	access:private
m_left	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_left;$/;"	m	class:dev::solidity::BinaryOperation	access:private
m_leftHandSide	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_leftHandSide;$/;"	m	class:dev::solidity::Assignment	access:private
m_legacy	libsolidity/ast/ASTJsonConverter.h	/^	bool m_legacy = false; \/\/\/< if true, use legacy format$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
m_length	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_length; \/\/\/< Length of the array, might be empty.$/;"	m	class:dev::solidity::ArrayTypeName	access:private
m_length	libsolidity/ast/Types.h	/^	u256 m_length;$/;"	m	class:dev::solidity::ArrayType	access:private
m_libraries	libevmasm/Assembly.h	/^	std::map<h256, std::string> m_libraries; \/\/\/< Identifiers of libraries to be linked.$/;"	m	class:dev::eth::Assembly	access:protected
m_libraries	libsolidity/interface/CompilerStack.h	/^	std::map<std::string, h160> m_libraries;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_libraries	solse/CommandLineInterface.h	/^	std::map<std::string, h160> m_libraries;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_library	libsolidity/analysis/StaticAnalyzer.h	/^	bool m_library = false;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_libraryName	libsolidity/ast/AST.h	/^	ASTPointer<UserDefinedTypeName> m_libraryName;$/;"	m	class:dev::solidity::UsingForDirective	access:private
m_listParameters	libdevcore/Whiskers.h	/^	StringListMap m_listParameters;$/;"	m	class:dev::Whiskers	access:private
m_literals	libsolidity/analysis/SemVerHandler.h	/^	std::vector<std::string> m_literals;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
m_literals	libsolidity/ast/AST.h	/^	std::vector<ASTString> m_literals;$/;"	m	class:dev::solidity::PragmaDirective	access:private
m_localVarUseCount	libsolidity/analysis/StaticAnalyzer.h	/^	std::map<std::pair<size_t, VariableDeclaration const*>, int> m_localVarUseCount;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
m_localVariables	libsolidity/ast/AST.h	/^	std::vector<VariableDeclaration const*> m_localVariables;$/;"	m	class:dev::solidity::VariableScope	access:private
m_localVariables	libsolidity/codegen/CompilerContext.h	/^	std::map<Declaration const*, std::vector<unsigned>> m_localVariables;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_location	libevmasm/Assembly.cpp	/^	SourceLocation m_location;$/;"	m	class:__anon18::Functionalizer	file:	access:private
m_location	libevmasm/AssemblyItem.h	/^	langutil::SourceLocation m_location;$/;"	m	class:dev::eth::AssemblyItem	access:private
m_location	libsolidity/ast/AST.h	/^	Location m_location; \/\/\/< Location of the variable if it is of reference type.$/;"	m	class:dev::solidity::VariableDeclaration	access:private
m_location	libsolidity/ast/AST.h	/^	SourceLocation m_location;$/;"	m	class:dev::solidity::ASTNode	access:private
m_location	libsolidity/ast/Types.h	/^	DataLocation m_location = DataLocation::Storage;$/;"	m	class:dev::solidity::ReferenceType	access:protected
m_location	libsolidity/parsing/Parser.cpp	/^	SourceLocation m_location;$/;"	m	class:dev::solidity::Parser::ASTNodeFactory	file:	access:private
m_loopExecutionHappened	libsolidity/formal/SMTChecker.h	/^	bool m_loopExecutionHappened = false;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_loopExpression	libsolidity/ast/AST.h	/^	ASTPointer<ExpressionStatement> m_loopExpression;$/;"	m	class:dev::solidity::ForStatement	access:private
m_lowLevelFunctionGenerationQueue	libsolidity/codegen/CompilerContext.h	/^	std::queue<std::tuple<std::string, unsigned, unsigned, std::function<void(CompilerContext&)>>> m_lowLevelFunctionGenerationQueue;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_lowLevelFunctions	libsolidity/codegen/CompilerContext.h	/^	std::map<std::string, eth::AssemblyItem> m_lowLevelFunctions;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_lvalues	libsolidity/codegen/LValue.h	/^	std::vector<std::unique_ptr<LValue>> m_lvalues;$/;"	m	class:dev::solidity::TupleObject	access:private
m_magicVariables	libsolidity/analysis/GlobalContext.h	/^	std::vector<std::shared_ptr<MagicVariableDeclaration const>> m_magicVariables;$/;"	m	class:dev::solidity::GlobalContext	access:private
m_matchGroup	libevmasm/SimplificationRules.h	/^	unsigned m_matchGroup = 0;$/;"	m	class:dev::eth::Pattern	access:private
m_matchGroup	libyul/optimiser/SimplificationRules.h	/^	unsigned m_matchGroup = 0;$/;"	m	class:yul::Pattern	access:private
m_matchGroups	libevmasm/SimplificationRules.h	/^	std::map<unsigned, Expression const*> m_matchGroups;$/;"	m	class:dev::eth::Rules	access:private
m_matchGroups	libevmasm/SimplificationRules.h	/^	std::map<unsigned, Expression const*>* m_matchGroups = nullptr;$/;"	m	class:dev::eth::Pattern	access:private
m_matchGroups	libyul/optimiser/SimplificationRules.h	/^	std::map<unsigned, Expression const*> m_matchGroups;$/;"	m	class:yul::SimplificationRules	access:private
m_matchGroups	libyul/optimiser/SimplificationRules.h	/^	std::map<unsigned, Expression const*>* m_matchGroups = nullptr;$/;"	m	class:yul::Pattern	access:private
m_maxSteps	libevmasm/ConstantOptimiser.h	/^	size_t m_maxSteps = 10000;$/;"	m	class:dev::eth::ComputeMethod	access:protected
m_memberName	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_memberName;$/;"	m	class:dev::solidity::MemberAccess	access:private
m_memberTypes	libsolidity/ast/Types.h	/^	MemberMap m_memberTypes;$/;"	m	class:dev::solidity::MemberList	access:private
m_members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<EnumValue>> m_members;$/;"	m	class:dev::solidity::EnumDefinition	access:private
m_members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> m_members;$/;"	m	class:dev::solidity::StructDefinition	access:private
m_members	libsolidity/ast/Types.h	/^	mutable std::map<ContractDefinition const*, std::unique_ptr<MemberList>> m_members;$/;"	m	class:dev::solidity::Type	access:protected
m_memoryContent	libevmasm/KnownState.h	/^	std::map<Id, Id> m_memoryContent;$/;"	m	class:dev::eth::KnownState	access:private
m_message	libdevcore/Result.h	/^	std::string m_message;$/;"	m	class:dev::Result	access:private
m_metadataLiteralSources	libsolidity/interface/CompilerStack.h	/^	bool m_metadataLiteralSources = false;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_modifier	libsolidity/ast/Types.h	/^	Modifier m_modifier;$/;"	m	class:dev::solidity::FixedPointType	access:private
m_modifier	libsolidity/ast/Types.h	/^	Modifier m_modifier;$/;"	m	class:dev::solidity::IntegerType	access:private
m_modifierDepth	libsolidity/codegen/ContractCompiler.h	/^	unsigned m_modifierDepth = 0;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_modifierName	libsolidity/ast/AST.h	/^	ASTPointer<Identifier> m_modifierName;$/;"	m	class:dev::solidity::ModifierInvocation	access:private
m_movable	libyul/optimiser/Semantics.h	/^	bool m_movable = true;$/;"	m	class:yul::MovableChecker	access:private
m_name	liblangutil/CharStream.h	/^	std::string m_name;$/;"	m	class:langutil::CharStream	access:private
m_name	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_name;$/;"	m	class:dev::solidity::Declaration	access:private
m_name	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_name;$/;"	m	class:dev::solidity::Identifier	access:private
m_nameDispenser	libyul/optimiser/Disambiguator.h	/^	NameDispenser m_nameDispenser;$/;"	m	class:yul::Disambiguator	access:protected
m_nameDispenser	libyul/optimiser/ExpressionSplitter.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::ExpressionSplitter	access:private
m_nameDispenser	libyul/optimiser/FullInliner.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::BodyCopier	access:public
m_nameDispenser	libyul/optimiser/FullInliner.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::FullInliner	access:private
m_nameDispenser	libyul/optimiser/FullInliner.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::InlineModifier	access:private
m_nameDispenser	libyul/optimiser/SSATransform.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::SSATransform	access:private
m_namePath	libsolidity/ast/AST.h	/^	std::vector<ASTString> m_namePath;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:private
m_namedLabels	libyul/backends/evm/EVMAssembly.h	/^	std::map<std::string, LabelID> m_namedLabels;$/;"	m	class:yul::EVMAssembly	access:private
m_namedTags	libevmasm/Assembly.h	/^	std::map<std::string, size_t> m_namedTags;$/;"	m	class:dev::eth::Assembly	access:protected
m_names	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTString>> m_names;$/;"	m	class:dev::solidity::FunctionCall	access:private
m_names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> m_names;$/;"	m	class:yul::Assignments	access:private
m_names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> m_names;$/;"	m	class:yul::NameCollector	access:private
m_neededBy	libevmasm/CommonSubexpressionEliminator.h	/^	std::multimap<Id, Id> m_neededBy;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_nextDataCounter	libyul/backends/evm/AsmCodeGen.h	/^	size_t m_nextDataCounter = std::numeric_limits<size_t>::max() \/ 2;$/;"	m	class:yul::EthAssemblyAdapter	access:private
m_nextFreeIndex	libsolidity/formal/SSAVariable.h	/^	std::shared_ptr<unsigned> m_nextFreeIndex;$/;"	m	class:dev::solidity::SSAVariable	access:private
m_nextLabelId	libyul/backends/evm/EVMAssembly.h	/^	LabelID m_nextLabelId = 0;$/;"	m	class:yul::EVMAssembly	access:private
m_nextSkippedComment	liblangutil/Scanner.h	/^	TokenDesc m_nextSkippedComment; \/\/ desc for next skipped comment$/;"	m	class:langutil::Scanner	access:private
m_nextToken	liblangutil/Scanner.h	/^	TokenDesc m_nextToken;     \/\/ desc for next token (one token look-ahead)$/;"	m	class:langutil::Scanner	access:private
m_noSolverWarning	libsolidity/formal/SMTChecker.h	/^	bool m_noSolverWarning = false;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_nodeContainer	libsolidity/analysis/ControlFlowBuilder.h	/^	CFG::NodeContainer& m_nodeContainer;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_nodeContainer	libsolidity/analysis/ControlFlowGraph.h	/^	NodeContainer m_nodeContainer;$/;"	m	class:dev::solidity::CFG	access:private
m_nodes	libsolidity/analysis/ControlFlowGraph.h	/^		std::vector<std::unique_ptr<CFGNode>> m_nodes;$/;"	m	class:dev::solidity::CFG::NodeContainer	access:private
m_nodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> m_nodes;$/;"	m	class:dev::solidity::SourceUnit	access:private
m_objectAccess	libyul/backends/evm/EVMDialect.h	/^	bool m_objectAccess;$/;"	m	struct:yul::EVMDialect	access:protected
m_occurrence	libsolidity/analysis/ControlFlowGraph.h	/^	ASTNode const* m_occurrence = nullptr;$/;"	m	class:dev::solidity::VariableOccurrence	access:private
m_occurrenceKind	libsolidity/analysis/ControlFlowGraph.h	/^	Kind m_occurrenceKind = Kind::Access;$/;"	m	class:dev::solidity::VariableOccurrence	access:private
m_offsets	libsolidity/ast/Types.h	/^	std::map<size_t, std::pair<u256, unsigned>> m_offsets;$/;"	m	class:dev::solidity::StorageOffsets	access:private
m_oldMode	libdevcore/CommonIO.cpp	/^	DWORD m_oldMode;$/;"	m	class:DisableConsoleBuffering	file:	access:private
m_onEdge	libsolidity/ast/ASTVisitor.h	/^	std::function<void(ASTNode const&, ASTNode const&)> m_onEdge;$/;"	m	class:dev::solidity::ASTReduce	access:private
m_onEndVisit	libsolidity/ast/ASTVisitor.h	/^	std::function<void(ASTNode const&)> m_onEndVisit;$/;"	m	class:dev::solidity::SimpleASTVisitor	access:private
m_onNode	libsolidity/ast/ASTVisitor.h	/^	std::function<bool(ASTNode const&)> m_onNode;$/;"	m	class:dev::solidity::ASTReduce	access:private
m_onVisit	libsolidity/ast/ASTVisitor.h	/^	std::function<bool(ASTNode const&)> m_onVisit;$/;"	m	class:dev::solidity::SimpleASTVisitor	access:private
m_onlyAssemble	solse/CommandLineInterface.h	/^	bool m_onlyAssemble = false;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_onlyLink	solse/CommandLineInterface.h	/^	bool m_onlyLink = false;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_operations	libsolidity/ast/AST.h	/^	std::shared_ptr<yul::Block> m_operations;$/;"	m	class:dev::solidity::InlineAssembly	access:private
m_operator	libsolidity/ast/AST.h	/^	Token m_operator;$/;"	m	class:dev::solidity::BinaryOperation	access:private
m_operator	libsolidity/ast/AST.h	/^	Token m_operator;$/;"	m	class:dev::solidity::UnaryOperation	access:private
m_optimiseOrderLiterals	libsolidity/codegen/ExpressionCompiler.h	/^	bool m_optimiseOrderLiterals;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
m_optimisedItems	libevmasm/PeepholeOptimiser.h	/^	AssemblyItems m_optimisedItems;$/;"	m	class:dev::eth::PeepholeOptimiser	access:private
m_optimiserSettings	libsolidity/codegen/Compiler.h	/^	OptimiserSettings const m_optimiserSettings;$/;"	m	class:dev::solidity::Compiler	access:private
m_optimiserSettings	libsolidity/codegen/ContractCompiler.h	/^	OptimiserSettings const m_optimiserSettings;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_optimiserSettings	libsolidity/interface/CompilerStack.h	/^	OptimiserSettings m_optimiserSettings;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_origBreakJump	libsolidity/analysis/ControlFlowBuilder.h	/^		CFGNode* m_origBreakJump;$/;"	m	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:private
m_origContinueJump	libsolidity/analysis/ControlFlowBuilder.h	/^		CFGNode* m_origContinueJump;$/;"	m	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:private
m_ostream	libsolidity/analysis/ControlFlowPrinter.h	/^  std::ostream* m_ostream = nullptr;$/;"	m	class:dev::solidity::ControlFlowPrinter	access:private
m_ostream	libsolidity/ast/ASTPrinter.h	/^	std::ostream* m_ostream = nullptr;$/;"	m	class:dev::solidity::ASTPrinter	access:private
m_otherCompilers	libsolidity/codegen/CompilerContext.h	/^	std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> m_otherCompilers;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_out	libevmasm/Assembly.cpp	/^	ostream& m_out;$/;"	m	class:__anon18::Functionalizer	file:	access:private
m_outerDeclaredVariables	libyul/optimiser/RedundantAssignEliminator.h	/^		std::set<YulString> m_outerDeclaredVariables;$/;"	m	class:yul::RedundantAssignEliminator::BlockScope	access:private
m_overflowTargets	libsolidity/formal/SMTChecker.h	/^	std::vector<OverflowTarget> m_overflowTargets;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_padded	libsolidity/codegen/LValue.h	/^	bool m_padded = false;$/;"	m	class:dev::solidity::MemoryItem	access:private
m_parameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> m_parameterNames;$/;"	m	class:dev::solidity::FunctionType	access:private
m_parameterTypes	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_parameterTypes;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
m_parameterTypes	libsolidity/ast/Types.h	/^	TypePointers m_parameterTypes;$/;"	m	class:dev::solidity::FunctionType	access:private
m_parameterTypes	libsolidity/ast/Types.h	/^	TypePointers m_parameterTypes;$/;"	m	class:dev::solidity::ModifierType	access:private
m_parameters	libdevcore/Whiskers.h	/^	StringMap m_parameters;$/;"	m	class:dev::Whiskers	access:private
m_parameters	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_parameters;$/;"	m	class:dev::solidity::CallableDeclaration	access:protected
m_parameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> m_parameters;$/;"	m	class:dev::solidity::ParameterList	access:private
m_params	libevmasm/ConstantOptimiser.h	/^	Params m_params;$/;"	m	class:dev::eth::ConstantOptimisationMethod	access:protected
m_parents	libsolidity/ast/ASTVisitor.h	/^	std::vector<ASTNode const*> m_parents;$/;"	m	class:dev::solidity::ASTReduce	access:private
m_parser	liblangutil/ParserBase.h	/^		ParserBase& m_parser;$/;"	m	class:langutil::ParserBase::RecursionGuard	access:private
m_parser	libsolidity/analysis/ControlFlowBuilder.h	/^		ControlFlowBuilder& m_parser;$/;"	m	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:private
m_parser	libsolidity/parsing/Parser.cpp	/^	Parser const& m_parser;$/;"	m	class:dev::solidity::Parser::ASTNodeFactory	file:	access:private
m_parserResult	libyul/AssemblyStack.h	/^	std::shared_ptr<yul::Object> m_parserResult;$/;"	m	class:yul::AssemblyStack	access:private
m_path	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_path;$/;"	m	class:dev::solidity::ImportDirective	access:private
m_pathConditions	libsolidity/formal/SMTChecker.h	/^	std::vector<smt::Expression> m_pathConditions;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_pending	libevmasm/Assembly.cpp	/^	strings m_pending;$/;"	m	class:__anon18::Functionalizer	file:	access:private
m_placeholderEntry	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_placeholderEntry = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_placeholderExit	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_placeholderExit = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_placeholderFound	libsolidity/analysis/SyntaxChecker.h	/^	bool m_placeholderFound = false;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
m_pos	libsolidity/analysis/SemVerHandler.h	/^	unsigned m_pos = 0;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
m_posInside	libsolidity/analysis/SemVerHandler.h	/^	unsigned m_posInside = 0;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
m_prefix	libevmasm/Assembly.cpp	/^	string const& m_prefix;$/;"	m	class:__anon18::Functionalizer	file:	access:private
m_processed	libdevcore/Algorithms.h	/^	std::set<V const*> m_processed;$/;"	m	class:dev::CycleDetector	access:private
m_processing	libdevcore/Algorithms.h	/^	std::set<V const*> m_processing;$/;"	m	class:dev::CycleDetector	access:private
m_pushedValue	libevmasm/AssemblyItem.h	/^	mutable std::shared_ptr<u256> m_pushedValue;$/;"	m	class:dev::eth::AssemblyItem	access:private
m_queryResponses	libsolidity/formal/SMTLib2Interface.h	/^	std::map<h256, std::string> const& m_queryResponses;$/;"	m	class:dev::solidity::smt::SMTLib2Interface::std	access:private
m_queue	libevmasm/PathGasMeter.h	/^	std::map<size_t, std::unique_ptr<GasPath>> m_queue;$/;"	m	class:dev::eth::PathGasMeter	access:private
m_rae	libyul/optimiser/RedundantAssignEliminator.h	/^		RedundantAssignEliminator& m_rae;$/;"	m	class:yul::RedundantAssignEliminator::BlockScope	access:private
m_readFile	libsolidity/interface/CompilerStack.h	/^	ReadCallback::Callback m_readFile;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_readFile	libsolidity/interface/StandardCompiler.h	/^	ReadCallback::Callback m_readFile;$/;"	m	class:dev::solidity::StandardCompiler	access:private
m_recursionDepth	liblangutil/ParserBase.h	/^	size_t m_recursionDepth = 0;$/;"	m	class:langutil::ParserBase	access:protected
m_recursive	libsolidity/ast/Types.h	/^	mutable boost::optional<bool> m_recursive;$/;"	m	class:dev::solidity::StructType	access:private
m_referenceCounts	libyul/optimiser/Rematerialiser.h	/^	std::map<YulString, size_t> m_referenceCounts;$/;"	m	class:yul::Rematerialiser	access:protected
m_referencedBy	libyul/optimiser/DataFlowAnalyzer.h	/^	std::map<YulString, std::set<YulString>> m_referencedBy;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
m_references	libyul/optimiser/DataFlowAnalyzer.h	/^	std::map<YulString, std::set<YulString>> m_references;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
m_references	libyul/optimiser/ExpressionJoiner.h	/^	std::map<YulString, size_t> m_references;	\/\/\/< Holds reference counts to all variable declarations in current block.$/;"	m	class:yul::ExpressionJoiner	access:private
m_references	libyul/optimiser/NameCollector.h	/^	std::map<YulString, size_t> m_references;$/;"	m	class:yul::ReferencesCounter	access:private
m_references	libyul/optimiser/UnusedPruner.h	/^	std::map<YulString, size_t> m_references;$/;"	m	class:yul::UnusedPruner	access:private
m_remappings	libsolidity/interface/CompilerStack.h	/^	std::vector<Remapping> m_remappings;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_remappings	solse/CommandLineInterface.h	/^	std::vector<dev::solidity::CompilerStack::Remapping> m_remappings;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_replacedTags	libevmasm/BlockDeduplicator.h	/^	std::map<u256, u256> m_replacedTags;$/;"	m	class:dev::eth::BlockDeduplicator	access:private
m_reportMutability	libsolidity/analysis/ViewPureChecker.cpp	/^	std::function<void(StateMutability, SourceLocation const&)> m_reportMutability;$/;"	m	class:__anon11::AssemblyViewPureChecker	file:	access:private
m_representatives	libevmasm/ExpressionClasses.h	/^	std::vector<Expression> m_representatives;$/;"	m	class:dev::eth::ExpressionClasses	access:private
m_requestedContractNames	libsolidity/interface/CompilerStack.h	/^	std::set<std::string> m_requestedContractNames;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_requestedFunctions	libsolidity/codegen/ABIFunctions.h	/^	std::map<std::string, std::string> m_requestedFunctions;$/;"	m	class:dev::solidity::ABIFunctions	access:private
m_requireDataMatch	libevmasm/SimplificationRules.h	/^	bool m_requireDataMatch = false;$/;"	m	class:dev::eth::Pattern	access:private
m_resolveInsideCode	libsolidity/analysis/ReferencesResolver.h	/^	bool const m_resolveInsideCode;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
m_resolver	libsolidity/analysis/ReferencesResolver.h	/^	NameAndTypeResolver& m_resolver;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
m_resolver	libyul/AsmAnalysis.h	/^	yul::ExternalIdentifierAccess::Resolver m_resolver;$/;"	m	class:yul::AsmAnalyzer	access:private
m_returnNode	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_returnNode = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_returnParameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> m_returnParameterNames;$/;"	m	class:dev::solidity::FunctionType	access:private
m_returnParameterTypes	libsolidity/ast/Types.h	/^	TypePointers m_returnParameterTypes;$/;"	m	class:dev::solidity::FunctionType	access:private
m_returnParameters	libsolidity/analysis/ReferencesResolver.h	/^	std::vector<ParameterList const*> m_returnParameters;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
m_returnParameters	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_returnParameters;$/;"	m	class:dev::solidity::CallableDeclaration	access:protected
m_returnTags	libsolidity/codegen/ContractCompiler.h	/^	std::vector<std::pair<eth::AssemblyItem, unsigned>> m_returnTags;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_returnTypes	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> m_returnTypes;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
m_revertNode	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* m_revertNode = nullptr;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
m_right	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_right;$/;"	m	class:dev::solidity::BinaryOperation	access:private
m_rightHandSide	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_rightHandSide;$/;"	m	class:dev::solidity::Assignment	access:private
m_routine	libevmasm/ConstantOptimiser.h	/^	AssemblyItems m_routine;$/;"	m	class:dev::eth::ComputeMethod	access:protected
m_rules	libevmasm/SimplificationRules.h	/^	std::vector<SimplificationRule<Pattern>> m_rules[256];$/;"	m	class:dev::eth::Rules	access:private
m_rules	libyul/optimiser/SimplificationRules.h	/^	std::vector<SimplificationRule<Pattern>> m_rules[256];$/;"	m	class:yul::SimplificationRules	access:private
m_runtimeCompiler	libsolidity/codegen/ContractCompiler.h	/^	ContractCompiler* m_runtimeCompiler = nullptr;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_runtimeContext	libsolidity/codegen/Compiler.h	/^	CompilerContext m_runtimeContext;$/;"	m	class:dev::solidity::Compiler	access:private
m_runtimeContext	libsolidity/codegen/CompilerContext.h	/^	CompilerContext *m_runtimeContext;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_runtimeSub	libsolidity/codegen/Compiler.h	/^	size_t m_runtimeSub = size_t(-1); \/\/\/< Identifier of the runtime sub-assembly, if present.$/;"	m	class:dev::solidity::Compiler	access:private
m_runtimeSub	libsolidity/codegen/CompilerContext.h	/^	size_t m_runtimeSub = -1;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_scanner	liblangutil/ParserBase.h	/^	std::shared_ptr<Scanner> m_scanner;$/;"	m	class:langutil::ParserBase	access:protected
m_scanner	liblangutil/Scanner.cpp	/^	Scanner* m_scanner;$/;"	m	class:langutil::LiteralScope	file:	access:private
m_scanner	libsolidity/formal/SMTChecker.h	/^	std::shared_ptr<langutil::Scanner> m_scanner;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_scanner	libyul/AssemblyStack.h	/^	std::shared_ptr<langutil::Scanner> m_scanner;$/;"	m	class:yul::AssemblyStack	access:private
m_scope	libsolidity/analysis/TypeChecker.h	/^	ContractDefinition const* m_scope = nullptr;$/;"	m	class:dev::solidity::TypeChecker	access:private
m_scope	libsolidity/ast/AST.h	/^	ASTNode const* m_scope = nullptr;$/;"	m	class:dev::solidity::Scopable	access:protected
m_scope	libyul/backends/evm/EVMCodeTransform.h	/^	Scope* m_scope = nullptr;$/;"	m	class:yul::CodeTransform	access:private
m_scope	libyul/backends/evm/EVMCodeTransform.h	/^	Scope* m_scope = nullptr;$/;"	m	class:yul::VariableReferenceCounter	access:private
m_scopeStackHeight	libsolidity/codegen/ContractCompiler.h	/^	std::map<unsigned, std::map<ASTNode const*, unsigned>> m_scopeStackHeight;$/;"	m	class:dev::solidity::ContractCompiler	access:private
m_scopes	libsolidity/analysis/NameAndTypeResolver.h	/^	std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& m_scopes;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
m_scopes	libsolidity/analysis/NameAndTypeResolver.h	/^	std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>>& m_scopes;$/;"	m	class:dev::solidity::NameAndTypeResolver	access:private
m_scopes	libsolidity/interface/CompilerStack.h	/^	std::map<ASTNode const*, std::shared_ptr<DeclarationContainer>> m_scopes;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_scopes	libyul/optimiser/Disambiguator.h	/^	std::vector<Scope*> m_scopes;$/;"	m	class:yul::Disambiguator	access:protected
m_secondNumber	liblangutil/Token.h	/^	unsigned int m_secondNumber;$/;"	m	class:langutil::ElementaryTypeNameToken	access:private
m_sequenceNumber	libevmasm/KnownState.h	/^	unsigned m_sequenceNumber = 1;$/;"	m	class:dev::eth::KnownState	access:private
m_shouldRunAgain	libyul/optimiser/UnusedPruner.h	/^	bool m_shouldRunAgain = false;$/;"	m	class:yul::UnusedPruner	access:private
m_singleUse	libyul/optimiser/FullInliner.h	/^	std::set<YulString> m_singleUse;$/;"	m	class:yul::FullInliner	access:private
m_size	libsolidity/codegen/LValue.h	/^	unsigned m_size;$/;"	m	class:dev::solidity::StackVariable	access:private
m_size	libyul/optimiser/Metrics.h	/^	size_t m_size = 0;$/;"	m	class:yul::CodeSize	access:private
m_skippedComment	liblangutil/Scanner.h	/^	TokenDesc m_skippedComment;  \/\/ desc for current skipped comment$/;"	m	class:langutil::Scanner	access:private
m_smtErrors	libsolidity/formal/SMTChecker.h	/^	langutil::ErrorList m_smtErrors;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_smtlib2Responses	libsolidity/interface/CompilerStack.h	/^	std::map<h256, std::string> m_smtlib2Responses;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_solver	libsolidity/formal/CVC4Interface.h	/^	CVC4::SmtEngine m_solver;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:private
m_solver	libsolidity/formal/Z3Interface.h	/^	z3::solver m_solver;$/;"	m	class:dev::solidity::smt::Z3Interface	access:private
m_solvers	libsolidity/formal/SMTPortfolio.h	/^	std::vector<std::shared_ptr<smt::SolverInterface>> m_solvers;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:private
m_source	liblangutil/CharStream.h	/^	std::string m_source;$/;"	m	class:langutil::CharStream	access:private
m_source	liblangutil/Scanner.h	/^	std::shared_ptr<CharStream> m_source;$/;"	m	class:langutil::Scanner	access:private
m_source	libsolidity/ast/ASTPrinter.h	/^	std::string m_source;$/;"	m	class:dev::solidity::ASTPrinter	access:private
m_source	solse/SymExecEngine.h	/^    std::string m_source;$/;"	m	class:SymExecEngine	access:private
m_sourceCodes	libevmasm/Assembly.cpp	/^	StringMap const& m_sourceCodes;$/;"	m	class:__anon18::Functionalizer	file:	access:private
m_sourceCodes	solse/CommandLineInterface.h	/^	std::map<std::string, std::string> m_sourceCodes;$/;"	m	class:dev::solidity::DocumentationType	access:private
m_sourceIndices	libsolidity/ast/ASTJsonConverter.h	/^	std::map<std::string, unsigned> m_sourceIndices;$/;"	m	class:dev::solidity::ASTJsonConverter	access:private
m_sourceOrder	libsolidity/interface/CompilerStack.h	/^	std::vector<Source const*> m_sourceOrder;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_sourceUnit	libsolidity/analysis/SyntaxChecker.h	/^	SourceUnit const* m_sourceUnit = nullptr;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
m_sourceUnit	libsolidity/ast/Types.h	/^	SourceUnit const& m_sourceUnit;$/;"	m	class:dev::solidity::ModuleType	access:private
m_sources	libsolidity/interface/CompilerStack.h	/^	std::map<std::string const, Source> m_sources;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_spareAssemblyItems	libevmasm/ExpressionClasses.h	/^	std::vector<std::shared_ptr<AssemblyItem>> m_spareAssemblyItems;$/;"	m	class:dev::eth::ExpressionClasses	access:private
m_ssa	libsolidity/formal/SymbolicVariables.h	/^	std::shared_ptr<SSAVariable> m_ssa;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
m_stack	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<int, Id> m_stack;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_stackAdjustment	libyul/backends/evm/EVMCodeTransform.h	/^	int m_stackAdjustment = 0;$/;"	m	class:yul::CodeTransform	access:private
m_stackElements	libevmasm/KnownState.h	/^	std::map<int, Id> m_stackElements;$/;"	m	class:dev::eth::KnownState	access:private
m_stackErrors	libyul/backends/evm/EVMCodeTransform.h	/^	std::vector<StackTooDeepError> m_stackErrors;$/;"	m	class:yul::CodeTransform	access:private
m_stackHeight	libevmasm/CommonSubexpressionEliminator.h	/^	int m_stackHeight = 0;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_stackHeight	libevmasm/KnownState.h	/^	int m_stackHeight = 0;$/;"	m	class:dev::eth::KnownState	access:private
m_stackHeight	libyul/AsmAnalysis.h	/^	int m_stackHeight = 0;$/;"	m	class:yul::AsmAnalyzer	access:private
m_stackHeight	libyul/backends/evm/EVMAssembly.h	/^	int m_stackHeight = 0;$/;"	m	class:yul::EVMAssembly	access:private
m_stackHeight	libyul/backends/evm/NoOutputAssembly.h	/^	int m_stackHeight = 0;$/;"	m	class:yul::NoOutputAssembly	access:private
m_stackState	libsolidity/interface/CompilerStack.h	/^	State m_stackState = Empty;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_state	libevmasm/CommonSubexpressionEliminator.h	/^	KnownState m_state;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
m_state	libevmasm/GasMeter.h	/^	std::shared_ptr<KnownState> m_state;$/;"	m	class:dev::eth::GasMeter	access:private
m_stateMutability	libsolidity/ast/AST.h	/^	StateMutability m_stateMutability;$/;"	m	class:dev::solidity::FunctionDefinition	access:private
m_stateMutability	libsolidity/ast/AST.h	/^	StateMutability m_stateMutability;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
m_stateMutability	libsolidity/ast/AST.h	/^	boost::optional<StateMutability> m_stateMutability; \/\/\/< state mutability for address type$/;"	m	class:dev::solidity::ElementaryTypeName	access:private
m_stateMutability	libsolidity/ast/Types.h	/^	StateMutability m_stateMutability = StateMutability::NonPayable;$/;"	m	class:dev::solidity::FunctionType	access:private
m_stateMutability	libsolidity/ast/Types.h	/^	StateMutability m_stateMutability;$/;"	m	class:dev::solidity::AddressType	access:private
m_stateVariables	libsolidity/codegen/CompilerContext.h	/^	std::map<Declaration const*, std::pair<u256, unsigned>> m_stateVariables;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_statements	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Statement>> m_statements;$/;"	m	class:dev::solidity::Block	access:private
m_statementsToPrefix	libyul/optimiser/ExpressionSplitter.h	/^	std::vector<Statement> m_statementsToPrefix;$/;"	m	class:yul::ExpressionSplitter	access:private
m_stdin	libdevcore/CommonIO.cpp	/^	HANDLE m_stdin;$/;"	m	class:DisableConsoleBuffering	file:	access:private
m_storageContent	libevmasm/KnownState.h	/^	std::map<Id, Id> m_storageContent;$/;"	m	class:dev::eth::KnownState	access:private
m_storageOffsets	libsolidity/ast/Types.h	/^	mutable std::unique_ptr<StorageOffsets> m_storageOffsets;$/;"	m	class:dev::solidity::MemberList	access:private
m_storageSize	libsolidity/ast/Types.h	/^	u256 m_storageSize;$/;"	m	class:dev::solidity::StorageOffsets	access:private
m_storeOperations	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<std::pair<StoreOperation::Target, Id>, StoreOperations> m_storeOperations;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_storeOperations	libevmasm/CommonSubexpressionEliminator.h	/^	std::vector<StoreOperation> m_storeOperations;$/;"	m	class:dev::eth::CommonSubexpressionEliminator	access:private
m_stream	libdevcore/AnsiColorized.h	/^	std::ostream& m_stream;$/;"	m	class:dev::AnsiColorized	access:private
m_stream	liblangutil/SourceReferenceFormatter.h	/^	std::ostream& m_stream;$/;"	m	class:langutil::SourceReferenceFormatter	access:protected
m_strings	libevmasm/Assembly.h	/^	std::map<h256, std::string> m_strings;$/;"	m	class:dev::eth::Assembly	access:protected
m_strings	libyul/YulString.h	/^	std::vector<std::shared_ptr<std::string>> m_strings = {std::make_shared<std::string>()};$/;"	m	class:yul::YulStringRepository	access:private
m_struct	libsolidity/ast/Types.h	/^	StructDefinition const& m_struct;$/;"	m	class:dev::solidity::StructType	access:private
m_subDenomination	libsolidity/ast/AST.h	/^	SubDenomination m_subDenomination;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
m_subExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_subExpression;$/;"	m	class:dev::solidity::UnaryOperation	access:private
m_subIDs	libyul/backends/evm/EVMDialect.h	/^	std::map<YulString, AbstractAssembly::SubID> m_subIDs;$/;"	m	struct:yul::EVMDialect	access:protected
m_subNodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> m_subNodes;$/;"	m	class:dev::solidity::ContractDefinition	access:private
m_subs	libevmasm/Assembly.h	/^	std::vector<std::shared_ptr<Assembly>> m_subs;$/;"	m	class:dev::eth::Assembly	access:protected
m_substitutions	libyul/optimiser/Substitution.h	/^	std::map<YulString, Expression const*> const& m_substitutions;$/;"	m	class:yul::Substitution::std	access:private
m_super	libsolidity/ast/Types.h	/^	bool m_super = false;$/;"	m	class:dev::solidity::ContractType	access:private
m_superPointer	libsolidity/analysis/GlobalContext.h	/^	std::map<ContractDefinition const*, std::shared_ptr<MagicVariableDeclaration const>> mutable m_superPointer;$/;"	m	class:dev::solidity::GlobalContext::std	access:private
m_symbolAliases	libsolidity/ast/AST.h	/^	std::vector<std::pair<ASTPointer<Identifier>, ASTPointer<ASTString>>> m_symbolAliases;$/;"	m	class:dev::solidity::ImportDirective	access:private
m_tagPositions	libevmasm/PathGasMeter.h	/^	std::map<u256, size_t> m_tagPositions;$/;"	m	class:dev::eth::PathGasMeter	access:private
m_tagPositionsInBytecode	libevmasm/Assembly.h	/^	mutable std::vector<size_t> m_tagPositionsInBytecode;$/;"	m	class:dev::eth::Assembly	access:protected
m_tagUnions	libevmasm/KnownState.h	/^	boost::bimap<Id, std::set<u256>> m_tagUnions;$/;"	m	class:dev::eth::KnownState	access:private
m_targetStack	libevmasm/CommonSubexpressionEliminator.h	/^	std::map<int, Id> m_targetStack;$/;"	m	class:dev::eth::CSECodeGenerator	access:private
m_template	libdevcore/Whiskers.h	/^	std::string m_template;$/;"	m	class:dev::Whiskers	access:private
m_termios	libdevcore/CommonIO.cpp	/^	struct termios m_termios;$/;"	m	class:DisableConsoleBuffering	typeref:struct:DisableConsoleBuffering::termios	file:	access:private
m_thisPointer	libsolidity/analysis/GlobalContext.h	/^	std::map<ContractDefinition const*, std::shared_ptr<MagicVariableDeclaration const>> mutable m_thisPointer;$/;"	m	class:dev::solidity::GlobalContext::std	access:private
m_toRemove	libyul/optimiser/RedundantAssignEliminator.h	/^	std::set<Assignment const*> const& m_toRemove;$/;"	m	class:yul::AssignmentRemover::std	access:private
m_token	liblangutil/Token.h	/^	Token m_token;$/;"	m	class:langutil::ElementaryTypeNameToken	access:private
m_token	libsolidity/ast/AST.h	/^	Token m_token;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
m_tokens	libsolidity/analysis/SemVerHandler.h	/^	std::vector<Token> m_tokens;$/;"	m	class:dev::solidity::SemVerMatchExpressionParser	access:private
m_tokens	libsolidity/ast/AST.h	/^	std::vector<Token> m_tokens;$/;"	m	class:dev::solidity::PragmaDirective	access:private
m_totalBits	libsolidity/ast/Types.h	/^	unsigned m_totalBits;$/;"	m	class:dev::solidity::FixedPointType	access:private
m_touchedVariable	libsolidity/formal/VariableUsage.h	/^	std::map<ASTNode const*, VariableDeclaration const*> m_touchedVariable;$/;"	m	class:dev::solidity::VariableUsage	access:private
m_translatedNames	libyul/optimiser/VarNameCleaner.h	/^	std::map<YulString, YulString> m_translatedNames;$/;"	m	class:yul::VarNameCleaner	access:private
m_translations	libyul/optimiser/Disambiguator.h	/^	std::map<void const*, YulString> m_translations;$/;"	m	class:yul::Disambiguator	access:protected
m_trueBody	libsolidity/ast/AST.h	/^	ASTPointer<Statement> m_trueBody;$/;"	m	class:dev::solidity::IfStatement	access:private
m_trueExpression	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_trueExpression;$/;"	m	class:dev::solidity::Conditional	access:private
m_type	libevmasm/AssemblyItem.h	/^	AssemblyItemType m_type;$/;"	m	class:dev::eth::AssemblyItem	access:private
m_type	libevmasm/SimplificationRules.h	/^	AssemblyItemType m_type;$/;"	m	class:dev::eth::Pattern	access:private
m_type	liblangutil/Exceptions.h	/^	Type m_type;$/;"	m	class:langutil::Error	access:private
m_type	liblangutil/Scanner.cpp	/^	enum LiteralType m_type;$/;"	m	class:langutil::LiteralScope	typeref:enum:langutil::LiteralScope::LiteralType	file:	access:private
m_type	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken m_type;$/;"	m	class:dev::solidity::ElementaryTypeName	access:private
m_type	libsolidity/ast/AST.h	/^	std::shared_ptr<Type const> m_type;$/;"	m	class:dev::solidity::MagicVariableDeclaration	access:private
m_type	libsolidity/formal/SymbolicVariables.h	/^	TypePointer m_type;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
m_typeArgument	libsolidity/ast/Types.h	/^	TypePointer m_typeArgument;$/;"	m	class:dev::solidity::MagicType	access:private
m_typeName	liblangutil/Exceptions.h	/^	std::string m_typeName;$/;"	m	class:langutil::Error	access:private
m_typeName	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_typeName; \/\/\/< can be empty ("var")$/;"	m	class:dev::solidity::VariableDeclaration	access:private
m_typeName	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_typeName;$/;"	m	class:dev::solidity::NewExpression	access:private
m_typeName	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_typeName;$/;"	m	class:dev::solidity::UsingForDirective	access:private
m_typeToken	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken m_typeToken;$/;"	m	class:dev::solidity::ElementaryTypeNameExpression	access:private
m_types	libsolidity/analysis/ConstantEvaluator.h	/^	std::shared_ptr<std::map<ASTNode const*, TypePointer>> m_types;$/;"	m	class:dev::solidity::ConstantEvaluator	access:private
m_unhandledQueries	libsolidity/formal/SMTLib2Interface.h	/^	std::vector<std::string> m_unhandledQueries;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:private
m_unhandledSMTLib2Queries	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> m_unhandledSMTLib2Queries;$/;"	m	class:dev::solidity::CompilerStack	access:private
m_uninterpretedTerms	libsolidity/formal/SMTChecker.h	/^	std::set<Expression const*> m_uninterpretedTerms;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_uniqueName	libsolidity/formal/SymbolicVariables.h	/^	std::string m_uniqueName;$/;"	m	class:dev::solidity::SymbolicVariable	access:protected
m_unusedStackSlots	libyul/backends/evm/EVMCodeTransform.h	/^	std::set<int> m_unusedStackSlots;$/;"	m	class:yul::CodeTransform	access:private
m_useNamedLabelsForFunctions	libyul/backends/evm/EVMCodeTransform.h	/^	bool const m_useNamedLabelsForFunctions = false;$/;"	m	class:yul::CodeTransform	access:private
m_usedNames	libyul/optimiser/NameDispenser.h	/^	std::set<YulString> m_usedNames;$/;"	m	class:yul::NameDispenser	access:private
m_usedNames	libyul/optimiser/VarNameCleaner.h	/^	std::set<YulString> m_usedNames;$/;"	m	class:yul::VarNameCleaner	access:private
m_usedTags	libevmasm/Assembly.h	/^	unsigned m_usedTags = 1;$/;"	m	class:dev::eth::Assembly	access:protected
m_usesAssembly	libsolidity/analysis/StaticAnalyzer.cpp	/^	map<ContractDefinition const*, bool> m_usesAssembly;$/;"	m	class:dev::solidity::ConstructorUsesAssembly	file:	access:private
m_value	libdevcore/Result.h	/^	ResultType m_value;$/;"	m	class:dev::Result	access:private
m_value	libevmasm/ConstantOptimiser.h	/^	u256 const& m_value;$/;"	m	class:dev::eth::ConstantOptimisationMethod	access:protected
m_value	libsolidity/ast/AST.h	/^	ASTPointer<ASTString> m_value;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
m_value	libsolidity/ast/AST.h	/^	ASTPointer<Expression> m_value;$/;"	m	class:dev::solidity::VariableDeclaration	access:private
m_value	libsolidity/ast/Types.h	/^	rational m_value;$/;"	m	class:dev::solidity::RationalNumberType	access:private
m_value	libsolidity/ast/Types.h	/^	std::string m_value;$/;"	m	class:dev::solidity::StringLiteralType	access:private
m_value	libyul/optimiser/DataFlowAnalyzer.h	/^	std::map<YulString, Expression const*> m_value;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
m_value	libyul/optimiser/RedundantAssignEliminator.h	/^		Value m_value = Undecided;$/;"	m	class:yul::RedundantAssignEliminator::State	access:private
m_valueSet	libsolidity/ast/Types.h	/^	bool const m_valueSet = false; \/\/\/< true iff the value to be sent is on the stack$/;"	m	class:dev::solidity::FunctionType	access:private
m_valueType	libsolidity/ast/AST.h	/^	ASTPointer<TypeName> m_valueType;$/;"	m	class:dev::solidity::Mapping	access:private
m_valueType	libsolidity/ast/Types.h	/^	TypePointer m_valueType;$/;"	m	class:dev::solidity::MappingType	access:private
m_values	libyul/optimiser/SSAValueTracker.h	/^	std::map<YulString, Expression const*> m_values;$/;"	m	class:yul::SSAValueTracker	access:private
m_varReplacements	libyul/optimiser/ExpressionInliner.h	/^	std::map<YulString, YulString> m_varReplacements;$/;"	m	class:yul::ExpressionInliner	access:private
m_variableReferences	libyul/optimiser/Semantics.h	/^	std::set<YulString> m_variableReferences;$/;"	m	class:yul::MovableChecker	access:private
m_variableReplacements	libyul/optimiser/FullInliner.h	/^	std::map<YulString, YulString> m_variableReplacements;$/;"	m	class:yul::BodyCopier	access:public
m_variableScopes	libyul/optimiser/DataFlowAnalyzer.h	/^	std::vector<Scope> m_variableScopes;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
m_variableUsage	libsolidity/formal/SMTChecker.h	/^	std::shared_ptr<VariableUsage> m_variableUsage;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_variables	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> m_variables;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:private
m_variables	libsolidity/formal/CVC4Interface.h	/^	std::map<std::string, CVC4::Expr> m_variables;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:private
m_variables	libsolidity/formal/SMTChecker.h	/^	std::unordered_map<VariableDeclaration const*, std::shared_ptr<SymbolicVariable>> m_variables;$/;"	m	class:dev::solidity::SMTChecker	access:private
m_variables	libsolidity/formal/SMTLib2Interface.h	/^	std::set<std::string> m_variables;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:private
m_variablesScheduledForDeletion	libyul/backends/evm/EVMCodeTransform.h	/^	std::set<Scope::Variable const*> m_variablesScheduledForDeletion;$/;"	m	class:yul::CodeTransform	access:private
m_variablesToReplace	libyul/optimiser/SSATransform.h	/^	std::set<YulString> const& m_variablesToReplace;$/;"	m	class:yul::SSATransform::std	access:private
m_varsToAlwaysRematerialize	libyul/optimiser/Rematerialiser.h	/^	std::set<YulString> m_varsToAlwaysRematerialize;$/;"	m	class:yul::Rematerialiser	access:protected
m_version	liblangutil/EVMVersion.h	/^	Version m_version = Version::Petersburg;$/;"	m	class:langutil::EVMVersion	access:private
m_versionPragmaFound	libsolidity/analysis/SyntaxChecker.h	/^	bool m_versionPragmaFound = false;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
m_visibility	libsolidity/ast/AST.h	/^	Declaration::Visibility m_visibility;$/;"	m	class:dev::solidity::FunctionTypeName	access:private
m_visibility	libsolidity/ast/AST.h	/^	Visibility m_visibility;$/;"	m	class:dev::solidity::Declaration	access:private
m_visit	libdevcore/Algorithms.h	/^	Visitor m_visit;$/;"	m	class:dev::CycleDetector	access:private
m_visitedNodes	libsolidity/codegen/CompilerContext.h	/^	std::stack<ASTNode const*> m_visitedNodes;$/;"	m	class:dev::solidity::CompilerContext	access:private
m_visitor	libdevcore/Visitor.h	/^	std::function<R(Visitable&)> m_visitor;$/;"	m	struct:dev::GenericFallbackReturnsVisitor	access:public
m_visitor	libdevcore/Visitor.h	/^	std::function<void(Visitable&)> m_visitor;$/;"	m	struct:dev::GenericFallbackVisitor	access:public
m_visitor	libdevcore/Visitor.h	/^	std::function<void(Visitable&)> m_visitor;$/;"	m	struct:dev::GenericVisitor	access:public
m_warningCount	liblangutil/ErrorReporter.h	/^	unsigned m_warningCount = 0;$/;"	m	class:langutil::ErrorReporter	access:private
m_yul	libyul/AsmPrinter.h	/^	bool m_yul = false;$/;"	m	class:yul::AsmPrinter	access:private
main	solse/main.cpp	/^int main(int argc, char **argv){$/;"	f	signature:(int argc, char **argv)
mainFuncName	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::mainFuncName = "_Main_";$/;"	m	class:SymExecEngine	file:
mainFuncName	solse/SymExecEngine.h	/^    static const std::string mainFuncName;$/;"	m	class:SymExecEngine	access:private
major	libsolidity/analysis/SemVerHandler.h	/^	unsigned major() const { return numbers[0]; }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
major	libsolidity/analysis/SemVerHandler.h	38;"	d
makePopExpressionStatement	libyul/optimiser/StructuralSimplifier.cpp	/^ExpressionStatement makePopExpressionStatement(langutil::SourceLocation const& _location, Expression&& _expression)$/;"	f	namespace:__anon5	signature:(langutil::SourceLocation const& _location, Expression&& _expression)
makeRational	libsolidity/ast/Types.h	/^inline rational makeRational(bigint const& _numerator, bigint const& _denominator)$/;"	f	namespace:dev::solidity	signature:(bigint const& _numerator, bigint const& _denominator)
markEndPosition	libsolidity/parsing/Parser.cpp	/^	void markEndPosition() { m_location.end = m_parser.endPosition(); }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:()
matchGroup	libevmasm/SimplificationRules.h	/^	unsigned matchGroup() const { return m_matchGroup; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
matchGroup	libyul/optimiser/SimplificationRules.h	/^	unsigned matchGroup() const { return m_matchGroup; }$/;"	f	class:yul::Pattern	access:public	signature:() const
matchGroupValue	libevmasm/SimplificationRules.cpp	/^Pattern::Expression const& Pattern::matchGroupValue() const$/;"	f	class:Pattern::Pattern	signature:() const
matchGroupValue	libevmasm/SimplificationRules.h	/^	Expression const& matchGroupValue() const;$/;"	p	class:dev::eth::Pattern	access:private	signature:() const
matchGroupValue	libyul/optimiser/SimplificationRules.cpp	/^Expression const& Pattern::matchGroupValue() const$/;"	f	class:Pattern	signature:() const
matchGroupValue	libyul/optimiser/SimplificationRules.h	/^	Expression const& matchGroupValue() const;$/;"	p	class:yul::Pattern	access:private	signature:() const
matchLibrary	libevmasm/LinkerObject.cpp	/^LinkerObject::matchLibrary($/;"	f	class:LinkerObject	signature:( string const& _linkRefName, map<string, h160> const& _libraryAddresses )
matchLibrary	libevmasm/LinkerObject.h	/^	static h160 const* matchLibrary($/;"	p	struct:dev::eth::LinkerObject	access:private	signature:( std::string const& _linkRefName, std::map<std::string, h160> const& _libraryAddresses )
matches	libevmasm/SimplificationRules.cpp	/^bool Pattern::matches(Expression const& _expr, ExpressionClasses const& _classes) const$/;"	f	class:Pattern	signature:(Expression const& _expr, ExpressionClasses const& _classes) const
matches	libevmasm/SimplificationRules.h	/^	bool matches(Expression const& _expr, ExpressionClasses const& _classes) const;$/;"	p	class:dev::eth::Pattern	access:public	signature:(Expression const& _expr, ExpressionClasses const& _classes) const
matches	libsolidity/analysis/SemVerHandler.cpp	/^bool SemVerMatchExpression::Conjunction::matches(SemVerVersion const& _version) const$/;"	f	class:SemVerMatchExpression::Conjunction	signature:(SemVerVersion const& _version) const
matches	libsolidity/analysis/SemVerHandler.cpp	/^bool SemVerMatchExpression::MatchComponent::matches(SemVerVersion const& _version) const$/;"	f	class:SemVerMatchExpression::MatchComponent	signature:(SemVerVersion const& _version) const
matches	libsolidity/analysis/SemVerHandler.cpp	/^bool SemVerMatchExpression::matches(SemVerVersion const& _version) const$/;"	f	class:SemVerMatchExpression	signature:(SemVerVersion const& _version) const
matches	libsolidity/analysis/SemVerHandler.h	/^		bool matches(SemVerVersion const& _version) const;$/;"	p	struct:dev::solidity::SemVerMatchExpression::Conjunction	access:public	signature:(SemVerVersion const& _version) const
matches	libsolidity/analysis/SemVerHandler.h	/^		bool matches(SemVerVersion const& _version) const;$/;"	p	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public	signature:(SemVerVersion const& _version) const
matches	libsolidity/analysis/SemVerHandler.h	/^	bool matches(SemVerVersion const& _version) const;$/;"	p	struct:dev::solidity::SemVerMatchExpression	access:public	signature:(SemVerVersion const& _version) const
matches	libyul/optimiser/SimplificationRules.cpp	/^bool Pattern::matches($/;"	f	class:Pattern	signature:( Expression const& _expr, Dialect const& _dialect, map<YulString, Expression const*> const& _ssaValues ) const
matches	libyul/optimiser/SimplificationRules.h	/^	bool matches($/;"	p	class:yul::Pattern	access:public	signature:( Expression const& _expr, Dialect const& _dialect, std::map<YulString, Expression const*> const& _ssaValues ) const
matchesBaseItem	libevmasm/SimplificationRules.cpp	/^bool Pattern::matchesBaseItem(AssemblyItem const* _item) const$/;"	f	class:Pattern	signature:(AssemblyItem const* _item) const
matchesBaseItem	libevmasm/SimplificationRules.h	/^	bool matchesBaseItem(AssemblyItem const* _item) const;$/;"	p	class:dev::eth::Pattern	access:private	signature:(AssemblyItem const* _item) const
maxIntegerValue	libsolidity/ast/Types.cpp	/^bigint FixedPointType::maxIntegerValue() const$/;"	f	class:FixedPointType	signature:() const
maxIntegerValue	libsolidity/ast/Types.h	/^	bigint maxIntegerValue() const;$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:() const
maxValue	libsolidity/ast/Types.cpp	/^bigint IntegerType::maxValue() const$/;"	f	class:IntegerType	signature:() const
maxValue	libsolidity/ast/Types.h	/^	bigint maxValue() const;$/;"	p	class:dev::solidity::IntegerType	access:public	signature:() const
maxValue	libsolidity/formal/SymbolicTypes.cpp	/^smt::Expression dev::solidity::maxValue(IntegerType const& _type)$/;"	f	class:dev::solidity	signature:(IntegerType const& _type)
maxValue	libsolidity/formal/SymbolicTypes.h	/^smt::Expression maxValue(IntegerType const& _type);$/;"	p	namespace:dev::solidity	signature:(IntegerType const& _type)
mechanism	solse/SolidityExprTranslator.h	/^    Mechanism mechanism;$/;"	m	class:ContextInfo	access:public
memberName	libsolidity/ast/AST.h	/^	ASTString const& memberName() const { return *m_memberName; }$/;"	f	class:dev::solidity::MemberAccess	access:public	signature:() const
memberStorageOffset	libsolidity/ast/Types.cpp	/^pair<u256, unsigned> const* MemberList::memberStorageOffset(string const& _name) const$/;"	f	class:MemberList	signature:(string const& _name) const
memberStorageOffset	libsolidity/ast/Types.h	/^	std::pair<u256, unsigned> const* memberStorageOffset(std::string const& _name) const;$/;"	p	class:dev::solidity::MemberList::std	access:public	signature:(std::string const& _name) const
memberType	libsolidity/ast/Types.h	/^	TypePointer memberType(std::string const& _name) const$/;"	f	class:dev::solidity::MemberList	access:public	signature:(std::string const& _name) const
memberType	libsolidity/ast/Types.h	/^	TypePointer memberType(std::string const& _name, ContractDefinition const* _currentScope = nullptr) const$/;"	f	class:dev::solidity::Type	access:public	signature:(std::string const& _name, ContractDefinition const* _currentScope = nullptr) const
memberValue	libsolidity/ast/Types.cpp	/^unsigned EnumType::memberValue(ASTString const& _member) const$/;"	f	class:EnumType	signature:(ASTString const& _member) const
memberValue	libsolidity/ast/Types.h	/^	unsigned int memberValue(ASTString const& _member) const;$/;"	p	class:dev::solidity::EnumType	access:public	signature:(ASTString const& _member) const
members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<EnumValue>> const& members() const { return m_members; }$/;"	f	class:dev::solidity::EnumDefinition::std	access:public	signature:() const
members	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& members() const { return m_members; }$/;"	f	class:dev::solidity::StructDefinition::std	access:public	signature:() const
members	libsolidity/ast/Types.cpp	/^MemberList const& Type::members(ContractDefinition const* _currentScope) const$/;"	f	class:Type	signature:(ContractDefinition const* _currentScope) const
members	libsolidity/ast/Types.h	/^	MemberList const& members(ContractDefinition const* _currentScope) const;$/;"	p	class:dev::solidity::Type	access:public	signature:(ContractDefinition const* _currentScope) const
membersByName	libsolidity/ast/Types.h	/^	MemberMap membersByName(std::string const& _name) const$/;"	f	class:dev::solidity::MemberList	access:public	signature:(std::string const& _name) const
membersMissingInMemory	libsolidity/ast/Types.cpp	/^set<string> StructType::membersMissingInMemory() const$/;"	f	class:StructType	signature:() const
membersMissingInMemory	libsolidity/ast/Types.h	/^	std::set<std::string> membersMissingInMemory() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
memoryCopy	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::memoryCopy()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
memoryCopy	libsolidity/codegen/CompilerUtils.h	/^	void memoryCopy();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
memoryCopy32	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::memoryCopy32()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
memoryCopy32	libsolidity/codegen/CompilerUtils.h	/^	void memoryCopy32();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
memoryGas	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::memoryGas(ExpressionClasses::Id _position)$/;"	f	class:GasMeter	signature:(ExpressionClasses::Id _position)
memoryGas	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::memoryGas(int _stackPosOffset, int _stackPosSize)$/;"	f	class:GasMeter	signature:(int _stackPosOffset, int _stackPosSize)
memoryGas	libevmasm/GasMeter.h	/^	GasConsumption memoryGas(ExpressionClasses::Id _position);$/;"	p	class:dev::eth::GasMeter	access:private	signature:(ExpressionClasses::Id _position)
memoryGas	libevmasm/GasMeter.h	/^	GasConsumption memoryGas(int _stackPosOffset, int _stackPosSize);$/;"	p	class:dev::eth::GasMeter	access:private	signature:(int _stackPosOffset, int _stackPosSize)
memoryGas	libevmasm/GasMeter.h	/^	static unsigned const memoryGas = 3;$/;"	m	namespace:dev::eth::GasCosts
memoryHeadSize	libsolidity/ast/Types.h	/^	virtual unsigned memoryHeadSize() const { return calldataEncodedSize(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
memoryMemberTypes	libsolidity/ast/Types.cpp	/^TypePointers StructType::memoryMemberTypes() const$/;"	f	class:StructType	signature:() const
memoryMemberTypes	libsolidity/ast/Types.h	/^	TypePointers memoryMemberTypes() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
memoryOffsetOfMember	libsolidity/ast/Types.cpp	/^u256 StructType::memoryOffsetOfMember(string const& _name) const$/;"	f	class:StructType	signature:(string const& _name) const
memoryOffsetOfMember	libsolidity/ast/Types.h	/^	u256 memoryOffsetOfMember(std::string const& _name) const;$/;"	p	class:dev::solidity::StructType	access:public	signature:(std::string const& _name) const
memorySize	libsolidity/ast/Types.cpp	/^u256 ArrayType::memorySize() const$/;"	f	class:ArrayType	signature:() const
memorySize	libsolidity/ast/Types.cpp	/^u256 StructType::memorySize() const$/;"	f	class:StructType	signature:() const
memorySize	libsolidity/ast/Types.h	/^	u256 memorySize() const;$/;"	p	class:dev::solidity::ArrayType	access:public	signature:() const
memorySize	libsolidity/ast/Types.h	/^	u256 memorySize() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
memoryStride	libsolidity/ast/Types.h	/^	unsigned memoryStride() const { return isByteArray() ? 1 : m_baseType->memoryHeadSize(); }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
mergeFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	void mergeFlow(std::array<CFGNode*, n> const& _nodes, CFGNode* _endNode = nullptr)$/;"	f	class:dev::solidity::ControlFlowBuilder	access:private	signature:(std::array<CFGNode*, n> const& _nodes, CFGNode* _endNode = nullptr)
mergeVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::mergeVariables(vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse)$/;"	f	class:SMTChecker	signature:(vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse)
mergeVariables	libsolidity/formal/SMTChecker.h	/^	void mergeVariables(std::vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::vector<VariableDeclaration const*> const& _variables, smt::Expression const& _condition, VariableIndices const& _indicesEndTrue, VariableIndices const& _indicesEndFalse)
message	libdevcore/Result.h	/^	std::string const& message() const { return m_message; }$/;"	f	class:dev::Result::std	access:public	signature:() const
message	liblangutil/SourceReferenceExtractor.h	/^	std::string message;      \/\/\/< A message that relates to this source reference (such as a warning or an error message).$/;"	m	struct:langutil::SourceReference	access:public
messageColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::messageColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
messageColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized messageColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
metaType	libsolidity/ast/Types.cpp	/^shared_ptr<MagicType> MagicType::metaType(TypePointer _type)$/;"	f	class:MagicType	signature:(TypePointer _type)
metaType	libsolidity/ast/Types.h	/^	static std::shared_ptr<MagicType> metaType(TypePointer _type);$/;"	p	class:dev::solidity::MagicType	access:public	signature:(TypePointer _type)
metadata	libsolidity/interface/CompilerStack.cpp	/^string const& CompilerStack::metadata(Contract const& _contract) const$/;"	f	class:CompilerStack	signature:(Contract const& _contract) const
metadata	libsolidity/interface/CompilerStack.cpp	/^string const& CompilerStack::metadata(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
metadata	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<std::string const> metadata; \/\/\/< The metadata json that will be hashed into the chain.$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
metadata	libsolidity/interface/CompilerStack.h	/^	std::string const& metadata(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:private	signature:(Contract const&) const
metadata	libsolidity/interface/CompilerStack.h	/^	std::string const& metadata(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
methodIdentifiers	libsolidity/interface/CompilerStack.cpp	/^Json::Value CompilerStack::methodIdentifiers(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
methodIdentifiers	libsolidity/interface/CompilerStack.h	/^	Json::Value methodIdentifiers(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _contractName) const
mid2_time	solse/SymExecEngine.cpp	/^uint64_t mid2_time;$/;"	v
mid_time	solse/SymExecEngine.cpp	/^uint64_t mid_time;$/;"	v
minIntegerValue	libsolidity/ast/Types.cpp	/^bigint FixedPointType::minIntegerValue() const$/;"	f	class:FixedPointType	signature:() const
minIntegerValue	libsolidity/ast/Types.h	/^	bigint minIntegerValue() const;$/;"	p	class:dev::solidity::FixedPointType	access:public	signature:() const
minValue	libsolidity/ast/Types.cpp	/^bigint IntegerType::minValue() const$/;"	f	class:IntegerType	signature:() const
minValue	libsolidity/ast/Types.h	/^	bigint minValue() const;$/;"	p	class:dev::solidity::IntegerType	access:public	signature:() const
minValue	libsolidity/formal/SymbolicTypes.cpp	/^smt::Expression dev::solidity::minValue(IntegerType const& _type)$/;"	f	class:dev::solidity	signature:(IntegerType const& _type)
minValue	libsolidity/formal/SymbolicTypes.h	/^smt::Expression minValue(IntegerType const& _type);$/;"	p	namespace:dev::solidity	signature:(IntegerType const& _type)
minimal	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings minimal()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
minor	libsolidity/analysis/SemVerHandler.h	/^	unsigned minor() const { return numbers[1]; }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
minor	libsolidity/analysis/SemVerHandler.h	39;"	d
mkapply_ds	libdevcore/Keccak256.cpp	119;"	d	file:
mkapply_sd	libdevcore/Keccak256.cpp	125;"	d	file:
mobileType	libsolidity/ast/Types.cpp	/^TypePointer RationalNumberType::mobileType() const$/;"	f	class:RationalNumberType	signature:() const
mobileType	libsolidity/ast/Types.cpp	/^TypePointer StringLiteralType::mobileType() const$/;"	f	class:StringLiteralType	signature:() const
mobileType	libsolidity/ast/Types.cpp	/^TypePointer TupleType::mobileType() const$/;"	f	class:TupleType	signature:() const
mobileType	libsolidity/ast/Types.h	/^	virtual TypePointer mobileType() const { return shared_from_this(); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
modWorkaround	libevmasm/RuleList.h	/^template <class S> S modWorkaround(S const& _a, S const& _b)$/;"	f	namespace:dev::solidity	signature:(S const& _a, S const& _b)
model_type	solse/mechanism.h	/^		z3::expr model_type;$/;"	m	class:Mechanism	access:public
modifiers	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ModifierInvocation>> const& modifiers() const { return m_functionModifiers; }$/;"	f	class:dev::solidity::FunctionDefinition::std	access:public	signature:() const
modifiers	libsolidity/parsing/Parser.h	/^		std::vector<ASTPointer<ModifierInvocation>> modifiers;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
mostSignificantBit	libsolidity/ast/Types.cpp	/^unsigned int mostSignificantBit(bigint const& _number)$/;"	f	namespace:__anon7	signature:(bigint const& _number)
movable	libevmasm/SemanticInformation.cpp	/^bool SemanticInformation::movable(Instruction _instruction)$/;"	f	class:SemanticInformation	signature:(Instruction _instruction)
movable	libevmasm/SemanticInformation.h	/^	static bool movable(solidity::Instruction _instruction);$/;"	p	struct:dev::eth::SemanticInformation	access:public	signature:(solidity::Instruction _instruction)
movable	libyul/Dialect.h	/^	bool movable = false;$/;"	m	struct:yul::BuiltinFunction	access:public
movable	libyul/optimiser/Semantics.h	/^	bool movable() const { return m_movable; }$/;"	f	class:yul::MovableChecker	access:public	signature:() const
moveIntoStack	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::moveIntoStack(unsigned _stackDepth, unsigned _itemSize)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _stackDepth, unsigned _itemSize)
moveIntoStack	libsolidity/codegen/CompilerUtils.h	/^	void moveIntoStack(unsigned _stackDepth, unsigned _itemSize = 1);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _stackDepth, unsigned _itemSize = 1)
moveToStackTop	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::moveToStackTop(unsigned _stackDepth, unsigned _itemSize)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _stackDepth, unsigned _itemSize)
moveToStackTop	libsolidity/codegen/CompilerUtils.h	/^	void moveToStackTop(unsigned _stackDepth, unsigned _itemSize = 1);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _stackDepth, unsigned _itemSize = 1)
moveToStackVariable	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::moveToStackVariable(VariableDeclaration const& _variable)$/;"	f	class:dev::solidity::CompilerUtils	signature:(VariableDeclaration const& _variable)
moveToStackVariable	libsolidity/codegen/CompilerUtils.h	/^	void moveToStackVariable(VariableDeclaration const& _variable);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(VariableDeclaration const& _variable)
multiline	liblangutil/SourceReferenceExtractor.h	/^	bool multiline = {false}; \/\/\/< Indicates whether the actual SourceReference is truncated to one line.$/;"	m	struct:langutil::SourceReference	access:public
multiplicity	libevmasm/ConstantOptimiser.h	/^		size_t multiplicity; \/\/\/< Number of times the constant appears in the code.$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
mutability	libsolidity/analysis/ViewPureChecker.h	/^		StateMutability mutability;$/;"	m	struct:dev::solidity::ViewPureChecker::MutabilityAndLocation	access:public
name	libevmasm/Instruction.h	/^	std::string name;	\/\/\/< The name of the instruction.$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
name	liblangutil/EVMVersion.h	/^	std::string name() const$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
name	liblangutil/Token.cpp	/^char const* name(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
name	liblangutil/Token.h	/^	char const* name(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
name	libsolidity/ast/AST.h	/^	ASTPointer<Identifier> const& name() const { return m_modifierName; }$/;"	f	class:dev::solidity::ModifierInvocation	access:public	signature:() const
name	libsolidity/ast/AST.h	/^	ASTString const& name() const { return *m_name; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
name	libsolidity/ast/AST.h	/^	ASTString const& name() const { return *m_name; }$/;"	f	class:dev::solidity::Identifier	access:public	signature:() const
name	libsolidity/ast/AST.h	/^	UserDefinedTypeName const& name() const { return *m_baseName; }$/;"	f	class:dev::solidity::InheritanceSpecifier	access:public	signature:() const
name	libsolidity/ast/Types.h	/^		std::string name;$/;"	m	struct:dev::solidity::MemberList::Member	access:public
name	libsolidity/formal/SolverInterface.h	/^	std::string name;$/;"	m	class:dev::solidity::smt::Expression	access:public
name	libsolidity/parsing/Parser.h	/^		ASTPointer<ASTString> name;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
name	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
name	libyul/AsmData.h	/^struct Identifier { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Identifier	access:public
name	libyul/AsmData.h	/^struct Label { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Label	access:public
name	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	m	struct:yul::TypedName	access:public
name	libyul/Dialect.h	/^	YulString name;$/;"	m	struct:yul::BuiltinFunction	access:public
name	libyul/Object.h	/^	YulString name;$/;"	m	struct:yul::ObjectNode	access:public
nameFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<Declaration const*> NameAndTypeResolver::nameFromCurrentScope(ASTString const& _name, bool _includeInvisibles) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTString const& _name, bool _includeInvisibles) const
nameFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	std::vector<Declaration const*> nameFromCurrentScope(ASTString const& _name, bool _includeInvisibles = false) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTString const& _name, bool _includeInvisibles = false) const
namePath	libsolidity/ast/AST.h	/^	std::vector<ASTString> const& namePath() const { return m_namePath; }$/;"	f	class:dev::solidity::UserDefinedTypeName::std	access:public	signature:() const
namePathToString	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::namePathToString(std::vector<ASTString> const& _namePath)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(std::vector<ASTString> const& _namePath)
namePathToString	libsolidity/ast/ASTJsonConverter.h	/^	static std::string namePathToString(std::vector<ASTString> const& _namePath);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(std::vector<ASTString> const& _namePath)
nameSeparator	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::nameSeparator = "@";$/;"	m	class:SymExecEngine	file:
nameSeparator	solse/SymExecEngine.h	/^    static const std::string nameSeparator;$/;"	m	class:SymExecEngine	access:private
namedLabel	libyul/backends/evm/AbstractAssembly.h	/^	virtual LabelID namedLabel(std::string const& _name) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(std::string const& _name)
namedLabel	libyul/backends/evm/AsmCodeGen.cpp	/^size_t EthAssemblyAdapter::namedLabel(std::string const& _name)$/;"	f	class:EthAssemblyAdapter	signature:(std::string const& _name)
namedLabel	libyul/backends/evm/EVMAssembly.cpp	/^AbstractAssembly::LabelID EVMAssembly::namedLabel(string const& _name)$/;"	f	class:EVMAssembly	signature:(string const& _name)
namedLabel	libyul/backends/evm/NoOutputAssembly.cpp	/^AbstractAssembly::LabelID NoOutputAssembly::namedLabel(string const&)$/;"	f	class:NoOutputAssembly	signature:(string const&)
namedTag	libevmasm/Assembly.cpp	/^AssemblyItem Assembly::namedTag(string const& _name)$/;"	f	class:Assembly	signature:(string const& _name)
namedTag	libevmasm/Assembly.h	/^	AssemblyItem namedTag(std::string const& _name);$/;"	p	class:dev::eth::Assembly	access:public	signature:(std::string const& _name)
namedTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem namedTag(std::string const& _name) { return m_asm->namedTag(_name); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::string const& _name)
names	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTString>> const& names() const { return m_names; }$/;"	f	class:dev::solidity::FunctionCall::std	access:public	signature:() const
names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> const& names() const { return m_names; }$/;"	f	class:yul::Assignments::std	access:public	signature:() const
names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> names() const { return m_names; }$/;"	f	class:yul::NameCollector	access:public	signature:() const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap AddressType::nativeMembers(ContractDefinition const*) const$/;"	f	class:AddressType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap ArrayType::nativeMembers(ContractDefinition const*) const$/;"	f	class:ArrayType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap ContractType::nativeMembers(ContractDefinition const* _contract) const$/;"	f	class:ContractType	signature:(ContractDefinition const* _contract) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap FixedBytesType::nativeMembers(ContractDefinition const*) const$/;"	f	class:FixedBytesType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap FunctionType::nativeMembers(ContractDefinition const*) const$/;"	f	class:FunctionType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap MagicType::nativeMembers(ContractDefinition const*) const$/;"	f	class:MagicType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap ModuleType::nativeMembers(ContractDefinition const*) const$/;"	f	class:ModuleType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap StructType::nativeMembers(ContractDefinition const*) const$/;"	f	class:StructType	signature:(ContractDefinition const*) const
nativeMembers	libsolidity/ast/Types.cpp	/^MemberList::MemberMap TypeType::nativeMembers(ContractDefinition const* _currentScope) const$/;"	f	class:TypeType	signature:(ContractDefinition const* _currentScope) const
nativeMembers	libsolidity/ast/Types.h	/^	virtual MemberList::MemberMap nativeMembers(ContractDefinition const* \/*_currentScope*\/) const$/;"	f	class:dev::solidity::Type	access:protected	signature:(ContractDefinition const* ) const
natspecDev	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecDev(Contract const& _contract) const$/;"	f	class:Json::CompilerStack	signature:(Contract const& _contract) const
natspecDev	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecDev(string const& _contractName) const$/;"	f	class:Json::CompilerStack	signature:(string const& _contractName) const
natspecDev	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecDev(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:private	signature:(Contract const&) const
natspecDev	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecDev(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:public	signature:(std::string const& _contractName) const
natspecUser	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecUser(Contract const& _contract) const$/;"	f	class:Json::CompilerStack	signature:(Contract const& _contract) const
natspecUser	libsolidity/interface/CompilerStack.cpp	/^Json::Value const& CompilerStack::natspecUser(string const& _contractName) const$/;"	f	class:Json::CompilerStack	signature:(string const& _contractName) const
natspecUser	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecUser(Contract const&) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:private	signature:(Contract const&) const
natspecUser	libsolidity/interface/CompilerStack.h	/^	Json::Value const& natspecUser(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::Json	access:public	signature:(std::string const& _contractName) const
needsHumanTargetedStdout	solse/CommandLineInterface.cpp	/^static bool needsHumanTargetedStdout(po::variables_map const& _args)$/;"	f	namespace:dev::solidity	signature:(po::variables_map const& _args)
newClass	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::newClass(SourceLocation const& _location)$/;"	f	class:ExpressionClasses	signature:(SourceLocation const& _location)
newClass	libevmasm/ExpressionClasses.h	/^	Id newClass(langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(langutil::SourceLocation const& _location)
newData	libevmasm/Assembly.h	/^	AssemblyItem newData(bytes const& _data) { h256 h(dev::keccak256(asString(_data))); m_data[h] = _data; return AssemblyItem(PushData, h); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(bytes const& _data)
newExpressionType	libsolidity/ast/Types.cpp	/^FunctionTypePointer FunctionType::newExpressionType(ContractDefinition const& _contract)$/;"	f	class:FunctionType	signature:(ContractDefinition const& _contract)
newExpressionType	libsolidity/ast/Types.cpp	/^shared_ptr<FunctionType const> const& ContractType::newExpressionType() const$/;"	f	class:ContractType	signature:() const
newExpressionType	libsolidity/ast/Types.h	/^	FunctionTypePointer const& newExpressionType() const;$/;"	p	class:dev::solidity::ContractType	access:public	signature:() const
newExpressionType	libsolidity/ast/Types.h	/^	static FunctionTypePointer newExpressionType(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::FunctionType	access:public	signature:(ContractDefinition const& _contract)
newLabel	libsolidity/analysis/ControlFlowBuilder.cpp	/^CFGNode* ControlFlowBuilder::newLabel()$/;"	f	class:ControlFlowBuilder	signature:()
newLabel	libsolidity/analysis/ControlFlowBuilder.h	/^	CFGNode* newLabel();$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:()
newLabelId	libyul/backends/evm/AbstractAssembly.h	/^	virtual LabelID newLabelId() = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:()
newLabelId	libyul/backends/evm/AsmCodeGen.cpp	/^size_t EthAssemblyAdapter::newLabelId()$/;"	f	class:EthAssemblyAdapter	signature:()
newLabelId	libyul/backends/evm/EVMAssembly.cpp	/^EVMAssembly::LabelID EVMAssembly::newLabelId()$/;"	f	class:EVMAssembly	signature:()
newLabelId	libyul/backends/evm/NoOutputAssembly.cpp	/^NoOutputAssembly::LabelID NoOutputAssembly::newLabelId()$/;"	f	class:NoOutputAssembly	signature:()
newLine	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::newLine()$/;"	f	class:IndentedWriter	signature:()
newLine	libdevcore/IndentedWriter.h	/^	void newLine();$/;"	p	class:dev::IndentedWriter	access:public	signature:()
newName	libyul/optimiser/NameDispenser.cpp	/^YulString NameDispenser::newName(YulString _nameHint)$/;"	f	class:NameDispenser	signature:(YulString _nameHint)
newName	libyul/optimiser/NameDispenser.h	/^	YulString newName(YulString _nameHint);$/;"	p	class:yul::NameDispenser	access:public	signature:(YulString _nameHint)
newNode	libsolidity/analysis/ControlFlowGraph.cpp	/^CFGNode* CFG::NodeContainer::newNode()$/;"	f	class:CFG::NodeContainer	signature:()
newNode	libsolidity/analysis/ControlFlowGraph.h	/^		CFGNode* newNode();$/;"	p	class:dev::solidity::CFG::NodeContainer	access:public	signature:()
newPushLibraryAddress	libevmasm/Assembly.cpp	/^AssemblyItem Assembly::newPushLibraryAddress(string const& _identifier)$/;"	f	class:Assembly	signature:(string const& _identifier)
newPushLibraryAddress	libevmasm/Assembly.h	/^	AssemblyItem newPushLibraryAddress(std::string const& _identifier);$/;"	p	class:dev::eth::Assembly	access:public	signature:(std::string const& _identifier)
newPushString	libevmasm/Assembly.h	/^	AssemblyItem newPushString(std::string const& _data) { h256 h(dev::keccak256(_data)); m_strings[h] = _data; return AssemblyItem(PushString, h); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(std::string const& _data)
newPushSubSize	libevmasm/Assembly.h	/^	AssemblyItem newPushSubSize(u256 const& _subId) { return AssemblyItem(PushSubSize, _subId); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(u256 const& _subId)
newPushTag	libevmasm/Assembly.h	/^	AssemblyItem newPushTag() { assertThrow(m_usedTags < 0xffffffff, AssemblyException, ""); return AssemblyItem(PushTag, m_usedTags++); }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
newSub	libevmasm/Assembly.h	/^	AssemblyItem newSub(AssemblyPointer const& _sub) { m_subs.push_back(_sub); return AssemblyItem(PushSub, m_subs.size() - 1); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(AssemblyPointer const& _sub)
newSymbolicVariable	libsolidity/formal/SymbolicTypes.cpp	/^pair<bool, shared_ptr<SymbolicVariable>> dev::solidity::newSymbolicVariable($/;"	f	class:dev::solidity	signature:( Type const& _type, std::string const& _uniqueName, smt::SolverInterface& _solver )
newSymbolicVariable	libsolidity/formal/SymbolicTypes.h	/^std::pair<bool, std::shared_ptr<SymbolicVariable>> newSymbolicVariable(Type const& _type, std::string const& _uniqueName, smt::SolverInterface& _solver);$/;"	p	namespace:dev::solidity	signature:(Type const& _type, std::string const& _uniqueName, smt::SolverInterface& _solver)
newTag	libevmasm/Assembly.h	/^	AssemblyItem newTag() { assertThrow(m_usedTags < 0xffffffff, AssemblyException, ""); return AssemblyItem(Tag, m_usedTags++); }$/;"	f	class:dev::eth::Assembly	access:public	signature:()
newTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem newTag() { return m_asm->newTag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
newTag	libsolidity/parsing/DocStringParser.cpp	/^void DocStringParser::newTag(string const& _tagName)$/;"	f	class:DocStringParser	signature:(string const& _tagName)
newTag	libsolidity/parsing/DocStringParser.h	/^	void newTag(std::string const& _tagName);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(std::string const& _tagName)
newValue	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::newValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
newValue	libsolidity/formal/SMTChecker.h	/^	smt::Expression newValue(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
newVariable	libsolidity/formal/SolverInterface.h	/^	Expression newVariable(std::string _name, SortPointer _sort)$/;"	f	class:dev::solidity::smt::SolverInterface	access:public	signature:(std::string _name, SortPointer _sort)
next	libevmasm/ControlFlowGraph.h	/^	BlockId next = BlockId::invalid();$/;"	m	struct:dev::eth::BasicBlock	access:public
next	liblangutil/Scanner.cpp	/^Token Scanner::next()$/;"	f	class:langutil::Scanner	signature:()
next	liblangutil/Scanner.h	/^	Token next();$/;"	p	class:langutil::Scanner	access:public	signature:()
next	libsolidity/ast/AST.cpp	/^	static size_t next() { return ++instance(); }$/;"	f	class:IDDispenser	access:public	signature:()
nextArrayElementFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::nextArrayElementFunction(ArrayType const& _type)$/;"	f	class:ABIFunctions	signature:(ArrayType const& _type)
nextArrayElementFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string nextArrayElementFunction(ArrayType const& _type);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(ArrayType const& _type)
nextChar	libsolidity/analysis/SemVerHandler.cpp	/^char SemVerMatchExpressionParser::nextChar()$/;"	f	class:SemVerMatchExpressionParser	signature:()
nextChar	libsolidity/analysis/SemVerHandler.h	/^	char nextChar();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
nextConstructor	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const* CompilerContext::nextConstructor(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
nextConstructor	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const* nextConstructor(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ContractDefinition const& _contract) const
nextFunctionToCompile	libsolidity/codegen/CompilerContext.cpp	/^Declaration const* CompilerContext::FunctionCompilationQueue::nextFunctionToCompile() const$/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:() const
nextFunctionToCompile	libsolidity/codegen/CompilerContext.cpp	/^Declaration const* CompilerContext::nextFunctionToCompile() const$/;"	f	class:dev::solidity::CompilerContext	signature:() const
nextFunctionToCompile	libsolidity/codegen/CompilerContext.h	/^		Declaration const* nextFunctionToCompile() const;$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:() const
nextFunctionToCompile	libsolidity/codegen/CompilerContext.h	/^	Declaration const* nextFunctionToCompile() const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:() const
nextToken	libsolidity/analysis/SemVerHandler.cpp	/^void SemVerMatchExpressionParser::nextToken()$/;"	f	class:SemVerMatchExpressionParser	signature:()
nextToken	libsolidity/analysis/SemVerHandler.h	/^	void nextToken();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
noVisibilitySpecified	libsolidity/ast/AST.h	/^	bool noVisibilitySpecified() const { return m_visibility == Visibility::Default; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
nodeId	libsolidity/ast/ASTJsonConverter.h	/^	static int nodeId(ASTNode const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(ASTNode const& _node)
nodeString	solse/SymExecEngine.cpp	/^std::string nodeString(Expression const & a) {$/;"	f	signature:(Expression const & a)
nodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> nodes() const { return m_nodes; }$/;"	f	class:dev::solidity::SourceUnit	access:public	signature:() const
noexcept	libdevcore/Common.h	33;"	d
noexcept	libdevcore/Exceptions.h	/^	std::string const* comment() const noexcept;$/;"	m	struct:dev::Exception	access:public
noexcept	libsolidity/interface/StandardCompiler.h	/^	Json::Value compile(Json::Value const& _input) noexcept;$/;"	m	class:dev::solidity::StandardCompiler	access:public
noexcept	libsolidity/interface/StandardCompiler.h	/^	std::string compile(std::string const& _input) noexcept;$/;"	m	class:dev::solidity::StandardCompiler	access:public
none	libsolidity/interface/OptimiserSettings.h	/^	static OptimiserSettings none()$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:()
normalColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::normalColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
normalColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized normalColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
numBits	libsolidity/ast/Types.h	/^	unsigned numBits() const { return m_bits; }$/;"	f	class:dev::solidity::IntegerType	access:public	signature:() const
numBits	libsolidity/ast/Types.h	/^	unsigned numBits() const { return m_totalBits; }$/;"	f	class:dev::solidity::FixedPointType	access:public	signature:() const
numBytes	libsolidity/ast/Types.h	/^	unsigned numBytes() const { return m_bytes; }$/;"	f	class:dev::solidity::FixedBytesType	access:public	signature:() const
numberOfLocalVariables	libsolidity/codegen/CompilerContext.cpp	/^unsigned CompilerContext::numberOfLocalVariables() const$/;"	f	class:dev::solidity::CompilerContext	signature:() const
numberOfLocalVariables	libsolidity/codegen/CompilerContext.h	/^	unsigned numberOfLocalVariables() const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:() const
numberOfMembers	libsolidity/ast/Types.cpp	/^size_t EnumType::numberOfMembers() const$/;"	f	class:EnumType	signature:() const
numberOfMembers	libsolidity/ast/Types.h	/^	size_t numberOfMembers() const;$/;"	p	class:dev::solidity::EnumType	access:public	signature:() const
numberOfPops	libevmasm/PeepholeOptimiser.cpp	/^size_t numberOfPops(AssemblyItems const& _items)$/;"	f	namespace:__anon19	signature:(AssemblyItems const& _items)
numberOfVariables	libyul/AsmScope.cpp	/^size_t Scope::numberOfVariables() const$/;"	f	class:Scope	signature:() const
numberOfVariables	libyul/AsmScope.h	/^	size_t numberOfVariables() const;$/;"	p	struct:yul::Scope	access:public	signature:() const
numbers	libsolidity/analysis/SemVerHandler.h	/^	unsigned numbers[3];$/;"	m	struct:dev::solidity::SemVerVersion	access:public
object	libsolidity/interface/CompilerStack.cpp	/^eth::LinkerObject const& CompilerStack::object(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
object	libsolidity/interface/CompilerStack.h	/^		eth::LinkerObject object; \/\/\/< Deployment object (includes the runtime sub-object).$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
object	libsolidity/interface/CompilerStack.h	/^	eth::LinkerObject const& object(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
objectWithLinkRefsHex	solse/CommandLineInterface.cpp	/^string CommandLineInterface::objectWithLinkRefsHex(eth::LinkerObject const& _obj)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(eth::LinkerObject const& _obj)
objectWithLinkRefsHex	solse/CommandLineInterface.h	/^	static std::string objectWithLinkRefsHex(eth::LinkerObject const& _obj);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(eth::LinkerObject const& _obj)
occurrence	libsolidity/analysis/ControlFlowGraph.h	/^	ASTNode const* occurrence() const { return m_occurrence; }$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:() const
offset	libsolidity/ast/Types.cpp	/^pair<u256, unsigned> const* StorageOffsets::offset(size_t _index) const$/;"	f	class:StorageOffsets	signature:(size_t _index) const
offset	libsolidity/ast/Types.h	/^	std::pair<u256, unsigned> const* offset(size_t _index) const;$/;"	p	class:dev::solidity::StorageOffsets::std	access:public	signature:(size_t _index) const
onlyExecuteMain	solse/SymExecEngine.h	/^    bool onlyExecuteMain;$/;"	m	class:SymExecEngine	access:private
onlySafeExperimentalFeaturesActivated	libsolidity/interface/CompilerStack.cpp	/^bool onlySafeExperimentalFeaturesActivated(set<ExperimentalFeature> const& features)$/;"	f	namespace:__anon15	signature:(set<ExperimentalFeature> const& features)
operations	libsolidity/ast/AST.h	/^	yul::Block const& operations() const { return *m_operations; }$/;"	f	class:dev::solidity::InlineAssembly::yul	access:public	signature:() const
operator !	libsolidity/formal/SolverInterface.h	/^	friend Expression operator!(Expression _a)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a)
operator !=	libdevcore/FixedHash.h	/^	bool operator!=(FixedHash const& _c) const { return m_data != _c.m_data; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash const& _c) const
operator !=	libdevcore/vector_ref.h	/^	bool operator!=(vector_ref<_T> const& _cmp) const { return !operator==(_cmp); }$/;"	f	class:dev::vector_ref	access:public	signature:(vector_ref<_T> const& _cmp) const
operator !=	libevmasm/AssemblyItem.h	/^	bool operator!=(AssemblyItem const& _other) const { return !operator==(_other); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const& _other) const
operator !=	libevmasm/AssemblyItem.h	/^	bool operator!=(Instruction _instr) const { return !operator==(_instr); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(Instruction _instr) const
operator !=	libevmasm/BlockDeduplicator.h	/^		bool operator!=(BlockIterator const& _other) const { return it != _other.it; }$/;"	f	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:(BlockIterator const& _other) const
operator !=	libevmasm/ControlFlowGraph.h	/^	bool operator!=(BlockId const& _other) const { return m_id != _other.m_id; }$/;"	f	class:dev::eth::BlockId	access:public	signature:(BlockId const& _other) const
operator !=	liblangutil/SourceLocation.h	/^	bool operator!=(SourceLocation const& _other) const { return !operator==(_other); }$/;"	f	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
operator !=	libsolidity/ast/AST.h	/^	bool operator!=(ASTNode const& _other) const { return !operator==(_other); }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(ASTNode const& _other) const
operator !=	libsolidity/ast/Types.h	/^	virtual bool operator!=(Type const& _other) const { return !this->operator ==(_other); }$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _other) const
operator !=	libsolidity/formal/SolverInterface.h	/^	friend Expression operator!=(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator !=	libyul/YulString.h	/^	bool operator!=(YulString const& _other) const { return m_handle.id != _other.m_handle.id; }$/;"	f	class:yul::YulString	access:public	signature:(YulString const& _other) const
operator !=	libyul/optimiser/RedundantAssignEliminator.h	/^		inline bool operator!=(State _other) const { return !operator==(_other); }$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(State _other) const
operator %	libsolidity/formal/SolverInterface.h	/^	friend Expression operator%(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator &&	libsolidity/formal/SolverInterface.h	/^	friend Expression operator&&(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator ()	libdevcore/Visitor.h	/^	R operator()(T&) const { return {}; }$/;"	f	struct:dev::GenericFallbackReturnsVisitor	access:public	signature:(T&) const
operator ()	libdevcore/Visitor.h	/^	R operator()(Visitable& _v) const { return m_visitor(_v); }$/;"	f	struct:dev::GenericFallbackReturnsVisitor	access:public	signature:(Visitable& _v) const
operator ()	libdevcore/Visitor.h	/^	void operator()() const {}$/;"	f	struct:dev::GenericVisitor	access:public	signature:() const
operator ()	libdevcore/Visitor.h	/^	void operator()(T&) const { }$/;"	f	struct:dev::GenericFallbackVisitor	access:public	signature:(T&) const
operator ()	libdevcore/Visitor.h	/^	void operator()(Visitable& _v) const { m_visitor(_v); }$/;"	f	struct:dev::GenericFallbackVisitor	access:public	signature:(Visitable& _v) const
operator ()	libdevcore/Visitor.h	/^	void operator()(Visitable& _v) const { m_visitor(_v); }$/;"	f	struct:dev::GenericVisitor	access:public	signature:(Visitable& _v) const
operator ()	libdevcore/Whiskers.cpp	/^Whiskers& Whiskers::operator ()($/;"	f	class:Whiskers	signature:( string const& _listParameter, vector<map<string, string>> const& _values )
operator ()	libdevcore/Whiskers.cpp	/^Whiskers& Whiskers::operator ()(string const& _parameter, string const& _value)$/;"	f	class:Whiskers	signature:(string const& _parameter, string const& _value)
operator ()	libdevcore/Whiskers.h	/^	Whiskers& operator()($/;"	p	class:dev::Whiskers	access:public	signature:( std::string const& _listParameter, std::vector<StringMap> const& _values )
operator ()	libdevcore/Whiskers.h	/^	Whiskers& operator()(std::string const& _parameter, std::string const& _value);$/;"	p	class:dev::Whiskers	access:public	signature:(std::string const& _parameter, std::string const& _value)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Assignment const& _assignment)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Assignment const& _assignment)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Block const& _block)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Block const& _block)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::ExpressionStatement const& _expr)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::ExpressionStatement const& _expr)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::ForLoop const& _for)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::ForLoop const& _for)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::FunctionCall const& _funCall)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::FunctionCall const& _funCall)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::FunctionDefinition const& _funDef)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::FunctionDefinition const& _funDef)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::FunctionalInstruction const& _instr)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::FunctionalInstruction const& _instr)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Identifier const&) {}$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Identifier const&)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::If const& _if)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::If const& _if)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Instruction const& _instruction)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Instruction const& _instruction)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Label const&) { }$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Label const&)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Literal const&) {}$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Literal const&)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::StackAssignment const&) {}$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::StackAssignment const&)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::Switch const& _switch)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::Switch const& _switch)
operator ()	libsolidity/analysis/ViewPureChecker.cpp	/^	void operator()(yul::VariableDeclaration const& _varDecl)$/;"	f	class:__anon11::AssemblyViewPureChecker	access:public	signature:(yul::VariableDeclaration const& _varDecl)
operator ()	libsolidity/formal/SolverInterface.h	/^	Expression operator()(std::vector<Expression> _arguments) const$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(std::vector<Expression> _arguments) const
operator ()	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicFunctionVariable::operator()(vector<smt::Expression> _arguments) const$/;"	f	class:SymbolicFunctionVariable	signature:(vector<smt::Expression> _arguments) const
operator ()	libsolidity/formal/SymbolicVariables.h	/^	smt::Expression operator()(std::vector<smt::Expression> _arguments) const;$/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:public	signature:(std::vector<smt::Expression> _arguments) const
operator ()	libsolidity/formal/SymbolicVariables.h	/^	virtual smt::Expression operator()(std::vector<smt::Expression> \/*_arguments*\/) const$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:(std::vector<smt::Expression> ) const
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Assignment const& _assignment)$/;"	f	class:AsmAnalyzer	signature:(Assignment const& _assignment)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Block const& _block)$/;"	f	class:AsmAnalyzer	signature:(Block const& _block)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(ExpressionStatement const& _statement)$/;"	f	class:AsmAnalyzer	signature:(ExpressionStatement const& _statement)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(ForLoop const& _for)$/;"	f	class:AsmAnalyzer	signature:(ForLoop const& _for)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(FunctionCall const& _funCall)$/;"	f	class:AsmAnalyzer	signature:(FunctionCall const& _funCall)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(FunctionDefinition const& _funDef)$/;"	f	class:AsmAnalyzer	signature:(FunctionDefinition const& _funDef)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(FunctionalInstruction const& _instr)$/;"	f	class:AsmAnalyzer	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Identifier const& _identifier)$/;"	f	class:AsmAnalyzer	signature:(Identifier const& _identifier)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(If const& _if)$/;"	f	class:AsmAnalyzer	signature:(If const& _if)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Label const& _label)$/;"	f	class:AsmAnalyzer	signature:(Label const& _label)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Literal const& _literal)$/;"	f	class:AsmAnalyzer	signature:(Literal const& _literal)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(StackAssignment const& _assignment)$/;"	f	class:AsmAnalyzer	signature:(StackAssignment const& _assignment)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(Switch const& _switch)$/;"	f	class:AsmAnalyzer	signature:(Switch const& _switch)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:AsmAnalyzer	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/AsmAnalysis.cpp	/^bool AsmAnalyzer::operator()(yul::Instruction const& _instruction)$/;"	f	class:AsmAnalyzer	signature:(yul::Instruction const& _instruction)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Assignment const& _assignment);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Assignment const& _assignment)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Block const& _block);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Block const& _block)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(ExpressionStatement const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(ExpressionStatement const&)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(ForLoop const& _forLoop);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(ForLoop const& _forLoop)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(FunctionCall const& _functionCall);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(FunctionCall const& _functionCall)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(FunctionDefinition const& _functionDefinition);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(FunctionDefinition const& _functionDefinition)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(FunctionalInstruction const& _functionalInstruction);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(FunctionalInstruction const& _functionalInstruction)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Identifier const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Identifier const&)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(If const& _if);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(If const& _if)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Instruction const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Instruction const&)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Label const& _label);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Label const& _label)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Literal const& _literal);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Literal const& _literal)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(StackAssignment const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(StackAssignment const&)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Switch const& _switch);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Switch const& _switch)
operator ()	libyul/AsmAnalysis.h	/^	bool operator()(VariableDeclaration const& _variableDeclaration);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(VariableDeclaration const& _variableDeclaration)
operator ()	libyul/AsmData.h	/^	template <class T> langutil::SourceLocation operator()(T const& _node) const$/;"	f	struct:yul::LocationExtractor	access:public	signature:(T const& _node) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Assignment const& _assignment) const$/;"	f	class:AsmPrinter	signature:(Assignment const& _assignment) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Block const& _block) const$/;"	f	class:AsmPrinter	signature:(Block const& _block) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(ExpressionStatement const& _statement) const$/;"	f	class:AsmPrinter	signature:(ExpressionStatement const& _statement) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(ForLoop const& _forLoop) const$/;"	f	class:AsmPrinter	signature:(ForLoop const& _forLoop) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(FunctionCall const& _functionCall) const$/;"	f	class:AsmPrinter	signature:(FunctionCall const& _functionCall) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(FunctionDefinition const& _functionDefinition) const$/;"	f	class:AsmPrinter	signature:(FunctionDefinition const& _functionDefinition) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(FunctionalInstruction const& _functionalInstruction) const$/;"	f	class:AsmPrinter	signature:(FunctionalInstruction const& _functionalInstruction) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Identifier const& _identifier) const$/;"	f	class:AsmPrinter	signature:(Identifier const& _identifier) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(If const& _if) const$/;"	f	class:AsmPrinter	signature:(If const& _if) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Label const& _label) const$/;"	f	class:AsmPrinter	signature:(Label const& _label) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Literal const& _literal) const$/;"	f	class:AsmPrinter	signature:(Literal const& _literal) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(StackAssignment const& _assignment) const$/;"	f	class:AsmPrinter	signature:(StackAssignment const& _assignment) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(Switch const& _switch) const$/;"	f	class:AsmPrinter	signature:(Switch const& _switch) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(VariableDeclaration const& _variableDeclaration) const$/;"	f	class:AsmPrinter	signature:(VariableDeclaration const& _variableDeclaration) const
operator ()	libyul/AsmPrinter.cpp	/^string AsmPrinter::operator()(yul::Instruction const& _instruction) const$/;"	f	class:AsmPrinter	signature:(yul::Instruction const& _instruction) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Assignment const& _assignment) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Assignment const& _assignment) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Block const& _block) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Block const& _block) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(ExpressionStatement const& _expr) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(ExpressionStatement const& _expr) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(ForLoop const& _forLoop) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(ForLoop const& _forLoop) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(FunctionCall const& _functionCall) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(FunctionCall const& _functionCall) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(FunctionDefinition const& _functionDefinition) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(FunctionDefinition const& _functionDefinition) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(FunctionalInstruction const& _functionalInstruction) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(FunctionalInstruction const& _functionalInstruction) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Identifier const& _identifier) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Identifier const& _identifier) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(If const& _if) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(If const& _if) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Instruction const& _instruction) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Instruction const& _instruction) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Label const& _label) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Label const& _label) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Literal const& _literal) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Literal const& _literal) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(StackAssignment const& _assignment) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(StackAssignment const& _assignment) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Switch const& _switch) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Switch const& _switch) const
operator ()	libyul/AsmPrinter.h	/^	std::string operator()(VariableDeclaration const& _variableDeclaration) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(VariableDeclaration const& _variableDeclaration) const
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(Block const& _block)$/;"	f	class:ScopeFiller	signature:(Block const& _block)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(ExpressionStatement const& _expr)$/;"	f	class:ScopeFiller	signature:(ExpressionStatement const& _expr)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(ForLoop const& _forLoop)$/;"	f	class:ScopeFiller	signature:(ForLoop const& _forLoop)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(FunctionDefinition const& _funDef)$/;"	f	class:ScopeFiller	signature:(FunctionDefinition const& _funDef)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(If const& _if)$/;"	f	class:ScopeFiller	signature:(If const& _if)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(Label const& _item)$/;"	f	class:ScopeFiller	signature:(Label const& _item)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(Switch const& _switch)$/;"	f	class:ScopeFiller	signature:(Switch const& _switch)
operator ()	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:ScopeFiller	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Assignment const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Assignment const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Block const& _block);$/;"	p	class:yul::ScopeFiller	access:public	signature:(Block const& _block)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(ExpressionStatement const& _expr);$/;"	p	class:yul::ScopeFiller	access:public	signature:(ExpressionStatement const& _expr)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(ForLoop const& _forLoop);$/;"	p	class:yul::ScopeFiller	access:public	signature:(ForLoop const& _forLoop)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(FunctionCall const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(FunctionCall const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(FunctionDefinition const& _functionDefinition);$/;"	p	class:yul::ScopeFiller	access:public	signature:(FunctionDefinition const& _functionDefinition)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(FunctionalInstruction const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(FunctionalInstruction const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Identifier const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Identifier const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(If const& _if);$/;"	p	class:yul::ScopeFiller	access:public	signature:(If const& _if)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Instruction const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Instruction const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Label const& _label);$/;"	p	class:yul::ScopeFiller	access:public	signature:(Label const& _label)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Literal const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Literal const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(StackAssignment const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(StackAssignment const&)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Switch const& _switch);$/;"	p	class:yul::ScopeFiller	access:public	signature:(Switch const& _switch)
operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(VariableDeclaration const& _variableDeclaration);$/;"	p	class:yul::ScopeFiller	access:public	signature:(VariableDeclaration const& _variableDeclaration)
operator ()	libyul/Utilities.cpp	/^bool Less<Literal>::operator()(Literal const& _lhs, Literal const& _rhs) const$/;"	f	class:Less	signature:(Literal const& _lhs, Literal const& _rhs) const
operator ()	libyul/Utilities.h	/^	bool operator()(T const& _lhs, T const& _rhs) const;$/;"	p	struct:yul::Less	access:public	signature:(T const& _lhs, T const& _rhs) const
operator ()	libyul/Utilities.h	/^	bool operator()(T const* _lhs, T const* _rhs) const$/;"	f	struct:yul::Less	access:public	signature:(T const* _lhs, T const* _rhs) const
operator ()	libyul/Utilities.h	/^template<> bool Less<Literal>::operator()(Literal const& _lhs, Literal const& _rhs) const;$/;"	p	class:yul::Less	signature:(Literal const& _lhs, Literal const& _rhs) const
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Assignment const& _assignment)$/;"	f	class:CodeTransform	signature:(Assignment const& _assignment)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Block const& _block)$/;"	f	class:CodeTransform	signature:(Block const& _block)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(ExpressionStatement const& _statement)$/;"	f	class:CodeTransform	signature:(ExpressionStatement const& _statement)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(ForLoop const& _forLoop)$/;"	f	class:CodeTransform	signature:(ForLoop const& _forLoop)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(FunctionCall const& _call)$/;"	f	class:CodeTransform	signature:(FunctionCall const& _call)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(FunctionDefinition const& _function)$/;"	f	class:CodeTransform	signature:(FunctionDefinition const& _function)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(FunctionalInstruction const& _instruction)$/;"	f	class:CodeTransform	signature:(FunctionalInstruction const& _instruction)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Identifier const& _identifier)$/;"	f	class:CodeTransform	signature:(Identifier const& _identifier)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(If const& _if)$/;"	f	class:CodeTransform	signature:(If const& _if)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Label const& _label)$/;"	f	class:CodeTransform	signature:(Label const& _label)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Literal const& _literal)$/;"	f	class:CodeTransform	signature:(Literal const& _literal)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(StackAssignment const& _assignment)$/;"	f	class:CodeTransform	signature:(StackAssignment const& _assignment)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(Switch const& _switch)$/;"	f	class:CodeTransform	signature:(Switch const& _switch)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:CodeTransform	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::operator()(yul::Instruction const& _instruction)$/;"	f	class:CodeTransform	signature:(yul::Instruction const& _instruction)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(Block const& _block)$/;"	f	class:VariableReferenceCounter	signature:(Block const& _block)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(ForLoop const& _forLoop)$/;"	f	class:VariableReferenceCounter	signature:(ForLoop const& _forLoop)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(FunctionDefinition const& _function)$/;"	f	class:VariableReferenceCounter	signature:(FunctionDefinition const& _function)
operator ()	libyul/backends/evm/EVMCodeTransform.cpp	/^void VariableReferenceCounter::operator()(Identifier const& _identifier)$/;"	f	class:VariableReferenceCounter	signature:(Identifier const& _identifier)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Assignment const& _assignment);$/;"	p	class:yul::CodeTransform	access:public	signature:(Assignment const& _assignment)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Block const& _block);$/;"	p	class:yul::CodeTransform	access:public	signature:(Block const& _block)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Block const& _block);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(Block const& _block)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(ExpressionStatement const& _statement);$/;"	p	class:yul::CodeTransform	access:public	signature:(ExpressionStatement const& _statement)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(ForLoop const&);$/;"	p	class:yul::CodeTransform	access:public	signature:(ForLoop const&)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(ForLoop const&);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(ForLoop const&)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionCall const&);$/;"	p	class:yul::CodeTransform	access:public	signature:(FunctionCall const&)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionDefinition const&);$/;"	p	class:yul::CodeTransform	access:public	signature:(FunctionDefinition const&)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionDefinition const&);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(FunctionDefinition const&)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionalInstruction const& _instr);$/;"	p	class:yul::CodeTransform	access:public	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Identifier const& _identifier);$/;"	p	class:yul::CodeTransform	access:public	signature:(Identifier const& _identifier)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Identifier const& _identifier);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(Identifier const& _identifier)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(If const& _if);$/;"	p	class:yul::CodeTransform	access:public	signature:(If const& _if)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Instruction const& _instruction);$/;"	p	class:yul::CodeTransform	access:public	signature:(Instruction const& _instruction)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Label const& _label);$/;"	p	class:yul::CodeTransform	access:public	signature:(Label const& _label)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Literal const& _literal);$/;"	p	class:yul::CodeTransform	access:public	signature:(Literal const& _literal)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(StackAssignment const& _assignment);$/;"	p	class:yul::CodeTransform	access:public	signature:(StackAssignment const& _assignment)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Switch const& _switch);$/;"	p	class:yul::CodeTransform	access:public	signature:(Switch const& _switch)
operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(VariableDeclaration const& _varDecl);$/;"	p	class:yul::CodeTransform	access:public	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(FunctionCall const& _call)$/;"	f	class:ASTCopier	signature:(FunctionCall const& _call)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(FunctionalInstruction const& _instruction)$/;"	f	class:ASTCopier	signature:(FunctionalInstruction const& _instruction)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(Identifier const& _identifier)$/;"	f	class:ASTCopier	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::operator()(Literal const& _literal)$/;"	f	class:ASTCopier	signature:(Literal const& _literal)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator ()(Block const& _block)$/;"	f	class:ASTCopier	signature:(Block const& _block)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Assignment const& _assignment)$/;"	f	class:ASTCopier	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(ExpressionStatement const& _statement)$/;"	f	class:ASTCopier	signature:(ExpressionStatement const& _statement)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(ForLoop const& _forLoop)$/;"	f	class:ASTCopier	signature:(ForLoop const& _forLoop)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(FunctionDefinition const& _function)$/;"	f	class:ASTCopier	signature:(FunctionDefinition const& _function)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(If const& _if)$/;"	f	class:ASTCopier	signature:(If const& _if)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Instruction const&)$/;"	f	class:ASTCopier	signature:(Instruction const&)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Label const&)$/;"	f	class:ASTCopier	signature:(Label const&)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(StackAssignment const&)$/;"	f	class:ASTCopier	signature:(StackAssignment const&)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(Switch const& _switch)$/;"	f	class:ASTCopier	signature:(Switch const& _switch)
operator ()	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:ASTCopier	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(FunctionCall const&) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(FunctionCall const&)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(FunctionalInstruction const& _instr) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(Identifier const& _identifier) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(Literal const& _literal) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(Literal const& _literal)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Assignment const& _assignment) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Block const& _block) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Block const& _block)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(ExpressionStatement const& _statement) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(ExpressionStatement const& _statement)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(ForLoop const&) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(ForLoop const&)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(FunctionDefinition const&) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(FunctionDefinition const&)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(If const& _if) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(If const& _if)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Instruction const& _instruction) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Instruction const& _instruction)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Label const& _label) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Label const& _label)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(StackAssignment const& _assignment) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(StackAssignment const& _assignment)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Switch const& _switch) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Switch const& _switch)
operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(VariableDeclaration const& _varDecl) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(Assignment& _assignment)$/;"	f	class:ASTModifier	signature:(Assignment& _assignment)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(Block& _block)$/;"	f	class:ASTModifier	signature:(Block& _block)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(ExpressionStatement& _statement)$/;"	f	class:ASTModifier	signature:(ExpressionStatement& _statement)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(ForLoop& _for)$/;"	f	class:ASTModifier	signature:(ForLoop& _for)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(FunctionCall& _funCall)$/;"	f	class:ASTModifier	signature:(FunctionCall& _funCall)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(FunctionDefinition& _fun)$/;"	f	class:ASTModifier	signature:(FunctionDefinition& _fun)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(FunctionalInstruction& _instr)$/;"	f	class:ASTModifier	signature:(FunctionalInstruction& _instr)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(If& _if)$/;"	f	class:ASTModifier	signature:(If& _if)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(Switch& _switch)$/;"	f	class:ASTModifier	signature:(Switch& _switch)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::operator()(VariableDeclaration& _varDecl)$/;"	f	class:ASTModifier	signature:(VariableDeclaration& _varDecl)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(Assignment const& _assignment)$/;"	f	class:ASTWalker	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(Block const& _block)$/;"	f	class:ASTWalker	signature:(Block const& _block)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(ExpressionStatement const& _statement)$/;"	f	class:ASTWalker	signature:(ExpressionStatement const& _statement)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(ForLoop const& _for)$/;"	f	class:ASTWalker	signature:(ForLoop const& _for)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(FunctionCall const& _funCall)$/;"	f	class:ASTWalker	signature:(FunctionCall const& _funCall)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(FunctionDefinition const& _fun)$/;"	f	class:ASTWalker	signature:(FunctionDefinition const& _fun)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(FunctionalInstruction const& _instr)$/;"	f	class:ASTWalker	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(If const& _if)$/;"	f	class:ASTWalker	signature:(If const& _if)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(Switch const& _switch)$/;"	f	class:ASTWalker	signature:(Switch const& _switch)
operator ()	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:ASTWalker	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Assignment const& _assignment);$/;"	p	class:yul::ASTWalker	access:public	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Assignment& _assignment);$/;"	p	class:yul::ASTModifier	access:public	signature:(Assignment& _assignment)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Block const& _block);$/;"	p	class:yul::ASTWalker	access:public	signature:(Block const& _block)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Block& _block);$/;"	p	class:yul::ASTModifier	access:public	signature:(Block& _block)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ExpressionStatement const& _statement);$/;"	p	class:yul::ASTWalker	access:public	signature:(ExpressionStatement const& _statement)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ExpressionStatement& _statement);$/;"	p	class:yul::ASTModifier	access:public	signature:(ExpressionStatement& _statement)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ForLoop const&);$/;"	p	class:yul::ASTWalker	access:public	signature:(ForLoop const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ForLoop&);$/;"	p	class:yul::ASTModifier	access:public	signature:(ForLoop&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionCall const& _funCall);$/;"	p	class:yul::ASTWalker	access:public	signature:(FunctionCall const& _funCall)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionCall& _funCall);$/;"	p	class:yul::ASTModifier	access:public	signature:(FunctionCall& _funCall)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionDefinition const&);$/;"	p	class:yul::ASTWalker	access:public	signature:(FunctionDefinition const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionDefinition&);$/;"	p	class:yul::ASTModifier	access:public	signature:(FunctionDefinition&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionalInstruction const& _instr);$/;"	p	class:yul::ASTWalker	access:public	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionalInstruction& _instr);$/;"	p	class:yul::ASTModifier	access:public	signature:(FunctionalInstruction& _instr)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Identifier const&) {}$/;"	f	class:yul::ASTWalker	access:public	signature:(Identifier const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Identifier&) {}$/;"	f	class:yul::ASTModifier	access:public	signature:(Identifier&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(If const& _if);$/;"	p	class:yul::ASTWalker	access:public	signature:(If const& _if)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(If& _if);$/;"	p	class:yul::ASTModifier	access:public	signature:(If& _if)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Instruction const&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTWalker	access:public	signature:(Instruction const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Instruction&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTModifier	access:public	signature:(Instruction&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Label const&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTWalker	access:public	signature:(Label const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Label&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTModifier	access:public	signature:(Label&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Literal const&) {}$/;"	f	class:yul::ASTWalker	access:public	signature:(Literal const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Literal&) {}$/;"	f	class:yul::ASTModifier	access:public	signature:(Literal&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(StackAssignment const&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTWalker	access:public	signature:(StackAssignment const&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(StackAssignment&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTModifier	access:public	signature:(StackAssignment&)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Switch const& _switch);$/;"	p	class:yul::ASTWalker	access:public	signature:(Switch const& _switch)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Switch& _switch);$/;"	p	class:yul::ASTModifier	access:public	signature:(Switch& _switch)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(VariableDeclaration const& _varDecl);$/;"	p	class:yul::ASTWalker	access:public	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(VariableDeclaration& _varDecl);$/;"	p	class:yul::ASTModifier	access:public	signature:(VariableDeclaration& _varDecl)
operator ()	libyul/optimiser/BlockFlattener.cpp	/^void BlockFlattener::operator()(Block& _block)$/;"	f	class:BlockFlattener	signature:(Block& _block)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(Assignment& _assignment)$/;"	f	class:DataFlowAnalyzer	signature:(Assignment& _assignment)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(Block& _block)$/;"	f	class:DataFlowAnalyzer	signature:(Block& _block)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(ForLoop& _for)$/;"	f	class:DataFlowAnalyzer	signature:(ForLoop& _for)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(FunctionDefinition& _fun)$/;"	f	class:DataFlowAnalyzer	signature:(FunctionDefinition& _fun)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(If& _if)$/;"	f	class:DataFlowAnalyzer	signature:(If& _if)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(Switch& _switch)$/;"	f	class:DataFlowAnalyzer	signature:(Switch& _switch)
operator ()	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::operator()(VariableDeclaration& _varDecl)$/;"	f	class:DataFlowAnalyzer	signature:(VariableDeclaration& _varDecl)
operator ()	libyul/optimiser/EquivalentFunctionCombiner.cpp	/^void EquivalentFunctionCombiner::operator()(FunctionCall& _funCall)$/;"	f	class:EquivalentFunctionCombiner	signature:(FunctionCall& _funCall)
operator ()	libyul/optimiser/EquivalentFunctionDetector.cpp	/^void EquivalentFunctionDetector::operator()(FunctionDefinition const& _fun)$/;"	f	class:EquivalentFunctionDetector	signature:(FunctionDefinition const& _fun)
operator ()	libyul/optimiser/ExpressionInliner.cpp	/^void ExpressionInliner::operator()(FunctionDefinition& _fun)$/;"	f	class:ExpressionInliner	signature:(FunctionDefinition& _fun)
operator ()	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::operator()(Block& _block)$/;"	f	class:ExpressionJoiner	signature:(Block& _block)
operator ()	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::operator()(FunctionCall& _funCall)$/;"	f	class:ExpressionJoiner	signature:(FunctionCall& _funCall)
operator ()	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::operator()(FunctionalInstruction& _instruction)$/;"	f	class:ExpressionJoiner	signature:(FunctionalInstruction& _instruction)
operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(Block& _block)$/;"	f	class:ExpressionSplitter	signature:(Block& _block)
operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(ForLoop& _loop)$/;"	f	class:ExpressionSplitter	signature:(ForLoop& _loop)
operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(FunctionCall& _funCall)$/;"	f	class:ExpressionSplitter	signature:(FunctionCall& _funCall)
operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(FunctionalInstruction& _instruction)$/;"	f	class:ExpressionSplitter	signature:(FunctionalInstruction& _instruction)
operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(If& _if)$/;"	f	class:ExpressionSplitter	signature:(If& _if)
operator ()	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::operator()(Switch& _switch)$/;"	f	class:ExpressionSplitter	signature:(Switch& _switch)
operator ()	libyul/optimiser/ForLoopInitRewriter.cpp	/^void ForLoopInitRewriter::operator()(Block& _block)$/;"	f	class:ForLoopInitRewriter	signature:(Block& _block)
operator ()	libyul/optimiser/FullInliner.cpp	/^Statement BodyCopier::operator()(FunctionDefinition const&)$/;"	f	class:BodyCopier	signature:(FunctionDefinition const&)
operator ()	libyul/optimiser/FullInliner.cpp	/^Statement BodyCopier::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:BodyCopier	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/FullInliner.cpp	/^void InlineModifier::operator()(Block& _block)$/;"	f	class:InlineModifier	signature:(Block& _block)
operator ()	libyul/optimiser/FunctionGrouper.cpp	/^void FunctionGrouper::operator()(Block& _block)$/;"	f	class:FunctionGrouper	signature:(Block& _block)
operator ()	libyul/optimiser/FunctionGrouper.h	/^	void operator()(Block& _block);$/;"	p	class:yul::FunctionGrouper	access:public	signature:(Block& _block)
operator ()	libyul/optimiser/FunctionHoister.cpp	/^void FunctionHoister::operator()(Block& _block)$/;"	f	class:FunctionHoister	signature:(Block& _block)
operator ()	libyul/optimiser/FunctionHoister.h	/^	virtual void operator()(Block& _block);$/;"	p	class:yul::FunctionHoister	access:public	signature:(Block& _block)
operator ()	libyul/optimiser/InlinableExpressionFunctionFinder.cpp	/^void InlinableExpressionFunctionFinder::operator()(FunctionCall const& _funCall)$/;"	f	class:InlinableExpressionFunctionFinder	signature:(FunctionCall const& _funCall)
operator ()	libyul/optimiser/InlinableExpressionFunctionFinder.cpp	/^void InlinableExpressionFunctionFinder::operator()(FunctionDefinition const& _function)$/;"	f	class:InlinableExpressionFunctionFinder	signature:(FunctionDefinition const& _function)
operator ()	libyul/optimiser/InlinableExpressionFunctionFinder.cpp	/^void InlinableExpressionFunctionFinder::operator()(Identifier const& _identifier)$/;"	f	class:InlinableExpressionFunctionFinder	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/MainFunction.cpp	/^void MainFunction::operator()(Block& _block)$/;"	f	class:MainFunction	signature:(Block& _block)
operator ()	libyul/optimiser/MainFunction.h	/^	void operator()(Block& _block);$/;"	p	class:yul::MainFunction	access:public	signature:(Block& _block)
operator ()	libyul/optimiser/Metrics.cpp	/^void AssignmentCounter::operator()(Assignment const& _assignment)$/;"	f	class:AssignmentCounter	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/Metrics.cpp	/^void CodeCost::operator()(FunctionCall const& _funCall)$/;"	f	class:CodeCost	signature:(FunctionCall const& _funCall)
operator ()	libyul/optimiser/Metrics.cpp	/^void CodeCost::operator()(FunctionalInstruction const& _instr)$/;"	f	class:CodeCost	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/optimiser/Metrics.cpp	/^void CodeCost::operator()(Literal const& _literal)$/;"	f	class:CodeCost	signature:(Literal const& _literal)
operator ()	libyul/optimiser/NameCollector.cpp	/^void Assignments::operator()(Assignment const& _assignment)$/;"	f	class:Assignments	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/NameCollector.cpp	/^void NameCollector::operator ()(FunctionDefinition const& _funDef)$/;"	f	class:NameCollector	signature:(FunctionDefinition const& _funDef)
operator ()	libyul/optimiser/NameCollector.cpp	/^void NameCollector::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:NameCollector	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/NameCollector.cpp	/^void ReferencesCounter::operator()(FunctionCall const& _funCall)$/;"	f	class:ReferencesCounter	signature:(FunctionCall const& _funCall)
operator ()	libyul/optimiser/NameCollector.cpp	/^void ReferencesCounter::operator()(Identifier const& _identifier)$/;"	f	class:ReferencesCounter	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/NameCollector.h	/^	virtual void operator()(FunctionCall const& _funCall);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(FunctionCall const& _funCall)
operator ()	libyul/optimiser/NameCollector.h	/^	virtual void operator()(Identifier const& _identifier);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void AssignmentRemover::operator()(Block& _block)$/;"	f	class:AssignmentRemover	signature:(Block& _block)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Assignment const& _assignment)$/;"	f	class:RedundantAssignEliminator	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Block const& _block)$/;"	f	class:RedundantAssignEliminator	signature:(Block const& _block)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(ForLoop const& _forLoop)$/;"	f	class:RedundantAssignEliminator	signature:(ForLoop const& _forLoop)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(FunctionDefinition const& _functionDefinition)$/;"	f	class:RedundantAssignEliminator	signature:(FunctionDefinition const& _functionDefinition)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Identifier const& _identifier)$/;"	f	class:RedundantAssignEliminator	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(If const& _if)$/;"	f	class:RedundantAssignEliminator	signature:(If const& _if)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(Switch const& _switch)$/;"	f	class:RedundantAssignEliminator	signature:(Switch const& _switch)
operator ()	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::operator()(VariableDeclaration const& _variableDeclaration)$/;"	f	class:RedundantAssignEliminator	signature:(VariableDeclaration const& _variableDeclaration)
operator ()	libyul/optimiser/SSAReverser.cpp	/^void SSAReverser::operator()(Block& _block)$/;"	f	class:SSAReverser	signature:(Block& _block)
operator ()	libyul/optimiser/SSATransform.cpp	/^void SSATransform::operator()(Block& _block)$/;"	f	class:SSATransform	signature:(Block& _block)
operator ()	libyul/optimiser/SSATransform.cpp	/^void SSATransform::operator()(ForLoop& _for)$/;"	f	class:SSATransform	signature:(ForLoop& _for)
operator ()	libyul/optimiser/SSATransform.cpp	/^void SSATransform::operator()(Identifier& _identifier)$/;"	f	class:SSATransform	signature:(Identifier& _identifier)
operator ()	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::operator()(Assignment const& _assignment)$/;"	f	class:SSAValueTracker	signature:(Assignment const& _assignment)
operator ()	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::operator()(FunctionDefinition const& _funDef)$/;"	f	class:SSAValueTracker	signature:(FunctionDefinition const& _funDef)
operator ()	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::operator()(VariableDeclaration const& _varDecl)$/;"	f	class:SSAValueTracker	signature:(VariableDeclaration const& _varDecl)
operator ()	libyul/optimiser/Semantics.cpp	/^void MovableChecker::operator()(FunctionCall const& _functionCall)$/;"	f	class:MovableChecker	signature:(FunctionCall const& _functionCall)
operator ()	libyul/optimiser/Semantics.cpp	/^void MovableChecker::operator()(FunctionalInstruction const& _instr)$/;"	f	class:MovableChecker	signature:(FunctionalInstruction const& _instr)
operator ()	libyul/optimiser/Semantics.cpp	/^void MovableChecker::operator()(Identifier const& _identifier)$/;"	f	class:MovableChecker	signature:(Identifier const& _identifier)
operator ()	libyul/optimiser/StructuralSimplifier.cpp	/^void StructuralSimplifier::operator()(Block& _block)$/;"	f	class:StructuralSimplifier	signature:(Block& _block)
operator ()	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::operator()(Expression const& _lhs, Expression const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Expression const& _lhs, Expression const& _rhs)
operator ()	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::operator()(Statement const& _lhs, Statement const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Statement const& _lhs, Statement const& _rhs)
operator ()	libyul/optimiser/SyntacticalEquality.h	/^	bool operator()(Expression const& _lhs, Expression const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Expression const& _lhs, Expression const& _rhs)
operator ()	libyul/optimiser/SyntacticalEquality.h	/^	bool operator()(Statement const& _lhs, Statement const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Statement const& _lhs, Statement const& _rhs)
operator ()	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::operator()(Block& _block)$/;"	f	class:UnusedPruner	signature:(Block& _block)
operator ()	libyul/optimiser/VarDeclInitializer.cpp	/^void VarDeclInitializer::operator()(Block& _block)$/;"	f	class:VarDeclInitializer	signature:(Block& _block)
operator ()	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::operator()(FunctionDefinition& _funDef)$/;"	f	class:VarNameCleaner	signature:(FunctionDefinition& _funDef)
operator ()	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::operator()(Identifier& _identifier)$/;"	f	class:VarNameCleaner	signature:(Identifier& _identifier)
operator ()	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::operator()(VariableDeclaration& _varDecl)$/;"	f	class:VarNameCleaner	signature:(VariableDeclaration& _varDecl)
operator *	libevmasm/BlockDeduplicator.cpp	/^AssemblyItem const& BlockDeduplicator::BlockIterator::operator*() const$/;"	f	class:BlockDeduplicator::BlockIterator	signature:() const
operator *	libevmasm/BlockDeduplicator.h	/^		AssemblyItem const& operator*() const;$/;"	p	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:() const
operator *	libsolidity/formal/SolverInterface.h	/^	friend Expression operator*(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator +	libdevcore/CommonData.h	/^inline std::vector<T> operator+(std::vector<T> const& _a, std::vector<T> const& _b)$/;"	f	namespace:dev	signature:(std::vector<T> const& _a, std::vector<T> const& _b)
operator +	libdevcore/CommonData.h	/^inline std::vector<T> operator+(std::vector<T>&& _a, std::vector<T>&& _b)$/;"	f	namespace:dev	signature:(std::vector<T>&& _a, std::vector<T>&& _b)
operator +	libsolidity/formal/SolverInterface.h	/^	friend Expression operator+(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator ++	libevmasm/BlockDeduplicator.cpp	/^BlockDeduplicator::BlockIterator& BlockDeduplicator::BlockIterator::operator++()$/;"	f	class:BlockDeduplicator::BlockIterator	signature:()
operator ++	libevmasm/BlockDeduplicator.h	/^		BlockIterator& operator++();$/;"	p	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:()
operator ++	libsolidity/formal/SSAVariable.h	/^	unsigned operator++()$/;"	f	class:dev::solidity::SSAVariable	access:public	signature:()
operator +=	libdevcore/CommonData.h	/^template <class T, class U> std::set<T>& operator+=(std::set<T>& _a, U const& _b)$/;"	f	namespace:dev	signature:(std::set<T>& _a, U const& _b)
operator +=	libdevcore/CommonData.h	/^template <class T, class U> std::vector<T>& operator+=(std::vector<T>& _a, U const& _b)$/;"	f	namespace:dev	signature:(std::vector<T>& _a, U const& _b)
operator +=	libdevcore/CommonData.h	/^template <class T, class U> std::vector<T>& operator+=(std::vector<T>& _a, U&& _b)$/;"	f	namespace:dev	signature:(std::vector<T>& _a, U&& _b)
operator +=	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption& GasMeter::GasConsumption::operator+=(GasConsumption const& _other)$/;"	f	class:GasMeter::GasConsumption	signature:(GasConsumption const& _other)
operator +=	libevmasm/GasMeter.h	/^		GasConsumption& operator+=(GasConsumption const& _other);$/;"	p	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(GasConsumption const& _other)
operator -	libsolidity/formal/SolverInterface.h	/^	friend Expression operator-(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator /	libsolidity/formal/SolverInterface.h	/^	friend Expression operator\/(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator <	libdevcore/FixedHash.h	/^	bool operator<(FixedHash const& _c) const { for (unsigned i = 0; i < N; ++i) if (m_data[i] < _c.m_data[i]) return true; else if (m_data[i] > _c.m_data[i]) return false; return false; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash const& _c) const
operator <	libevmasm/AssemblyItem.h	/^	bool operator<(AssemblyItem const& _other) const$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const& _other) const
operator <	libevmasm/ControlFlowGraph.h	/^	bool operator<(BlockId const& _other) const { return m_id < _other.m_id; }$/;"	f	class:dev::eth::BlockId	access:public	signature:(BlockId const& _other) const
operator <	libevmasm/ExpressionClasses.cpp	/^bool ExpressionClasses::Expression::operator<(ExpressionClasses::Expression const& _other) const$/;"	f	class:ExpressionClasses::Expression	signature:(ExpressionClasses::Expression const& _other) const
operator <	libevmasm/ExpressionClasses.h	/^		bool operator<(Expression const& _other) const;$/;"	p	struct:dev::eth::ExpressionClasses::Expression	access:public	signature:(Expression const& _other) const
operator <	libevmasm/GasMeter.h	/^		bool operator<(GasConsumption const& _other) const$/;"	f	struct:dev::eth::GasMeter::GasConsumption	access:public	signature:(GasConsumption const& _other) const
operator <	liblangutil/EVMVersion.h	/^	bool operator<(EVMVersion const& _other) const { return m_version < _other.m_version; }$/;"	f	class:langutil::EVMVersion	access:public	signature:(EVMVersion const& _other) const
operator <	liblangutil/SourceLocation.h	/^	inline bool operator<(SourceLocation const& _other) const;$/;"	p	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
operator <	liblangutil/SourceLocation.h	/^bool SourceLocation::operator<(SourceLocation const& _other) const$/;"	f	class:langutil::SourceLocation	signature:(SourceLocation const& _other) const
operator <	libsolidity/analysis/ControlFlowGraph.h	/^	bool operator<(VariableOccurrence const& _rhs) const$/;"	f	class:dev::solidity::VariableOccurrence	access:public	signature:(VariableOccurrence const& _rhs) const
operator <	libsolidity/formal/SolverInterface.h	/^	friend Expression operator<(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator <	libyul/YulString.h	/^	bool operator<(YulString const& _other) const$/;"	f	class:yul::YulString	access:public	signature:(YulString const& _other) const
operator <	libyul/optimiser/EquivalentFunctionDetector.cpp	/^bool EquivalentFunctionDetector::RoughHeuristic::operator<(EquivalentFunctionDetector::RoughHeuristic const& _rhs) const$/;"	f	class:EquivalentFunctionDetector::RoughHeuristic	signature:(EquivalentFunctionDetector::RoughHeuristic const& _rhs) const
operator <	libyul/optimiser/EquivalentFunctionDetector.h	/^		bool operator<(RoughHeuristic const& _rhs) const;$/;"	p	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:public	signature:(RoughHeuristic const& _rhs) const
operator <<	libdevcore/AnsiColorized.h	/^	std::ostream& operator<<(T&& _t)$/;"	f	class:dev::AnsiColorized	access:public	signature:(T&& _t)
operator <<	libdevcore/Common.h	/^inline std::ostream& operator<<(std::ostream& os, bytes const& _bytes)$/;"	f	namespace:dev	signature:(std::ostream& os, bytes const& _bytes)
operator <<	libdevcore/FixedHash.h	/^inline std::ostream& operator<<(std::ostream& _out, FixedHash<N> const& _h)$/;"	f	namespace:dev	signature:(std::ostream& _out, FixedHash<N> const& _h)
operator <<	libevmasm/Assembly.h	/^	template <class T> Assembly& operator<<(T const& _d) { append(_d); return *this; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(T const& _d)
operator <<	libevmasm/Assembly.h	/^inline std::ostream& operator<<(std::ostream& _out, Assembly const& _a)$/;"	f	namespace:dev::eth	signature:(std::ostream& _out, Assembly const& _a)
operator <<	libevmasm/AssemblyItem.cpp	/^ostream& dev::eth::operator<<(ostream& _out, AssemblyItem const& _item)$/;"	f	class:dev::eth	signature:(ostream& _out, AssemblyItem const& _item)
operator <<	libevmasm/AssemblyItem.h	/^inline std::ostream& operator<<(std::ostream& _out, AssemblyItems const& _items)$/;"	f	namespace:dev::eth	signature:(std::ostream& _out, AssemblyItems const& _items)
operator <<	libevmasm/AssemblyItem.h	/^std::ostream& operator<<(std::ostream& _out, AssemblyItem const& _item);$/;"	p	namespace:dev::eth	signature:(std::ostream& _out, AssemblyItem const& _item)
operator <<	libevmasm/GasMeter.h	/^inline std::ostream& operator<<(std::ostream& _str, GasMeter::GasConsumption const& _consumption)$/;"	f	namespace:dev::eth	signature:(std::ostream& _str, GasMeter::GasConsumption const& _consumption)
operator <<	liblangutil/Scanner.cpp	/^std::ostream& operator<<(std::ostream& os, ScannerError _errorCode)$/;"	f	namespace:langutil	signature:(std::ostream& os, ScannerError _errorCode)
operator <<	liblangutil/Scanner.h	/^std::ostream& operator<<(std::ostream& os, ScannerError _errorCode);$/;"	p	namespace:langutil	signature:(std::ostream& os, ScannerError _errorCode)
operator <<	liblangutil/SourceLocation.h	/^inline std::ostream& operator<<(std::ostream& _out, SourceLocation const& _location)$/;"	f	namespace:langutil	signature:(std::ostream& _out, SourceLocation const& _location)
operator <<	liblangutil/Token.h	/^inline std::ostream& operator<<(std::ostream& os, Token token)$/;"	f	namespace:langutil	signature:(std::ostream& os, Token token)
operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(Instruction _instruction) { m_asm->append(_instruction); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(Instruction _instruction)
operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(bytes const& _data) { m_asm->append(_data); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(bytes const& _data)
operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(eth::AssemblyItem const& _item) { m_asm->append(_item); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(eth::AssemblyItem const& _item)
operator <<	libsolidity/codegen/CompilerContext.h	/^	CompilerContext& operator<<(u256 const& _value) { m_asm->append(_value); return *this; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(u256 const& _value)
operator <=	libsolidity/formal/SolverInterface.h	/^	friend Expression operator<=(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator =	libevmasm/AssemblyItem.h	/^	AssemblyItem& operator=(AssemblyItem const&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const&)
operator =	libevmasm/AssemblyItem.h	/^	AssemblyItem& operator=(AssemblyItem&&) = default;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem&&)
operator =	liblangutil/ErrorReporter.cpp	/^ErrorReporter& ErrorReporter::operator=(ErrorReporter const& _errorReporter)$/;"	f	class:ErrorReporter	signature:(ErrorReporter const& _errorReporter)
operator =	liblangutil/ErrorReporter.h	/^	ErrorReporter& operator=(ErrorReporter const& _errorReporter);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(ErrorReporter const& _errorReporter)
operator =	libsolidity/formal/SolverInterface.h	/^	Expression& operator=(Expression const&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression const&)
operator =	libsolidity/formal/SolverInterface.h	/^	Expression& operator=(Expression&&) = default;$/;"	p	class:dev::solidity::smt::Expression	access:public	signature:(Expression&&)
operator =	libyul/YulString.h	/^	YulString& operator=(YulString const&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString const&)
operator =	libyul/YulString.h	/^	YulString& operator=(YulString&&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString&&)
operator =	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator& operator=(RedundantAssignEliminator const&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator const&)
operator =	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator& operator=(RedundantAssignEliminator&&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator&&)
operator =	solse/SolidityExprTranslator.h	/^    ContextInfo& operator=(const ContextInfo& other) {$/;"	f	class:ContextInfo	access:public	signature:(const ContextInfo& other)
operator =	solse/SymExecEngine.h	/^    StructInfo& operator=(const StructInfo& other){$/;"	f	class:StructInfo	access:public	signature:(const StructInfo& other)
operator =	solse/mechanism.h	/^    Mechanism& operator=(const Mechanism& other) {$/;"	f	class:Mechanism	access:public	signature:(const Mechanism& other)
operator ==	libdevcore/FixedHash.h	/^	bool operator==(FixedHash const& _c) const { return m_data == _c.m_data; }$/;"	f	class:dev::FixedHash	access:public	signature:(FixedHash const& _c) const
operator ==	libdevcore/vector_ref.h	/^	bool operator==(vector_ref<_T> const& _cmp) const { return m_data == _cmp.m_data && m_count == _cmp.m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:(vector_ref<_T> const& _cmp) const
operator ==	libevmasm/AssemblyItem.h	/^	bool operator==(AssemblyItem const& _other) const$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(AssemblyItem const& _other) const
operator ==	libevmasm/AssemblyItem.h	/^	bool operator==(Instruction _instr) const$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(Instruction _instr) const
operator ==	libevmasm/BlockDeduplicator.h	/^		bool operator==(BlockIterator const& _other) const { return it == _other.it; }$/;"	f	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public	signature:(BlockIterator const& _other) const
operator ==	libevmasm/ControlFlowGraph.h	/^	bool operator==(BlockId const& _other) const { return m_id == _other.m_id; }$/;"	f	class:dev::eth::BlockId	access:public	signature:(BlockId const& _other) const
operator ==	libevmasm/KnownState.cpp	/^bool KnownState::operator==(KnownState const& _other) const$/;"	f	class:KnownState	signature:(KnownState const& _other) const
operator ==	libevmasm/KnownState.h	/^	bool operator==(KnownState const& _other) const;$/;"	p	class:dev::eth::KnownState	access:public	signature:(KnownState const& _other) const
operator ==	liblangutil/EVMVersion.h	/^	bool operator==(EVMVersion const& _other) const { return m_version == _other.m_version; }$/;"	f	class:langutil::EVMVersion	access:public	signature:(EVMVersion const& _other) const
operator ==	liblangutil/SourceLocation.h	/^	bool operator==(SourceLocation const& _other) const$/;"	f	struct:langutil::SourceLocation	access:public	signature:(SourceLocation const& _other) const
operator ==	libsolidity/ast/AST.h	/^	bool operator==(ASTNode const& _other) const { return this == &_other; }$/;"	f	class:dev::solidity::ASTNode	access:public	signature:(ASTNode const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool AddressType::operator==(Type const& _other) const$/;"	f	class:AddressType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool ArrayType::operator==(Type const& _other) const$/;"	f	class:ArrayType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool ContractType::operator==(Type const& _other) const$/;"	f	class:ContractType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool EnumType::operator==(Type const& _other) const$/;"	f	class:EnumType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool FixedBytesType::operator==(Type const& _other) const$/;"	f	class:FixedBytesType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool FixedPointType::operator==(Type const& _other) const$/;"	f	class:FixedPointType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool FunctionType::operator==(Type const& _other) const$/;"	f	class:FunctionType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool IntegerType::operator==(Type const& _other) const$/;"	f	class:IntegerType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool MagicType::operator==(Type const& _other) const$/;"	f	class:MagicType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool MappingType::operator==(Type const& _other) const$/;"	f	class:MappingType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool ModifierType::operator==(Type const& _other) const$/;"	f	class:ModifierType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool ModuleType::operator==(Type const& _other) const$/;"	f	class:ModuleType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool RationalNumberType::operator==(Type const& _other) const$/;"	f	class:RationalNumberType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool StringLiteralType::operator==(Type const& _other) const$/;"	f	class:StringLiteralType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool StructType::operator==(Type const& _other) const$/;"	f	class:StructType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool TupleType::operator==(Type const& _other) const$/;"	f	class:TupleType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.cpp	/^bool TypeType::operator==(Type const& _other) const$/;"	f	class:TypeType	signature:(Type const& _other) const
operator ==	libsolidity/ast/Types.h	/^	bool operator==(ReferenceType const& _other) const$/;"	f	class:dev::solidity::ReferenceType	access:public	signature:(ReferenceType const& _other) const
operator ==	libsolidity/ast/Types.h	/^	virtual bool operator==(Type const& _other) const { return category() == _other.category(); }$/;"	f	class:dev::solidity::Type	access:public	signature:(Type const& _other) const
operator ==	libsolidity/formal/SolverInterface.h	/^	friend Expression operator==(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator ==	libsolidity/formal/SolverInterface.h	/^	virtual bool operator==(Sort const& _other) const { return kind == _other.kind; }$/;"	f	struct:dev::solidity::smt::Sort	access:public	signature:(Sort const& _other) const
operator ==	libsolidity/interface/OptimiserSettings.h	/^	bool operator==(OptimiserSettings const& _other) const$/;"	f	struct:dev::solidity::OptimiserSettings	access:public	signature:(OptimiserSettings const& _other) const
operator ==	libyul/YulString.h	/^	bool operator==(YulString const& _other) const { return m_handle.id == _other.m_handle.id; }$/;"	f	class:yul::YulString	access:public	signature:(YulString const& _other) const
operator ==	libyul/optimiser/RedundantAssignEliminator.h	/^		inline bool operator==(State _other) const { return m_value == _other.m_value; }$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(State _other) const
operator >	libsolidity/formal/SolverInterface.h	/^	friend Expression operator>(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator >=	libsolidity/formal/SolverInterface.h	/^	friend Expression operator>=(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator Arith	libdevcore/FixedHash.h	/^	operator Arith() const { return fromBigEndian<Arith>(m_data); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
operator ResultType const&	libdevcore/Result.h	/^	operator ResultType const&() const { return m_value; }$/;"	f	class:dev::Result	access:public	signature:() const
operator []	libdevcore/FixedHash.h	/^	uint8_t operator[](unsigned _i) const { return m_data[_i]; }$/;"	f	class:dev::FixedHash	access:public	signature:(unsigned _i) const
operator []	libdevcore/FixedHash.h	/^	uint8_t& operator[](unsigned _i) { return m_data[_i]; }$/;"	f	class:dev::FixedHash	access:public	signature:(unsigned _i)
operator []	libdevcore/vector_ref.h	/^	_T const& operator[](size_t _i) const { assert(m_data); assert(_i < m_count); return m_data[_i]; }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _i) const
operator []	libdevcore/vector_ref.h	/^	_T& operator[](size_t _i) { assert(m_data); assert(_i < m_count); return m_data[_i]; }$/;"	f	class:dev::vector_ref	access:public	signature:(size_t _i)
operator bool	libdevcore/FixedHash.h	/^	explicit operator bool() const { return std::any_of(m_data.begin(), m_data.end(), [](uint8_t _b) { return _b != 0; }); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
operator bool	libdevcore/vector_ref.h	/^	explicit operator bool() const { return m_data && m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
operator bool	libevmasm/ControlFlowGraph.h	/^	explicit operator bool() const { return *this != invalid(); }$/;"	f	class:dev::eth::BlockId	access:public	signature:() const
operator vector_ref<_T const>	libdevcore/vector_ref.h	/^	operator vector_ref<_T const>() const { return vector_ref<_T const>(m_data, m_count); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
operator vector_ref<_T2>	libdevcore/vector_ref.h	/^	template <class _T2> explicit operator vector_ref<_T2>() const { assert(m_count * sizeof(_T) \/ sizeof(_T2) * sizeof(_T2) \/ sizeof(_T) == m_count); return vector_ref<_T2>(reinterpret_cast<_T2*>(m_data), m_count * sizeof(_T) \/ sizeof(_T2)); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
operator ||	libsolidity/formal/SolverInterface.h	/^	friend Expression operator||(Expression _a, Expression _b)$/;"	f	class:dev::solidity::smt::Expression	access:friend	signature:(Expression _a, Expression _b)
operator ~	libdevcore/FixedHash.h	/^	FixedHash operator~() const { FixedHash ret; for (unsigned i = 0; i < N; ++i) ret[i] = ~m_data[i]; return ret; }$/;"	f	class:dev::FixedHash	access:public	signature:() const
optimal_assertions	solse/SymExecEngine.cpp	/^std::vector<z3::expr> optimal_assertions;$/;"	v
optimal_count	solse/SymExecEngine.cpp	/^unsigned optimal_count = 0;$/;"	v
optimise	libevmasm/Assembly.cpp	/^Assembly& Assembly::optimise(OptimiserSettings const& _settings)$/;"	f	class:Assembly	signature:(OptimiserSettings const& _settings)
optimise	libevmasm/Assembly.cpp	/^Assembly& Assembly::optimise(bool _enable, EVMVersion _evmVersion, bool _isCreation, size_t _runs)$/;"	f	class:Assembly	signature:(bool _enable, EVMVersion _evmVersion, bool _isCreation, size_t _runs)
optimise	libevmasm/Assembly.h	/^	Assembly& optimise(OptimiserSettings const& _settings);$/;"	p	class:dev::eth::Assembly	access:public	signature:(OptimiserSettings const& _settings)
optimise	libevmasm/Assembly.h	/^	Assembly& optimise(bool _enable, langutil::EVMVersion _evmVersion, bool _isCreation, size_t _runs);$/;"	p	class:dev::eth::Assembly	access:public	signature:(bool _enable, langutil::EVMVersion _evmVersion, bool _isCreation, size_t _runs)
optimise	libevmasm/JumpdestRemover.cpp	/^bool JumpdestRemover::optimise(set<size_t> const& _tagsReferencedFromOutside)$/;"	f	class:JumpdestRemover	signature:(set<size_t> const& _tagsReferencedFromOutside)
optimise	libevmasm/JumpdestRemover.h	/^	bool optimise(std::set<size_t> const& _tagsReferencedFromOutside);$/;"	p	class:dev::eth::JumpdestRemover	access:public	signature:(std::set<size_t> const& _tagsReferencedFromOutside)
optimise	libevmasm/PeepholeOptimiser.cpp	/^bool PeepholeOptimiser::optimise()$/;"	f	class:PeepholeOptimiser	signature:()
optimise	libevmasm/PeepholeOptimiser.h	/^	bool optimise();$/;"	p	class:dev::eth::PeepholeOptimiser	access:public	signature:()
optimise	libsolidity/codegen/CompilerContext.h	/^	void optimise(OptimiserSettings const& _settings) { m_asm->optimise(translateOptimiserSettings(_settings)); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(OptimiserSettings const& _settings)
optimiseConstants	libevmasm/ConstantOptimiser.cpp	/^unsigned ConstantOptimisationMethod::optimiseConstants($/;"	f	class:ConstantOptimisationMethod	signature:( bool _isCreation, size_t _runs, langutil::EVMVersion _evmVersion, Assembly& _assembly )
optimiseConstants	libevmasm/ConstantOptimiser.h	/^	static unsigned optimiseConstants($/;"	p	class:dev::eth::ConstantOptimisationMethod	access:public	signature:( bool _isCreation, size_t _runs, langutil::EVMVersion _evmVersion, Assembly& _assembly )
optimiseInternal	libevmasm/Assembly.cpp	/^map<u256, u256> Assembly::optimiseInternal($/;"	f	class:Assembly	signature:( OptimiserSettings const& _settings, std::set<size_t> _tagsReferencedFromOutside )
optimiseInternal	libevmasm/Assembly.h	/^	std::map<u256, u256> optimiseInternal(OptimiserSettings const& _settings, std::set<size_t> _tagsReferencedFromOutside);$/;"	p	class:dev::eth::Assembly	access:protected	signature:(OptimiserSettings const& _settings, std::set<size_t> _tagsReferencedFromOutside)
optimisedBlocks	libevmasm/ControlFlowGraph.cpp	/^BasicBlocks ControlFlowGraph::optimisedBlocks()$/;"	f	class:ControlFlowGraph	signature:()
optimisedBlocks	libevmasm/ControlFlowGraph.h	/^	BasicBlocks optimisedBlocks();$/;"	p	class:dev::eth::ControlFlowGraph	access:public	signature:()
optimize	libyul/AssemblyStack.cpp	/^void AssemblyStack::optimize()$/;"	f	class:AssemblyStack	signature:()
optimize	libyul/AssemblyStack.cpp	/^void AssemblyStack::optimize(Object& _object)$/;"	f	class:AssemblyStack	signature:(Object& _object)
optimize	libyul/AssemblyStack.h	/^	void optimize();$/;"	p	class:yul::AssemblyStack	access:public	signature:()
optimize	libyul/AssemblyStack.h	/^	void optimize(yul::Object& _object);$/;"	p	class:yul::AssemblyStack	access:private	signature:(yul::Object& _object)
optimizeBreakingItem	libevmasm/CommonSubexpressionEliminator.cpp	/^void CommonSubexpressionEliminator::optimizeBreakingItem()$/;"	f	class:CommonSubexpressionEliminator	signature:()
optimizeBreakingItem	libevmasm/CommonSubexpressionEliminator.h	/^	void optimizeBreakingItem();$/;"	p	class:dev::eth::CommonSubexpressionEliminator	access:private	signature:()
out	libevmasm/PeepholeOptimiser.cpp	/^	std::back_insert_iterator<AssemblyItems> out;$/;"	m	struct:__anon19::OptimiserState	file:	access:public
outlineExpression	libyul/optimiser/ExpressionSplitter.cpp	/^void ExpressionSplitter::outlineExpression(Expression& _expr)$/;"	f	class:ExpressionSplitter	signature:(Expression& _expr)
outlineExpression	libyul/optimiser/ExpressionSplitter.h	/^	void outlineExpression(Expression& _expr);$/;"	p	class:yul::ExpressionSplitter	access:private	signature:(Expression& _expr)
outputCompilationResults	solse/CommandLineInterface.cpp	/^void CommandLineInterface::outputCompilationResults()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
outputCompilationResults	solse/CommandLineInterface.h	/^	void outputCompilationResults();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
overloadedDeclarations	libsolidity/ast/ASTAnnotations.h	/^	std::vector<Declaration const*> overloadedDeclarations;$/;"	m	struct:dev::solidity::IdentifierAnnotation	access:public
override	libdevcore/Exceptions.h	/^	char const* what() const noexcept override;$/;"	m	struct:dev::Exception	access:public
override	libevmasm/ConstantOptimiser.h	/^	AssemblyItems execute(Assembly& _assembly) const override;$/;"	m	class:dev::eth::CodeCopyMethod	access:public
override	libevmasm/ConstantOptimiser.h	/^	bigint gasNeeded() const override;$/;"	m	class:dev::eth::CodeCopyMethod	access:public
override	libevmasm/ConstantOptimiser.h	/^	bigint gasNeeded() const override;$/;"	m	class:dev::eth::LiteralMethod	access:public
override	liblangutil/SourceReferenceFormatterHuman.h	/^	void printExceptionInformation(SourceReferenceExtractor::Message const& _msg) override;$/;"	m	class:langutil::SourceReferenceFormatterHuman	access:public
override	liblangutil/SourceReferenceFormatterHuman.h	/^	void printSourceLocation(SourceReference const& _ref) override;$/;"	m	class:langutil::SourceReferenceFormatterHuman	access:public
override	libsolidity/analysis/ControlFlowAnalyzer.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::ControlFlowAnalyzer	access:public
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(BinaryOperation const& _operation) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Break const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Conditional const& _conditional) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Continue const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(FunctionDefinition const& _functionDefinition) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(FunctionTypeName const& _functionTypeName) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(ModifierInvocation const& _modifierInvocation) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(PlaceholderStatement const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(Throw const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(VariableDeclaration const& _variableDeclaration) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:private
override	libsolidity/analysis/ControlFlowBuilder.h	/^	bool visitNode(ASTNode const&) override;$/;"	m	class:dev::solidity::ControlFlowBuilder	access:protected
override	libsolidity/analysis/ControlFlowGraph.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::CFG	access:public
override	libsolidity/analysis/ControlFlowPrinter.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::ControlFlowPrinter	access:public
override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(EventDefinition const& _event) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
override	libsolidity/analysis/DocStringAnalyser.h	/^	bool visit(ModifierDefinition const& _modifier) override;$/;"	m	class:dev::solidity::DocStringAnalyser	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(Block& _block) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ContractDefinition& _contract) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(EnumDefinition& _enum) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(EnumValue& _value) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(EventDefinition& _event) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ForStatement& _forLoop) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(FunctionDefinition& _function) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(FunctionTypeName& _funTypeName) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ImportDirective& _import) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(ModifierDefinition& _modifier) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(SourceUnit& _sourceUnit) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(StructDefinition& _struct) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	bool visit(VariableDeclaration& _declaration) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(Block& _block) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(ContractDefinition& _contract) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(EnumDefinition& _enum) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(EventDefinition& _event) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(ForStatement& _forLoop) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(FunctionDefinition& _function) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(FunctionTypeName& _funTypeName) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(ModifierDefinition& _modifier) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(SourceUnit& _sourceUnit) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(StructDefinition& _struct) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/NameAndTypeResolver.h	/^	void endVisit(VariableDeclarationStatement& _variableDeclarationStatement) override;$/;"	m	class:dev::solidity::DeclarationRegistrationHelper	access:private
override	libsolidity/analysis/PostTypeChecker.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
override	libsolidity/analysis/PostTypeChecker.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
override	libsolidity/analysis/PostTypeChecker.h	/^	bool visit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
override	libsolidity/analysis/PostTypeChecker.h	/^	void endVisit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
override	libsolidity/analysis/PostTypeChecker.h	/^	void endVisit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::PostTypeChecker	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(Block const& _block) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(ElementaryTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(ForStatement const& _for) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(FunctionDefinition const& _functionDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(ModifierDefinition const& _modifierDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(ArrayTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(Block const& _block) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(ForStatement const& _for) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(FunctionDefinition const& _functionDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(FunctionTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(Mapping const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(ModifierDefinition const& _modifierDefinition) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(UserDefinedTypeName const& _typeName) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/ReferencesResolver.h	/^	void endVisit(VariableDeclarationStatement const& _varDeclStatement) override;$/;"	m	class:dev::solidity::ReferencesResolver	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(BinaryOperation const& _operation) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(ExpressionStatement const& _statement) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	bool visit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	void endVisit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/StaticAnalyzer.h	/^	void endVisit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::StaticAnalyzer	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Break const& _breakStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Continue const& _continueStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(FunctionTypeName const& _node) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Literal const& _literal) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(ModifierDefinition const& _modifier) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(PlaceholderStatement const& _placeholderStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(PragmaDirective const& _pragma) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(SourceUnit const& _sourceUnit) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(StructDefinition const& _struct) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(Throw const& _throwStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(UnaryOperation const& _operation) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(VariableDeclarationStatement const& _statement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(ModifierDefinition const& _modifier) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(SourceUnit const& _sourceUnit) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/SyntaxChecker.h	/^	void endVisit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::SyntaxChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(Assignment const& _assignment) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(Conditional const& _conditional) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(ContractDefinition const& _contract) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(EventDefinition const& _eventDef) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(IndexAccess const& _indexAccess) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(StructDefinition const& _struct) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(TupleExpression const& _tuple) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(UnaryOperation const& _operation) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(VariableDeclaration const& _variable) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(VariableDeclarationStatement const& _variable) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(BinaryOperation const& _operation) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(ElementaryTypeNameExpression const& _expr) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(EmitStatement const& _emit) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(ExpressionStatement const& _statement) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(FunctionTypeName const& _funType) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(InheritanceSpecifier const& _inheritance) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(Literal const& _literal) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(NewExpression const& _newExpression) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(Return const& _return) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/TypeChecker.h	/^	void endVisit(UsingForDirective const& _usingFor) override;$/;"	m	class:dev::solidity::TypeChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	bool visit(FunctionDefinition const& _funDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	bool visit(ModifierDefinition const& _modifierDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(FunctionDefinition const& _funDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(IndexAccess const& _indexAccess) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(ModifierDefinition const& _modifierDef) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/analysis/ViewPureChecker.h	/^	void endVisit(ModifierInvocation const& _modifier) override;$/;"	m	class:dev::solidity::ViewPureChecker	access:private
override	libsolidity/ast/AST.h	/^	BinaryOperationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::BinaryOperation	access:public
override	libsolidity/ast/AST.h	/^	ContractDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
override	libsolidity/ast/AST.h	/^	EventDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
override	libsolidity/ast/AST.h	/^	ExpressionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Expression	access:public
override	libsolidity/ast/AST.h	/^	FunctionCallAnnotation& annotation() const override;$/;"	m	class:dev::solidity::FunctionCall	access:public
override	libsolidity/ast/AST.h	/^	FunctionDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
override	libsolidity/ast/AST.h	/^	FunctionTypePointer functionType(bool \/*_internal*\/) const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
override	libsolidity/ast/AST.h	/^	FunctionTypePointer functionType(bool \/*_internal*\/) const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
override	libsolidity/ast/AST.h	/^	FunctionTypePointer functionType(bool \/*_internal*\/) const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
override	libsolidity/ast/AST.h	/^	IdentifierAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Identifier	access:public
override	libsolidity/ast/AST.h	/^	ImportAnnotation& annotation() const override;$/;"	m	class:dev::solidity::ImportDirective	access:public
override	libsolidity/ast/AST.h	/^	InlineAssemblyAnnotation& annotation() const override;$/;"	m	class:dev::solidity::InlineAssembly	access:public
override	libsolidity/ast/AST.h	/^	MemberAccessAnnotation& annotation() const override;$/;"	m	class:dev::solidity::MemberAccess	access:public
override	libsolidity/ast/AST.h	/^	ModifierDefinitionAnnotation& annotation() const override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
override	libsolidity/ast/AST.h	/^	ReturnAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Return	access:public
override	libsolidity/ast/AST.h	/^	SourceUnitAnnotation& annotation() const override;$/;"	m	class:dev::solidity::SourceUnit	access:public
override	libsolidity/ast/AST.h	/^	StatementAnnotation& annotation() const override;$/;"	m	class:dev::solidity::Statement	access:public
override	libsolidity/ast/AST.h	/^	TypeDeclarationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypeDeclarationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::StructDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypeNameAnnotation& annotation() const override;$/;"	m	class:dev::solidity::TypeName	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::EnumValue	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::ImportDirective	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::StructDefinition	access:public
override	libsolidity/ast/AST.h	/^	TypePointer type() const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
override	libsolidity/ast/AST.h	/^	UserDefinedTypeNameAnnotation& annotation() const override;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:public
override	libsolidity/ast/AST.h	/^	VariableDeclarationAnnotation& annotation() const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
override	libsolidity/ast/AST.h	/^	bool isLValue() const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ArrayTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Assignment	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::BinaryOperation	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Block	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Break	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Conditional	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Continue	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ElementaryTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ElementaryTypeNameExpression	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EmitStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EnumValue	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::EventDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ExpressionStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ForStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::FunctionCall	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::FunctionTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Identifier	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::IfStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ImportDirective	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::IndexAccess	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::InlineAssembly	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Mapping	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::MemberAccess	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ModifierInvocation	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::NewExpression	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::ParameterList	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::PlaceholderStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::PragmaDirective	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Return	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::SourceUnit	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::StructDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::Throw	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::TupleExpression	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::UnaryOperation	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::UsingForDirective	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTConstVisitor& _visitor) const override;$/;"	m	class:dev::solidity::WhileStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ArrayTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Assignment	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::BinaryOperation	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Block	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Break	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Conditional	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Continue	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ContractDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ElementaryTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ElementaryTypeNameExpression	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EmitStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EnumDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EnumValue	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::EventDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ExpressionStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ForStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::FunctionCall	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::FunctionDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::FunctionTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Identifier	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::IfStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ImportDirective	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::IndexAccess	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::InheritanceSpecifier	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::InlineAssembly	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Literal::SubDenomination	access:private
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Mapping	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::MemberAccess	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ModifierDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ModifierInvocation	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::NewExpression	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::ParameterList	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::PlaceholderStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::PragmaDirective	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Return	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::SourceUnit	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::StructDefinition	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::Throw	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::TupleExpression	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::UnaryOperation	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::UserDefinedTypeName	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::UsingForDirective	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::VariableDeclaration	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::VariableDeclarationStatement	access:public
override	libsolidity/ast/AST.h	/^	void accept(ASTVisitor& _visitor) override;$/;"	m	class:dev::solidity::WhileStatement	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ArrayTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Assignment const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(BinaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Block const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Break const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Conditional const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Continue const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ElementaryTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ElementaryTypeNameExpression const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EmitStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EnumDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EnumValue const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(EventDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ExpressionStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ForStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(FunctionCall const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(FunctionTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Identifier const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(IfStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ImportDirective const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(IndexAccess const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(InheritanceSpecifier const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(InlineAssembly const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Literal const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Mapping const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(MemberAccess const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ModifierDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ModifierInvocation const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(NewExpression const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(ParameterList const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(PlaceholderStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(PragmaDirective const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Return const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(SourceUnit const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(StructDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(Throw const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(TupleExpression const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(UnaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(UserDefinedTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(UsingForDirective const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(VariableDeclaration const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(VariableDeclarationStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	bool visit(WhileStatement const& _node) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTJsonConverter.h	/^	void endVisit(EventDefinition const&) override;$/;"	m	class:dev::solidity::ASTJsonConverter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ArrayTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Assignment const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(BinaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Block const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Break const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Conditional const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Continue const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ElementaryTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ElementaryTypeNameExpression const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EmitStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EnumDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EnumValue const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(EventDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ExpressionStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ForStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(FunctionCall const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(FunctionTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Identifier const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(IfStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ImportDirective const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(IndexAccess const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(InheritanceSpecifier const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(InlineAssembly const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Literal const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Mapping const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(MemberAccess const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ModifierDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ModifierInvocation const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(NewExpression const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(ParameterList const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(PlaceholderStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(PragmaDirective const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Return const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(StructDefinition const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(Throw const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(TupleExpression const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(UnaryOperation const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(UserDefinedTypeName const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(UsingForDirective const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(VariableDeclaration const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(VariableDeclarationStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	bool visit(WhileStatement const& _node) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ArrayTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Assignment const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(BinaryOperation const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Block const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Break const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Conditional const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Continue const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ContractDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ElementaryTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ElementaryTypeNameExpression const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EmitStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EnumDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EnumValue const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(EventDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ExpressionStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ForStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(FunctionCall const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(FunctionDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(FunctionTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Identifier const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(IfStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ImportDirective const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(IndexAccess const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(InheritanceSpecifier const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(InlineAssembly const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Literal const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Mapping const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(MemberAccess const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ModifierDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ModifierInvocation const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(NewExpression const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(ParameterList const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(PlaceholderStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(PragmaDirective const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Return const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(StructDefinition const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(Throw const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(TupleExpression const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(UnaryOperation const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(UserDefinedTypeName const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(UsingForDirective const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(VariableDeclaration const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(VariableDeclarationStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/ASTPrinter.h	/^	void endVisit(WhileStatement const&) override;$/;"	m	class:dev::solidity::ASTPrinter	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isExplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _convertTo) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _other) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	BoolResult isImplicitlyConvertibleTo(Type const& _other) const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const* _currentScope) const override;$/;"	m	class:dev::solidity::TypeType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::MagicType	access:public
override	libsolidity/ast/Types.h	/^	MemberList::MemberMap nativeMembers(ContractDefinition const*) const override;$/;"	m	class:dev::solidity::ModuleType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer closestTemporaryType(TypePointer const& _targetType) const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer copyForLocation(DataLocation _location, bool _isPointer) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer copyForLocation(DataLocation _location, bool _isPointer) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer decodingType() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer encodingType() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer encodingType() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer interfaceType(bool _inLibrary) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer interfaceType(bool _inLibrary) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer interfaceType(bool _inLibrary) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer mobileType() const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer mobileType() const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
override	libsolidity/ast/Types.h	/^	TypePointer mobileType() const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::BoolType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token _operator, TypePointer const& _other) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult binaryOperatorResult(Token, TypePointer const&) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::BoolType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	TypeResult unaryOperatorResult(Token _operator) const override;$/;"	m	class:dev::solidity::ReferenceType	access:public
override	libsolidity/ast/Types.h	/^	bool canBeUsedExternally(bool _inLibrary) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	bool canBeUsedExternally(bool _inLibrary) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	bool isDynamicallyEncoded() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	bool isDynamicallyEncoded() const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::MagicType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::MappingType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ModifierType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::ModuleType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	bool operator==(Type const& _other) const override;$/;"	m	class:dev::solidity::TypeType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::MappingType	access:public
override	libsolidity/ast/Types.h	/^	std::string canonicalName() const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::FixedBytesType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::MagicType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::MappingType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ModifierType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::ModuleType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	std::string richIdentifier() const override;$/;"	m	class:dev::solidity::TypeType	access:public
override	libsolidity/ast/Types.h	/^	std::string signatureInExternalFunction(bool _structsByName) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	std::string signatureInExternalFunction(bool _structsByName) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ContractType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::FixedPointType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::IntegerType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::MagicType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::MappingType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ModifierType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::ModuleType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool _short) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool) const override;$/;"	m	class:dev::solidity::StringLiteralType	access:public
override	libsolidity/ast/Types.h	/^	std::string toString(bool) const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	u256 literalValue(Literal const* _literal) const override;$/;"	m	class:dev::solidity::AddressType	access:public
override	libsolidity/ast/Types.h	/^	u256 literalValue(Literal const* _literal) const override;$/;"	m	class:dev::solidity::BoolType	access:public
override	libsolidity/ast/Types.h	/^	u256 literalValue(Literal const* _literal) const override;$/;"	m	class:dev::solidity::RationalNumberType	access:public
override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::ModifierType	access:public
override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	u256 storageSize() const override;$/;"	m	class:dev::solidity::TypeType	access:public
override	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize(bool _padded) const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize(bool _padded) const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	unsigned calldataEncodedSize(bool _padded) const override;$/;"	m	class:dev::solidity::StructType	access:public
override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::ArrayType	access:public
override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::TupleType	access:public
override	libsolidity/ast/Types.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::TypeType	access:public
override	libsolidity/ast/Types.h	/^	unsigned storageBytes() const override;$/;"	m	class:dev::solidity::EnumType	access:public
override	libsolidity/ast/Types.h	/^	unsigned storageBytes() const override;$/;"	m	class:dev::solidity::FunctionType	access:public
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Block const& _block) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Break const& _breakStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Continue const& _continueStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(EmitStatement const& _emit) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(ExpressionStatement const& _expressionStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(ForStatement const& _forStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(FunctionDefinition const& _function) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(IfStatement const& _ifStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(InlineAssembly const& _inlineAssembly) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(PlaceholderStatement const&) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Return const& _return) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(Throw const& _throw) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(VariableDeclaration const& _variableDeclaration) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	bool visit(WhileStatement const& _whileStatement) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ContractCompiler.h	/^	void endVisit(Block const& _block) override;$/;"	m	class:dev::solidity::ContractCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(Assignment const& _assignment) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(BinaryOperation const& _binaryOperation) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(Conditional const& _condition) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(FunctionCall const& _functionCall) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(IndexAccess const& _indexAccess) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(MemberAccess const& _memberAccess) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(NewExpression const& _newExpression) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(TupleExpression const& _tuple) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	bool visit(UnaryOperation const& _unaryOperation) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	void endVisit(Identifier const& _identifier) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/ExpressionCompiler.h	/^	void endVisit(Literal const& _literal) override;$/;"	m	class:dev::solidity::ExpressionCompiler	access:private
override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::MemoryItem	access:public
override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StackVariable	access:public
override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StorageArrayLength	access:public
override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StorageByteArrayElement	access:public
override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::StorageItem	access:public
override	libsolidity/codegen/LValue.h	/^	) const override;$/;"	m	class:dev::solidity::TupleObject	access:public
override	libsolidity/codegen/LValue.h	/^	unsigned sizeOnStack() const override;$/;"	m	class:dev::solidity::TupleObject	access:public
override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::MemoryItem	access:public
override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StackVariable	access:public
override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StorageArrayLength	access:public
override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StorageByteArrayElement	access:public
override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::StorageItem	access:public
override	libsolidity/codegen/LValue.h	/^	void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const override;$/;"	m	class:dev::solidity::TupleObject	access:public
override	libsolidity/formal/CVC4Interface.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
override	libsolidity/formal/CVC4Interface.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
override	libsolidity/formal/CVC4Interface.h	/^	void declareVariable(std::string const&, Sort const&) override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
override	libsolidity/formal/CVC4Interface.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
override	libsolidity/formal/CVC4Interface.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
override	libsolidity/formal/CVC4Interface.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::CVC4Interface	access:public
override	libsolidity/formal/SMTChecker.h	/^	bool visit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	bool visit(ForStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	bool visit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	bool visit(IfStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	bool visit(MemberAccess const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	bool visit(WhileStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Assignment const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(BinaryOperation const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(ContractDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(FunctionCall const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(FunctionDefinition const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Identifier const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(IndexAccess const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Literal const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(Return const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(TupleExpression const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(UnaryOperation const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(VariableDeclaration const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTChecker.h	/^	void endVisit(VariableDeclarationStatement const& _node) override;$/;"	m	class:dev::solidity::SMTChecker	access:private
override	libsolidity/formal/SMTLib2Interface.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
override	libsolidity/formal/SMTLib2Interface.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
override	libsolidity/formal/SMTLib2Interface.h	/^	void declareVariable(std::string const&, Sort const&) override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
override	libsolidity/formal/SMTLib2Interface.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
override	libsolidity/formal/SMTLib2Interface.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
override	libsolidity/formal/SMTLib2Interface.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::SMTLib2Interface	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	std::vector<std::string> unhandledQueries() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	void declareVariable(std::string const&, Sort const&) override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/SMTPortfolio.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::SMTPortfolio	access:public
override	libsolidity/formal/Z3Interface.h	/^	std::pair<CheckResult, std::vector<std::string>> check(std::vector<Expression> const& _expressionsToEvaluate) override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
override	libsolidity/formal/Z3Interface.h	/^	void addAssertion(Expression const& _expr) override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
override	libsolidity/formal/Z3Interface.h	/^	void declareVariable(std::string const& _name, Sort const& _sort) override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
override	libsolidity/formal/Z3Interface.h	/^	void pop() override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
override	libsolidity/formal/Z3Interface.h	/^	void push() override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
override	libsolidity/formal/Z3Interface.h	/^	void reset() override;$/;"	m	class:dev::solidity::smt::Z3Interface	access:public
override	libyul/Object.h	/^	std::string toString(bool _yul) const override;$/;"	m	struct:yul::Data	access:public
override	libyul/Object.h	/^	std::string toString(bool _yul) const override;$/;"	m	struct:yul::Object	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	SubID appendData(dev::bytes const& _data) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	int stackHeight() const override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	size_t namedLabel(std::string const& _name) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	size_t newLabelId() override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendAssemblySize() override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendBeginsub(LabelID, int) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendConstant(dev::u256 const& _constant) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendDataOffset(SubID _sub) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendDataSize(SubID _sub) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendInstruction(dev::solidity::Instruction _instruction) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJump(int _stackDiffAfter) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJumpTo(LabelID _labelId, int _stackDiffAfter) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJumpToIf(LabelID _labelId) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJumpsub(LabelID, int, int) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendLabel(LabelID _labelId) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendLabelReference(LabelID _labelId) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendLinkerSymbol(std::string const& _linkerSymbol) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void appendReturnsub(int, int) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/AsmCodeGen.h	/^	void setSourceLocation(langutil::SourceLocation const& _location) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	LabelID namedLabel(std::string const& _name) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	LabelID newLabelId() override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	SubID appendData(dev::bytes const& _data) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendAssemblySize() override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendBeginsub(LabelID _labelId, int _arguments) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendConstant(dev::u256 const& _constant) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendDataOffset(SubID _sub) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendDataSize(SubID _sub) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendInstruction(dev::solidity::Instruction _instruction) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendJump(int _stackDiffAfter) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendJumpTo(LabelID _labelId, int _stackDiffAfter) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendJumpToIf(LabelID _labelId) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendJumpsub(LabelID _labelId, int _arguments, int _returns) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendLabel(LabelID _labelId) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendLabelReference(LabelID _labelId) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendLinkerSymbol(std::string const& _name) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void appendReturnsub(int _returns, int _stackDiffAfter) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMAssembly.h	/^	void setSourceLocation(langutil::SourceLocation const& _location) override;$/;"	m	class:yul::EVMAssembly	access:public
override	libyul/backends/evm/EVMDialect.h	/^	BuiltinFunctionForEVM const* builtin(YulString _name) const override;$/;"	m	struct:yul::EVMDialect	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	LabelID namedLabel(std::string const& _name) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	LabelID newLabelId() override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	SubID appendData(dev::bytes const& _data) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendAssemblySize() override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendBeginsub(LabelID _labelId, int _arguments) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendConstant(dev::u256 const& _constant) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendDataOffset(SubID _sub) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendDataSize(SubID _sub) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendInstruction(dev::solidity::Instruction _instruction) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJump(int _stackDiffAfter) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJumpTo(LabelID _labelId, int _stackDiffAfter) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJumpToIf(LabelID _labelId) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJumpsub(LabelID _labelId, int _arguments, int _returns) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendLabel(LabelID _labelId) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendLabelReference(LabelID _labelId) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendLinkerSymbol(std::string const& _name) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendReturnsub(int _returns, int _stackDiffAfter) override;$/;"	m	class:yul::NoOutputAssembly	access:public
override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(FunctionCall const&) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(FunctionalInstruction const& _instr) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(Identifier const& _identifier) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(Literal const& _literal) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Assignment const& _assignment) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Block const& _block) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(ExpressionStatement const& _statement) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(ForLoop const&) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(FunctionDefinition const&) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(If const& _if) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Instruction const& _instruction) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Label const& _label) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(StackAssignment const& _assignment) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Switch const& _switch) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::ASTCopier	access:public
override	libyul/optimiser/BlockFlattener.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::BlockFlattener	access:public
override	libyul/optimiser/CommonSubexpressionEliminator.h	/^	void visit(Expression& _e) override;$/;"	m	class:yul::CommonSubexpressionEliminator	access:protected
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(Assignment& _assignment) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(ForLoop&) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(FunctionDefinition&) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(If& _if) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(Switch& _switch) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(VariableDeclaration& _varDecl) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
override	libyul/optimiser/Disambiguator.h	/^	YulString translateIdentifier(YulString _name) override;$/;"	m	class:yul::Disambiguator	access:protected
override	libyul/optimiser/Disambiguator.h	/^	void enterFunction(FunctionDefinition const& _function) override;$/;"	m	class:yul::Disambiguator	access:protected
override	libyul/optimiser/Disambiguator.h	/^	void enterScope(Block const& _block) override;$/;"	m	class:yul::Disambiguator	access:protected
override	libyul/optimiser/Disambiguator.h	/^	void leaveFunction(FunctionDefinition const& _function) override;$/;"	m	class:yul::Disambiguator	access:protected
override	libyul/optimiser/Disambiguator.h	/^	void leaveScope(Block const& _block) override;$/;"	m	class:yul::Disambiguator	access:protected
override	libyul/optimiser/EquivalentFunctionCombiner.h	/^	void operator()(FunctionCall& _funCall) override;$/;"	m	class:yul::EquivalentFunctionCombiner	access:public
override	libyul/optimiser/EquivalentFunctionDetector.h	/^	void operator()(FunctionDefinition const& _fun) override;$/;"	m	class:yul::EquivalentFunctionDetector	access:public
override	libyul/optimiser/ExpressionInliner.h	/^	void operator()(FunctionDefinition& _fun) override;$/;"	m	class:yul::ExpressionInliner	access:public
override	libyul/optimiser/ExpressionInliner.h	/^	void visit(Expression& _expression) override;$/;"	m	class:yul::ExpressionInliner	access:public
override	libyul/optimiser/ExpressionJoiner.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::ExpressionJoiner	access:private
override	libyul/optimiser/ExpressionJoiner.h	/^	void operator()(FunctionCall&) override;$/;"	m	class:yul::ExpressionJoiner	access:private
override	libyul/optimiser/ExpressionJoiner.h	/^	void operator()(FunctionalInstruction&) override;$/;"	m	class:yul::ExpressionJoiner	access:private
override	libyul/optimiser/ExpressionJoiner.h	/^	void visit(Expression& _e) override;$/;"	m	class:yul::ExpressionJoiner	access:private
override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::ExpressionSplitter	access:public
override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(ForLoop&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(FunctionCall&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(FunctionalInstruction&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(If&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(Switch&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
override	libyul/optimiser/ForLoopInitRewriter.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::ForLoopInitRewriter	access:public
override	libyul/optimiser/FullInliner.h	/^	Statement operator()(FunctionDefinition const& _funDef) override;$/;"	m	class:yul::BodyCopier	access:public
override	libyul/optimiser/FullInliner.h	/^	Statement operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::BodyCopier	access:public
override	libyul/optimiser/FullInliner.h	/^	YulString translateIdentifier(YulString _name) override;$/;"	m	class:yul::BodyCopier	access:public
override	libyul/optimiser/FullInliner.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::InlineModifier	access:public
override	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void operator()(FunctionCall const& _funCall) override;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:public
override	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void operator()(FunctionDefinition const& _function) override;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:public
override	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void operator()(Identifier const& _identifier) override;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:public
override	libyul/optimiser/Metrics.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::AssignmentCounter	access:public
override	libyul/optimiser/Metrics.h	/^	void operator()(FunctionCall const& _funCall) override;$/;"	m	class:yul::CodeCost	access:private
override	libyul/optimiser/Metrics.h	/^	void operator()(FunctionalInstruction const& _instr) override;$/;"	m	class:yul::CodeCost	access:private
override	libyul/optimiser/Metrics.h	/^	void operator()(Literal const& _literal) override;$/;"	m	class:yul::CodeCost	access:private
override	libyul/optimiser/Metrics.h	/^	void visit(Expression const& _expression) override;$/;"	m	class:yul::CodeCost	access:private
override	libyul/optimiser/Metrics.h	/^	void visit(Expression const& _expression) override;$/;"	m	class:yul::CodeSize	access:private
override	libyul/optimiser/Metrics.h	/^	void visit(Statement const& _statement) override;$/;"	m	class:yul::CodeCost	access:private
override	libyul/optimiser/Metrics.h	/^	void visit(Statement const& _statement) override;$/;"	m	class:yul::CodeSize	access:private
override	libyul/optimiser/NameCollector.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::Assignments	access:public
override	libyul/optimiser/NameCollector.h	/^	void operator()(FunctionDefinition const& _funDef) override;$/;"	m	class:yul::NameCollector	access:public
override	libyul/optimiser/NameCollector.h	/^	void operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::NameCollector	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Block const& _block) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::AssignmentRemover	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(ForLoop const&) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(FunctionDefinition const&) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Identifier const& _identifier) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(If const& _if) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Switch const& _switch) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(VariableDeclaration const& _variableDeclaration) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
override	libyul/optimiser/Rematerialiser.h	/^	void visit(Expression& _e) override;$/;"	m	class:yul::Rematerialiser	access:protected
override	libyul/optimiser/SSAReverser.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::SSAReverser	access:public
override	libyul/optimiser/SSATransform.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::SSATransform	access:public
override	libyul/optimiser/SSATransform.h	/^	void operator()(ForLoop&) override;$/;"	m	class:yul::SSATransform	access:public
override	libyul/optimiser/SSATransform.h	/^	void operator()(Identifier&) override;$/;"	m	class:yul::SSATransform	access:public
override	libyul/optimiser/SSAValueTracker.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::SSAValueTracker	access:public
override	libyul/optimiser/SSAValueTracker.h	/^	void operator()(FunctionDefinition const& _funDef) override;$/;"	m	class:yul::SSAValueTracker	access:public
override	libyul/optimiser/SSAValueTracker.h	/^	void operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::SSAValueTracker	access:public
override	libyul/optimiser/Semantics.h	/^	void operator()(FunctionCall const& _functionCall) override;$/;"	m	class:yul::MovableChecker	access:public
override	libyul/optimiser/Semantics.h	/^	void operator()(FunctionalInstruction const& _functionalInstruction) override;$/;"	m	class:yul::MovableChecker	access:public
override	libyul/optimiser/Semantics.h	/^	void operator()(Identifier const& _identifier) override;$/;"	m	class:yul::MovableChecker	access:public
override	libyul/optimiser/Semantics.h	/^	void visit(Statement const&) override;$/;"	m	class:yul::MovableChecker	access:public
override	libyul/optimiser/StructuralSimplifier.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::StructuralSimplifier	access:public
override	libyul/optimiser/Substitution.h	/^	Expression translate(Expression const& _expression) override;$/;"	m	class:yul::Substitution	access:public
override	libyul/optimiser/UnusedPruner.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::UnusedPruner	access:public
override	libyul/optimiser/VarDeclInitializer.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::VarDeclInitializer	access:public
override	libyul/optimiser/VarNameCleaner.h	/^	void operator()(FunctionDefinition& _funDef) override;$/;"	m	class:yul::VarNameCleaner	access:public
override	libyul/optimiser/VarNameCleaner.h	/^	void operator()(Identifier& _identifier) override;$/;"	m	class:yul::VarNameCleaner	access:public
override	libyul/optimiser/VarNameCleaner.h	/^	void operator()(VariableDeclaration& _varDecl) override;$/;"	m	class:yul::VarNameCleaner	access:public
override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::BinaryOperation const& _node) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::ContractDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::FunctionDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::Literal const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::StructDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    bool visit(dev::solidity::VariableDeclaration const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    void endVisit(dev::solidity::ContractDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    void endVisit(dev::solidity::FunctionDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
override	solse/SymExecEngine.h	/^    void endVisit(dev::solidity::StructDefinition const&) override;$/;"	m	class:SymExecEngine	access:public
overrideError	libsolidity/analysis/ContractLevelChecker.cpp	/^void ContractLevelChecker::overrideError(FunctionDefinition const& function, FunctionDefinition const& super, string message)$/;"	f	class:ContractLevelChecker	signature:(FunctionDefinition const& function, FunctionDefinition const& super, string message)
overrideError	libsolidity/analysis/ContractLevelChecker.h	/^	void overrideError(FunctionDefinition const& function, FunctionDefinition const& super, std::string message);$/;"	p	class:dev::solidity::ContractLevelChecker	access:private	signature:(FunctionDefinition const& function, FunctionDefinition const& super, std::string message)
p_z3_ctx	solse/mechanism.cpp	/^z3::context* Mechanism::p_z3_ctx=new z3::context();$/;"	m	class:Mechanism	file:
p_z3_ctx	solse/mechanism.h	/^		static z3::context* p_z3_ctx;$/;"	m	class:Mechanism	access:public
packIntoContractCreator	libsolidity/codegen/ContractCompiler.cpp	/^size_t ContractCompiler::packIntoContractCreator(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
packIntoContractCreator	libsolidity/codegen/ContractCompiler.h	/^	size_t packIntoContractCreator(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
packedEncode	libsolidity/codegen/CompilerUtils.h	/^	void packedEncode($/;"	f	class:dev::solidity::CompilerUtils	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false )
padArguments	libsolidity/ast/Types.cpp	/^bool FunctionType::padArguments() const$/;"	f	class:FunctionType	signature:() const
padArguments	libsolidity/ast/Types.h	/^	bool padArguments() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
padded	libsolidity/codegen/ABIFunctions.h	/^		bool padded = true;$/;"	m	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public
paramName	libsolidity/ast/ASTAnnotations.h	/^	std::string paramName;	\/\/\/< Only used for @param, stores the parameter name.$/;"	m	struct:dev::solidity::DocTag	access:public
parameterList	libsolidity/ast/AST.h	/^	ParameterList const& parameterList() const { return *m_parameters; }$/;"	f	class:dev::solidity::CallableDeclaration	access:public	signature:() const
parameterNames	libsolidity/ast/Types.cpp	/^vector<string> FunctionType::parameterNames() const$/;"	f	class:FunctionType	signature:() const
parameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> parameterNames() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
parameterTypeList	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> const& parameterTypeList() const { return m_parameterTypes; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
parameterTypes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& parameterTypes() const { return m_parameterTypes->parameters(); }$/;"	f	class:dev::solidity::FunctionTypeName::std	access:public	signature:() const
parameterTypes	libsolidity/ast/Types.cpp	/^TypePointers FunctionType::parameterTypes() const$/;"	f	class:FunctionType	signature:() const
parameterTypes	libsolidity/ast/Types.h	/^	TypePointers parameterTypes() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
parameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& parameters() const { return m_parameters->parameters(); }$/;"	f	class:dev::solidity::CallableDeclaration::std	access:public	signature:() const
parameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& parameters() const { return m_parameters; }$/;"	f	class:dev::solidity::ParameterList::std	access:public	signature:() const
parameters	libsolidity/parsing/Parser.h	/^		ASTPointer<ParameterList> parameters;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
parameters	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
parameters	libyul/Dialect.h	/^	std::vector<Type> parameters;$/;"	m	struct:yul::BuiltinFunction	access:public
parenthesizeIdentifier	libsolidity/ast/Types.cpp	/^string parenthesizeIdentifier(string const& _internal)$/;"	f	namespace:__anon8	signature:(string const& _internal)
parenthesizeUserIdentifier	libsolidity/ast/Types.cpp	/^string parenthesizeUserIdentifier(string const& _internal)$/;"	f	namespace:__anon8	signature:(string const& _internal)
parse	libdevcore/JSON.cpp	/^bool parse(Json::CharReaderBuilder& _builder, string const& _input, Json::Value& _json, string* _errs)$/;"	f	namespace:dev::__anon25	signature:(Json::CharReaderBuilder& _builder, string const& _input, Json::Value& _json, string* _errs)
parse	libsolidity/analysis/SemVerHandler.cpp	/^SemVerMatchExpression SemVerMatchExpressionParser::parse()$/;"	f	class:SemVerMatchExpressionParser	signature:()
parse	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpression parse();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:public	signature:()
parse	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::parse()$/;"	f	class:CompilerStack	signature:()
parse	libsolidity/interface/CompilerStack.h	/^	bool parse();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
parse	libsolidity/parsing/DocStringParser.cpp	/^bool DocStringParser::parse(string const& _docString, ErrorReporter& _errorReporter)$/;"	f	class:DocStringParser	signature:(string const& _docString, ErrorReporter& _errorReporter)
parse	libsolidity/parsing/DocStringParser.h	/^	bool parse(std::string const& _docString, langutil::ErrorReporter& _errorReporter);$/;"	p	class:dev::solidity::DocStringParser	access:public	signature:(std::string const& _docString, langutil::ErrorReporter& _errorReporter)
parse	libsolidity/parsing/Parser.cpp	/^ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)$/;"	f	class:dev::solidity::Parser	signature:(shared_ptr<Scanner> const& _scanner)
parse	libsolidity/parsing/Parser.h	/^	ASTPointer<SourceUnit> parse(std::shared_ptr<langutil::Scanner> const& _scanner);$/;"	p	class:dev::solidity::Parser	access:public	signature:(std::shared_ptr<langutil::Scanner> const& _scanner)
parse	libyul/AsmParser.cpp	/^shared_ptr<Block> Parser::parse(std::shared_ptr<Scanner> const& _scanner, bool _reuseScanner)$/;"	f	class:Parser	signature:(std::shared_ptr<Scanner> const& _scanner, bool _reuseScanner)
parse	libyul/AsmParser.h	/^	std::shared_ptr<Block> parse(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner);$/;"	p	class:yul::Parser	access:public	signature:(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner)
parse	libyul/ObjectParser.cpp	/^shared_ptr<Object> ObjectParser::parse(shared_ptr<Scanner> const& _scanner, bool _reuseScanner)$/;"	f	class:ObjectParser	signature:(shared_ptr<Scanner> const& _scanner, bool _reuseScanner)
parse	libyul/ObjectParser.h	/^	std::shared_ptr<Object> parse(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner);$/;"	p	class:yul::ObjectParser	access:public	signature:(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner)
parseAndAnalyze	libsolidity/interface/CompilerStack.cpp	/^bool CompilerStack::parseAndAnalyze()$/;"	f	class:CompilerStack	signature:()
parseAndAnalyze	libsolidity/interface/CompilerStack.h	/^	bool parseAndAnalyze();$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:()
parseAndAnalyze	libyul/AssemblyStack.cpp	/^bool AssemblyStack::parseAndAnalyze(std::string const& _sourceName, std::string const& _source)$/;"	f	class:AssemblyStack	signature:(std::string const& _sourceName, std::string const& _source)
parseAndAnalyze	libyul/AssemblyStack.h	/^	bool parseAndAnalyze(std::string const& _sourceName, std::string const& _source);$/;"	p	class:yul::AssemblyStack	access:public	signature:(std::string const& _sourceName, std::string const& _source)
parseArguments	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::parseArguments(int _argc, char** _argv)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(int _argc, char** _argv)
parseArguments	solse/CommandLineInterface.h	/^	bool parseArguments(int _argc, char** _argv);$/;"	p	class:dev::solidity::DocumentationType	access:public	signature:(int _argc, char** _argv)
parseBinaryExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseBinaryExpression($/;"	f	class:dev::solidity::Parser	signature:( int _minPrecedence, ASTPointer<Expression> const& _partiallyParsedExpression )
parseBinaryExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseBinaryExpression(int _minPrecedence = 4,$/;"	p	class:dev::solidity::Parser	access:private	signature:(int _minPrecedence = 4, ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
parseBlock	libsolidity/parsing/Parser.cpp	/^ASTPointer<Block> Parser::parseBlock(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseBlock	libsolidity/parsing/Parser.h	/^	ASTPointer<Block> parseBlock(ASTPointer<ASTString> const& _docString = {});$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString = {})
parseBlock	libyul/AsmParser.cpp	/^Block Parser::parseBlock()$/;"	f	class:Parser	signature:()
parseBlock	libyul/AsmParser.h	/^	Block parseBlock();$/;"	p	class:yul::Parser	access:protected	signature:()
parseBlock	libyul/ObjectParser.cpp	/^shared_ptr<Block> ObjectParser::parseBlock()$/;"	f	class:ObjectParser	signature:()
parseBlock	libyul/ObjectParser.h	/^	std::shared_ptr<Block> parseBlock();$/;"	p	class:yul::ObjectParser	access:private	signature:()
parseCall	libyul/AsmParser.cpp	/^Expression Parser::parseCall(Parser::ElementaryOperation&& _initialOp)$/;"	f	class:Parser	signature:(Parser::ElementaryOperation&& _initialOp)
parseCall	libyul/AsmParser.h	/^	Expression parseCall(ElementaryOperation&& _initialOp);$/;"	p	class:yul::Parser	access:protected	signature:(ElementaryOperation&& _initialOp)
parseCase	libyul/AsmParser.cpp	/^Case Parser::parseCase()$/;"	f	class:Parser	signature:()
parseCase	libyul/AsmParser.h	/^	Case parseCase();$/;"	p	class:yul::Parser	access:protected	signature:()
parseCode	libyul/ObjectParser.cpp	/^shared_ptr<Block> ObjectParser::parseCode()$/;"	f	class:ObjectParser	signature:()
parseCode	libyul/ObjectParser.h	/^	std::shared_ptr<Block> parseCode();$/;"	p	class:yul::ObjectParser	access:private	signature:()
parseContractDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<ContractDefinition> Parser::parseContractDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
parseContractDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<ContractDefinition> parseContractDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseContractKind	libsolidity/parsing/Parser.cpp	/^ContractDefinition::ContractKind Parser::parseContractKind()$/;"	f	class:dev::solidity::Parser	signature:()
parseContractKind	libsolidity/parsing/Parser.h	/^	ContractDefinition::ContractKind parseContractKind();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseData	libyul/ObjectParser.cpp	/^void ObjectParser::parseData(Object& _containingObject)$/;"	f	class:ObjectParser	signature:(Object& _containingObject)
parseData	libyul/ObjectParser.h	/^	void parseData(Object& _containingObject);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object& _containingObject)
parseDoWhileStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<WhileStatement> Parser::parseDoWhileStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseDoWhileStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<WhileStatement> parseDoWhileStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
parseDocString	libsolidity/parsing/DocStringParser.h	/^	void parseDocString(std::string const& _string);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(std::string const& _string)
parseDocStrings	libsolidity/analysis/DocStringAnalyser.cpp	/^void DocStringAnalyser::parseDocStrings($/;"	f	class:DocStringAnalyser	signature:( Documented const& _node, DocumentedAnnotation& _annotation, set<string> const& _validTags, string const& _nodeName )
parseDocStrings	libsolidity/analysis/DocStringAnalyser.h	/^	void parseDocStrings($/;"	p	class:dev::solidity::DocStringAnalyser	access:private	signature:( Documented const& _node, DocumentedAnnotation& _annotation, std::set<std::string> const& _validTags, std::string const& _nodeName )
parseDocTag	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::parseDocTag(iter _pos, iter _end, string const& _tag)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end, string const& _tag)
parseDocTag	libsolidity/parsing/DocStringParser.h	/^	iter parseDocTag(iter _pos, iter _end, std::string const& _tag);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end, std::string const& _tag)
parseDocTagLine	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::parseDocTagLine(iter _pos, iter _end, bool _appending)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end, bool _appending)
parseDocTagLine	libsolidity/parsing/DocStringParser.h	/^	iter parseDocTagLine(iter _pos, iter _end, bool _appending);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end, bool _appending)
parseDocTagParam	libsolidity/parsing/DocStringParser.cpp	/^DocStringParser::iter DocStringParser::parseDocTagParam(iter _pos, iter _end)$/;"	f	class:DocStringParser	signature:(iter _pos, iter _end)
parseDocTagParam	libsolidity/parsing/DocStringParser.h	/^	iter parseDocTagParam(iter _pos, iter _end);$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:(iter _pos, iter _end)
parseElementaryOperation	libyul/AsmParser.cpp	/^Parser::ElementaryOperation Parser::parseElementaryOperation()$/;"	f	class:Parser	signature:()
parseElementaryOperation	libyul/AsmParser.h	/^	ElementaryOperation parseElementaryOperation();$/;"	p	class:yul::Parser	access:protected	signature:()
parseElementaryTypeVector	libsolidity/ast/Types.cpp	/^TypePointers FunctionType::parseElementaryTypeVector(strings const& _types)$/;"	f	class:FunctionType	signature:(strings const& _types)
parseElementaryTypeVector	libsolidity/ast/Types.h	/^	static TypePointers parseElementaryTypeVector(strings const& _types);$/;"	p	class:dev::solidity::FunctionType	access:private	signature:(strings const& _types)
parseEmitStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<EmitStatement> Parser::parseEmitStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseEmitStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<EmitStatement> parseEmitStatement(ASTPointer<ASTString> const& docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& docString)
parseEnumDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<EnumDefinition> Parser::parseEnumDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
parseEnumDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<EnumDefinition> parseEnumDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseEnumValue	libsolidity/parsing/Parser.cpp	/^ASTPointer<EnumValue> Parser::parseEnumValue()$/;"	f	class:dev::solidity::Parser	signature:()
parseEnumValue	libsolidity/parsing/Parser.h	/^	ASTPointer<EnumValue> parseEnumValue();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseEventDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<EventDefinition> Parser::parseEventDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
parseEventDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<EventDefinition> parseEventDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseExpression($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<Expression> const& _partiallyParsedExpression )
parseExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseExpression($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
parseExpression	libyul/AsmParser.cpp	/^Expression Parser::parseExpression()$/;"	f	class:Parser	signature:()
parseExpression	libyul/AsmParser.h	/^	Expression parseExpression();$/;"	p	class:yul::Parser	access:protected	signature:()
parseExpressionStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<ExpressionStatement> Parser::parseExpressionStatement($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _partialParserResult )
parseExpressionStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<ExpressionStatement> parseExpressionStatement($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
parseForLoop	libyul/AsmParser.cpp	/^ForLoop Parser::parseForLoop()$/;"	f	class:Parser	signature:()
parseForLoop	libyul/AsmParser.h	/^	ForLoop parseForLoop();$/;"	p	class:yul::Parser	access:protected	signature:()
parseForStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<ForStatement> Parser::parseForStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseForStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<ForStatement> parseForStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
parseFunctionCallArguments	libsolidity/parsing/Parser.cpp	/^pair<vector<ASTPointer<Expression>>, vector<ASTPointer<ASTString>>> Parser::parseFunctionCallArguments()$/;"	f	class:dev::solidity::Parser	signature:()
parseFunctionCallArguments	libsolidity/parsing/Parser.h	/^	std::pair<std::vector<ASTPointer<Expression>>, std::vector<ASTPointer<ASTString>>> parseFunctionCallArguments();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseFunctionCallListArguments	libsolidity/parsing/Parser.cpp	/^vector<ASTPointer<Expression>> Parser::parseFunctionCallListArguments()$/;"	f	class:dev::solidity::Parser	signature:()
parseFunctionCallListArguments	libsolidity/parsing/Parser.h	/^	std::vector<ASTPointer<Expression>> parseFunctionCallListArguments();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseFunctionDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<FunctionDefinition> parseFunctionDefinition(ASTString const* _contractName);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTString const* _contractName)
parseFunctionDefinition	libyul/AsmParser.cpp	/^FunctionDefinition Parser::parseFunctionDefinition()$/;"	f	class:Parser	signature:()
parseFunctionDefinition	libyul/AsmParser.h	/^	FunctionDefinition parseFunctionDefinition();$/;"	p	class:yul::Parser	access:protected	signature:()
parseFunctionDefinitionOrFunctionTypeStateVariable	libsolidity/parsing/Parser.cpp	/^ASTPointer<ASTNode> Parser::parseFunctionDefinitionOrFunctionTypeStateVariable()$/;"	f	class:dev::solidity::Parser	signature:()
parseFunctionDefinitionOrFunctionTypeStateVariable	libsolidity/parsing/Parser.h	/^	ASTPointer<ASTNode> parseFunctionDefinitionOrFunctionTypeStateVariable();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseFunctionHeader	libsolidity/parsing/Parser.cpp	/^Parser::FunctionHeaderParserResult Parser::parseFunctionHeader(bool _forceEmptyName, bool _allowModifiers)$/;"	f	class:dev::solidity::Parser	signature:(bool _forceEmptyName, bool _allowModifiers)
parseFunctionHeader	libsolidity/parsing/Parser.h	/^	FunctionHeaderParserResult parseFunctionHeader(bool _forceEmptyName, bool _allowModifiers);$/;"	p	class:dev::solidity::Parser	access:private	signature:(bool _forceEmptyName, bool _allowModifiers)
parseFunctionType	libsolidity/parsing/Parser.cpp	/^ASTPointer<FunctionTypeName> Parser::parseFunctionType()$/;"	f	class:dev::solidity::Parser	signature:()
parseFunctionType	libsolidity/parsing/Parser.h	/^	ASTPointer<FunctionTypeName> parseFunctionType();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseIdentifier	libsolidity/parsing/Parser.cpp	/^ASTPointer<Identifier> Parser::parseIdentifier()$/;"	f	class:dev::solidity::Parser	signature:()
parseIdentifier	libsolidity/parsing/Parser.h	/^	ASTPointer<Identifier> parseIdentifier();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseIfStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<IfStatement> Parser::parseIfStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseIfStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<IfStatement> parseIfStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
parseImportDirective	libsolidity/parsing/Parser.cpp	/^ASTPointer<ImportDirective> Parser::parseImportDirective()$/;"	f	class:dev::solidity::Parser	signature:()
parseImportDirective	libsolidity/parsing/Parser.h	/^	ASTPointer<ImportDirective> parseImportDirective();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseIndexAccessedPath	libsolidity/parsing/Parser.cpp	/^Parser::IndexAccessedPath Parser::parseIndexAccessedPath()$/;"	f	class:dev::solidity::Parser	signature:()
parseIndexAccessedPath	libsolidity/parsing/Parser.h	/^	IndexAccessedPath parseIndexAccessedPath();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseInheritanceSpecifier	libsolidity/parsing/Parser.cpp	/^ASTPointer<InheritanceSpecifier> Parser::parseInheritanceSpecifier()$/;"	f	class:dev::solidity::Parser	signature:()
parseInheritanceSpecifier	libsolidity/parsing/Parser.h	/^	ASTPointer<InheritanceSpecifier> parseInheritanceSpecifier();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseInlineAssembly	libsolidity/parsing/Parser.cpp	/^ASTPointer<InlineAssembly> Parser::parseInlineAssembly(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseInlineAssembly	libsolidity/parsing/Parser.h	/^	ASTPointer<InlineAssembly> parseInlineAssembly(ASTPointer<ASTString> const& _docString = {});$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString = {})
parseLeftHandSideExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseLeftHandSideExpression($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<Expression> const& _partiallyParsedExpression )
parseLeftHandSideExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseLeftHandSideExpression($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
parseLibraryOption	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::parseLibraryOption(string const& _input)$/;"	f	class:dev::solidity::CommandLineInterface	signature:(string const& _input)
parseLibraryOption	solse/CommandLineInterface.h	/^	bool parseLibraryOption(std::string const& _input);$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:(std::string const& _input)
parseMapping	libsolidity/parsing/Parser.cpp	/^ASTPointer<Mapping> Parser::parseMapping()$/;"	f	class:dev::solidity::Parser	signature:()
parseMapping	libsolidity/parsing/Parser.h	/^	ASTPointer<Mapping> parseMapping();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseMatchComponent	libsolidity/analysis/SemVerHandler.cpp	/^SemVerMatchExpression::MatchComponent SemVerMatchExpressionParser::parseMatchComponent()$/;"	f	class:SemVerMatchExpressionParser	signature:()
parseMatchComponent	libsolidity/analysis/SemVerHandler.h	/^	SemVerMatchExpression::MatchComponent parseMatchComponent();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
parseMatchExpression	libsolidity/analysis/SemVerHandler.cpp	/^void SemVerMatchExpressionParser::parseMatchExpression()$/;"	f	class:SemVerMatchExpressionParser	signature:()
parseMatchExpression	libsolidity/analysis/SemVerHandler.h	/^	void parseMatchExpression();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
parseModifierDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<ModifierDefinition> Parser::parseModifierDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
parseModifierDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<ModifierDefinition> parseModifierDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseModifierInvocation	libsolidity/parsing/Parser.cpp	/^ASTPointer<ModifierInvocation> Parser::parseModifierInvocation()$/;"	f	class:dev::solidity::Parser	signature:()
parseModifierInvocation	libsolidity/parsing/Parser.h	/^	ASTPointer<ModifierInvocation> parseModifierInvocation();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseObject	libyul/ObjectParser.cpp	/^shared_ptr<Object> ObjectParser::parseObject(Object* _containingObject)$/;"	f	class:ObjectParser	signature:(Object* _containingObject)
parseObject	libyul/ObjectParser.h	/^	std::shared_ptr<Object> parseObject(Object* _containingObject = nullptr);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object* _containingObject = nullptr)
parseOptimizerSettings	libsolidity/interface/StandardCompiler.cpp	/^boost::optional<Json::Value> StandardCompiler::parseOptimizerSettings(Json::Value const& _jsonInput)$/;"	f	class:StandardCompiler	signature:(Json::Value const& _jsonInput)
parseOptimizerSettings	libsolidity/interface/StandardCompiler.h	/^	boost::optional<Json::Value> parseOptimizerSettings(Json::Value const& _settings);$/;"	p	class:dev::solidity::StandardCompiler	access:private	signature:(Json::Value const& _settings)
parseParameterList	libsolidity/parsing/Parser.cpp	/^ASTPointer<ParameterList> Parser::parseParameterList($/;"	f	class:dev::solidity::Parser	signature:( VarDeclParserOptions const& _options, bool _allowEmpty )
parseParameterList	libsolidity/parsing/Parser.h	/^	ASTPointer<ParameterList> parseParameterList($/;"	p	class:dev::solidity::Parser	access:private	signature:( VarDeclParserOptions const& _options = {}, bool _allowEmpty = true )
parsePragmaDirective	libsolidity/parsing/Parser.cpp	/^ASTPointer<PragmaDirective> Parser::parsePragmaDirective()$/;"	f	class:dev::solidity::Parser	signature:()
parsePragmaDirective	libsolidity/parsing/Parser.h	/^	ASTPointer<PragmaDirective> parsePragmaDirective();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parsePragmaVersion	libsolidity/parsing/Parser.cpp	/^void Parser::parsePragmaVersion(vector<Token> const& tokens, vector<string> const& literals)$/;"	f	class:dev::solidity::Parser	signature:(vector<Token> const& tokens, vector<string> const& literals)
parsePragmaVersion	libsolidity/parsing/Parser.h	/^	void parsePragmaVersion(std::vector<Token> const& tokens, std::vector<std::string> const& literals);$/;"	p	class:dev::solidity::Parser	access:private	signature:(std::vector<Token> const& tokens, std::vector<std::string> const& literals)
parsePrimaryExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parsePrimaryExpression()$/;"	f	class:dev::solidity::Parser	signature:()
parsePrimaryExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parsePrimaryExpression();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseRational	libsolidity/ast/Types.cpp	/^tuple<bool, rational> RationalNumberType::parseRational(string const& _value)$/;"	f	class:RationalNumberType	signature:(string const& _value)
parseRational	libsolidity/ast/Types.h	/^	static std::tuple<bool, rational> parseRational(std::string const& _value);$/;"	p	class:dev::solidity::RationalNumberType	access:private	signature:(std::string const& _value)
parseRemapping	libsolidity/interface/CompilerStack.cpp	/^boost::optional<CompilerStack::Remapping> CompilerStack::parseRemapping(string const& _remapping)$/;"	f	class:CompilerStack	signature:(string const& _remapping)
parseRemapping	libsolidity/interface/CompilerStack.h	/^	static boost::optional<Remapping> parseRemapping(std::string const& _remapping);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::string const& _remapping)
parseSimpleStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<Statement> Parser::parseSimpleStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseSimpleStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<Statement> parseSimpleStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
parseSize	liblangutil/Token.cpp	/^int parseSize(string::const_iterator _begin, string::const_iterator _end)$/;"	f	namespace:langutil::TokenTraits	signature:(string::const_iterator _begin, string::const_iterator _end)
parseStateMutability	libsolidity/parsing/Parser.cpp	/^StateMutability Parser::parseStateMutability()$/;"	f	class:dev::solidity::Parser	signature:()
parseStateMutability	libsolidity/parsing/Parser.h	/^	StateMutability parseStateMutability();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<Statement> Parser::parseStatement()$/;"	f	class:dev::solidity::Parser	signature:()
parseStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<Statement> parseStatement();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseStatement	libyul/AsmParser.cpp	/^Statement Parser::parseStatement()$/;"	f	class:Parser	signature:()
parseStatement	libyul/AsmParser.h	/^	Statement parseStatement();$/;"	p	class:yul::Parser	access:protected	signature:()
parseStructDefinition	libsolidity/parsing/Parser.cpp	/^ASTPointer<StructDefinition> Parser::parseStructDefinition()$/;"	f	class:dev::solidity::Parser	signature:()
parseStructDefinition	libsolidity/parsing/Parser.h	/^	ASTPointer<StructDefinition> parseStructDefinition();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseTypeName	libsolidity/parsing/Parser.cpp	/^ASTPointer<TypeName> Parser::parseTypeName(bool _allowVar)$/;"	f	class:dev::solidity::Parser	signature:(bool _allowVar)
parseTypeName	libsolidity/parsing/Parser.h	/^	ASTPointer<TypeName> parseTypeName(bool _allowVar);$/;"	p	class:dev::solidity::Parser	access:private	signature:(bool _allowVar)
parseTypeNameSuffix	libsolidity/parsing/Parser.cpp	/^ASTPointer<TypeName> Parser::parseTypeNameSuffix(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory)
parseTypeNameSuffix	libsolidity/parsing/Parser.h	/^	ASTPointer<TypeName> parseTypeNameSuffix(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<TypeName> type, ASTNodeFactory& nodeFactory)
parseTypedName	libyul/AsmParser.cpp	/^TypedName Parser::parseTypedName()$/;"	f	class:Parser	signature:()
parseTypedName	libyul/AsmParser.h	/^	TypedName parseTypedName();$/;"	p	class:yul::Parser	access:protected	signature:()
parseUnaryExpression	libsolidity/parsing/Parser.cpp	/^ASTPointer<Expression> Parser::parseUnaryExpression($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<Expression> const& _partiallyParsedExpression )
parseUnaryExpression	libsolidity/parsing/Parser.h	/^	ASTPointer<Expression> parseUnaryExpression($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<Expression> const& _partiallyParsedExpression = ASTPointer<Expression>() )
parseUniqueName	libyul/ObjectParser.cpp	/^YulString ObjectParser::parseUniqueName(Object const* _containingObject)$/;"	f	class:ObjectParser	signature:(Object const* _containingObject)
parseUniqueName	libyul/ObjectParser.h	/^	YulString parseUniqueName(Object const* _containingObject);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object const* _containingObject)
parseUserDefinedTypeName	libsolidity/parsing/Parser.cpp	/^ASTPointer<UserDefinedTypeName> Parser::parseUserDefinedTypeName()$/;"	f	class:dev::solidity::Parser	signature:()
parseUserDefinedTypeName	libsolidity/parsing/Parser.h	/^	ASTPointer<UserDefinedTypeName> parseUserDefinedTypeName();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseUsingDirective	libsolidity/parsing/Parser.cpp	/^ASTPointer<UsingForDirective> Parser::parseUsingDirective()$/;"	f	class:dev::solidity::Parser	signature:()
parseUsingDirective	libsolidity/parsing/Parser.h	/^	ASTPointer<UsingForDirective> parseUsingDirective();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseValues	libsolidity/formal/SMTLib2Interface.cpp	/^vector<string> SMTLib2Interface::parseValues(string::const_iterator _start, string::const_iterator _end)$/;"	f	class:SMTLib2Interface	signature:(string::const_iterator _start, string::const_iterator _end)
parseValues	libsolidity/formal/SMTLib2Interface.h	/^	std::vector<std::string> parseValues(std::string::const_iterator _start, std::string::const_iterator _end);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string::const_iterator _start, std::string::const_iterator _end)
parseVariableDeclaration	libsolidity/parsing/Parser.cpp	/^ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration($/;"	f	class:dev::solidity::Parser	signature:( VarDeclParserOptions const& _options, ASTPointer<TypeName> const& _lookAheadArrayType )
parseVariableDeclaration	libsolidity/parsing/Parser.h	/^	ASTPointer<VariableDeclaration> parseVariableDeclaration($/;"	p	class:dev::solidity::Parser	access:private	signature:( VarDeclParserOptions const& _options = {}, ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>() )
parseVariableDeclaration	libyul/AsmParser.cpp	/^VariableDeclaration Parser::parseVariableDeclaration()$/;"	f	class:Parser	signature:()
parseVariableDeclaration	libyul/AsmParser.h	/^	VariableDeclaration parseVariableDeclaration();$/;"	p	class:yul::Parser	access:protected	signature:()
parseVariableDeclarationStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<VariableDeclarationStatement> Parser::parseVariableDeclarationStatement($/;"	f	class:dev::solidity::Parser	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<TypeName> const& _lookAheadArrayType )
parseVariableDeclarationStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<VariableDeclarationStatement> parseVariableDeclarationStatement($/;"	p	class:dev::solidity::Parser	access:private	signature:( ASTPointer<ASTString> const& _docString, ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>() )
parseVersionPart	libsolidity/analysis/SemVerHandler.cpp	/^unsigned SemVerMatchExpressionParser::parseVersionPart()$/;"	f	class:SemVerMatchExpressionParser	signature:()
parseVersionPart	libsolidity/analysis/SemVerHandler.h	/^	unsigned parseVersionPart();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
parseVisibilitySpecifier	libsolidity/parsing/Parser.cpp	/^Declaration::Visibility Parser::parseVisibilitySpecifier()$/;"	f	class:dev::solidity::Parser	signature:()
parseVisibilitySpecifier	libsolidity/parsing/Parser.h	/^	Declaration::Visibility parseVisibilitySpecifier();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
parseWhileStatement	libsolidity/parsing/Parser.cpp	/^ASTPointer<WhileStatement> Parser::parseWhileStatement(ASTPointer<ASTString> const& _docString)$/;"	f	class:dev::solidity::Parser	signature:(ASTPointer<ASTString> const& _docString)
parseWhileStatement	libsolidity/parsing/Parser.h	/^	ASTPointer<WhileStatement> parseWhileStatement(ASTPointer<ASTString> const& _docString);$/;"	p	class:dev::solidity::Parser	access:private	signature:(ASTPointer<ASTString> const& _docString)
parserError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::parserError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
parserError	liblangutil/ErrorReporter.h	/^	void parserError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
parserError	liblangutil/ParserBase.cpp	/^void ParserBase::parserError(string const& _description)$/;"	f	class:ParserBase	signature:(string const& _description)
parserError	liblangutil/ParserBase.h	/^	void parserError(std::string const& _description);$/;"	p	class:langutil::ParserBase	access:protected	signature:(std::string const& _description)
parserResult	libyul/AssemblyStack.cpp	/^shared_ptr<Object> AssemblyStack::parserResult() const$/;"	f	class:AssemblyStack	signature:() const
parserResult	libyul/AssemblyStack.h	/^	std::shared_ptr<Object> parserResult() const;$/;"	p	class:yul::AssemblyStack	access:public	signature:() const
passesAddressChecksum	libdevcore/CommonData.cpp	/^bool dev::passesAddressChecksum(string const& _str, bool _strict)$/;"	f	class:dev	signature:(string const& _str, bool _strict)
passesAddressChecksum	libdevcore/CommonData.h	/^bool passesAddressChecksum(std::string const& _str, bool _strict);$/;"	p	namespace:dev	signature:(std::string const& _str, bool _strict)
passesAddressChecksum	libsolidity/ast/AST.cpp	/^bool Literal::passesAddressChecksum() const$/;"	f	class:Literal	signature:() const
passesAddressChecksum	libsolidity/ast/AST.h	/^	bool passesAddressChecksum() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
patch	libsolidity/analysis/SemVerHandler.h	/^	unsigned patch() const { return numbers[2]; }$/;"	f	struct:dev::solidity::SemVerVersion	access:public	signature:() const
path	libsolidity/ast/AST.h	/^	ASTString const& path() const { return *m_path; }$/;"	f	class:dev::solidity::ImportDirective	access:public	signature:() const
path	libsolidity/ast/ASTAnnotations.h	/^	std::string path;$/;"	m	struct:dev::solidity::SourceUnitAnnotation	access:public
path	libsolidity/formal/SMTChecker.h	/^		smt::Expression path;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
path	libsolidity/parsing/Parser.h	/^		std::vector<ASTPointer<PrimaryExpression>> path;$/;"	m	struct:dev::solidity::Parser::IndexAccessedPath	access:public
pathCondition	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> pathCondition;$/;"	m	class:ContextInfo	access:public
pathFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^Declaration const* NameAndTypeResolver::pathFromCurrentScope(vector<ASTString> const& _path) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(vector<ASTString> const& _path) const
pathFromCurrentScope	libsolidity/analysis/NameAndTypeResolver.h	/^	Declaration const* pathFromCurrentScope(std::vector<ASTString> const& _path) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(std::vector<ASTString> const& _path) const
pattern	libevmasm/SimplificationRule.h	/^	Pattern pattern;$/;"	m	struct:dev::solidity::SimplificationRule	access:public
peekLiteral	liblangutil/Scanner.h	/^	std::string const& peekLiteral() const { return m_nextToken.literal; }$/;"	f	class:langutil::Scanner::std	access:public	signature:() const
peekLocation	liblangutil/Scanner.h	/^	SourceLocation peekLocation() const { return m_nextToken.location; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
peekNextToken	liblangutil/ParserBase.cpp	/^Token ParserBase::peekNextToken() const$/;"	f	class:ParserBase	signature:() const
peekNextToken	liblangutil/ParserBase.h	/^	Token peekNextToken() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
peekNextToken	liblangutil/Scanner.h	/^	Token peekNextToken() const { return m_nextToken.token; }$/;"	f	class:langutil::Scanner	access:public	signature:() const
peekStatementType	libsolidity/parsing/Parser.cpp	/^Parser::LookAheadInfo Parser::peekStatementType() const$/;"	f	class:dev::solidity::Parser	signature:() const
peekStatementType	libsolidity/parsing/Parser.h	/^	LookAheadInfo peekStatementType() const;$/;"	p	class:dev::solidity::Parser	access:private	signature:() const
performImports	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::performImports(SourceUnit& _sourceUnit, map<string, SourceUnit const*> const& _sourceUnits)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(SourceUnit& _sourceUnit, map<string, SourceUnit const*> const& _sourceUnits)
performImports	libsolidity/analysis/NameAndTypeResolver.h	/^	bool performImports(SourceUnit& _sourceUnit, std::map<std::string, SourceUnit const*> const& _sourceUnits);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(SourceUnit& _sourceUnit, std::map<std::string, SourceUnit const*> const& _sourceUnits)
performInline	libyul/optimiser/FullInliner.cpp	/^vector<Statement> InlineModifier::performInline(Statement& _statement, FunctionCall& _funCall)$/;"	f	class:InlineModifier	signature:(Statement& _statement, FunctionCall& _funCall)
performInline	libyul/optimiser/FullInliner.h	/^	std::vector<Statement> performInline(Statement& _statement, FunctionCall& _funCall);$/;"	p	class:yul::InlineModifier	access:private	signature:(Statement& _statement, FunctionCall& _funCall)
petersburg	liblangutil/EVMVersion.h	/^	static EVMVersion petersburg() { return {Version::Petersburg}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
pi	libdevcore/Keccak256.cpp	/^static uint8_t const pi[24] = \\$/;"	m	namespace:dev::__anon23	file:
placeAndConnectLabel	libsolidity/analysis/ControlFlowBuilder.cpp	/^void ControlFlowBuilder::placeAndConnectLabel(CFGNode* _node)$/;"	f	class:ControlFlowBuilder	signature:(CFGNode* _node)
placeAndConnectLabel	libsolidity/analysis/ControlFlowBuilder.h	/^	void placeAndConnectLabel(CFGNode *_node);$/;"	p	class:dev::solidity::ControlFlowBuilder	access:private	signature:(CFGNode *_node)
pop	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::pop()$/;"	f	class:CVC4Interface	signature:()
pop	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::pop()$/;"	f	class:SMTLib2Interface	signature:()
pop	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::pop()$/;"	f	class:SMTPortfolio	signature:()
pop	libsolidity/formal/SolverInterface.h	/^	virtual void pop() = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
pop	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::pop()$/;"	f	class:Z3Interface	signature:()
popAndJump	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::popAndJump(unsigned _toHeight, eth::AssemblyItem const& _jumpTo)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _toHeight, eth::AssemblyItem const& _jumpTo)
popAndJump	libsolidity/codegen/CompilerUtils.h	/^	void popAndJump(unsigned _toHeight, eth::AssemblyItem const& _jumpTo);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _toHeight, eth::AssemblyItem const& _jumpTo)
popPathCondition	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::popPathCondition()$/;"	f	class:SMTChecker	signature:()
popPathCondition	libsolidity/formal/SMTChecker.h	/^	void popPathCondition();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
popScope	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::popScope()$/;"	f	class:DataFlowAnalyzer	signature:()
popScope	libyul/optimiser/DataFlowAnalyzer.h	/^	void popScope();$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:()
popScopedVariables	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::popScopedVariables(ASTNode const* _node)$/;"	f	class:ContractCompiler	signature:(ASTNode const* _node)
popScopedVariables	libsolidity/codegen/ContractCompiler.h	/^	void popScopedVariables(ASTNode const* _node);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ASTNode const* _node)
popStackElement	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::popStackElement(Type const& _type)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type)
popStackElement	libsolidity/codegen/CompilerUtils.h	/^	void popStackElement(Type const& _type);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _type)
popStackSlots	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::popStackSlots(size_t _amount)$/;"	f	class:dev::solidity::CompilerUtils	signature:(size_t _amount)
popStackSlots	libsolidity/codegen/CompilerUtils.h	/^	void popStackSlots(size_t _amount);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(size_t _amount)
popStorageArrayElement	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::popStorageArrayElement(ArrayType const& _type) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _type) const
popStorageArrayElement	libsolidity/codegen/ArrayUtils.h	/^	void popStorageArrayElement(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
popVisitedNodes	libsolidity/codegen/CompilerContext.h	/^	void popVisitedNodes() { m_visitedNodes.pop(); updateSourceLocation(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
position	liblangutil/CharStream.h	/^	int position() const { return m_position; }$/;"	f	class:langutil::CharStream	access:public	signature:() const
position	liblangutil/ParserBase.cpp	/^int ParserBase::position() const$/;"	f	class:ParserBase	signature:() const
position	liblangutil/ParserBase.h	/^	int position() const;$/;"	p	class:langutil::ParserBase	access:protected	signature:() const
position	liblangutil/SourceReferenceExtractor.h	/^	LineColumn position;      \/\/\/< Actual (error) position this source reference is surrounding.$/;"	m	struct:langutil::SourceReference	access:public
positionFromSourceLocation	libsolidity/interface/CompilerStack.cpp	/^tuple<int, int, int, int> CompilerStack::positionFromSourceLocation(SourceLocation const& _sourceLocation) const$/;"	f	class:CompilerStack	signature:(SourceLocation const& _sourceLocation) const
positionFromSourceLocation	libsolidity/interface/CompilerStack.h	/^	std::tuple<int, int, int, int> positionFromSourceLocation(langutil::SourceLocation const& _sourceLocation) const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(langutil::SourceLocation const& _sourceLocation) const
post	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
pre	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
preCond	solse/mechanism.h	/^		z3::expr preCond;$/;"	m	class:Mechanism	access:public
precedence	liblangutil/Token.cpp	/^int precedence(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
precedence	liblangutil/Token.h	/^	int precedence(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
prefix	libsolidity/analysis/SemVerHandler.h	/^		Token prefix = Token::Illegal;$/;"	m	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public
prefix	libsolidity/interface/CompilerStack.h	/^		std::string prefix;$/;"	m	struct:dev::solidity::CompilerStack::Remapping	access:public
prepareMemoryStore	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::prepareMemoryStore(Type const& _type, bool _padToWords)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type, bool _padToWords)
prepareMemoryStore	libsolidity/codegen/CompilerUtils.h	/^	unsigned prepareMemoryStore(Type const& _type, bool _padToWords);$/;"	p	class:dev::solidity::CompilerUtils	access:private	signature:(Type const& _type, bool _padToWords)
prerelease	libsolidity/analysis/SemVerHandler.h	/^	std::string prerelease;$/;"	m	struct:dev::solidity::SemVerVersion	access:public
prev	libevmasm/ControlFlowGraph.h	/^	BlockId prev = BlockId::invalid();$/;"	m	struct:dev::eth::BasicBlock	access:public
price	solse/mechanism.h	/^		z3::expr price;$/;"	m	class:Mechanism	access:public
primary	liblangutil/SourceReferenceExtractor.h	/^		SourceReference primary;$/;"	m	struct:langutil::SourceReferenceExtractor::Message	access:public
print	libdevcore/JSON.cpp	/^string print(Json::Value const& _input, Json::StreamWriterBuilder const& _builder)$/;"	f	namespace:dev::__anon25	signature:(Json::Value const& _input, Json::StreamWriterBuilder const& _builder)
print	libsolidity/analysis/ControlFlowPrinter.cpp	/^void ControlFlowPrinter::print(ostream& _stream)$/;"	f	class:ControlFlowPrinter	signature:(ostream& _stream)
print	libsolidity/analysis/ControlFlowPrinter.h	/^	void print(std::ostream& _stream);$/;"	p	class:dev::solidity::ControlFlowPrinter	access:public	signature:(std::ostream& _stream)
print	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::print(ostream& _stream, ASTNode const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ostream& _stream, ASTNode const& _node)
print	libsolidity/ast/ASTJsonConverter.h	/^	void print(std::ostream& _stream, ASTNode const& _node);$/;"	p	class:dev::solidity::ASTJsonConverter	access:public	signature:(std::ostream& _stream, ASTNode const& _node)
print	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::print(ostream& _stream)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ostream& _stream)
print	libsolidity/ast/ASTPrinter.h	/^	void print(std::ostream& _stream);$/;"	p	class:dev::solidity::ASTPrinter	access:public	signature:(std::ostream& _stream)
print	libyul/AssemblyStack.cpp	/^string AssemblyStack::print() const$/;"	f	class:AssemblyStack	signature:() const
print	libyul/AssemblyStack.h	/^	std::string print() const;$/;"	p	class:yul::AssemblyStack	access:public	signature:() const
printContext	solse/SolidityExprTranslator.cpp	/^printContext(){$/;"	f	class:ContextInfo	signature:()
printContext	solse/SolidityExprTranslator.h	/^    void printContext();$/;"	p	class:ContextInfo	access:public	signature:()
printExceptionInformation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printExceptionInformation(SourceReferenceExtractor::Message const& _msg)$/;"	f	class:SourceReferenceFormatter	signature:(SourceReferenceExtractor::Message const& _msg)
printExceptionInformation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printExceptionInformation(dev::Exception const& _error, std::string const& _category)$/;"	f	class:SourceReferenceFormatter	signature:(dev::Exception const& _error, std::string const& _category)
printExceptionInformation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printExceptionInformation(SourceReferenceExtractor::Message const& _msg);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(SourceReferenceExtractor::Message const& _msg)
printExceptionInformation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printExceptionInformation(dev::Exception const& _error, std::string const& _category);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(dev::Exception const& _error, std::string const& _category)
printExceptionInformation	liblangutil/SourceReferenceFormatterHuman.cpp	/^void SourceReferenceFormatterHuman::printExceptionInformation(SourceReferenceExtractor::Message const& _msg)$/;"	f	class:SourceReferenceFormatterHuman	signature:(SourceReferenceExtractor::Message const& _msg)
printFunctionFlow	libsolidity/analysis/ControlFlowPrinter.cpp	/^void ControlFlowPrinter::printFunctionFlow(CFGNode const* _entry) const$/;"	f	class:ControlFlowPrinter	signature:(CFGNode const* _entry) const
printFunctionFlow	libsolidity/analysis/ControlFlowPrinter.h	/^	void printFunctionFlow(CFGNode const* _entry) const;$/;"	p	class:dev::solidity::ControlFlowPrinter	access:private	signature:(CFGNode const* _entry) const
printLocation	libevmasm/Assembly.cpp	/^	void printLocation()$/;"	f	class:__anon18::Functionalizer	access:public	signature:()
printSourceLocation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printSourceLocation(SourceLocation const* _location)$/;"	f	class:SourceReferenceFormatter	signature:(SourceLocation const* _location)
printSourceLocation	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printSourceLocation(SourceReference const& _ref)$/;"	f	class:SourceReferenceFormatter	signature:(SourceReference const& _ref)
printSourceLocation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printSourceLocation(SourceLocation const* _location);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(SourceLocation const* _location)
printSourceLocation	liblangutil/SourceReferenceFormatter.h	/^	virtual void printSourceLocation(SourceReference const& _ref);$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:(SourceReference const& _ref)
printSourceLocation	liblangutil/SourceReferenceFormatterHuman.cpp	/^void SourceReferenceFormatterHuman::printSourceLocation(SourceReference const& _ref)$/;"	f	class:SourceReferenceFormatterHuman	signature:(SourceReference const& _ref)
printSourceName	liblangutil/SourceReferenceFormatter.cpp	/^void SourceReferenceFormatter::printSourceName(SourceReference const& _ref)$/;"	f	class:SourceReferenceFormatter	signature:(SourceReference const& _ref)
printSourceName	liblangutil/SourceReferenceFormatter.h	/^	void printSourceName(SourceReference const& _ref);$/;"	p	class:langutil::SourceReferenceFormatter	access:protected	signature:(SourceReference const& _ref)
printSourcePart	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::printSourcePart(ASTNode const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ASTNode const& _node)
printSourcePart	libsolidity/ast/ASTPrinter.h	/^	void printSourcePart(ASTNode const& _node);$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:(ASTNode const& _node)
printType	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::printType(Expression const& _expression)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Expression const& _expression)
printType	libsolidity/ast/ASTPrinter.h	/^	void printType(Expression const& _expression);$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:(Expression const& _expression)
print_model	solse/SymExecEngine.cpp	/^void SymExecEngine::print_model (z3::model z3_model, ContextInfo& current_ctx, std::string title){$/;"	f	class:SymExecEngine	signature:(z3::model z3_model, ContextInfo& current_ctx, std::string title)
print_model	solse/SymExecEngine.h	/^    void print_model(z3::model, ContextInfo&,  std::string);$/;"	p	class:SymExecEngine	access:public	signature:(z3::model, ContextInfo&, std::string)
print_model	solse/mechanism.h	/^    void print_model(z3::model& model, std::string desc){$/;"	f	class:Mechanism	access:public	signature:(z3::model& model, std::string desc)
processInput	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::processInput()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
processInput	solse/CommandLineInterface.h	/^	bool processInput();$/;"	p	class:dev::solidity::DocumentationType	access:public	signature:()
projectors	solse/SymExecEngine.h	/^    std::vector<z3::func_decl_vector> projectors;$/;"	m	class:StructInfo	access:public
providesObjectAccess	libyul/backends/evm/EVMDialect.h	/^	bool providesObjectAccess() const { return m_objectAccess; }$/;"	f	struct:yul::EVMDialect	access:public	signature:() const
push	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::push()$/;"	f	class:CVC4Interface	signature:()
push	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::push()$/;"	f	class:SMTLib2Interface	signature:()
push	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::push()$/;"	f	class:SMTPortfolio	signature:()
push	libsolidity/formal/SolverInterface.h	/^	virtual void push() = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
push	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::push()$/;"	f	class:Z3Interface	signature:()
pushCombinedFunctionEntryLabel	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::pushCombinedFunctionEntryLabel(Declaration const& _function, bool _runtimeOnly)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Declaration const& _function, bool _runtimeOnly)
pushCombinedFunctionEntryLabel	libsolidity/codegen/CompilerUtils.h	/^	void pushCombinedFunctionEntryLabel(Declaration const& _function, bool _runtimeOnly = true);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Declaration const& _function, bool _runtimeOnly = true)
pushInstruction	libevmasm/Instruction.h	/^inline Instruction pushInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
pushNewTag	libsolidity/codegen/CompilerContext.h	/^	eth::AssemblyItem pushNewTag() { return m_asm->append(m_asm->newPushTag()).tag(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:()
pushPathCondition	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::pushPathCondition(smt::Expression const& _e)$/;"	f	class:SMTChecker	signature:(smt::Expression const& _e)
pushPathCondition	libsolidity/formal/SMTChecker.h	/^	void pushPathCondition(smt::Expression const& _e);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(smt::Expression const& _e)
pushScope	libyul/optimiser/DataFlowAnalyzer.cpp	/^void DataFlowAnalyzer::pushScope(bool _functionScope)$/;"	f	class:DataFlowAnalyzer	signature:(bool _functionScope)
pushScope	libyul/optimiser/DataFlowAnalyzer.h	/^	void pushScope(bool _functionScope);$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(bool _functionScope)
pushSubroutineOffset	libevmasm/Assembly.h	/^	void pushSubroutineOffset(size_t _subRoutine) { append(AssemblyItem(PushSub, _subRoutine)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _subRoutine)
pushSubroutineOffset	libsolidity/codegen/CompilerContext.h	/^	void pushSubroutineOffset(size_t _subRoutine) { m_asm->pushSubroutineOffset(_subRoutine); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(size_t _subRoutine)
pushSubroutineSize	libevmasm/Assembly.h	/^	void pushSubroutineSize(size_t _subRoutine) { append(newPushSubSize(_subRoutine)); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _subRoutine)
pushSubroutineSize	libsolidity/codegen/CompilerContext.h	/^	void pushSubroutineSize(size_t _subRoutine) { m_asm->pushSubroutineSize(_subRoutine); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(size_t _subRoutine)
pushTag	libevmasm/AssemblyItem.h	/^	AssemblyItem pushTag() const { assertThrow(m_type == PushTag || m_type == Tag, Exception, ""); return AssemblyItem(PushTag, data()); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
pushVisitedNodes	libsolidity/codegen/CompilerContext.h	/^	void pushVisitedNodes(ASTNode const* _node) { m_visitedNodes.push(_node); updateSourceLocation(); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(ASTNode const* _node)
pushZeroPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::pushZeroPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
pushZeroPointer	libsolidity/codegen/CompilerUtils.h	/^	void pushZeroPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
pushZeroValue	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::pushZeroValue(Type const& _type)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type)
pushZeroValue	libsolidity/codegen/CompilerUtils.h	/^	void pushZeroValue(Type const& _type);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _type)
pushedTags	libevmasm/ControlFlowGraph.h	/^	std::vector<BlockId> pushedTags;$/;"	m	struct:dev::eth::BasicBlock	access:public
pushedValue	libevmasm/AssemblyItem.h	/^	u256 const* pushedValue() const { return m_pushedValue.get(); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
qeZ3	solse/main.cpp	/^z3::expr qeZ3(z3::context &c, z3::expr_vector qeVec, z3::expr formula, bool forAll);$/;"	p	file:	signature:(z3::context &c, z3::expr_vector qeVec, z3::expr formula, bool forAll)
qeZ3	solse/main.cpp	/^z3::expr qeZ3(z3::context &c, z3::expr_vector qeVec, z3::expr formula, bool forAll){$/;"	f	signature:(z3::context &c, z3::expr_vector qeVec, z3::expr formula, bool forAll)
quadCoeffDiv	libevmasm/GasMeter.h	/^	static unsigned const quadCoeffDiv = 512;$/;"	m	namespace:dev::eth::GasCosts
querySolver	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::querySolver(string const& _input)$/;"	f	class:SMTLib2Interface	signature:(string const& _input)
querySolver	libsolidity/formal/SMTLib2Interface.h	/^	std::string querySolver(std::string const& _input);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string const& _input)
queryTimeout	libsolidity/formal/SolverInterface.h	/^	static int const queryTimeout = 10000;$/;"	m	class:dev::solidity::smt::SolverInterface	access:protected
queue	libevmasm/PathGasMeter.cpp	/^void PathGasMeter::queue(std::unique_ptr<GasPath>&& _newPath)$/;"	f	class:PathGasMeter	signature:(std::unique_ptr<GasPath>&& _newPath)
queue	libevmasm/PathGasMeter.h	/^	void queue(std::unique_ptr<GasPath>&& _newPath);$/;"	p	class:dev::eth::PathGasMeter	access:private	signature:(std::unique_ptr<GasPath>&& _newPath)
quotedAlternativesList	libdevcore/StringUtils.cpp	/^string dev::quotedAlternativesList(vector<string> const& suggestions)$/;"	f	class:dev	signature:(vector<string> const& suggestions)
quotedAlternativesList	libdevcore/StringUtils.h	/^std::string quotedAlternativesList(std::vector<std::string> const& suggestions);$/;"	p	namespace:dev	signature:(std::vector<std::string> const& suggestions)
range	libsolidity/formal/SolverInterface.h	/^	SortPointer range;$/;"	m	struct:dev::solidity::smt::ArraySort	access:public
readFile	libdevcore/CommonIO.cpp	/^inline _T readFile(std::string const& _file)$/;"	f	namespace:__anon24	signature:(std::string const& _file)
readFileAsString	libdevcore/CommonIO.cpp	/^string dev::readFileAsString(string const& _file)$/;"	f	class:dev	signature:(string const& _file)
readFileAsString	libdevcore/CommonIO.h	/^std::string readFileAsString(std::string const& _file);$/;"	p	namespace:dev	signature:(std::string const& _file)
readInputFile	solse/main.cpp	/^ReadCallback::Result readInputFile(std::string const& _path){$/;"	f	signature:(std::string const& _path)
readInputFilesAndConfigureRemappings	solse/CommandLineInterface.cpp	/^bool CommandLineInterface::readInputFilesAndConfigureRemappings()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
readInputFilesAndConfigureRemappings	solse/CommandLineInterface.h	/^	bool readInputFilesAndConfigureRemappings();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
readStandardInput	libdevcore/CommonIO.cpp	/^string dev::readStandardInput()$/;"	f	class:dev	signature:()
readStandardInput	libdevcore/CommonIO.h	/^std::string readStandardInput();$/;"	p	namespace:dev	signature:()
readStandardInputChar	libdevcore/CommonIO.cpp	/^int dev::readStandardInputChar()$/;"	f	class:dev	signature:()
readStandardInputChar	libdevcore/CommonIO.h	/^int readStandardInputChar();$/;"	p	namespace:dev	signature:()
rebuildCode	libevmasm/ControlFlowGraph.cpp	/^BasicBlocks ControlFlowGraph::rebuildCode()$/;"	f	class:ControlFlowGraph	signature:()
rebuildCode	libevmasm/ControlFlowGraph.h	/^	BasicBlocks rebuildCode();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
rebuildExpression	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::rebuildExpression(ExpressionTemplate const& _template)$/;"	f	class:ExpressionClasses	signature:(ExpressionTemplate const& _template)
rebuildExpression	libevmasm/ExpressionClasses.h	/^	Id rebuildExpression(ExpressionTemplate const& _template);$/;"	p	class:dev::eth::ExpressionClasses	access:private	signature:(ExpressionTemplate const& _template)
recursive	libsolidity/ast/Types.cpp	/^bool StructType::recursive() const$/;"	f	class:StructType	signature:() const
recursive	libsolidity/ast/Types.h	/^	bool recursive() const;$/;"	p	class:dev::solidity::StructType	access:public	signature:() const
reduceToCommonKnowledge	libevmasm/KnownState.cpp	/^void KnownState::reduceToCommonKnowledge(KnownState const& _other, bool _combineSequenceNumbers)$/;"	f	class:KnownState	signature:(KnownState const& _other, bool _combineSequenceNumbers)
reduceToCommonKnowledge	libevmasm/KnownState.h	/^	void reduceToCommonKnowledge(KnownState const& _other, bool _combineSequenceNumbers);$/;"	p	class:dev::eth::KnownState	access:public	signature:(KnownState const& _other, bool _combineSequenceNumbers)
ref	libdevcore/FixedHash.h	/^	bytesConstRef ref() const { return bytesConstRef(m_data.data(), N); }$/;"	f	class:dev::FixedHash	access:public	signature:() const
ref	libdevcore/FixedHash.h	/^	bytesRef ref() { return bytesRef(m_data.data(), N); }$/;"	f	class:dev::FixedHash	access:public	signature:()
referenceLocation	libsolidity/ast/AST.h	/^	Location referenceLocation() const { return m_location; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
referencedDeclaration	libsolidity/ast/ASTAnnotations.h	/^	Declaration const* referencedDeclaration = nullptr;$/;"	m	struct:dev::solidity::IdentifierAnnotation	access:public
referencedDeclaration	libsolidity/ast/ASTAnnotations.h	/^	Declaration const* referencedDeclaration = nullptr;$/;"	m	struct:dev::solidity::MemberAccessAnnotation	access:public
referencedDeclaration	libsolidity/ast/ASTAnnotations.h	/^	Declaration const* referencedDeclaration = nullptr;$/;"	m	struct:dev::solidity::UserDefinedTypeNameAnnotation	access:public
referencedSourceUnits	libsolidity/ast/AST.cpp	/^set<SourceUnit const*> SourceUnit::referencedSourceUnits(bool _recurse, set<SourceUnit const*> _skipList) const$/;"	f	class:SourceUnit	signature:(bool _recurse, set<SourceUnit const*> _skipList) const
referencedSourceUnits	libsolidity/ast/AST.h	/^	std::set<SourceUnit const*> referencedSourceUnits(bool _recurse = false, std::set<SourceUnit const*> _skipList = std::set<SourceUnit const*>()) const;$/;"	p	class:dev::solidity::SourceUnit	access:public	signature:(bool _recurse = false, std::set<SourceUnit const*> _skipList = std::set<SourceUnit const*>()) const
referencedTags	libevmasm/JumpdestRemover.cpp	/^set<size_t> JumpdestRemover::referencedTags(AssemblyItems const& _items, size_t _subId)$/;"	f	class:JumpdestRemover	signature:(AssemblyItems const& _items, size_t _subId)
referencedTags	libevmasm/JumpdestRemover.h	/^	static std::set<size_t> referencedTags(AssemblyItems const& _items, size_t _subId);$/;"	p	class:dev::eth::JumpdestRemover	access:public	signature:(AssemblyItems const& _items, size_t _subId)
referencedVariables	libyul/optimiser/Semantics.h	/^	std::set<YulString> const& referencedVariables() const { return m_variableReferences; }$/;"	f	class:yul::MovableChecker::std	access:public	signature:() const
references	libyul/optimiser/NameCollector.h	/^	std::map<YulString, size_t> const& references() const { return m_references; }$/;"	f	class:yul::ReferencesCounter::std	access:public	signature:() const
registerDeclaration	libsolidity/analysis/DeclarationContainer.cpp	/^bool DeclarationContainer::registerDeclaration($/;"	f	class:DeclarationContainer	signature:( Declaration const& _declaration, ASTString const* _name, bool _invisible, bool _update )
registerDeclaration	libsolidity/analysis/DeclarationContainer.h	/^	bool registerDeclaration(Declaration const& _declaration, ASTString const* _name = nullptr, bool _invisible = false, bool _update = false);$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(Declaration const& _declaration, ASTString const* _name = nullptr, bool _invisible = false, bool _update = false)
registerDeclaration	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::registerDeclaration($/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:( DeclarationContainer& _container, Declaration const& _declaration, string const* _name, SourceLocation const* _errorLocation, bool _warnOnShadow, bool _inactive, ErrorReporter& _errorReporter )
registerDeclaration	libsolidity/analysis/NameAndTypeResolver.cpp	/^void DeclarationRegistrationHelper::registerDeclaration(Declaration& _declaration, bool _opensScope)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(Declaration& _declaration, bool _opensScope)
registerDeclaration	libsolidity/analysis/NameAndTypeResolver.h	/^	static bool registerDeclaration($/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:public	signature:( DeclarationContainer& _container, Declaration const& _declaration, std::string const* _name, langutil::SourceLocation const* _errorLocation, bool _warnOnShadow, bool _inactive, langutil::ErrorReporter& _errorReporter )
registerDeclaration	libsolidity/analysis/NameAndTypeResolver.h	/^	void registerDeclaration(Declaration& _declaration, bool _opensScope);$/;"	p	class:dev::solidity::DeclarationRegistrationHelper	access:private	signature:(Declaration& _declaration, bool _opensScope)
registerDeclarations	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::registerDeclarations(SourceUnit& _sourceUnit, ASTNode const* _currentScope)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(SourceUnit& _sourceUnit, ASTNode const* _currentScope)
registerDeclarations	libsolidity/analysis/NameAndTypeResolver.h	/^	bool registerDeclarations(SourceUnit& _sourceUnit, ASTNode const* _currentScope = nullptr);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(SourceUnit& _sourceUnit, ASTNode const* _currentScope = nullptr)
registerFunction	libyul/AsmScope.cpp	/^bool Scope::registerFunction(YulString _name, std::vector<YulType> const& _arguments, std::vector<YulType> const& _returns)$/;"	f	class:Scope	signature:(YulString _name, std::vector<YulType> const& _arguments, std::vector<YulType> const& _returns)
registerFunction	libyul/AsmScope.h	/^	bool registerFunction($/;"	p	struct:yul::Scope	access:public	signature:( YulString _name, std::vector<YulType> const& _arguments, std::vector<YulType> const& _returns )
registerLabel	libyul/AsmScope.cpp	/^bool Scope::registerLabel(YulString _name)$/;"	f	class:Scope	signature:(YulString _name)
registerLabel	libyul/AsmScope.h	/^	bool registerLabel(YulString _name);$/;"	p	struct:yul::Scope	access:public	signature:(YulString _name)
registerStateVariables	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::registerStateVariables(ContractDefinition const& _contract)$/;"	f	class:ContractCompiler	signature:(ContractDefinition const& _contract)
registerStateVariables	libsolidity/codegen/ContractCompiler.h	/^	void registerStateVariables(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ContractDefinition const& _contract)
registerVariable	libyul/AsmScope.cpp	/^bool Scope::registerVariable(YulString _name, YulType const& _type)$/;"	f	class:Scope	signature:(YulString _name, YulType const& _type)
registerVariable	libyul/AsmScopeFiller.cpp	/^bool ScopeFiller::registerVariable(TypedName const& _name, SourceLocation const& _location, Scope& _scope)$/;"	f	class:ScopeFiller	signature:(TypedName const& _name, SourceLocation const& _location, Scope& _scope)
registerVariable	libyul/AsmScopeFiller.h	/^	bool registerVariable($/;"	p	class:yul::ScopeFiller	access:private	signature:( TypedName const& _name, langutil::SourceLocation const& _location, Scope& _scope )
relativeStackElement	libevmasm/KnownState.cpp	/^KnownState::Id KnownState::relativeStackElement(int _stackOffset, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(int _stackOffset, SourceLocation const& _location)
relativeStackElement	libevmasm/KnownState.h	/^	Id relativeStackElement(int _stackOffset, langutil::SourceLocation const& _location = {});$/;"	p	class:dev::eth::KnownState	access:public	signature:(int _stackOffset, langutil::SourceLocation const& _location = {})
removeEmptyBlocks	libyul/optimiser/OptimizerUtilities.cpp	/^void yul::removeEmptyBlocks(Block& _block)$/;"	f	class:yul	signature:(Block& _block)
removeEmptyBlocks	libyul/optimiser/OptimizerUtilities.h	/^void removeEmptyBlocks(Block& _block);$/;"	p	namespace:yul	signature:(Block& _block)
removeLocalVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::removeLocalVariables()$/;"	f	class:SMTChecker	signature:()
removeLocalVariables	libsolidity/formal/SMTChecker.h	/^	void removeLocalVariables();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
removeStackTopIfPossible	libevmasm/CommonSubexpressionEliminator.cpp	/^bool CSECodeGenerator::removeStackTopIfPossible()$/;"	f	class:CSECodeGenerator	signature:()
removeStackTopIfPossible	libevmasm/CommonSubexpressionEliminator.h	/^	bool removeStackTopIfPossible();$/;"	p	class:dev::eth::CSECodeGenerator	access:private	signature:()
removeUnusedBlocks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::removeUnusedBlocks()$/;"	f	class:ControlFlowGraph	signature:()
removeUnusedBlocks	libevmasm/ControlFlowGraph.h	/^	void removeUnusedBlocks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
removeVariable	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::removeVariable(Declaration const& _declaration)$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration)
removeVariable	libsolidity/codegen/CompilerContext.h	/^	void removeVariable(Declaration const& _declaration);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration)
removeVariablesAboveStackHeight	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::removeVariablesAboveStackHeight(unsigned _stackHeight)$/;"	f	class:dev::solidity::CompilerContext	signature:(unsigned _stackHeight)
removeVariablesAboveStackHeight	libsolidity/codegen/CompilerContext.h	/^	void removeVariablesAboveStackHeight(unsigned _stackHeight);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(unsigned _stackHeight)
removesNonConstants	libevmasm/SimplificationRule.h	/^	bool removesNonConstants;$/;"	m	struct:dev::solidity::SimplificationRule	access:public
renameVariables	libyul/optimiser/VarNameCleaner.cpp	/^void VarNameCleaner::renameVariables(vector<TypedName>& _variables)$/;"	f	class:VarNameCleaner	signature:(vector<TypedName>& _variables)
renameVariables	libyul/optimiser/VarNameCleaner.h	/^	void renameVariables(std::vector<TypedName>& _variables);$/;"	p	class:yul::VarNameCleaner	access:private	signature:(std::vector<TypedName>& _variables)
render	libdevcore/Whiskers.cpp	/^string Whiskers::render() const$/;"	f	class:Whiskers	signature:() const
render	libdevcore/Whiskers.h	/^	std::string render() const;$/;"	p	class:dev::Whiskers	access:public	signature:() const
replace	libdevcore/Whiskers.cpp	/^string Whiskers::replace($/;"	f	class:Whiskers	signature:( string const& _template, StringMap const& _parameters, map<string, vector<StringMap>> const& _listParameters )
replace	libdevcore/Whiskers.h	/^	static std::string replace($/;"	p	class:dev::Whiskers	access:private	signature:( std::string const& _template, StringMap const& _parameters, StringListMap const& _listParameters = StringListMap() )
replaceConstants	libevmasm/ConstantOptimiser.cpp	/^void ConstantOptimisationMethod::replaceConstants($/;"	f	class:ConstantOptimisationMethod	signature:( AssemblyItems& _items, map<u256, AssemblyItems> const& _replacements )
replaceConstants	libevmasm/ConstantOptimiser.h	/^	static void replaceConstants(AssemblyItems& _items, std::map<u256, AssemblyItems> const& _replacements);$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(AssemblyItems& _items, std::map<u256, AssemblyItems> const& _replacements)
replaceItem	libevmasm/BlockDeduplicator.h	/^		AssemblyItem const* replaceItem;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
replaceWith	libevmasm/BlockDeduplicator.h	/^		AssemblyItem const* replaceWith;$/;"	m	struct:dev::eth::BlockDeduplicator::BlockIterator	access:public
replacedTags	libevmasm/BlockDeduplicator.h	/^	std::map<u256, u256> const& replacedTags() const { return m_replacedTags; }$/;"	f	class:dev::eth::BlockDeduplicator::std	access:public	signature:() const
reportMutability	libsolidity/analysis/ViewPureChecker.cpp	/^void ViewPureChecker::reportMutability($/;"	f	class:ViewPureChecker	signature:( StateMutability _mutability, SourceLocation const& _location, boost::optional<SourceLocation> const& _nestedLocation )
reportMutability	libsolidity/analysis/ViewPureChecker.h	/^	void reportMutability($/;"	p	class:dev::solidity::ViewPureChecker	access:private	signature:( StateMutability _mutability, langutil::SourceLocation const& _location, boost::optional<langutil::SourceLocation> const& _nestedLocation = {} )
representative	libevmasm/ExpressionClasses.h	/^	Expression const& representative(Id _id) const { return m_representatives.at(_id); }$/;"	f	class:dev::eth::ExpressionClasses	access:public	signature:(Id _id) const
requestedContractNames	libsolidity/interface/StandardCompiler.cpp	/^set<string> requestedContractNames(Json::Value const& _outputSelection)$/;"	f	namespace:__anon17	signature:(Json::Value const& _outputSelection)
requestedFunctions	libsolidity/codegen/ABIFunctions.cpp	/^pair<string, set<string>> ABIFunctions::requestedFunctions()$/;"	f	class:ABIFunctions	signature:()
requestedFunctions	libsolidity/codegen/ABIFunctions.h	/^	std::pair<std::string, std::set<std::string>> requestedFunctions();$/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:()
requireLValue	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::requireLValue(Expression const& _expression)$/;"	f	class:TypeChecker	signature:(Expression const& _expression)
requireLValue	libsolidity/analysis/TypeChecker.h	/^	void requireLValue(Expression const& _expression);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(Expression const& _expression)
reset	libdevcore/vector_ref.h	/^	void reset() { m_data = nullptr; m_count = 0; }$/;"	f	class:dev::vector_ref	access:public	signature:()
reset	libevmasm/KnownState.h	/^	void reset() { resetStorage(); resetMemory(); resetStack(); }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
reset	liblangutil/CharStream.h	/^	void reset() { m_position = 0; }$/;"	f	class:langutil::CharStream	access:public	signature:()
reset	liblangutil/Scanner.cpp	/^void Scanner::reset()$/;"	f	class:langutil::Scanner	signature:()
reset	liblangutil/Scanner.cpp	/^void Scanner::reset(CharStream _source)$/;"	f	class:langutil::Scanner	signature:(CharStream _source)
reset	liblangutil/Scanner.cpp	/^void Scanner::reset(std::shared_ptr<CharStream> _source)$/;"	f	class:langutil::Scanner	signature:(std::shared_ptr<CharStream> _source)
reset	liblangutil/Scanner.h	/^	void reset();$/;"	p	class:langutil::Scanner	access:public	signature:()
reset	liblangutil/Scanner.h	/^	void reset(CharStream _source);$/;"	p	class:langutil::Scanner	access:public	signature:(CharStream _source)
reset	liblangutil/Scanner.h	/^	void reset(std::shared_ptr<CharStream> _source);$/;"	p	class:langutil::Scanner	access:public	signature:(std::shared_ptr<CharStream> _source)
reset	libsolidity/analysis/SemVerHandler.cpp	/^void SemVerMatchExpressionParser::reset()$/;"	f	class:SemVerMatchExpressionParser	signature:()
reset	libsolidity/analysis/SemVerHandler.h	/^	void reset();$/;"	p	class:dev::solidity::SemVerMatchExpressionParser	access:private	signature:()
reset	libsolidity/ast/AST.cpp	/^	static void reset() { instance() = 0; }$/;"	f	class:IDDispenser	access:public	signature:()
reset	libsolidity/formal/CVC4Interface.cpp	/^void CVC4Interface::reset()$/;"	f	class:CVC4Interface	signature:()
reset	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::reset()$/;"	f	class:SMTLib2Interface	signature:()
reset	libsolidity/formal/SMTPortfolio.cpp	/^void SMTPortfolio::reset()$/;"	f	class:SMTPortfolio	signature:()
reset	libsolidity/formal/SolverInterface.h	/^	virtual void reset() = 0;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
reset	libsolidity/formal/Z3Interface.cpp	/^void Z3Interface::reset()$/;"	f	class:Z3Interface	signature:()
reset	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::reset(bool _keepSources)$/;"	f	class:CompilerStack	signature:(bool _keepSources)
reset	libsolidity/interface/CompilerStack.h	/^		void reset() { *this = Source(); }$/;"	f	struct:dev::solidity::CompilerStack::Source	access:public	signature:()
reset	libsolidity/interface/CompilerStack.h	/^	void reset(bool _keepSources = false);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(bool _keepSources = false)
resetDeclaration	libsolidity/formal/SymbolicVariables.cpp	/^void SymbolicFunctionVariable::resetDeclaration()$/;"	f	class:SymbolicFunctionVariable	signature:()
resetDeclaration	libsolidity/formal/SymbolicVariables.h	/^	void resetDeclaration();$/;"	p	class:dev::solidity::SymbolicFunctionVariable	access:private	signature:()
resetDev	libsolidity/parsing/DocStringParser.h	/^	void resetDev();$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:()
resetID	libsolidity/ast/AST.cpp	/^void ASTNode::resetID()$/;"	f	class:ASTNode	signature:()
resetID	libsolidity/ast/AST.h	/^	static void resetID();$/;"	p	class:dev::solidity::ASTNode	access:public	signature:()
resetIndex	libsolidity/formal/SSAVariable.cpp	/^void SSAVariable::resetIndex()$/;"	f	class:SSAVariable	signature:()
resetIndex	libsolidity/formal/SSAVariable.h	/^	void resetIndex();$/;"	p	class:dev::solidity::SSAVariable	access:public	signature:()
resetLatestStatementPointer	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::resetLatestStatementPointer()$/;"	f	class:ExpressionJoiner	signature:()
resetLatestStatementPointer	libyul/optimiser/ExpressionJoiner.h	/^	void resetLatestStatementPointer();$/;"	p	class:yul::ExpressionJoiner	access:private	signature:()
resetMatchGroups	libevmasm/SimplificationRules.h	/^	void resetMatchGroups() { m_matchGroups.clear(); }$/;"	f	class:dev::eth::Rules	access:private	signature:()
resetMatchGroups	libyul/optimiser/SimplificationRules.h	/^	void resetMatchGroups() { m_matchGroups.clear(); }$/;"	f	class:yul::SimplificationRules	access:private	signature:()
resetMemory	libevmasm/KnownState.h	/^	void resetMemory() { m_memoryContent.clear(); }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
resetStack	libevmasm/KnownState.h	/^	void resetStack() { m_stackElements.clear(); m_stackHeight = 0; }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
resetStateVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetStateVariables()$/;"	f	class:SMTChecker	signature:()
resetStateVariables	libsolidity/formal/SMTChecker.h	/^	void resetStateVariables();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
resetStorage	libevmasm/KnownState.h	/^	void resetStorage() { m_storageContent.clear(); }$/;"	f	class:dev::eth::KnownState	access:public	signature:()
resetStorageReferences	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetStorageReferences()$/;"	f	class:SMTChecker	signature:()
resetStorageReferences	libsolidity/formal/SMTChecker.h	/^	void resetStorageReferences();$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:()
resetUser	libsolidity/parsing/DocStringParser.h	/^	void resetUser();$/;"	p	class:dev::solidity::DocStringParser	access:private	signature:()
resetVariable	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariable(VariableDeclaration const& _variable)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _variable)
resetVariable	libsolidity/formal/SMTChecker.h	/^	void resetVariable(VariableDeclaration const& _variable);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _variable)
resetVariableIndices	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariableIndices(VariableIndices const& _indices)$/;"	f	class:SMTChecker	signature:(VariableIndices const& _indices)
resetVariableIndices	libsolidity/formal/SMTChecker.h	/^	void resetVariableIndices(VariableIndices const& _indices);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableIndices const& _indices)
resetVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariables(function<bool(VariableDeclaration const&)> const& _filter)$/;"	f	class:SMTChecker	signature:(function<bool(VariableDeclaration const&)> const& _filter)
resetVariables	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::resetVariables(vector<VariableDeclaration const*> _variables)$/;"	f	class:SMTChecker	signature:(vector<VariableDeclaration const*> _variables)
resetVariables	libsolidity/formal/SMTChecker.h	/^	void resetVariables(std::function<bool(VariableDeclaration const&)> const& _filter);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::function<bool(VariableDeclaration const&)> const& _filter)
resetVariables	libsolidity/formal/SMTChecker.h	/^	void resetVariables(std::vector<VariableDeclaration const*> _variables);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(std::vector<VariableDeclaration const*> _variables)
resetVisitedNodes	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::resetVisitedNodes(ASTNode const* _node)$/;"	f	class:dev::solidity::CompilerContext	signature:(ASTNode const* _node)
resetVisitedNodes	libsolidity/codegen/CompilerContext.h	/^	void resetVisitedNodes(ASTNode const* _node);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ASTNode const* _node)
resizeDynamicArray	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::resizeDynamicArray(ArrayType const& _typeIn) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _typeIn) const
resizeDynamicArray	libsolidity/codegen/ArrayUtils.h	/^	void resizeDynamicArray(ArrayType const& _type) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _type) const
resolve	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::resolve(ASTNode const& _root)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ASTNode const& _root)
resolve	libsolidity/analysis/ReferencesResolver.h	/^	bool resolve(ASTNode const& _root);$/;"	p	class:dev::solidity::ReferencesResolver	access:public	signature:(ASTNode const& _root)
resolveImports	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::resolveImports()$/;"	f	class:CompilerStack	signature:()
resolveImports	libsolidity/interface/CompilerStack.h	/^	void resolveImports();$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:()
resolveName	libsolidity/analysis/DeclarationContainer.cpp	/^vector<Declaration const*> DeclarationContainer::resolveName(ASTString const& _name, bool _recursive, bool _alsoInvisible) const$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name, bool _recursive, bool _alsoInvisible) const
resolveName	libsolidity/analysis/DeclarationContainer.h	/^	std::vector<Declaration const*> resolveName(ASTString const& _name, bool _recursive = false, bool _alsoInvisible = false) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name, bool _recursive = false, bool _alsoInvisible = false) const
resolveName	libsolidity/analysis/NameAndTypeResolver.cpp	/^vector<Declaration const*> NameAndTypeResolver::resolveName(ASTString const& _name, ASTNode const* _scope) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTString const& _name, ASTNode const* _scope) const
resolveName	libsolidity/analysis/NameAndTypeResolver.h	/^	std::vector<Declaration const*> resolveName(ASTString const& _name, ASTNode const* _scope = nullptr) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTString const& _name, ASTNode const* _scope = nullptr) const
resolveNamesAndTypes	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::resolveNamesAndTypes(ASTNode& _node, bool _resolveInsideCode)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTNode& _node, bool _resolveInsideCode)
resolveNamesAndTypes	libsolidity/analysis/NameAndTypeResolver.h	/^	bool resolveNamesAndTypes(ASTNode& _node, bool _resolveInsideCode = true);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTNode& _node, bool _resolveInsideCode = true)
resolveNamesAndTypesInternal	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::resolveNamesAndTypesInternal(ASTNode& _node, bool _resolveInsideCode)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTNode& _node, bool _resolveInsideCode)
resolveNamesAndTypesInternal	libsolidity/analysis/NameAndTypeResolver.h	/^	bool resolveNamesAndTypesInternal(ASTNode& _node, bool _resolveInsideCode = true);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:private	signature:(ASTNode& _node, bool _resolveInsideCode = true)
resolveNextLinks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::resolveNextLinks()$/;"	f	class:ControlFlowGraph	signature:()
resolveNextLinks	libevmasm/ControlFlowGraph.h	/^	void resolveNextLinks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
resolveVirtualFunction	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const& CompilerContext::resolveVirtualFunction($/;"	f	class:dev::solidity::CompilerContext	signature:( FunctionDefinition const& _function, vector<ContractDefinition const*>::const_iterator _searchStart )
resolveVirtualFunction	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const& CompilerContext::resolveVirtualFunction(FunctionDefinition const& _function)$/;"	f	class:dev::solidity::CompilerContext	signature:(FunctionDefinition const& _function)
resolveVirtualFunction	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const& resolveVirtualFunction($/;"	p	class:dev::solidity::CompilerContext	access:private	signature:( FunctionDefinition const& _function, std::vector<ContractDefinition const*>::const_iterator _searchStart )
resolveVirtualFunction	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const& resolveVirtualFunction(FunctionDefinition const& _function);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(FunctionDefinition const& _function)
resolveVirtualFunctionModifier	libsolidity/codegen/CompilerContext.cpp	/^ModifierDefinition const& CompilerContext::resolveVirtualFunctionModifier($/;"	f	class:dev::solidity::CompilerContext	signature:( ModifierDefinition const& _modifier ) const
resolveVirtualFunctionModifier	libsolidity/codegen/CompilerContext.h	/^	ModifierDefinition const& resolveVirtualFunctionModifier(ModifierDefinition const& _modifier) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(ModifierDefinition const& _modifier) const
responseOrErrorMessage	libsolidity/interface/ReadFile.h	/^		std::string responseOrErrorMessage;$/;"	m	struct:dev::solidity::ReadCallback::Result	access:public
ret	libevmasm/Instruction.h	/^	int ret;			\/\/\/< Number of items placed (back) on the stack by this instruction, assuming args items were removed.$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
retrieveLength	libsolidity/codegen/ArrayUtils.cpp	/^void ArrayUtils::retrieveLength(ArrayType const& _arrayType, unsigned _stackDepth) const$/;"	f	class:ArrayUtils	signature:(ArrayType const& _arrayType, unsigned _stackDepth) const
retrieveLength	libsolidity/codegen/ArrayUtils.h	/^	void retrieveLength(ArrayType const& _arrayType, unsigned _stackDepth = 0) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, unsigned _stackDepth = 0) const
retrieveValue	libsolidity/codegen/LValue.cpp	/^void MemoryItem::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:MemoryItem	signature:(SourceLocation const&, bool _remove) const
retrieveValue	libsolidity/codegen/LValue.cpp	/^void StackVariable::retrieveValue(SourceLocation const& _location, bool) const$/;"	f	class:StackVariable	signature:(SourceLocation const& _location, bool) const
retrieveValue	libsolidity/codegen/LValue.cpp	/^void StorageArrayLength::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:StorageArrayLength	signature:(SourceLocation const&, bool _remove) const
retrieveValue	libsolidity/codegen/LValue.cpp	/^void StorageByteArrayElement::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:StorageByteArrayElement	signature:(SourceLocation const&, bool _remove) const
retrieveValue	libsolidity/codegen/LValue.cpp	/^void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const$/;"	f	class:StorageItem	signature:(SourceLocation const&, bool _remove) const
retrieveValue	libsolidity/codegen/LValue.cpp	/^void TupleObject::retrieveValue(SourceLocation const&, bool) const$/;"	f	class:TupleObject	signature:(SourceLocation const&, bool) const
retrieveValue	libsolidity/codegen/LValue.h	/^	virtual void retrieveValue(langutil::SourceLocation const& _location, bool _remove = false) const = 0;$/;"	p	class:dev::solidity::LValue	access:public	signature:(langutil::SourceLocation const& _location, bool _remove = false) const
returnParameterList	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> const& returnParameterList() const { return m_returnParameters; }$/;"	f	class:dev::solidity::CallableDeclaration	access:public	signature:() const
returnParameterNames	libsolidity/ast/Types.h	/^	std::vector<std::string> const& returnParameterNames() const { return m_returnParameterNames; }$/;"	f	class:dev::solidity::FunctionType::std	access:public	signature:() const
returnParameterTypeList	libsolidity/ast/AST.h	/^	ASTPointer<ParameterList> const& returnParameterTypeList() const { return m_returnTypes; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
returnParameterTypes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& returnParameterTypes() const { return m_returnTypes->parameters(); }$/;"	f	class:dev::solidity::FunctionTypeName::std	access:public	signature:() const
returnParameterTypes	libsolidity/ast/Types.h	/^	TypePointers const& returnParameterTypes() const { return m_returnParameterTypes; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
returnParameterTypesWithoutDynamicTypes	libsolidity/ast/Types.cpp	/^TypePointers FunctionType::returnParameterTypesWithoutDynamicTypes() const$/;"	f	class:FunctionType	signature:() const
returnParameterTypesWithoutDynamicTypes	libsolidity/ast/Types.h	/^	TypePointers returnParameterTypesWithoutDynamicTypes() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
returnParameters	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<VariableDeclaration>> const& returnParameters() const { return m_returnParameters->parameters(); }$/;"	f	class:dev::solidity::CallableDeclaration::std	access:public	signature:() const
returnParameters	libsolidity/parsing/Parser.h	/^		ASTPointer<ParameterList> returnParameters;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
returnValues	libevmasm/AssemblyItem.cpp	/^int AssemblyItem::returnValues() const$/;"	f	class:AssemblyItem	signature:() const
returnValues	libevmasm/AssemblyItem.h	/^	int returnValues() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
returnVariables	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
returns	libyul/AsmScope.h	/^		std::vector<YulType> returns;$/;"	m	struct:yul::Scope::Function	access:public
returns	libyul/Dialect.h	/^	std::vector<Type> returns;$/;"	m	struct:yul::BuiltinFunction	access:public
revert	libsolidity/analysis/ControlFlowGraph.h	/^	CFGNode* revert = nullptr;$/;"	m	struct:dev::solidity::FunctionFlow	access:public
revertWithStringData	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::revertWithStringData(Type const& _argumentType)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _argumentType)
revertWithStringData	libsolidity/codegen/CompilerUtils.h	/^	void revertWithStringData(Type const& _argumentType);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _argumentType)
rho	libdevcore/Keccak256.cpp	/^static uint8_t const rho[24] = \\$/;"	m	namespace:dev::__anon23	file:
richIdentifier	libsolidity/ast/Types.cpp	/^string AddressType::richIdentifier() const$/;"	f	class:AddressType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string ArrayType::richIdentifier() const$/;"	f	class:ArrayType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string ContractType::richIdentifier() const$/;"	f	class:ContractType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string EnumType::richIdentifier() const$/;"	f	class:EnumType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string FixedBytesType::richIdentifier() const$/;"	f	class:FixedBytesType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string FixedPointType::richIdentifier() const$/;"	f	class:FixedPointType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string FunctionType::richIdentifier() const$/;"	f	class:FunctionType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string IntegerType::richIdentifier() const$/;"	f	class:IntegerType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string MagicType::richIdentifier() const$/;"	f	class:MagicType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string MappingType::richIdentifier() const$/;"	f	class:MappingType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string ModifierType::richIdentifier() const$/;"	f	class:ModifierType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string ModuleType::richIdentifier() const$/;"	f	class:ModuleType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string RationalNumberType::richIdentifier() const$/;"	f	class:RationalNumberType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string StringLiteralType::richIdentifier() const$/;"	f	class:StringLiteralType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string StructType::richIdentifier() const$/;"	f	class:StructType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string TupleType::richIdentifier() const$/;"	f	class:TupleType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string TypeType::richIdentifier() const$/;"	f	class:TypeType	signature:() const
richIdentifier	libsolidity/ast/Types.cpp	/^string richIdentifier(TypePointer const& _type)$/;"	f	namespace:__anon8	signature:(TypePointer const& _type)
richIdentifier	libsolidity/ast/Types.h	/^	virtual std::string richIdentifier() const = 0;$/;"	p	class:dev::solidity::Type	access:public	signature:() const
rightExpression	libsolidity/ast/AST.h	/^	Expression const& rightExpression() const { return *m_right; }$/;"	f	class:dev::solidity::BinaryOperation	access:public	signature:() const
rightHandSide	libsolidity/ast/AST.h	/^	Expression const& rightHandSide() const { return *m_rightHandSide; }$/;"	f	class:dev::solidity::Assignment	access:public	signature:() const
rightShiftNumberOnStack	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::rightShiftNumberOnStack(unsigned _bits)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _bits)
rightShiftNumberOnStack	libsolidity/codegen/CompilerUtils.h	/^	void rightShiftNumberOnStack(unsigned _bits);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _bits)
rol	libdevcore/Keccak256.cpp	69;"	d	file:
rollback	liblangutil/CharStream.cpp	/^char CharStream::rollback(size_t _amount)$/;"	f	class:CharStream	signature:(size_t _amount)
rollback	liblangutil/CharStream.h	/^	char rollback(size_t _amount);$/;"	p	class:langutil::CharStream	access:public	signature:(size_t _amount)
rollback	liblangutil/Scanner.h	/^	void rollback(int _amount) { m_char = m_source->rollback(_amount); }$/;"	f	class:langutil::Scanner	access:private	signature:(int _amount)
root	solse/SymExecEngine.h	/^    dev::solidity::ASTNode const& root;$/;"	m	class:SymExecEngine::dev::solidity	access:private
rotateStackDown	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::rotateStackDown(unsigned _items)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _items)
rotateStackDown	libsolidity/codegen/CompilerUtils.h	/^	void rotateStackDown(unsigned _items);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _items)
rotateStackUp	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::rotateStackUp(unsigned _items)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _items)
rotateStackUp	libsolidity/codegen/CompilerUtils.h	/^	void rotateStackUp(unsigned _items);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _items)
roundUpFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::roundUpFunction()$/;"	f	class:ABIFunctions	signature:()
roundUpFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string roundUpFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
run	libdevcore/Algorithms.h	/^	BreadthFirstSearch& run(ForEachChild&& _forEachChild)$/;"	f	struct:dev::BreadthFirstSearch	access:public	signature:(ForEachChild&& _forEachChild)
run	libdevcore/Algorithms.h	/^	V const* run(V const& _vertex)$/;"	f	class:dev::CycleDetector	access:public	signature:(V const& _vertex)
run	libyul/CompilabilityChecker.cpp	/^std::map<YulString, int> CompilabilityChecker::run(std::shared_ptr<Dialect> _dialect, Block const& _ast)$/;"	f	class:CompilabilityChecker	signature:(std::shared_ptr<Dialect> _dialect, Block const& _ast)
run	libyul/CompilabilityChecker.h	/^	static std::map<YulString, int> run(std::shared_ptr<Dialect> _dialect, Block const& _ast);$/;"	p	class:yul::CompilabilityChecker	access:public	signature:(std::shared_ptr<Dialect> _dialect, Block const& _ast)
run	libyul/backends/evm/EVMObjectCompiler.cpp	/^void EVMObjectCompiler::run(Object& _object, bool _optimize)$/;"	f	class:EVMObjectCompiler	signature:(Object& _object, bool _optimize)
run	libyul/backends/evm/EVMObjectCompiler.h	/^	void run(Object& _object, bool _optimize);$/;"	p	class:yul::EVMObjectCompiler	access:private	signature:(Object& _object, bool _optimize)
run	libyul/optimiser/EquivalentFunctionCombiner.cpp	/^void EquivalentFunctionCombiner::run(Block& _ast)$/;"	f	class:EquivalentFunctionCombiner	signature:(Block& _ast)
run	libyul/optimiser/EquivalentFunctionCombiner.h	/^	static void run(Block& _ast);$/;"	p	class:yul::EquivalentFunctionCombiner	access:public	signature:(Block& _ast)
run	libyul/optimiser/EquivalentFunctionDetector.h	/^	static std::map<YulString, FunctionDefinition const*> run(Block& _block)$/;"	f	class:yul::EquivalentFunctionDetector	access:public	signature:(Block& _block)
run	libyul/optimiser/ExpressionInliner.cpp	/^void ExpressionInliner::run()$/;"	f	class:ExpressionInliner	signature:()
run	libyul/optimiser/ExpressionInliner.h	/^	void run();$/;"	p	class:yul::ExpressionInliner	access:public	signature:()
run	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::run(Block& _ast)$/;"	f	class:ExpressionJoiner	signature:(Block& _ast)
run	libyul/optimiser/ExpressionJoiner.h	/^	static void run(Block& _ast);$/;"	p	class:yul::ExpressionJoiner	access:public	signature:(Block& _ast)
run	libyul/optimiser/ExpressionSimplifier.cpp	/^void ExpressionSimplifier::run(Dialect const& _dialect, Block& _ast)$/;"	f	class:ExpressionSimplifier	signature:(Dialect const& _dialect, Block& _ast)
run	libyul/optimiser/ExpressionSimplifier.h	/^	static void run(Dialect const& _dialect, Block& _ast);$/;"	p	class:yul::ExpressionSimplifier	access:public	signature:(Dialect const& _dialect, Block& _ast)
run	libyul/optimiser/FullInliner.cpp	/^void FullInliner::run()$/;"	f	class:FullInliner	signature:()
run	libyul/optimiser/FullInliner.h	/^	void run();$/;"	p	class:yul::FullInliner	access:public	signature:()
run	libyul/optimiser/RedundantAssignEliminator.cpp	/^void RedundantAssignEliminator::run(Dialect const& _dialect, Block& _ast)$/;"	f	class:RedundantAssignEliminator	signature:(Dialect const& _dialect, Block& _ast)
run	libyul/optimiser/RedundantAssignEliminator.h	/^	static void run(Dialect const& _dialect, Block& _ast);$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(Dialect const& _dialect, Block& _ast)
run	libyul/optimiser/Rematerialiser.cpp	/^void Rematerialiser::run($/;"	f	class:Rematerialiser	signature:( Dialect const& _dialect, FunctionDefinition& _function, set<YulString> _varsToAlwaysRematerialize )
run	libyul/optimiser/Rematerialiser.cpp	/^void Rematerialiser::run(Dialect const& _dialect, Block& _ast, set<YulString> _varsToAlwaysRematerialize)$/;"	f	class:Rematerialiser	signature:(Dialect const& _dialect, Block& _ast, set<YulString> _varsToAlwaysRematerialize)
run	libyul/optimiser/Rematerialiser.h	/^	static void run($/;"	p	class:yul::Rematerialiser	access:public	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> _varsToAlwaysRematerialize = {} )
run	libyul/optimiser/Rematerialiser.h	/^	static void run($/;"	p	class:yul::Rematerialiser	access:public	signature:( Dialect const& _dialect, FunctionDefinition& _function, std::set<YulString> _varsToAlwaysRematerialize = {} )
run	libyul/optimiser/SSAReverser.cpp	/^void SSAReverser::run(Block& _block)$/;"	f	class:SSAReverser	signature:(Block& _block)
run	libyul/optimiser/SSAReverser.h	/^	static void run(Block& _block);$/;"	p	class:yul::SSAReverser	access:public	signature:(Block& _block)
run	libyul/optimiser/SSATransform.cpp	/^void SSATransform::run(Block& _ast, NameDispenser& _nameDispenser)$/;"	f	class:SSATransform	signature:(Block& _ast, NameDispenser& _nameDispenser)
run	libyul/optimiser/SSATransform.h	/^	static void run(Block& _ast, NameDispenser& _nameDispenser);$/;"	p	class:yul::SSATransform	access:public	signature:(Block& _ast, NameDispenser& _nameDispenser)
run	libyul/optimiser/StackCompressor.cpp	/^bool StackCompressor::run(shared_ptr<Dialect> const& _dialect, Block& _ast)$/;"	f	class:StackCompressor	signature:(shared_ptr<Dialect> const& _dialect, Block& _ast)
run	libyul/optimiser/StackCompressor.h	/^	static bool run(std::shared_ptr<Dialect> const& _dialect, Block& _ast);$/;"	p	class:yul::StackCompressor	access:public	signature:(std::shared_ptr<Dialect> const& _dialect, Block& _ast)
run	libyul/optimiser/Suite.cpp	/^void OptimiserSuite::run($/;"	f	class:OptimiserSuite	signature:( shared_ptr<Dialect> const& _dialect, Block& _ast, AsmAnalysisInfo const& _analysisInfo, set<YulString> const& _externallyUsedIdentifiers )
run	libyul/optimiser/Suite.h	/^	static void run($/;"	p	class:yul::OptimiserSuite	access:public	signature:( std::shared_ptr<Dialect> const& _dialect, Block& _ast, AsmAnalysisInfo const& _analysisInfo, std::set<YulString> const& _externallyUsedIdentifiers = {} )
runCSE	libevmasm/Assembly.h	/^		bool runCSE = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
runCSE	libsolidity/interface/OptimiserSettings.h	/^	bool runCSE = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runConstantOptimiser	libevmasm/Assembly.h	/^		bool runConstantOptimiser = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
runConstantOptimiser	libsolidity/interface/OptimiserSettings.h	/^	bool runConstantOptimiser = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runDeduplicate	libevmasm/Assembly.h	/^		bool runDeduplicate = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
runDeduplicate	libsolidity/interface/OptimiserSettings.h	/^	bool runDeduplicate = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runGas	libevmasm/GasMeter.cpp	/^unsigned GasMeter::runGas(Instruction _instruction)$/;"	f	class:GasMeter	signature:(Instruction _instruction)
runGas	libevmasm/GasMeter.h	/^	static unsigned runGas(Instruction _instruction);$/;"	p	class:dev::eth::GasMeter	access:public	signature:(Instruction _instruction)
runJumpdestRemover	libevmasm/Assembly.h	/^		bool runJumpdestRemover = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
runJumpdestRemover	libsolidity/interface/OptimiserSettings.h	/^	bool runJumpdestRemover = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runOrderLiterals	libsolidity/interface/OptimiserSettings.h	/^	bool runOrderLiterals = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runPeephole	libevmasm/Assembly.h	/^		bool runPeephole = false;$/;"	m	struct:dev::eth::Assembly::OptimiserSettings	access:public
runPeephole	libsolidity/interface/OptimiserSettings.h	/^	bool runPeephole = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runUntilStabilised	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::runUntilStabilised($/;"	f	class:UnusedPruner	signature:( Dialect const& _dialect, Block& _ast, set<YulString> const& _externallyUsedFunctions )
runUntilStabilised	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::runUntilStabilised($/;"	f	class:UnusedPruner	signature:( Dialect const& _dialect, FunctionDefinition& _function, set<YulString> const& _externallyUsedFunctions )
runUntilStabilised	libyul/optimiser/UnusedPruner.h	/^	static void runUntilStabilised($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> const& _externallyUsedFunctions = {} )
runUntilStabilised	libyul/optimiser/UnusedPruner.h	/^	static void runUntilStabilised($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, FunctionDefinition& _functionDefinition, std::set<YulString> const& _externallyUsedFunctions = {} )
runYulOptimiser	libsolidity/interface/OptimiserSettings.h	/^	bool runYulOptimiser = false;$/;"	m	struct:dev::solidity::OptimiserSettings	access:public
runs	libevmasm/ConstantOptimiser.h	/^		size_t runs; \/\/\/< Estimated number of calls per opcode oven the lifetime of the contract.$/;"	m	struct:dev::eth::ConstantOptimisationMethod::Params	access:public
runtimeAssemblyItems	libsolidity/codegen/Compiler.h	/^	eth::AssemblyItems const& runtimeAssemblyItems() const { return m_context.assembly().sub(m_runtimeSub).items(); }$/;"	f	class:dev::solidity::Compiler::eth	access:public	signature:() const
runtimeAssemblyItems	libsolidity/interface/CompilerStack.cpp	/^eth::AssemblyItems const* CompilerStack::runtimeAssemblyItems(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
runtimeAssemblyItems	libsolidity/interface/CompilerStack.h	/^	eth::AssemblyItems const* runtimeAssemblyItems(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
runtimeAssemblyPtr	libsolidity/codegen/Compiler.cpp	/^std::shared_ptr<eth::Assembly> Compiler::runtimeAssemblyPtr() const$/;"	f	class:Compiler	signature:() const
runtimeAssemblyPtr	libsolidity/codegen/Compiler.h	/^	std::shared_ptr<eth::Assembly> runtimeAssemblyPtr() const;$/;"	p	class:dev::solidity::Compiler	access:public	signature:() const
runtimeContext	libsolidity/codegen/CompilerContext.h	/^	CompilerContext* runtimeContext() const { return m_runtimeContext; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
runtimeObject	libsolidity/codegen/Compiler.h	/^	eth::LinkerObject runtimeObject() const { return m_context.assembledRuntimeObject(m_runtimeSub); }$/;"	f	class:dev::solidity::Compiler	access:public	signature:() const
runtimeObject	libsolidity/interface/CompilerStack.cpp	/^eth::LinkerObject const& CompilerStack::runtimeObject(string const& _contractName) const$/;"	f	class:eth::CompilerStack	signature:(string const& _contractName) const
runtimeObject	libsolidity/interface/CompilerStack.h	/^		eth::LinkerObject runtimeObject; \/\/\/< Runtime object.$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
runtimeObject	libsolidity/interface/CompilerStack.h	/^	eth::LinkerObject const& runtimeObject(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::eth	access:public	signature:(std::string const& _contractName) const
runtimeSourceMapping	libsolidity/interface/CompilerStack.cpp	/^string const* CompilerStack::runtimeSourceMapping(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
runtimeSourceMapping	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<std::string const> runtimeSourceMapping;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
runtimeSourceMapping	libsolidity/interface/CompilerStack.h	/^	std::string const* runtimeSourceMapping(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
runtimeSub	libsolidity/codegen/CompilerContext.h	/^	size_t runtimeSub() const { return m_runtimeSub; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
s2u	libdevcore/Common.h	/^inline u256 s2u(s256 _u)$/;"	f	namespace:dev	signature:(s256 _u)
sanitizePath	libdevcore/CommonIO.cpp	/^string dev::sanitizePath(string const& _path) {$/;"	f	class:dev	signature:(string const& _path)
sanitizePath	libdevcore/CommonIO.h	/^std::string sanitizePath(std::string const& _path);$/;"	p	namespace:dev	signature:(std::string const& _path)
scanDecimalDigits	liblangutil/Scanner.cpp	/^void Scanner::scanDecimalDigits()$/;"	f	class:langutil::Scanner	signature:()
scanDecimalDigits	liblangutil/Scanner.h	/^	void scanDecimalDigits();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanEscape	liblangutil/Scanner.cpp	/^bool Scanner::scanEscape()$/;"	f	class:langutil::Scanner	signature:()
scanEscape	liblangutil/Scanner.h	/^	bool scanEscape();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanHexByte	liblangutil/Scanner.cpp	/^bool Scanner::scanHexByte(char& o_scannedByte)$/;"	f	class:langutil::Scanner	signature:(char& o_scannedByte)
scanHexByte	liblangutil/Scanner.h	/^	bool scanHexByte(char& o_scannedByte);$/;"	p	class:langutil::Scanner	access:private	signature:(char& o_scannedByte)
scanHexString	liblangutil/Scanner.cpp	/^Token Scanner::scanHexString()$/;"	f	class:langutil::Scanner	signature:()
scanHexString	liblangutil/Scanner.h	/^	Token scanHexString();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanIdentifierOrKeyword	liblangutil/Scanner.cpp	/^tuple<Token, unsigned, unsigned> Scanner::scanIdentifierOrKeyword()$/;"	f	class:langutil::Scanner	signature:()
scanIdentifierOrKeyword	liblangutil/Scanner.h	/^	std::tuple<Token, unsigned, unsigned> scanIdentifierOrKeyword();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanMultiLineDocComment	liblangutil/Scanner.cpp	/^Token Scanner::scanMultiLineDocComment()$/;"	f	class:langutil::Scanner	signature:()
scanMultiLineDocComment	liblangutil/Scanner.h	/^	Token scanMultiLineDocComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanNumber	liblangutil/Scanner.cpp	/^Token Scanner::scanNumber(char _charSeen)$/;"	f	class:langutil::Scanner	signature:(char _charSeen)
scanNumber	liblangutil/Scanner.h	/^	Token scanNumber(char _charSeen = 0);$/;"	p	class:langutil::Scanner	access:private	signature:(char _charSeen = 0)
scanSingleLineDocComment	liblangutil/Scanner.cpp	/^Token Scanner::scanSingleLineDocComment()$/;"	f	class:langutil::Scanner	signature:()
scanSingleLineDocComment	liblangutil/Scanner.h	/^	Token scanSingleLineDocComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanSlash	liblangutil/Scanner.cpp	/^Token Scanner::scanSlash()$/;"	f	class:langutil::Scanner	signature:()
scanSlash	liblangutil/Scanner.h	/^	Token scanSlash();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanString	liblangutil/Scanner.cpp	/^Token Scanner::scanString()$/;"	f	class:langutil::Scanner	signature:()
scanString	liblangutil/Scanner.h	/^	Token scanString();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanToken	liblangutil/Scanner.cpp	/^void Scanner::scanToken()$/;"	f	class:langutil::Scanner	signature:()
scanToken	liblangutil/Scanner.h	/^	void scanToken();$/;"	p	class:langutil::Scanner	access:private	signature:()
scanUnicode	liblangutil/Scanner.cpp	/^bool Scanner::scanUnicode(unsigned & o_codepoint)$/;"	f	class:langutil::Scanner	signature:(unsigned & o_codepoint)
scanUnicode	liblangutil/Scanner.h	/^	bool scanUnicode(unsigned& o_codepoint);$/;"	p	class:langutil::Scanner	access:private	signature:(unsigned& o_codepoint)
scanner	libsolidity/interface/CompilerStack.cpp	/^Scanner const& CompilerStack::scanner(string const& _sourceName) const$/;"	f	class:CompilerStack	signature:(string const& _sourceName) const
scanner	libsolidity/interface/CompilerStack.h	/^		std::shared_ptr<langutil::Scanner> scanner;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
scanner	libsolidity/interface/CompilerStack.h	/^	langutil::Scanner const& scanner(std::string const& _sourceName) const;$/;"	p	class:dev::solidity::CompilerStack::langutil	access:public	signature:(std::string const& _sourceName) const
scanner	libyul/AssemblyStack.cpp	/^Scanner const& AssemblyStack::scanner() const$/;"	f	class:AssemblyStack	signature:() const
scanner	libyul/AssemblyStack.h	/^	langutil::Scanner const& scanner() const;$/;"	p	class:yul::AssemblyStack::langutil	access:public	signature:() const
scope	libsolidity/ast/AST.h	/^	ASTNode const* scope() const { return m_scope; }$/;"	f	class:dev::solidity::Scopable	access:public	signature:() const
scope	libyul/AsmAnalysis.cpp	/^Scope& AsmAnalyzer::scope(Block const* _block)$/;"	f	class:AsmAnalyzer	signature:(Block const* _block)
scope	libyul/AsmAnalysis.h	/^	Scope& scope(Block const* _block);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(Block const* _block)
scope	libyul/AsmScopeFiller.cpp	/^Scope& ScopeFiller::scope(Block const* _block)$/;"	f	class:ScopeFiller	signature:(Block const* _block)
scope	libyul/AsmScopeFiller.h	/^	Scope& scope(Block const* _block);$/;"	p	class:yul::ScopeFiller	access:private	signature:(Block const* _block)
scopeSpecifier	solse/SymExecEngine.cpp	/^const std::string SymExecEngine::scopeSpecifier = "$";$/;"	m	class:SymExecEngine	file:
scopeSpecifier	solse/SymExecEngine.h	/^    static const std::string scopeSpecifier;$/;"	m	class:SymExecEngine	access:private
secondNumber	liblangutil/Token.h	/^	unsigned int secondNumber() const { return m_secondNumber; }$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:() const
secondary	liblangutil/SourceReferenceExtractor.h	/^		std::vector<SourceReference> secondary;$/;"	m	struct:langutil::SourceReferenceExtractor::Message	access:public
secondaryColored	liblangutil/SourceReferenceFormatterHuman.cpp	/^AnsiColorized SourceReferenceFormatterHuman::secondaryColored() const$/;"	f	class:SourceReferenceFormatterHuman	signature:() const
secondaryColored	liblangutil/SourceReferenceFormatterHuman.h	/^	dev::AnsiColorized secondaryColored() const;$/;"	p	class:langutil::SourceReferenceFormatterHuman	access:private	signature:() const
select	libsolidity/formal/SolverInterface.h	/^	static Expression select(Expression _array, Expression _index)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _array, Expression _index)
selectErrorToken	liblangutil/Scanner.h	/^	inline Token selectErrorToken(ScannerError _err) { advance(); return setError(_err); }$/;"	f	class:langutil::Scanner	access:private	signature:(ScannerError _err)
selectToken	liblangutil/Scanner.cpp	/^Token Scanner::selectToken(char _next, Token _then, Token _else)$/;"	f	class:langutil::Scanner	signature:(char _next, Token _then, Token _else)
selectToken	liblangutil/Scanner.h	/^	inline Token selectToken(Token _tok) { advance(); return _tok; }$/;"	f	class:langutil::Scanner	access:private	signature:(Token _tok)
selectToken	liblangutil/Scanner.h	/^	inline Token selectToken(char _next, Token _then, Token _else);$/;"	p	class:langutil::Scanner	access:private	signature:(char _next, Token _then, Token _else)
selfType	libsolidity/ast/Types.cpp	/^TypePointer const& FunctionType::selfType() const$/;"	f	class:FunctionType	signature:() const
selfType	libsolidity/ast/Types.h	/^	TypePointer const& selfType() const;$/;"	p	class:dev::solidity::FunctionType	access:public	signature:() const
selfdestructGas	libevmasm/GasMeter.h	/^	inline unsigned selfdestructGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
selfdestructRefundGas	libevmasm/GasMeter.h	/^	static unsigned const selfdestructRefundGas = 24000;$/;"	m	namespace:dev::eth::GasCosts
sequenceNumber	libevmasm/ExpressionClasses.h	/^		unsigned sequenceNumber = 0;$/;"	m	struct:dev::eth::ExpressionClasses::Expression	access:public
sequenceNumber	libevmasm/KnownState.h	/^	unsigned sequenceNumber() const { return m_sequenceNumber; }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
serr	solse/CommandLineInterface.cpp	/^std::ostream& serr(bool _used = true)$/;"	f	namespace:dev::solidity	signature:(bool _used = true)
setCurrentContract	libsolidity/analysis/GlobalContext.cpp	/^void GlobalContext::setCurrentContract(ContractDefinition const& _contract)$/;"	f	class:dev::solidity::GlobalContext	signature:(ContractDefinition const& _contract)
setCurrentContract	libsolidity/analysis/GlobalContext.h	/^	void setCurrentContract(ContractDefinition const& _contract);$/;"	p	class:dev::solidity::GlobalContext	access:public	signature:(ContractDefinition const& _contract)
setCurrentObject	libyul/backends/evm/EVMDialect.cpp	/^void EVMDialect::setCurrentObject(Object const* _object)$/;"	f	class:EVMDialect	signature:(Object const* _object)
setCurrentObject	libyul/backends/evm/EVMDialect.h	/^	void setCurrentObject(Object const* _object);$/;"	p	struct:yul::EVMDialect	access:public	signature:(Object const* _object)
setData	libevmasm/AssemblyItem.h	/^	void setData(u256 const& _data) { assertThrow(m_type != Operation, Exception, ""); m_data = std::make_shared<u256>(_data); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(u256 const& _data)
setDebugMode	solse/SolidityExprTranslator.cpp	/^setDebugMode(bool mode) {$/;"	f	class:SolidityExprTranslator	signature:(bool mode)
setDebugMode	solse/SolidityExprTranslator.h	/^    void setDebugMode(bool mode);$/;"	p	class:SolidityExprTranslator	access:public	signature:(bool mode)
setDeposit	libevmasm/Assembly.h	/^	void setDeposit(int _deposit) { m_deposit = _deposit; assertThrow(m_deposit >= 0, InvalidDeposit, ""); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(int _deposit)
setEVMVersion	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setEVMVersion(langutil::EVMVersion _version)$/;"	f	class:CompilerStack	signature:(langutil::EVMVersion _version)
setEVMVersion	libsolidity/interface/CompilerStack.h	/^	void setEVMVersion(langutil::EVMVersion _version = langutil::EVMVersion{});$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(langutil::EVMVersion _version = langutil::EVMVersion{})
setEndPositionFromNode	libsolidity/parsing/Parser.cpp	/^	void setEndPositionFromNode(ASTPointer<ASTNode> const& _node) { m_location.end = _node->location().end; }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(ASTPointer<ASTNode> const& _node)
setExperimentalFeatures	libsolidity/codegen/CompilerContext.h	/^	void setExperimentalFeatures(std::set<ExperimentalFeature> const& _features) { m_experimentalFeatures = _features; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::set<ExperimentalFeature> const& _features)
setInheritanceHierarchy	libsolidity/codegen/CompilerContext.h	/^	void setInheritanceHierarchy(std::vector<ContractDefinition const*> const& _hierarchy) { m_inheritanceHierarchy = _hierarchy; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::vector<ContractDefinition const*> const& _hierarchy)
setJsonNode	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::setJsonNode($/;"	f	class:dev::solidity::ASTJsonConverter	signature:( ASTNode const& _node, string const& _nodeName, initializer_list<pair<string, Json::Value>>&& _attributes )
setJsonNode	libsolidity/ast/ASTJsonConverter.cpp	/^void ASTJsonConverter::setJsonNode($/;"	f	class:dev::solidity::ASTJsonConverter	signature:( ASTNode const& _node, string const& _nodeType, std::vector<pair<string, Json::Value>>&& _attributes )
setJsonNode	libsolidity/ast/ASTJsonConverter.h	/^	void setJsonNode($/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:( ASTNode const& _node, std::string const& _nodeName, std::initializer_list<std::pair<std::string, Json::Value>>&& _attributes )
setJsonNode	libsolidity/ast/ASTJsonConverter.h	/^	void setJsonNode($/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:( ASTNode const& _node, std::string const& _nodeName, std::vector<std::pair<std::string, Json::Value>>&& _attributes )
setJumpType	libevmasm/AssemblyItem.h	/^	void setJumpType(JumpType _jumpType) { m_jumpType = _jumpType; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(JumpType _jumpType)
setLValue	libsolidity/codegen/ExpressionCompiler.h	/^	void setLValue(Expression const& _expression, _Arguments const&... _arguments);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Expression const& _expression, _Arguments const&... _arguments)
setLValue	libsolidity/codegen/ExpressionCompiler.h	/^void ExpressionCompiler::setLValue(Expression const& _expression, _Arguments const&... _arguments)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Expression const& _expression, _Arguments const&... _arguments)
setLValueFromDeclaration	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::setLValueFromDeclaration(Declaration const& _declaration, Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Declaration const& _declaration, Expression const& _expression)
setLValueFromDeclaration	libsolidity/codegen/ExpressionCompiler.h	/^	void setLValueFromDeclaration(Declaration const& _declaration, Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Declaration const& _declaration, Expression const& _expression)
setLValueToStorageItem	libsolidity/codegen/ExpressionCompiler.cpp	/^void ExpressionCompiler::setLValueToStorageItem(Expression const& _expression)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Expression const& _expression)
setLValueToStorageItem	libsolidity/codegen/ExpressionCompiler.h	/^	void setLValueToStorageItem(Expression const& _expression);$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:(Expression const& _expression)
setLabelToCurrentPosition	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::setLabelToCurrentPosition(LabelID _labelId)$/;"	f	class:EVMAssembly	signature:(LabelID _labelId)
setLabelToCurrentPosition	libyul/backends/evm/EVMAssembly.h	/^	void setLabelToCurrentPosition(AbstractAssembly::LabelID _labelId);$/;"	p	class:yul::EVMAssembly	access:private	signature:(AbstractAssembly::LabelID _labelId)
setLibraries	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setLibraries(std::map<std::string, h160> const& _libraries)$/;"	f	class:CompilerStack	signature:(std::map<std::string, h160> const& _libraries)
setLibraries	libsolidity/interface/CompilerStack.h	/^	void setLibraries(std::map<std::string, h160> const& _libraries = std::map<std::string, h160>{});$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::map<std::string, h160> const& _libraries = std::map<std::string, h160>{})
setLocation	libevmasm/AssemblyItem.h	/^	void setLocation(langutil::SourceLocation const& _location) { m_location = _location; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(langutil::SourceLocation const& _location)
setLocation	libsolidity/parsing/Parser.cpp	/^	void setLocation(SourceLocation const& _location) { m_location = _location; }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:(SourceLocation const& _location)
setLocationEmpty	libsolidity/parsing/Parser.cpp	/^	void setLocationEmpty() { m_location.end = m_location.start; }$/;"	f	class:dev::solidity::Parser::ASTNodeFactory	access:public	signature:()
setMatchGroup	libevmasm/SimplificationRules.cpp	/^void Pattern::setMatchGroup(unsigned _group, map<unsigned, Expression const*>& _matchGroups)$/;"	f	class:Pattern	signature:(unsigned _group, map<unsigned, Expression const*>& _matchGroups)
setMatchGroup	libevmasm/SimplificationRules.h	/^	void setMatchGroup(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups);$/;"	p	class:dev::eth::Pattern	access:public	signature:(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups)
setMatchGroup	libyul/optimiser/SimplificationRules.cpp	/^void Pattern::setMatchGroup(unsigned _group, map<unsigned, Expression const*>& _matchGroups)$/;"	f	class:Pattern	signature:(unsigned _group, map<unsigned, Expression const*>& _matchGroups)
setMatchGroup	libyul/optimiser/SimplificationRules.h	/^	void setMatchGroup(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups);$/;"	p	class:yul::Pattern	access:public	signature:(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups)
setOptimiserSettings	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setOptimiserSettings(OptimiserSettings _settings)$/;"	f	class:CompilerStack	signature:(OptimiserSettings _settings)
setOptimiserSettings	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setOptimiserSettings(bool _optimize, unsigned _runs)$/;"	f	class:CompilerStack	signature:(bool _optimize, unsigned _runs)
setOptimiserSettings	libsolidity/interface/CompilerStack.h	/^	void setOptimiserSettings(OptimiserSettings _settings);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(OptimiserSettings _settings)
setOptimiserSettings	libsolidity/interface/CompilerStack.h	/^	void setOptimiserSettings(bool _optimize, unsigned _runs = 200);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(bool _optimize, unsigned _runs = 200)
setOtherCompilers	libsolidity/codegen/CompilerContext.h	/^	void setOtherCompilers(std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers) { m_otherCompilers = _otherCompilers; }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(std::map<ContractDefinition const*, std::shared_ptr<Compiler const>> const& _otherCompilers)
setPrevLinks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::setPrevLinks()$/;"	f	class:ControlFlowGraph	signature:()
setPrevLinks	libevmasm/ControlFlowGraph.h	/^	void setPrevLinks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
setPushTagSubIdAndTag	libevmasm/AssemblyItem.cpp	/^void AssemblyItem::setPushTagSubIdAndTag(size_t _subId, size_t _tag)$/;"	f	class:AssemblyItem	signature:(size_t _subId, size_t _tag)
setPushTagSubIdAndTag	libevmasm/AssemblyItem.h	/^	void setPushTagSubIdAndTag(size_t _subId, size_t _tag);$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(size_t _subId, size_t _tag)
setPushedValue	libevmasm/AssemblyItem.h	/^	void setPushedValue(u256 const& _value) const { m_pushedValue = std::make_shared<u256>(_value); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:(u256 const& _value) const
setRemappings	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::setRemappings(vector<Remapping> const& _remappings)$/;"	f	class:CompilerStack	signature:(vector<Remapping> const& _remappings)
setRemappings	libsolidity/interface/CompilerStack.h	/^	void setRemappings(std::vector<Remapping> const& _remappings);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(std::vector<Remapping> const& _remappings)
setRequestedContractNames	libsolidity/interface/CompilerStack.h	/^	void setRequestedContractNames(std::set<std::string> const& _contractNames = std::set<std::string>{}) {$/;"	f	class:dev::solidity::CompilerStack	access:public	signature:(std::set<std::string> const& _contractNames = std::set<std::string>{})
setScope	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::setScope(ASTNode const* _node)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTNode const* _node)
setScope	libsolidity/analysis/NameAndTypeResolver.h	/^	void setScope(ASTNode const* _node);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTNode const* _node)
setScope	libsolidity/ast/AST.h	/^	void setScope(ASTNode const* _scope) { m_scope = _scope; }$/;"	f	class:dev::solidity::Scopable	access:public	signature:(ASTNode const* _scope)
setSourceLocation	libevmasm/Assembly.h	/^	void setSourceLocation(langutil::SourceLocation const& _location) { m_currentSourceLocation = _location; }$/;"	f	class:dev::eth::Assembly	access:public	signature:(langutil::SourceLocation const& _location)
setSourceLocation	libyul/backends/evm/AbstractAssembly.h	/^	virtual void setSourceLocation(langutil::SourceLocation const& _location) = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:(langutil::SourceLocation const& _location)
setSourceLocation	libyul/backends/evm/AsmCodeGen.cpp	/^void EthAssemblyAdapter::setSourceLocation(SourceLocation const& _location)$/;"	f	class:EthAssemblyAdapter	signature:(SourceLocation const& _location)
setSourceLocation	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::setSourceLocation(SourceLocation const&)$/;"	f	class:EVMAssembly	signature:(SourceLocation const&)
setStackElement	libevmasm/KnownState.cpp	/^void KnownState::setStackElement(int _stackHeight, Id _class)$/;"	f	class:KnownState	signature:(int _stackHeight, Id _class)
setStackElement	libevmasm/KnownState.h	/^	void setStackElement(int _stackHeight, Id _class);$/;"	p	class:dev::eth::KnownState	access:private	signature:(int _stackHeight, Id _class)
setStackOffset	libsolidity/codegen/CompilerContext.h	/^	void setStackOffset(int _offset) { m_asm->setDeposit(_offset); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:(int _offset)
setSubIDs	libyul/backends/evm/EVMDialect.cpp	/^void EVMDialect::setSubIDs(map<YulString, AbstractAssembly::SubID> _subIDs)$/;"	f	class:EVMDialect	signature:(map<YulString, AbstractAssembly::SubID> _subIDs)
setSubIDs	libyul/backends/evm/EVMDialect.h	/^	void setSubIDs(std::map<YulString, AbstractAssembly::SubID> _subIDs);$/;"	p	struct:yul::EVMDialect	access:public	signature:(std::map<YulString, AbstractAssembly::SubID> _subIDs)
setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicUnknownValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicUnknownValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicUnknownValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
setSymbolicUnknownValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicUnknownValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicZeroValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.cpp	/^void dev::solidity::smt::setSymbolicZeroValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)$/;"	f	class:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicZeroValue(SymbolicVariable const& _variable, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(SymbolicVariable const& _variable, smt::SolverInterface& _interface)
setSymbolicZeroValue	libsolidity/formal/SymbolicTypes.h	/^void setSymbolicZeroValue(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface);$/;"	p	namespace:dev::solidity::smt	signature:(smt::Expression _expr, TypePointer const& _type, smt::SolverInterface& _interface)
setToZero	libsolidity/codegen/LValue.cpp	/^void MemoryItem::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:MemoryItem	signature:(SourceLocation const&, bool _removeReference) const
setToZero	libsolidity/codegen/LValue.cpp	/^void StackVariable::setToZero(SourceLocation const& _location, bool) const$/;"	f	class:StackVariable	signature:(SourceLocation const& _location, bool) const
setToZero	libsolidity/codegen/LValue.cpp	/^void StorageArrayLength::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:StorageArrayLength	signature:(SourceLocation const&, bool _removeReference) const
setToZero	libsolidity/codegen/LValue.cpp	/^void StorageByteArrayElement::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:StorageByteArrayElement	signature:(SourceLocation const&, bool _removeReference) const
setToZero	libsolidity/codegen/LValue.cpp	/^void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const$/;"	f	class:StorageItem	signature:(SourceLocation const&, bool _removeReference) const
setToZero	libsolidity/codegen/LValue.cpp	/^void TupleObject::setToZero(SourceLocation const&, bool) const$/;"	f	class:TupleObject	signature:(SourceLocation const&, bool) const
setToZero	libsolidity/codegen/LValue.h	/^	virtual void setToZero($/;"	p	class:dev::solidity::LValue	access:public	signature:( langutil::SourceLocation const& _location = {}, bool _removeReference = true ) const
setType	libsolidity/analysis/ConstantEvaluator.cpp	/^void ConstantEvaluator::setType(ASTNode const& _node, TypePointer const& _type)$/;"	f	class:ConstantEvaluator	signature:(ASTNode const& _node, TypePointer const& _type)
setType	libsolidity/analysis/ConstantEvaluator.h	/^	void setType(ASTNode const& _node, TypePointer const& _type);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(ASTNode const& _node, TypePointer const& _type)
setUnknownValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setUnknownValue(SymbolicVariable& _variable)$/;"	f	class:SMTChecker	signature:(SymbolicVariable& _variable)
setUnknownValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setUnknownValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
setUnknownValue	libsolidity/formal/SMTChecker.h	/^	void setUnknownValue(SymbolicVariable& _variable);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(SymbolicVariable& _variable)
setUnknownValue	libsolidity/formal/SMTChecker.h	/^	void setUnknownValue(VariableDeclaration const& decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& decl)
setValue	libyul/optimiser/SSAValueTracker.cpp	/^void SSAValueTracker::setValue(YulString _name, Expression const* _value)$/;"	f	class:SSAValueTracker	signature:(YulString _name, Expression const* _value)
setValue	libyul/optimiser/SSAValueTracker.h	/^	void setValue(YulString _name, Expression const* _value);$/;"	p	class:yul::SSAValueTracker	access:private	signature:(YulString _name, Expression const* _value)
setZeroValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setZeroValue(SymbolicVariable& _variable)$/;"	f	class:SMTChecker	signature:(SymbolicVariable& _variable)
setZeroValue	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::setZeroValue(VariableDeclaration const& _decl)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl)
setZeroValue	libsolidity/formal/SMTChecker.h	/^	void setZeroValue(SymbolicVariable& _variable);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(SymbolicVariable& _variable)
setZeroValue	libsolidity/formal/SMTChecker.h	/^	void setZeroValue(VariableDeclaration const& _decl);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl)
shallInline	libyul/optimiser/FullInliner.cpp	/^bool FullInliner::shallInline(FunctionCall const& _funCall, YulString _callSite)$/;"	f	class:FullInliner	signature:(FunctionCall const& _funCall, YulString _callSite)
shallInline	libyul/optimiser/FullInliner.h	/^	bool shallInline(FunctionCall const& _funCall, YulString _callSite);$/;"	p	class:yul::FullInliner	access:public	signature:(FunctionCall const& _funCall, YulString _callSite)
shiftLeftFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::shiftLeftFunction(size_t _numBits)$/;"	f	class:ABIFunctions	signature:(size_t _numBits)
shiftLeftFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string shiftLeftFunction(size_t _numBits);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(size_t _numBits)
shiftRightFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::shiftRightFunction(size_t _numBits)$/;"	f	class:ABIFunctions	signature:(size_t _numBits)
shiftRightFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string shiftRightFunction(size_t _numBits);$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:(size_t _numBits)
shouldRunAgain	libyul/optimiser/UnusedPruner.h	/^	bool shouldRunAgain() const { return m_shouldRunAgain; }$/;"	f	class:yul::UnusedPruner	access:public	signature:() const
sideEffects	libevmasm/Instruction.h	/^	bool sideEffects;	\/\/\/< false if the only effect on the execution environment (apart from gas usage) is a change to a topmost segment of the stack$/;"	m	struct:dev::solidity::Instruction::InstructionInfo	access:public
signatureInExternalFunction	libsolidity/ast/Types.cpp	/^string ArrayType::signatureInExternalFunction(bool _structsByName) const$/;"	f	class:ArrayType	signature:(bool _structsByName) const
signatureInExternalFunction	libsolidity/ast/Types.cpp	/^string StructType::signatureInExternalFunction(bool _structsByName) const$/;"	f	class:StructType	signature:(bool _structsByName) const
signatureInExternalFunction	libsolidity/ast/Types.h	/^	virtual std::string signatureInExternalFunction(bool \/*_structsByName*\/) const$/;"	f	class:dev::solidity::Type	access:public	signature:(bool ) const
similarNameSuggestions	libsolidity/analysis/NameAndTypeResolver.cpp	/^string NameAndTypeResolver::similarNameSuggestions(ASTString const& _name) const$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(ASTString const& _name) const
similarNameSuggestions	libsolidity/analysis/NameAndTypeResolver.h	/^	std::string similarNameSuggestions(ASTString const& _name) const;$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(ASTString const& _name) const
similarNames	libsolidity/analysis/DeclarationContainer.cpp	/^vector<ASTString> DeclarationContainer::similarNames(ASTString const& _name) const$/;"	f	class:DeclarationContainer	signature:(ASTString const& _name) const
similarNames	libsolidity/analysis/DeclarationContainer.h	/^	std::vector<ASTString> similarNames(ASTString const& _name) const;$/;"	p	class:dev::solidity::DeclarationContainer	access:public	signature:(ASTString const& _name) const
simpleRunGas	libevmasm/ConstantOptimiser.cpp	/^bigint ConstantOptimisationMethod::simpleRunGas(AssemblyItems const& _items)$/;"	f	class:ConstantOptimisationMethod	signature:(AssemblyItems const& _items)
simpleRunGas	libevmasm/ConstantOptimiser.h	/^	static bigint simpleRunGas(AssemblyItems const& _items);$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:(AssemblyItems const& _items)
simplificationRuleList	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleList($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern B, Pattern C, Pattern X, Pattern Y )
simplificationRuleListPart1	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart1($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern B, Pattern C, Pattern, Pattern )
simplificationRuleListPart2	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart2($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern Y )
simplificationRuleListPart3	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart3($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern )
simplificationRuleListPart4	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart4($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern Y )
simplificationRuleListPart5	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart5($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern )
simplificationRuleListPart6	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart6($/;"	f	namespace:dev::solidity	signature:( Pattern, Pattern, Pattern, Pattern X, Pattern Y )
simplificationRuleListPart7	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart7($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern B, Pattern, Pattern X, Pattern Y )
simplificationRuleListPart8	libevmasm/RuleList.h	/^std::vector<SimplificationRule<Pattern>> simplificationRuleListPart8($/;"	f	namespace:dev::solidity	signature:( Pattern A, Pattern, Pattern, Pattern X, Pattern Y )
simplify	libyul/optimiser/StructuralSimplifier.cpp	/^void StructuralSimplifier::simplify(std::vector<yul::Statement>& _statements)$/;"	f	class:StructuralSimplifier	signature:(std::vector<yul::Statement>& _statements)
simplify	libyul/optimiser/StructuralSimplifier.h	/^	void simplify(std::vector<Statement>& _statements);$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(std::vector<Statement>& _statements)
size	libdevcore/FixedHash.h	/^	enum { size = N };$/;"	e	enum:dev::FixedHash::__anon20
size	libdevcore/vector_ref.h	/^	size_t size() const { return m_count; }$/;"	f	class:dev::vector_ref	access:public	signature:() const
size	libevmasm/ExpressionClasses.h	/^	Id size() const { return m_representatives.size(); }$/;"	f	class:dev::eth::ExpressionClasses	access:public	signature:() const
size	solse/mechanism.h	/^		unsigned size=0;$/;"	m	class:Mechanism	access:public
sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned ArrayType::sizeOnStack() const$/;"	f	class:ArrayType	signature:() const
sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned FunctionType::sizeOnStack() const$/;"	f	class:FunctionType	signature:() const
sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned TupleType::sizeOnStack() const$/;"	f	class:TupleType	signature:() const
sizeOnStack	libsolidity/ast/Types.cpp	/^unsigned TypeType::sizeOnStack() const$/;"	f	class:TypeType	signature:() const
sizeOnStack	libsolidity/ast/Types.h	/^	virtual unsigned sizeOnStack() const { return 1; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
sizeOnStack	libsolidity/codegen/CompilerUtils.cpp	/^unsigned CompilerUtils::sizeOnStack(vector<shared_ptr<Type const>> const& _variableTypes)$/;"	f	class:dev::solidity::CompilerUtils	signature:(vector<shared_ptr<Type const>> const& _variableTypes)
sizeOnStack	libsolidity/codegen/CompilerUtils.h	/^	static unsigned sizeOnStack(std::vector<T> const& _variables);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(std::vector<T> const& _variables)
sizeOnStack	libsolidity/codegen/CompilerUtils.h	/^	static unsigned sizeOnStack(std::vector<std::shared_ptr<Type const>> const& _variableTypes);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(std::vector<std::shared_ptr<Type const>> const& _variableTypes)
sizeOnStack	libsolidity/codegen/CompilerUtils.h	/^unsigned CompilerUtils::sizeOnStack(std::vector<T> const& _variables)$/;"	f	class:dev::solidity::CompilerUtils	signature:(std::vector<T> const& _variables)
sizeOnStack	libsolidity/codegen/LValue.cpp	/^unsigned TupleObject::sizeOnStack() const$/;"	f	class:TupleObject	signature:() const
sizeOnStack	libsolidity/codegen/LValue.h	/^	virtual unsigned sizeOnStack() const { return 1; }$/;"	f	class:dev::solidity::LValue	access:public	signature:() const
skipLineOrEOS	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator skipLineOrEOS($/;"	f	namespace:__anon14	signature:( string::const_iterator _nlPos, string::const_iterator _end )
skipMultiLineComment	liblangutil/Scanner.cpp	/^Token Scanner::skipMultiLineComment()$/;"	f	class:langutil::Scanner	signature:()
skipMultiLineComment	liblangutil/Scanner.h	/^	Token skipMultiLineComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
skipSingleLineComment	liblangutil/Scanner.cpp	/^Token Scanner::skipSingleLineComment()$/;"	f	class:langutil::Scanner	signature:()
skipSingleLineComment	liblangutil/Scanner.h	/^	Token skipSingleLineComment();$/;"	p	class:langutil::Scanner	access:private	signature:()
skipWhitespace	liblangutil/Scanner.cpp	/^bool Scanner::skipWhitespace()$/;"	f	class:langutil::Scanner	signature:()
skipWhitespace	liblangutil/Scanner.h	/^	bool skipWhitespace();$/;"	p	class:langutil::Scanner	access:private	signature:()
skipWhitespace	libsolidity/parsing/DocStringParser.cpp	/^string::const_iterator skipWhitespace($/;"	f	namespace:__anon14	signature:( string::const_iterator _pos, string::const_iterator _end )
skipWhitespaceExceptUnicodeLinebreak	liblangutil/Scanner.cpp	/^void Scanner::skipWhitespaceExceptUnicodeLinebreak()$/;"	f	class:langutil::Scanner	signature:()
skipWhitespaceExceptUnicodeLinebreak	liblangutil/Scanner.h	/^	void skipWhitespaceExceptUnicodeLinebreak();$/;"	p	class:langutil::Scanner	access:private	signature:()
sloadGas	libevmasm/GasMeter.h	/^	inline unsigned sloadGas(langutil::EVMVersion _evmVersion)$/;"	f	namespace:dev::eth::GasCosts	signature:(langutil::EVMVersion _evmVersion)
smallestCovering	liblangutil/SourceLocation.h	/^	static SourceLocation smallestCovering(SourceLocation _a, SourceLocation const& _b)$/;"	f	struct:langutil::SourceLocation	access:public	signature:(SourceLocation _a, SourceLocation const& _b)
smt	libsolidity/formal/CVC4Interface.h	/^namespace smt$/;"	n	namespace:dev::solidity
smt	libsolidity/formal/SMTLib2Interface.h	/^namespace smt$/;"	n	namespace:dev::solidity
smt	libsolidity/formal/SMTPortfolio.h	/^namespace smt$/;"	n	namespace:dev::solidity
smt	libsolidity/formal/SolverInterface.h	/^namespace smt$/;"	n	namespace:dev::solidity
smt	libsolidity/formal/SymbolicTypes.h	/^namespace smt$/;"	n	namespace:dev::solidity
smt	libsolidity/formal/Z3Interface.h	/^namespace smt$/;"	n	namespace:dev::solidity
smtKind	libsolidity/formal/SymbolicTypes.cpp	/^smt::Kind dev::solidity::smtKind(Type::Category _category)$/;"	f	class:dev::solidity	signature:(Type::Category _category)
smtKind	libsolidity/formal/SymbolicTypes.h	/^smt::Kind smtKind(Type::Category _category);$/;"	p	namespace:dev::solidity	signature:(Type::Category _category)
smtSort	libsolidity/formal/SymbolicTypes.cpp	/^smt::SortPointer dev::solidity::smtSort(Type const& _type)$/;"	f	class:dev::solidity	signature:(Type const& _type)
smtSort	libsolidity/formal/SymbolicTypes.cpp	/^vector<smt::SortPointer> dev::solidity::smtSort(vector<TypePointer> const& _types)$/;"	f	class:dev::solidity	signature:(vector<TypePointer> const& _types)
smtSort	libsolidity/formal/SymbolicTypes.h	/^smt::SortPointer smtSort(Type const& _type);$/;"	p	namespace:dev::solidity	signature:(Type const& _type)
smtSort	libsolidity/formal/SymbolicTypes.h	/^std::vector<smt::SortPointer> smtSort(std::vector<TypePointer> const& _types);$/;"	p	namespace:dev::solidity	signature:(std::vector<TypePointer> const& _types)
solAssert	liblangutil/Exceptions.h	44;"	d
solExprTranslator	solse/SymExecEngine.h	/^    SolidityExprTranslator* solExprTranslator;$/;"	m	class:SymExecEngine	access:private
solUnimplemented	liblangutil/Exceptions.h	50;"	d
solUnimplementedAssert	liblangutil/Exceptions.h	47;"	d
sol_collusion_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<std::tuple<ASTPointer<Expression const>,ASTPointer<Expression const> >> sol_collusion_check_exprs;$/;"	m	class:ContextInfo	access:public
sol_efficient_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_efficient_check_exprs;$/;"	m	class:ContextInfo	access:public
sol_max_exps	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_max_exps;$/;"	m	class:ContextInfo	access:public
sol_min_exps	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_min_exps;$/;"	m	class:ContextInfo	access:public
sol_optimal_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_optimal_check_exprs;$/;"	m	class:ContextInfo	access:public
sol_revenue	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_revenue;$/;"	m	class:ContextInfo	access:public
sol_truth_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_truth_check_exprs;$/;"	m	class:ContextInfo	access:public
sol_utilities	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_utilities;$/;"	m	class:ContextInfo	access:public
sol_winners	solse/SolidityExprTranslator.h	/^    std::vector<ASTPointer<Expression const>> sol_winners;$/;"	m	class:ContextInfo	access:public
solidity	libevmasm/Instruction.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libevmasm/RuleList.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libevmasm/SimplificationRule.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ConstantEvaluator.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ContractLevelChecker.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ControlFlowAnalyzer.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ControlFlowBuilder.h	/^namespace solidity {$/;"	n	namespace:dev
solidity	libsolidity/analysis/ControlFlowGraph.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ControlFlowPrinter.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/DeclarationContainer.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/DocStringAnalyser.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/GlobalContext.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/analysis/GlobalContext.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/NameAndTypeResolver.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/analysis/NameAndTypeResolver.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/PostTypeChecker.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ReferencesResolver.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/analysis/ReferencesResolver.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/SemVerHandler.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/StaticAnalyzer.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/SyntaxChecker.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/TypeChecker.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/analysis/ViewPureChecker.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/AST.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ASTAnnotations.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ASTEnums.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ASTForward.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ASTJsonConverter.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/ast/ASTJsonConverter.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ASTPrinter.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/ast/ASTPrinter.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ASTVisitor.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/AST_accept.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/ExperimentalFeatures.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/ast/Types.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/codegen/ABIFunctions.h	/^namespace solidity {$/;"	n	namespace:dev
solidity	libsolidity/codegen/ArrayUtils.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/codegen/Compiler.h	/^namespace solidity {$/;"	n	namespace:dev
solidity	libsolidity/codegen/CompilerContext.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/codegen/CompilerContext.h	/^namespace solidity {$/;"	n	namespace:dev
solidity	libsolidity/codegen/CompilerUtils.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/codegen/CompilerUtils.h	/^namespace solidity {$/;"	n	namespace:dev
solidity	libsolidity/codegen/ContractCompiler.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/codegen/ExpressionCompiler.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/codegen/ExpressionCompiler.h	/^namespace solidity {$/;"	n	namespace:dev
solidity	libsolidity/codegen/LValue.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/CVC4Interface.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SMTChecker.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SMTLib2Interface.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SMTPortfolio.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SSAVariable.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SolverInterface.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SymbolicTypes.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/SymbolicVariables.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/VariableUsage.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/formal/Z3Interface.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/ABI.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/CompilerStack.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/GasEstimator.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/Natspec.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/OptimiserSettings.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/ReadFile.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/StandardCompiler.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/interface/Version.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/parsing/DocStringParser.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/parsing/Parser.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	libsolidity/parsing/Parser.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libsolidity/parsing/Token.h	/^namespace solidity$/;"	n	namespace:dev
solidity	libyul/backends/evm/AbstractAssembly.h	/^namespace solidity$/;"	n	namespace:dev
solidity	solse/CommandLineInterface.cpp	/^namespace solidity$/;"	n	namespace:dev	file:
solidity	solse/CommandLineInterface.h	/^namespace solidity$/;"	n	namespace:dev
solverAnswered	libsolidity/formal/SMTPortfolio.cpp	/^bool SMTPortfolio::solverAnswered(CheckResult result)$/;"	f	class:SMTPortfolio	signature:(CheckResult result)
solverAnswered	libsolidity/formal/SMTPortfolio.h	/^	static bool solverAnswered(CheckResult result);$/;"	p	class:dev::solidity::smt::SMTPortfolio	access:private	signature:(CheckResult result)
solvers	libsolidity/formal/SolverInterface.h	/^	virtual unsigned solvers() { return 1; }$/;"	f	class:dev::solidity::smt::SolverInterface	access:public	signature:()
sort	libsolidity/formal/SolverInterface.h	/^	SortPointer sort;$/;"	m	class:dev::solidity::smt::Expression	access:public
source	liblangutil/ParserBase.h	/^	std::shared_ptr<CharStream> source() const { return m_scanner->charStream(); }$/;"	f	class:langutil::ParserBase	access:public	signature:() const
source	liblangutil/SourceLocation.h	/^	std::shared_ptr<CharStream> source;$/;"	m	struct:langutil::SourceLocation	access:public
source	libsolidity/interface/CompilerStack.cpp	/^CompilerStack::Source const& CompilerStack::source(string const& _sourceName) const$/;"	f	class:CompilerStack::CompilerStack	signature:(string const& _sourceName) const
source	libsolidity/interface/CompilerStack.h	/^	Source const& source(std::string const& _sourceName) const;$/;"	p	class:dev::solidity::CompilerStack	access:private	signature:(std::string const& _sourceName) const
sourceAt	liblangutil/Scanner.h	/^	std::string sourceAt(SourceLocation const& _location) const$/;"	f	class:langutil::Scanner	access:public	signature:(SourceLocation const& _location) const
sourceIndices	libsolidity/interface/CompilerStack.cpp	/^map<string, unsigned> CompilerStack::sourceIndices() const$/;"	f	class:CompilerStack	signature:() const
sourceIndices	libsolidity/interface/CompilerStack.h	/^	std::map<std::string, unsigned> sourceIndices() const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:() const
sourceLocationToString	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::sourceLocationToString(SourceLocation const& _location) const$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(SourceLocation const& _location) const
sourceLocationToString	libsolidity/ast/ASTJsonConverter.h	/^	std::string sourceLocationToString(langutil::SourceLocation const& _location) const;$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(langutil::SourceLocation const& _location) const
sourceMapping	libsolidity/interface/CompilerStack.cpp	/^string const* CompilerStack::sourceMapping(string const& _contractName) const$/;"	f	class:CompilerStack	signature:(string const& _contractName) const
sourceMapping	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<std::string const> sourceMapping;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
sourceMapping	libsolidity/interface/CompilerStack.h	/^	std::string const* sourceMapping(std::string const& _contractName) const;$/;"	p	class:dev::solidity::CompilerStack::std	access:public	signature:(std::string const& _contractName) const
sourceName	liblangutil/SourceReferenceExtractor.h	/^	std::string sourceName;   \/\/\/< Underlying source name (for example the filename).$/;"	m	struct:langutil::SourceReference	access:public
sourceNames	libsolidity/interface/CompilerStack.cpp	/^vector<string> CompilerStack::sourceNames() const$/;"	f	class:CompilerStack	signature:() const
sourceNames	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> sourceNames() const;$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:() const
sourcePos	liblangutil/Scanner.h	/^	int sourcePos() const { return m_source->position(); }$/;"	f	class:langutil::Scanner	access:private	signature:() const
sourceUnit	libsolidity/ast/AST.cpp	/^SourceUnit const& Scopable::sourceUnit() const$/;"	f	class:Scopable	signature:() const
sourceUnit	libsolidity/ast/AST.h	/^	SourceUnit const& sourceUnit() const;$/;"	p	class:dev::solidity::Scopable	access:public	signature:() const
sourceUnit	libsolidity/ast/ASTAnnotations.h	/^	SourceUnit const* sourceUnit = nullptr;$/;"	m	struct:dev::solidity::ImportAnnotation	access:public
sourceUnitName	libsolidity/ast/AST.cpp	/^string Scopable::sourceUnitName() const$/;"	f	class:Scopable	signature:() const
sourceUnitName	libsolidity/ast/AST.h	/^	std::string sourceUnitName() const;$/;"	p	class:dev::solidity::Scopable	access:public	signature:() const
sout	solse/CommandLineInterface.cpp	/^std::ostream& sout()$/;"	f	namespace:dev::solidity	signature:()
splitBlocks	libevmasm/ControlFlowGraph.cpp	/^void ControlFlowGraph::splitBlocks()$/;"	f	class:ControlFlowGraph	signature:()
splitBlocks	libevmasm/ControlFlowGraph.h	/^	void splitBlocks();$/;"	p	class:dev::eth::ControlFlowGraph	access:private	signature:()
splitExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::splitExternalFunctionIdFunction()$/;"	f	class:ABIFunctions	signature:()
splitExternalFunctionIdFunction	libsolidity/codegen/ABIFunctions.h	/^	std::string splitExternalFunctionIdFunction();$/;"	p	class:dev::solidity::ABIFunctions	access:private	signature:()
splitExternalFunctionType	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::splitExternalFunctionType(bool _leftAligned)$/;"	f	class:dev::solidity::CompilerUtils	signature:(bool _leftAligned)
splitExternalFunctionType	libsolidity/codegen/CompilerUtils.h	/^	void splitExternalFunctionType(bool _rightAligned);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(bool _rightAligned)
splitFlow	libsolidity/analysis/ControlFlowBuilder.h	/^	std::array<CFGNode*, n> splitFlow()$/;"	f	class:dev::solidity::ControlFlowBuilder	access:private	signature:()
splitForeignPushTag	libevmasm/AssemblyItem.cpp	/^pair<size_t, size_t> AssemblyItem::splitForeignPushTag() const$/;"	f	class:AssemblyItem	signature:() const
splitForeignPushTag	libevmasm/AssemblyItem.h	/^	std::pair<size_t, size_t> splitForeignPushTag() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
spuriousDragon	liblangutil/EVMVersion.h	/^	static EVMVersion spuriousDragon() { return {Version::SpuriousDragon}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
sstoreRefundGas	libevmasm/GasMeter.h	/^	static unsigned const sstoreRefundGas = 15000;$/;"	m	namespace:dev::eth::GasCosts
sstoreResetGas	libevmasm/GasMeter.h	/^	static unsigned const sstoreResetGas = 5000;$/;"	m	namespace:dev::eth::GasCosts
sstoreSetGas	libevmasm/GasMeter.h	/^	static unsigned const sstoreSetGas = 20000;$/;"	m	namespace:dev::eth::GasCosts
stackElement	libevmasm/KnownState.cpp	/^ExpressionClasses::Id KnownState::stackElement(int _stackHeight, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(int _stackHeight, SourceLocation const& _location)
stackElement	libevmasm/KnownState.h	/^	Id stackElement(int _stackHeight, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:public	signature:(int _stackHeight, langutil::SourceLocation const& _location)
stackElements	libevmasm/KnownState.h	/^	std::map<int, Id> const& stackElements() const { return m_stackElements; }$/;"	f	class:dev::eth::KnownState::std	access:public	signature:() const
stackError	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::stackError(StackTooDeepError _error, int _targetStackHeight)$/;"	f	class:CodeTransform	signature:(StackTooDeepError _error, int _targetStackHeight)
stackError	libyul/backends/evm/EVMCodeTransform.h	/^	void stackError(StackTooDeepError _error, int _targetStackSize);$/;"	p	class:yul::CodeTransform	access:private	signature:(StackTooDeepError _error, int _targetStackSize)
stackErrors	libyul/backends/evm/EVMCodeTransform.h	/^	std::vector<StackTooDeepError> const& stackErrors() const { return m_stackErrors; }$/;"	f	class:yul::CodeTransform::std	access:public	signature:() const
stackHeight	libevmasm/KnownState.h	/^	int stackHeight() const { return m_stackHeight; }$/;"	f	class:dev::eth::KnownState	access:public	signature:() const
stackHeight	libsolidity/codegen/CompilerContext.h	/^	unsigned stackHeight() const { solAssert(m_asm->deposit() >= 0, ""); return unsigned(m_asm->deposit()); }$/;"	f	class:dev::solidity::CompilerContext	access:public	signature:() const
stackHeight	libsolidity/codegen/ContractCompiler.cpp	/^	unsigned stackHeight;$/;"	m	class:__anon12::StackHeightChecker	file:	access:private
stackHeight	libyul/backends/evm/AbstractAssembly.h	/^	virtual int stackHeight() const = 0;$/;"	p	class:dev::solidity::Instruction::AbstractAssembly	access:public	signature:() const
stackHeight	libyul/backends/evm/AsmCodeGen.cpp	/^int EthAssemblyAdapter::stackHeight() const$/;"	f	class:EthAssemblyAdapter	signature:() const
stackHeightInfo	libyul/AsmAnalysisInfo.h	/^	StackHeightInfo stackHeightInfo;$/;"	m	struct:yul::AsmAnalysisInfo	access:public
stackLimit	libevmasm/GasMeter.h	/^	static unsigned const stackLimit = 1024;$/;"	m	namespace:dev::eth::GasCosts
start	liblangutil/SourceLocation.h	/^	int start = -1;$/;"	m	struct:langutil::SourceLocation	access:public
startColumn	liblangutil/SourceReferenceExtractor.h	/^	int startColumn = {-1};   \/\/\/< Highlighting range-start of text field.$/;"	m	struct:langutil::SourceReference	access:public
startFunction	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::FunctionCompilationQueue::startFunction(Declaration const& _function)$/;"	f	class:dev::solidity::CompilerContext::FunctionCompilationQueue	signature:(Declaration const& _function)
startFunction	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::startFunction(Declaration const& _function)$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _function)
startFunction	libsolidity/codegen/CompilerContext.h	/^		void startFunction(Declaration const& _function);$/;"	p	struct:dev::solidity::CompilerContext::FunctionCompilationQueue	access:public	signature:(Declaration const& _function)
startFunction	libsolidity/codegen/CompilerContext.h	/^	void startFunction(Declaration const& _function);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _function)
startState	libevmasm/ControlFlowGraph.h	/^	KnownStatePointer startState;$/;"	m	struct:dev::eth::BasicBlock	access:public
start_time	solse/SymExecEngine.cpp	/^uint64_t start_time;$/;"	v
state	libevmasm/PathGasMeter.h	/^	std::shared_ptr<KnownState> state;$/;"	m	struct:dev::eth::GasPath	access:public
state	libsolidity/interface/CompilerStack.h	/^	State state() const { return m_stackState; }$/;"	f	class:dev::solidity::CompilerStack	access:public	signature:() const
stateMutability	libsolidity/ast/AST.h	/^	StateMutability stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::FunctionDefinition	access:public	signature:() const
stateMutability	libsolidity/ast/AST.h	/^	StateMutability stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
stateMutability	libsolidity/ast/AST.h	/^	boost::optional<StateMutability> const& stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::ElementaryTypeName::boost	access:public	signature:() const
stateMutability	libsolidity/ast/Types.h	/^	StateMutability stateMutability() const { return m_stateMutability; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
stateMutability	libsolidity/ast/Types.h	/^	StateMutability stateMutability(void) const { return m_stateMutability; }$/;"	f	class:dev::solidity::AddressType	access:public	signature:(void) const
stateMutability	libsolidity/parsing/Parser.h	/^		StateMutability stateMutability = StateMutability::NonPayable;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
stateMutabilityToString	libsolidity/ast/ASTEnums.h	/^inline std::string stateMutabilityToString(StateMutability const& _stateMutability)$/;"	f	namespace:dev::solidity	signature:(StateMutability const& _stateMutability)
stateVarValueZ3ExprMap	solse/SolidityExprTranslator.h	/^    std::unordered_map<std::string, z3::expr> stateVarValueZ3ExprMap;$/;"	m	class:ContextInfo	access:public
stateVarValuesZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> stateVarValuesZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
stateVarZ3ExprMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, z3::expr> stateVarZ3ExprMap;$/;"	m	class:SymExecEngine	access:private
stateVariables	libsolidity/ast/AST.h	/^	std::vector<VariableDeclaration const*> stateVariables() const { return filteredNodes<VariableDeclaration>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
stateVariables	libsolidity/ast/Types.cpp	/^vector<tuple<VariableDeclaration const*, u256, unsigned>> ContractType::stateVariables() const$/;"	f	class:ContractType	signature:() const
stateVariables	libsolidity/ast/Types.h	/^	std::vector<std::tuple<VariableDeclaration const*, u256, unsigned>> stateVariables() const;$/;"	p	class:dev::solidity::ContractType	access:public	signature:() const
state_variable_records	solse/SymExecEngine.cpp	/^ std::unordered_map<std::string, std::vector<std::string>> state_variable_records;$/;"	v
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Assignment const& _lhs, Assignment const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Assignment const& _lhs, Assignment const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Block const& _lhs, Block const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Block const& _lhs, Block const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(ForLoop const& _lhs, ForLoop const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(ForLoop const& _lhs, ForLoop const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(If const& _lhs, If const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(If const& _lhs, If const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Instruction const&, Instruction const&)$/;"	f	class:SyntacticallyEqual	signature:(Instruction const&, Instruction const&)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Label const&, Label const&)$/;"	f	class:SyntacticallyEqual	signature:(Label const&, Label const&)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(StackAssignment const&, StackAssignment const&)$/;"	f	class:SyntacticallyEqual	signature:(StackAssignment const&, StackAssignment const&)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(Switch const& _lhs, Switch const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Switch const& _lhs, Switch const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::statementEqual(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Assignment const& _lhs, Assignment const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Assignment const& _lhs, Assignment const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Block const& _lhs, Block const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Block const& _lhs, Block const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(ForLoop const& _lhs, ForLoop const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(ForLoop const& _lhs, ForLoop const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(If const& _lhs, If const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(If const& _lhs, If const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Instruction const& _lhs, Instruction const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(Instruction const& _lhs, Instruction const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Label const& _lhs, Label const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(Label const& _lhs, Label const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(StackAssignment const& _lhs, StackAssignment const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(StackAssignment const& _lhs, StackAssignment const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Switch const& _lhs, Switch const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Switch const& _lhs, Switch const& _rhs)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)$/;"	f	class:yul::SyntacticallyEqual	access:private	signature:(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)
statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs)
statements	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<Statement>> const& statements() const { return m_statements; }$/;"	f	class:dev::solidity::Block::std	access:public	signature:() const
statements	libyul/AsmData.h	/^struct Block { langutil::SourceLocation location; std::vector<Statement> statements; };$/;"	m	struct:yul::Block	access:public
static_assert	libsolidity/ast/Types.h	/^static_assert(std::is_nothrow_move_constructible<MemberList>::value, "MemberList should be noexcept move constructible");$/;"	p	namespace:dev::solidity	signature:(std::is_nothrow_move_constructible<MemberList>::value, )
std::CompilerStack::filesystemFriendlyName	libsolidity/interface/CompilerStack.cpp	/^std::string const CompilerStack::filesystemFriendlyName(string const& _contractName) const$/;"	f	class:std::CompilerStack	signature:(string const& _contractName) const
std::Parser::instructionNames	libyul/AsmParser.cpp	/^std::map<dev::solidity::Instruction, string> const& Parser::instructionNames()$/;"	f	class:std::Parser	signature:()
std::Parser::instructions	libyul/AsmParser.cpp	/^std::map<string, dev::solidity::Instruction> const& Parser::instructions()$/;"	f	class:std::Parser	signature:()
std::c_instructionInfo	libevmasm/Instruction.cpp	/^static std::map<Instruction, InstructionInfo> const c_instructionInfo =$/;"	m	class:std	file:
std::dev::solidity::c_instructions	libevmasm/Instruction.cpp	/^std::map<std::string, Instruction> const dev::solidity::c_instructions =$/;"	m	class:std::dev::solidity	file:
storageBytes	libsolidity/ast/Types.cpp	/^unsigned EnumType::storageBytes() const$/;"	f	class:EnumType	signature:() const
storageBytes	libsolidity/ast/Types.cpp	/^unsigned FunctionType::storageBytes() const$/;"	f	class:FunctionType	signature:() const
storageBytes	libsolidity/ast/Types.h	/^	virtual unsigned storageBytes() const { return 32; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
storageContent	libevmasm/KnownState.h	/^	std::map<Id, Id> const& storageContent() const { return m_storageContent; }$/;"	f	class:dev::eth::KnownState::std	access:public	signature:() const
storageLocationOfVariable	libsolidity/codegen/CompilerContext.cpp	/^pair<u256, unsigned> CompilerContext::storageLocationOfVariable(Declaration const& _declaration) const$/;"	f	class:dev::solidity::CompilerContext	signature:(Declaration const& _declaration) const
storageLocationOfVariable	libsolidity/codegen/CompilerContext.h	/^	std::pair<u256, unsigned> storageLocationOfVariable(Declaration const& _declaration) const;$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(Declaration const& _declaration) const
storageOffsetsOfMember	libsolidity/ast/Types.cpp	/^pair<u256, unsigned> const& StructType::storageOffsetsOfMember(string const& _name) const$/;"	f	class:StructType	signature:(string const& _name) const
storageOffsetsOfMember	libsolidity/ast/Types.h	/^	std::pair<u256, unsigned> const& storageOffsetsOfMember(std::string const& _name) const;$/;"	p	class:dev::solidity::StructType::std	access:public	signature:(std::string const& _name) const
storageSize	libsolidity/ast/Types.cpp	/^u256 ArrayType::storageSize() const$/;"	f	class:ArrayType	signature:() const
storageSize	libsolidity/ast/Types.cpp	/^u256 FunctionType::storageSize() const$/;"	f	class:FunctionType	signature:() const
storageSize	libsolidity/ast/Types.cpp	/^u256 ModifierType::storageSize() const$/;"	f	class:ModifierType	signature:() const
storageSize	libsolidity/ast/Types.cpp	/^u256 StructType::storageSize() const$/;"	f	class:StructType	signature:() const
storageSize	libsolidity/ast/Types.cpp	/^u256 TupleType::storageSize() const$/;"	f	class:TupleType	signature:() const
storageSize	libsolidity/ast/Types.cpp	/^u256 TypeType::storageSize() const$/;"	f	class:TypeType	signature:() const
storageSize	libsolidity/ast/Types.cpp	/^u256 const& MemberList::storageSize() const$/;"	f	class:MemberList	signature:() const
storageSize	libsolidity/ast/Types.h	/^	u256 const& storageSize() const { return m_storageSize; }$/;"	f	class:dev::solidity::StorageOffsets	access:public	signature:() const
storageSize	libsolidity/ast/Types.h	/^	u256 const& storageSize() const;$/;"	p	class:dev::solidity::MemberList	access:public	signature:() const
storageSize	libsolidity/ast/Types.h	/^	virtual u256 storageSize() const { return 1; }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
storageStride	libsolidity/ast/Types.h	/^	unsigned storageStride() const { return isByteArray() ? 1 : m_baseType->storageBytes(); }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:() const
store	libsolidity/formal/SolverInterface.h	/^	static Expression store(Expression _array, Expression _index, Expression _element)$/;"	f	class:dev::solidity::smt::Expression	access:public	signature:(Expression _array, Expression _index, Expression _element)
storeFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
storeFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void storeFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
storeInMemory	libevmasm/KnownState.cpp	/^KnownState::StoreOperation KnownState::storeInMemory(Id _slot, Id _value, SourceLocation const& _location)$/;"	f	class:KnownState	signature:(Id _slot, Id _value, SourceLocation const& _location)
storeInMemory	libevmasm/KnownState.h	/^	StoreOperation storeInMemory(Id _slot, Id _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, Id _value, langutil::SourceLocation const& _location)
storeInMemory	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeInMemory(unsigned _offset)$/;"	f	class:dev::solidity::CompilerUtils	signature:(unsigned _offset)
storeInMemory	libsolidity/codegen/CompilerUtils.h	/^	void storeInMemory(unsigned _offset);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(unsigned _offset)
storeInMemoryDynamic	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeInMemoryDynamic(Type const& _type, bool _padToWordBoundaries)$/;"	f	class:dev::solidity::CompilerUtils	signature:(Type const& _type, bool _padToWordBoundaries)
storeInMemoryDynamic	libsolidity/codegen/CompilerUtils.h	/^	void storeInMemoryDynamic(Type const& _type, bool _padToWords = true);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(Type const& _type, bool _padToWords = true)
storeInStorage	libevmasm/KnownState.cpp	/^KnownState::StoreOperation KnownState::storeInStorage($/;"	f	class:KnownState	signature:( Id _slot, Id _value, SourceLocation const& _location)
storeInStorage	libevmasm/KnownState.h	/^	StoreOperation storeInStorage(Id _slot, Id _value, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(Id _slot, Id _value, langutil::SourceLocation const& _location)
storeItem	libevmasm/ExpressionClasses.cpp	/^AssemblyItem const* ExpressionClasses::storeItem(AssemblyItem const& _item)$/;"	f	class:ExpressionClasses	signature:(AssemblyItem const& _item)
storeItem	libevmasm/ExpressionClasses.h	/^	AssemblyItem const* storeItem(AssemblyItem const& _item);$/;"	p	class:dev::eth::ExpressionClasses	access:public	signature:(AssemblyItem const& _item)
storeLength	libsolidity/codegen/ArrayUtils.h	/^	void storeLength(ArrayType const& _arrayType, unsigned _stackDepthLength = 0, unsigned _stackDepthRef = 1) const;$/;"	p	class:dev::solidity::ArrayUtils	access:public	signature:(ArrayType const& _arrayType, unsigned _stackDepthLength = 0, unsigned _stackDepthRef = 1) const
storeStackHeight	libsolidity/codegen/ContractCompiler.cpp	/^void ContractCompiler::storeStackHeight(ASTNode const* _node)$/;"	f	class:ContractCompiler	signature:(ASTNode const* _node)
storeStackHeight	libsolidity/codegen/ContractCompiler.h	/^	void storeStackHeight(ASTNode const* _node);$/;"	p	class:dev::solidity::ContractCompiler	access:private	signature:(ASTNode const* _node)
storeStringData	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::storeStringData(bytesConstRef _data)$/;"	f	class:dev::solidity::CompilerUtils	signature:(bytesConstRef _data)
storeStringData	libsolidity/codegen/CompilerUtils.h	/^	void storeStringData(bytesConstRef _data);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(bytesConstRef _data)
storeValue	libsolidity/codegen/LValue.cpp	/^void MemoryItem::storeValue(Type const& _sourceType, SourceLocation const&, bool _move) const$/;"	f	class:MemoryItem	signature:(Type const& _sourceType, SourceLocation const&, bool _move) const
storeValue	libsolidity/codegen/LValue.cpp	/^void StackVariable::storeValue(Type const&, SourceLocation const& _location, bool _move) const$/;"	f	class:StackVariable	signature:(Type const&, SourceLocation const& _location, bool _move) const
storeValue	libsolidity/codegen/LValue.cpp	/^void StorageArrayLength::storeValue(Type const&, SourceLocation const&, bool _move) const$/;"	f	class:StorageArrayLength	signature:(Type const&, SourceLocation const&, bool _move) const
storeValue	libsolidity/codegen/LValue.cpp	/^void StorageByteArrayElement::storeValue(Type const&, SourceLocation const&, bool _move) const$/;"	f	class:StorageByteArrayElement	signature:(Type const&, SourceLocation const&, bool _move) const
storeValue	libsolidity/codegen/LValue.cpp	/^void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _location, bool _move) const$/;"	f	class:StorageItem	signature:(Type const& _sourceType, SourceLocation const& _location, bool _move) const
storeValue	libsolidity/codegen/LValue.cpp	/^void TupleObject::storeValue(Type const& _sourceType, SourceLocation const& _location, bool) const$/;"	f	class:TupleObject	signature:(Type const& _sourceType, SourceLocation const& _location, bool) const
storeValue	libsolidity/codegen/LValue.h	/^	virtual void storeValue(Type const& _sourceType,$/;"	p	class:dev::solidity::LValue	access:public	signature:(Type const& _sourceType, langutil::SourceLocation const& _location = {}, bool _move = false) const
str	libyul/YulString.h	/^	std::string const& str() const$/;"	f	class:yul::YulString::std	access:public	signature:() const
stream	libevmasm/KnownState.cpp	/^ostream& KnownState::stream(ostream& _out) const$/;"	f	class:KnownState	signature:(ostream& _out) const
stream	libevmasm/KnownState.h	/^	std::ostream& stream(std::ostream& _out) const;$/;"	p	class:dev::eth::KnownState	access:public	signature:(std::ostream& _out) const
strictAssemblyForEVM	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<EVMDialect> EVMDialect::strictAssemblyForEVM(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
strictAssemblyForEVM	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> strictAssemblyForEVM(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
strictAssemblyForEVMObjects	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<EVMDialect> EVMDialect::strictAssemblyForEVMObjects(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
strictAssemblyForEVMObjects	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> strictAssemblyForEVMObjects(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
stringDistance	libdevcore/StringUtils.cpp	/^size_t dev::stringDistance(string const& _str1, string const& _str2)$/;"	f	class:dev	signature:(string const& _str1, string const& _str2)
stringDistance	libdevcore/StringUtils.h	/^size_t stringDistance(std::string const& _str1, std::string const& _str2);$/;"	p	namespace:dev	signature:(std::string const& _str1, std::string const& _str2)
stringForReferencePart	libsolidity/ast/Types.cpp	/^string ReferenceType::stringForReferencePart() const$/;"	f	class:ReferenceType	signature:() const
stringForReferencePart	libsolidity/ast/Types.h	/^	std::string stringForReferencePart() const;$/;"	p	class:dev::solidity::ReferenceType	access:protected	signature:() const
stringMemory	libsolidity/ast/Types.h	/^	static ArrayType& stringMemory() { static std::shared_ptr<ArrayType> addr(std::make_shared<ArrayType>(DataLocation::Memory, true)); return *addr; }$/;"	f	class:dev::solidity::ArrayType	access:public	signature:()
stringToHandle	libyul/YulString.h	/^	Handle stringToHandle(std::string const& _string)$/;"	f	class:yul::YulStringRepository	access:public	signature:(std::string const& _string)
stringWithinDistance	libdevcore/StringUtils.cpp	/^bool dev::stringWithinDistance(string const& _str1, string const& _str2, size_t _maxDistance, size_t _lenThreshold)$/;"	f	class:dev	signature:(string const& _str1, string const& _str2, size_t _maxDistance, size_t _lenThreshold)
stringWithinDistance	libdevcore/StringUtils.h	/^bool stringWithinDistance(std::string const& _str1, std::string const& _str2, size_t _maxDistance, size_t _lenThreshold = 0);$/;"	p	namespace:dev	signature:(std::string const& _str1, std::string const& _str2, size_t _maxDistance, size_t _lenThreshold = 0)
stringZ3Test	solse/main.cpp	/^void stringZ3Test();$/;"	p	file:	signature:()
stringZ3Test	solse/main.cpp	/^void stringZ3Test(){$/;"	f	signature:()
stripSuffix	libyul/optimiser/VarNameCleaner.cpp	/^YulString VarNameCleaner::stripSuffix(YulString const& _name) const$/;"	f	class:VarNameCleaner	signature:(YulString const& _name) const
stripSuffix	libyul/optimiser/VarNameCleaner.h	/^	YulString stripSuffix(YulString const& _name) const;$/;"	p	class:yul::VarNameCleaner	access:private	signature:(YulString const& _name) const
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Assignment const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Assignment const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Block const *stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Block const *stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Break const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Break const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Continue const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Continue const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(ExpressionStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(ExpressionStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(ForStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(ForStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(FunctionCall const* funCall, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(FunctionCall const* funCall, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(FunctionDefinition const* funcDef, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(FunctionDefinition const* funcDef, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(IfStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(IfStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Return const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Return const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Statement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Statement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Statement const* stmt, std::vector<ContextInfo> preCondVec) {$/;"	f	class:SymExecEngine	signature:(Statement const* stmt, std::vector<ContextInfo> preCondVec)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(Throw const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Throw const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(UnaryOperation const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(UnaryOperation const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(VariableDeclarationStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(VariableDeclarationStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.cpp	/^strongestPostcondition(WhileStatement const* stmt, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(WhileStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Assignment const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Assignment const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Block const *stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Block const *stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Break const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Break const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Continue const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Continue const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::ExpressionStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::ExpressionStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::ForStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::ForStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::FunctionCall const* funCall, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::FunctionCall const* funCall, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::FunctionDefinition const* funcDef, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::FunctionDefinition const* funcDef, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::IfStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::IfStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Return const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Return const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Statement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Statement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Statement const* stmt, std::vector<ContextInfo>);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Statement const* stmt, std::vector<ContextInfo>)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::Throw const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::Throw const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::UnaryOperation const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::UnaryOperation const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::VariableDeclarationStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::VariableDeclarationStatement const* stmt, ContextInfo& preCond)
strongestPostcondition	solse/SymExecEngine.h	/^    std::vector<ContextInfo> strongestPostcondition(dev::solidity::WhileStatement const* stmt, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:public	signature:(dev::solidity::WhileStatement const* stmt, ContextInfo& preCond)
structConstructor	solse/SymExecEngine.h	/^    std::vector<z3::func_decl> structConstructor;    \/\/ always has one element$/;"	m	class:StructInfo	access:public
structDefinition	libsolidity/ast/Types.h	/^	StructDefinition const& structDefinition() const { return m_struct; }$/;"	f	class:dev::solidity::StructType	access:public	signature:() const
structName	solse/SymExecEngine.h	/^    std::string structName;$/;"	m	class:StructInfo	access:public
structSort	solse/SymExecEngine.h	/^    std::vector<z3::sort> structSort;           \/\/ always has one element$/;"	m	class:StructInfo	access:public
structsMap	solse/SymExecEngine.h	/^    std::unordered_map<std::string, std::shared_ptr<StructInfo>> structsMap;$/;"	m	class:SymExecEngine	access:private
structuralEstimation	libsolidity/interface/GasEstimator.cpp	/^GasEstimator::ASTGasConsumptionSelfAccumulated GasEstimator::structuralEstimation($/;"	f	class:GasEstimator	signature:( AssemblyItems const& _items, vector<ASTNode const*> const& _ast ) const
structuralEstimation	libsolidity/interface/GasEstimator.h	/^	ASTGasConsumptionSelfAccumulated structuralEstimation($/;"	p	struct:dev::solidity::GasEstimator	access:public	signature:( eth::AssemblyItems const& _items, std::vector<ASTNode const*> const& _ast ) const
structureSizeEstimate	libsolidity/analysis/StaticAnalyzer.cpp	/^bigint StaticAnalyzer::structureSizeEstimate(Type const& _type, set<StructDefinition const*>& _structsSeen)$/;"	f	class:StaticAnalyzer	signature:(Type const& _type, set<StructDefinition const*>& _structsSeen)
structureSizeEstimate	libsolidity/analysis/StaticAnalyzer.h	/^	static bigint structureSizeEstimate(Type const& _type, std::set<StructDefinition const*>& _structsSeen);$/;"	p	class:dev::solidity::StaticAnalyzer	access:private	signature:(Type const& _type, std::set<StructDefinition const*>& _structsSeen)
sub	libevmasm/Assembly.h	/^	Assembly const& sub(size_t _sub) const { return *m_subs.at(_sub); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _sub) const
sub	libevmasm/Assembly.h	/^	Assembly& sub(size_t _sub) { return *m_subs.at(_sub); }$/;"	f	class:dev::eth::Assembly	access:public	signature:(size_t _sub)
subDenomination	libsolidity/ast/AST.h	/^	SubDenomination subDenomination() const { return m_subDenomination; }$/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
subExpression	libsolidity/ast/AST.h	/^	Expression const& subExpression() const { return *m_subExpression; }$/;"	f	class:dev::solidity::UnaryOperation	access:public	signature:() const
subIndexByName	libyul/Object.h	/^	std::map<YulString, size_t> subIndexByName;$/;"	m	struct:yul::Object	access:public
subNodes	libsolidity/ast/AST.h	/^	std::vector<ASTPointer<ASTNode>> const& subNodes() const { return m_subNodes; }$/;"	f	class:dev::solidity::ContractDefinition::std	access:public	signature:() const
subObjects	libyul/Object.h	/^	std::vector<std::shared_ptr<ObjectNode>> subObjects;$/;"	m	struct:yul::Object	access:public
subtractReferences	libyul/optimiser/UnusedPruner.cpp	/^void UnusedPruner::subtractReferences(map<YulString, size_t> const& _subtrahend)$/;"	f	class:UnusedPruner	signature:(map<YulString, size_t> const& _subtrahend)
subtractReferences	libyul/optimiser/UnusedPruner.h	/^	void subtractReferences(std::map<YulString, size_t> const& _subtrahend);$/;"	p	class:yul::UnusedPruner	access:private	signature:(std::map<YulString, size_t> const& _subtrahend)
success	libsolidity/interface/ReadFile.h	/^		bool success;$/;"	m	struct:dev::solidity::ReadCallback::Result	access:public
superContract	libsolidity/codegen/CompilerContext.cpp	/^vector<ContractDefinition const*>::const_iterator CompilerContext::superContract(ContractDefinition const& _contract) const$/;"	f	class:dev::solidity::CompilerContext	signature:(ContractDefinition const& _contract) const
superContract	libsolidity/codegen/CompilerContext.h	/^	std::vector<ContractDefinition const*>::const_iterator superContract(ContractDefinition const& _contract) const;$/;"	p	class:dev::solidity::CompilerContext	access:private	signature:(ContractDefinition const& _contract) const
superFunction	libsolidity/ast/ASTAnnotations.h	/^	FunctionDefinition const* superFunction = nullptr;$/;"	m	struct:dev::solidity::FunctionDefinitionAnnotation	access:public
superFunction	libsolidity/codegen/CompilerContext.cpp	/^FunctionDefinition const& CompilerContext::superFunction(FunctionDefinition const& _function, ContractDefinition const& _base)$/;"	f	class:dev::solidity::CompilerContext	signature:(FunctionDefinition const& _function, ContractDefinition const& _base)
superFunction	libsolidity/codegen/CompilerContext.h	/^	FunctionDefinition const& superFunction(FunctionDefinition const& _function, ContractDefinition const& _base);$/;"	p	class:dev::solidity::CompilerContext	access:public	signature:(FunctionDefinition const& _function, ContractDefinition const& _base)
superScope	libyul/AsmScope.h	/^	Scope* superScope = nullptr;$/;"	m	struct:yul::Scope	access:public
supportsReturndata	liblangutil/EVMVersion.h	/^	bool supportsReturndata() const { return *this >= byzantium(); }$/;"	f	class:langutil::EVMVersion	access:public	signature:() const
swapInstruction	libevmasm/Instruction.h	/^inline Instruction swapInstruction(unsigned _number)$/;"	f	class:dev::solidity::Instruction	access:private	signature:(unsigned _number)
swapStackElements	libevmasm/KnownState.cpp	/^void KnownState::swapStackElements($/;"	f	class:KnownState	signature:( int _stackHeightA, int _stackHeightB, SourceLocation const& _location )
swapStackElements	libevmasm/KnownState.h	/^	void swapStackElements(int _stackHeightA, int _stackHeightB, langutil::SourceLocation const& _location);$/;"	p	class:dev::eth::KnownState	access:private	signature:(int _stackHeightA, int _stackHeightB, langutil::SourceLocation const& _location)
swarmHash	libdevcore/SwarmHash.cpp	/^h256 dev::swarmHash(string const& _input)$/;"	f	class:dev	signature:(string const& _input)
swarmHash	libdevcore/SwarmHash.h	/^h256 swarmHash(std::string const& _input);$/;"	p	namespace:dev	signature:(std::string const& _input)
swarmHash	libsolidity/interface/CompilerStack.cpp	/^h256 const& CompilerStack::Source::swarmHash() const$/;"	f	class:CompilerStack::Source	signature:() const
swarmHash	libsolidity/interface/CompilerStack.h	/^		h256 const& swarmHash() const;$/;"	p	struct:dev::solidity::CompilerStack::Source	access:public	signature:() const
swarmHashCached	libsolidity/interface/CompilerStack.h	/^		h256 mutable swarmHashCached;$/;"	m	struct:dev::solidity::CompilerStack::Source	access:public
swarmHashIntermediate	libdevcore/SwarmHash.cpp	/^h256 swarmHashIntermediate(string const& _input, size_t _offset, size_t _length)$/;"	f	namespace:__anon22	signature:(string const& _input, size_t _offset, size_t _length)
swarmHashSimple	libdevcore/SwarmHash.cpp	/^h256 swarmHashSimple(bytesConstRef _data, size_t _size)$/;"	f	namespace:__anon22	signature:(bytesConstRef _data, size_t _size)
switchCaseEqual	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::switchCaseEqual(Case const& _lhs, Case const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(Case const& _lhs, Case const& _rhs)
switchCaseEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool switchCaseEqual(Case const& _lhs, Case const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Case const& _lhs, Case const& _rhs)
symExecEngine	solse/SolidityExprTranslator.h	/^    SymExecEngine* symExecEngine;$/;"	m	class:SolidityExprTranslator	access:private
symbolAliases	libsolidity/ast/AST.h	/^	std::vector<std::pair<ASTPointer<Identifier>, ASTPointer<ASTString>>> const& symbolAliases() const$/;"	f	class:dev::solidity::ImportDirective::std	access:public	signature:() const
symbolicExecution	solse/SymExecEngine.cpp	/^symbolicExecution() {$/;"	f	class:SymExecEngine	signature:()
symbolicExecution	solse/SymExecEngine.h	/^    void symbolicExecution();$/;"	p	class:SymExecEngine	access:public	signature:()
syntaxError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::syntaxError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
syntaxError	liblangutil/ErrorReporter.h	/^	void syntaxError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
synthesis	solse/SymExecEngine.cpp	/^void SymExecEngine::synthesis(std::vector<ContextInfo>& contexts ){$/;"	f	class:SymExecEngine	signature:(std::vector<ContextInfo>& contexts )
synthesis	solse/SymExecEngine.h	/^    void synthesis(std::vector<ContextInfo>& contexts);$/;"	p	class:SymExecEngine	access:public	signature:(std::vector<ContextInfo>& contexts)
tag	libevmasm/AssemblyItem.h	/^	AssemblyItem tag() const { assertThrow(m_type == PushTag || m_type == Tag, Exception, ""); return AssemblyItem(Tag, data()); }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
tagUnion	libevmasm/KnownState.cpp	/^KnownState::Id KnownState::tagUnion(set<u256> _tags)$/;"	f	class:KnownState	signature:(set<u256> _tags)
tagUnion	libevmasm/KnownState.h	/^	Id tagUnion(std::set<u256> _tags);$/;"	p	class:dev::eth::KnownState	access:private	signature:(std::set<u256> _tags)
tags	libsolidity/parsing/DocStringParser.h	/^	std::multimap<std::string, DocTag> const& tags() const { return m_docTags; }$/;"	f	class:dev::solidity::DocStringParser::std	access:public	signature:() const
tagsInExpression	libevmasm/KnownState.cpp	/^set<u256> KnownState::tagsInExpression(KnownState::Id _expressionId)$/;"	f	class:KnownState	signature:(KnownState::Id _expressionId)
tagsInExpression	libevmasm/KnownState.h	/^	std::set<u256> tagsInExpression(Id _expressionId);$/;"	p	class:dev::eth::KnownState	access:public	signature:(Id _expressionId)
takesArbitraryParameters	libsolidity/ast/Types.h	/^	bool takesArbitraryParameters() const { return m_arbitraryParameters; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
takesSinglePackedBytesParameter	libsolidity/ast/Types.h	/^	bool takesSinglePackedBytesParameter() const$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
tangerineWhistle	liblangutil/EVMVersion.h	/^	static EVMVersion tangerineWhistle() { return {Version::TangerineWhistle}; }$/;"	f	class:langutil::EVMVersion	access:public	signature:()
target	libsolidity/interface/CompilerStack.h	/^		std::string target;$/;"	m	struct:dev::solidity::CompilerStack::Remapping	access:public
tentativelyUpdateCodeSize	libyul/optimiser/FullInliner.cpp	/^void FullInliner::tentativelyUpdateCodeSize(YulString _function, YulString _callSite)$/;"	f	class:FullInliner	signature:(YulString _function, YulString _callSite)
tentativelyUpdateCodeSize	libyul/optimiser/FullInliner.h	/^	void tentativelyUpdateCodeSize(YulString _function, YulString _callSite);$/;"	p	class:yul::FullInliner	access:public	signature:(YulString _function, YulString _callSite)
text	liblangutil/SourceReferenceExtractor.h	/^	std::string text;         \/\/\/< Extracted source code text (potentially truncated if multiline or too long).$/;"	m	struct:langutil::SourceReference	access:public
tier0Gas	libevmasm/GasMeter.h	/^	static unsigned const tier0Gas = 0;$/;"	m	namespace:dev::eth::GasCosts
tier1Gas	libevmasm/GasMeter.h	/^	static unsigned const tier1Gas = 2;$/;"	m	namespace:dev::eth::GasCosts
tier2Gas	libevmasm/GasMeter.h	/^	static unsigned const tier2Gas = 3;$/;"	m	namespace:dev::eth::GasCosts
tier3Gas	libevmasm/GasMeter.h	/^	static unsigned const tier3Gas = 5;$/;"	m	namespace:dev::eth::GasCosts
tier4Gas	libevmasm/GasMeter.h	/^	static unsigned const tier4Gas = 8;$/;"	m	namespace:dev::eth::GasCosts
tier5Gas	libevmasm/GasMeter.h	/^	static unsigned const tier5Gas = 10;$/;"	m	namespace:dev::eth::GasCosts
tier6Gas	libevmasm/GasMeter.h	/^	static unsigned const tier6Gas = 20;$/;"	m	namespace:dev::eth::GasCosts
tier7Gas	libevmasm/GasMeter.h	/^	static unsigned const tier7Gas = 0;$/;"	m	namespace:dev::eth::GasCosts
timeSinceEpochMillisec	solse/SymExecEngine.cpp	/^uint64_t timeSinceEpochMillisec() {$/;"	f	signature:()
toAssemblyItem	libevmasm/SimplificationRules.cpp	/^AssemblyItem Pattern::toAssemblyItem(SourceLocation const& _location) const$/;"	f	class:Pattern	signature:(SourceLocation const& _location) const
toAssemblyItem	libevmasm/SimplificationRules.h	/^	AssemblyItem toAssemblyItem(langutil::SourceLocation const& _location) const;$/;"	p	class:dev::eth::Pattern	access:public	signature:(langutil::SourceLocation const& _location) const
toAssemblyText	libevmasm/AssemblyItem.cpp	/^string AssemblyItem::toAssemblyText() const$/;"	f	class:AssemblyItem	signature:() const
toAssemblyText	libevmasm/AssemblyItem.h	/^	std::string toAssemblyText() const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:() const
toBigEndian	libdevcore/CommonData.h	/^inline bytes toBigEndian(u160 _val) { bytes ret(20); toBigEndian(_val, ret); return ret; }$/;"	f	namespace:dev	signature:(u160 _val)
toBigEndian	libdevcore/CommonData.h	/^inline bytes toBigEndian(u256 _val) { bytes ret(32); toBigEndian(_val, ret); return ret; }$/;"	f	namespace:dev	signature:(u256 _val)
toBigEndian	libdevcore/CommonData.h	/^inline void toBigEndian(T _val, Out& o_out)$/;"	f	namespace:dev	signature:(T _val, Out& o_out)
toBytes	libdevcore/vector_ref.h	/^	std::vector<unsigned char> toBytes() const { return std::vector<unsigned char>(reinterpret_cast<unsigned char const*>(m_data), reinterpret_cast<unsigned char const*>(m_data) + m_count * sizeof(_T)); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
toCVC4Expr	libsolidity/formal/CVC4Interface.cpp	/^CVC4::Expr CVC4Interface::toCVC4Expr(Expression const& _expr)$/;"	f	class:CVC4Interface	signature:(Expression const& _expr)
toCVC4Expr	libsolidity/formal/CVC4Interface.h	/^	CVC4::Expr toCVC4Expr(Expression const& _expr);$/;"	p	class:dev::solidity::smt::CVC4Interface	access:private	signature:(Expression const& _expr)
toCompactBigEndian	libdevcore/CommonData.h	/^inline bytes toCompactBigEndian(T _val, unsigned _min = 0)$/;"	f	namespace:dev	signature:(T _val, unsigned _min = 0)
toCompactBigEndian	libdevcore/CommonData.h	/^inline bytes toCompactBigEndian(uint8_t _val, unsigned _min = 0)$/;"	f	namespace:dev	signature:(uint8_t _val, unsigned _min = 0)
toCompactHexWithPrefix	libdevcore/CommonData.h	/^inline std::string toCompactHexWithPrefix(u256 val)$/;"	f	namespace:dev	signature:(u256 val)
toExpression	libyul/optimiser/SimplificationRules.cpp	/^Expression Pattern::toExpression(SourceLocation const& _location) const$/;"	f	class:Pattern	signature:(SourceLocation const& _location) const
toExpression	libyul/optimiser/SimplificationRules.h	/^	Expression toExpression(langutil::SourceLocation const& _location) const;$/;"	p	class:yul::Pattern	access:public	signature:(langutil::SourceLocation const& _location) const
toFunctionNameSuffix	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::EncodingOptions::toFunctionNameSuffix() const$/;"	f	class:ABIFunctions::EncodingOptions	signature:() const
toFunctionNameSuffix	libsolidity/codegen/ABIFunctions.h	/^		std::string toFunctionNameSuffix() const;$/;"	p	struct:dev::solidity::ABIFunctions::EncodingOptions	access:public	signature:() const
toHex	libdevcore/CommonData.cpp	/^string dev::toHex(bytes const& _data, HexPrefix _prefix, HexCase _case)$/;"	f	class:dev	signature:(bytes const& _data, HexPrefix _prefix, HexCase _case)
toHex	libdevcore/CommonData.h	/^inline std::string toHex(u256 val, HexPrefix prefix = HexPrefix::DontAdd)$/;"	f	namespace:dev	signature:(u256 val, HexPrefix prefix = HexPrefix::DontAdd)
toHex	libdevcore/CommonData.h	/^std::string toHex(bytes const& _data, HexPrefix _prefix = HexPrefix::DontAdd, HexCase _case = HexCase::Lower);$/;"	p	namespace:dev	signature:(bytes const& _data, HexPrefix _prefix = HexPrefix::DontAdd, HexCase _case = HexCase::Lower)
toHex	libevmasm/LinkerObject.cpp	/^string LinkerObject::toHex() const$/;"	f	class:LinkerObject	signature:() const
toHex	libevmasm/LinkerObject.h	/^	std::string toHex() const;$/;"	p	struct:dev::eth::LinkerObject	access:public	signature:() const
toJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value&& ASTJsonConverter::toJson(ASTNode const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ASTNode const& _node)
toJson	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value toJson(std::vector<ASTPointer<T>> const& _nodes)$/;"	f	class:dev::solidity::ASTJsonConverter	access:public	signature:(std::vector<ASTPointer<T>> const& _nodes)
toJson	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value&& toJson(ASTNode const& _node);$/;"	p	class:dev::solidity::ASTJsonConverter	access:public	signature:(ASTNode const& _node)
toJsonOrNull	libsolidity/ast/ASTJsonConverter.h	/^	Json::Value toJsonOrNull(ASTNode const* _node)$/;"	f	class:dev::solidity::ASTJsonConverter	access:private	signature:(ASTNode const* _node)
toLittleEndian	libdevcore/SwarmHash.cpp	/^bytes toLittleEndian(size_t _size)$/;"	f	namespace:__anon22	signature:(size_t _size)
toSExpr	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::toSExpr(Expression const& _expr)$/;"	f	class:SMTLib2Interface	signature:(Expression const& _expr)
toSExpr	libsolidity/formal/SMTLib2Interface.h	/^	std::string toSExpr(Expression const& _expr);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(Expression const& _expr)
toSizeAfterFreeMemoryPointer	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::toSizeAfterFreeMemoryPointer()$/;"	f	class:dev::solidity::CompilerUtils	signature:()
toSizeAfterFreeMemoryPointer	libsolidity/codegen/CompilerUtils.h	/^	void toSizeAfterFreeMemoryPointer();$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:()
toSmtLibSort	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::toSmtLibSort(Sort const& _sort)$/;"	f	class:SMTLib2Interface	signature:(Sort const& _sort)
toSmtLibSort	libsolidity/formal/SMTLib2Interface.cpp	/^string SMTLib2Interface::toSmtLibSort(vector<SortPointer> const& _sorts)$/;"	f	class:SMTLib2Interface	signature:(vector<SortPointer> const& _sorts)
toSmtLibSort	libsolidity/formal/SMTLib2Interface.h	/^	std::string toSmtLibSort(Sort const& _sort);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(Sort const& _sort)
toSmtLibSort	libsolidity/formal/SMTLib2Interface.h	/^	std::string toSmtLibSort(std::vector<SortPointer> const& _sort);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::vector<SortPointer> const& _sort)
toString	libdevcore/CommonIO.h	/^std::string toString(_T const& _t)$/;"	f	namespace:dev	signature:(_T const& _t)
toString	libdevcore/vector_ref.h	/^	std::string toString() const { return std::string((char const*)m_data, ((char const*)m_data) + m_count * sizeof(_T)); }$/;"	f	class:dev::vector_ref	access:public	signature:() const
toString	libevmasm/SimplificationRules.cpp	/^string ExpressionTemplate::toString() const$/;"	f	class:ExpressionTemplate	signature:() const
toString	libevmasm/SimplificationRules.cpp	/^string Pattern::toString() const$/;"	f	class:Pattern	signature:() const
toString	libevmasm/SimplificationRules.h	/^	std::string toString() const;$/;"	p	class:dev::eth::Pattern	access:public	signature:() const
toString	libevmasm/SimplificationRules.h	/^	std::string toString() const;$/;"	p	struct:dev::eth::ExpressionTemplate	access:public	signature:() const
toString	liblangutil/Token.cpp	/^char const* toString(Token tok)$/;"	f	namespace:langutil::TokenTraits	signature:(Token tok)
toString	liblangutil/Token.h	/^	char const* toString(Token tok);$/;"	p	namespace:langutil::TokenTraits	signature:(Token tok)
toString	liblangutil/Token.h	/^	std::string toString(bool const& tokenValue = false) const$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:(bool const& tokenValue = false) const
toString	libsolidity/ast/Types.cpp	/^std::string StringLiteralType::toString(bool) const$/;"	f	class:StringLiteralType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string AddressType::toString(bool) const$/;"	f	class:AddressType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string ArrayType::toString(bool _short) const$/;"	f	class:ArrayType	signature:(bool _short) const
toString	libsolidity/ast/Types.cpp	/^string ContractType::toString(bool) const$/;"	f	class:ContractType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string EnumType::toString(bool) const$/;"	f	class:EnumType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string FixedPointType::toString(bool) const$/;"	f	class:FixedPointType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string FunctionType::toString(bool _short) const$/;"	f	class:FunctionType	signature:(bool _short) const
toString	libsolidity/ast/Types.cpp	/^string IntegerType::toString(bool) const$/;"	f	class:IntegerType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string MagicType::toString(bool _short) const$/;"	f	class:MagicType	signature:(bool _short) const
toString	libsolidity/ast/Types.cpp	/^string MappingType::toString(bool _short) const$/;"	f	class:MappingType	signature:(bool _short) const
toString	libsolidity/ast/Types.cpp	/^string ModifierType::toString(bool _short) const$/;"	f	class:ModifierType	signature:(bool _short) const
toString	libsolidity/ast/Types.cpp	/^string ModuleType::toString(bool) const$/;"	f	class:ModuleType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string RationalNumberType::toString(bool) const$/;"	f	class:RationalNumberType	signature:(bool) const
toString	libsolidity/ast/Types.cpp	/^string StructType::toString(bool _short) const$/;"	f	class:StructType	signature:(bool _short) const
toString	libsolidity/ast/Types.cpp	/^string TupleType::toString(bool _short) const$/;"	f	class:TupleType	signature:(bool _short) const
toString	libsolidity/ast/Types.h	/^	std::string toString() const { return toString(false); }$/;"	f	class:dev::solidity::Type	access:public	signature:() const
toString	libsolidity/ast/Types.h	/^	virtual std::string toString(bool _short) const = 0;$/;"	p	class:dev::solidity::Type	access:public	signature:(bool _short) const
toString	libyul/Object.cpp	/^string Data::toString(bool) const$/;"	f	class:Data	signature:(bool) const
toString	libyul/Object.cpp	/^string Object::toString(bool _yul) const$/;"	f	class:Object	signature:(bool _yul) const
toString	libyul/Object.h	/^	virtual std::string toString(bool _yul) const = 0;$/;"	p	struct:yul::ObjectNode	access:public	signature:(bool _yul) const
toString	solse/SolidityExprTranslator.cpp	/^toString() {$/;"	f	class:ContextInfo	signature:()
toString	solse/SolidityExprTranslator.h	/^    std::string toString();$/;"	p	class:ContextInfo	access:public	signature:()
toString	solse/SymExecEngine.h	/^    std::string toString(){$/;"	f	class:StructInfo	access:public	signature:()
toStringInHex	libevmasm/Assembly.cpp	/^string Assembly::toStringInHex(u256 _value)$/;"	f	class:Assembly	signature:(u256 _value)
toStringInHex	libevmasm/Assembly.h	/^	static std::string toStringInHex(u256 _value);$/;"	p	class:dev::eth::Assembly	access:private	signature:(u256 _value)
toSubAssemblyTag	libevmasm/AssemblyItem.cpp	/^AssemblyItem AssemblyItem::toSubAssemblyTag(size_t _subId) const$/;"	f	class:AssemblyItem	signature:(size_t _subId) const
toSubAssemblyTag	libevmasm/AssemblyItem.h	/^	AssemblyItem toSubAssemblyTag(size_t _subId) const;$/;"	p	class:dev::eth::AssemblyItem	access:public	signature:(size_t _subId) const
toZ3Expr	libsolidity/formal/Z3Interface.cpp	/^z3::expr Z3Interface::toZ3Expr(Expression const& _expr)$/;"	f	class:Z3Interface	signature:(Expression const& _expr)
toZ3Expr	libsolidity/formal/Z3Interface.h	/^	z3::expr toZ3Expr(Expression const& _expr);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(Expression const& _expr)
to_string	liblangutil/Scanner.cpp	/^std::string to_string(ScannerError _errorCode)$/;"	f	namespace:langutil	signature:(ScannerError _errorCode)
to_string	liblangutil/Scanner.h	/^std::string to_string(ScannerError _errorCode);$/;"	p	namespace:langutil	signature:(ScannerError _errorCode)
token	liblangutil/Scanner.h	/^		Token token;$/;"	m	struct:langutil::Scanner::TokenDesc	access:public
token	liblangutil/Token.h	/^	Token token() const { return m_token; }$/;"	f	class:langutil::ElementaryTypeNameToken	access:public	signature:() const
token	libsolidity/ast/AST.h	/^	Token token() const { return m_token; }$/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
tokens	libsolidity/ast/AST.h	/^	std::vector<Token> const& tokens() const { return m_tokens; }$/;"	f	class:dev::solidity::PragmaDirective::std	access:public	signature:() const
touchedVariables	libsolidity/formal/VariableUsage.cpp	/^vector<VariableDeclaration const*> VariableUsage::touchedVariables(ASTNode const& _node) const$/;"	f	class:VariableUsage	signature:(ASTNode const& _node) const
touchedVariables	libsolidity/formal/VariableUsage.h	/^	std::vector<VariableDeclaration const*> touchedVariables(ASTNode const& _node) const;$/;"	p	class:dev::solidity::VariableUsage	access:public	signature:(ASTNode const& _node) const
translate	libyul/optimiser/ASTCopier.cpp	/^Block ASTCopier::translate(Block const& _block)$/;"	f	class:ASTCopier	signature:(Block const& _block)
translate	libyul/optimiser/ASTCopier.cpp	/^Case ASTCopier::translate(Case const& _case)$/;"	f	class:ASTCopier	signature:(Case const& _case)
translate	libyul/optimiser/ASTCopier.cpp	/^Expression ASTCopier::translate(Expression const& _expression)$/;"	f	class:ASTCopier	signature:(Expression const& _expression)
translate	libyul/optimiser/ASTCopier.cpp	/^Identifier ASTCopier::translate(Identifier const& _identifier)$/;"	f	class:ASTCopier	signature:(Identifier const& _identifier)
translate	libyul/optimiser/ASTCopier.cpp	/^Literal ASTCopier::translate(Literal const& _literal)$/;"	f	class:ASTCopier	signature:(Literal const& _literal)
translate	libyul/optimiser/ASTCopier.cpp	/^Statement ASTCopier::translate(Statement const& _statement)$/;"	f	class:ASTCopier	signature:(Statement const& _statement)
translate	libyul/optimiser/ASTCopier.cpp	/^TypedName ASTCopier::translate(TypedName const& _typedName)$/;"	f	class:ASTCopier	signature:(TypedName const& _typedName)
translate	libyul/optimiser/ASTCopier.h	/^	Block translate(Block const& _block);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Block const& _block)
translate	libyul/optimiser/ASTCopier.h	/^	Case translate(Case const& _case);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Case const& _case)
translate	libyul/optimiser/ASTCopier.h	/^	Identifier translate(Identifier const& _identifier);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Identifier const& _identifier)
translate	libyul/optimiser/ASTCopier.h	/^	Literal translate(Literal const& _literal);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Literal const& _literal)
translate	libyul/optimiser/ASTCopier.h	/^	TypedName translate(TypedName const& _typedName);$/;"	p	class:yul::ASTCopier	access:protected	signature:(TypedName const& _typedName)
translate	libyul/optimiser/ASTCopier.h	/^	std::unique_ptr<T> translate(std::unique_ptr<T> const& _v)$/;"	f	class:yul::ASTCopier	access:protected	signature:(std::unique_ptr<T> const& _v)
translate	libyul/optimiser/ASTCopier.h	/^	virtual Expression translate(Expression const& _expression);$/;"	p	class:yul::ASTCopier	access:public	signature:(Expression const& _expression)
translate	libyul/optimiser/ASTCopier.h	/^	virtual Statement translate(Statement const& _statement);$/;"	p	class:yul::ASTCopier	access:public	signature:(Statement const& _statement)
translate	libyul/optimiser/Substitution.cpp	/^Expression Substitution::translate(Expression const& _expression)$/;"	f	class:Substitution	signature:(Expression const& _expression)
translate	solse/SolidityExprTranslator.cpp	/^translate(BinaryOperation const* binaryExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(BinaryOperation const* binaryExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(Expression const* aExpr, ContextInfo& ctxInfo){$/;"	f	class:SolidityExprTranslator	signature:(Expression const* aExpr, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(FunctionCall const* functioncallExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(FunctionCall const* functioncallExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(Identifier const* idExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(Identifier const* idExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(IndexAccess const* indexAccessExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(IndexAccess const* indexAccessExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(Literal const* litExpr, ContextInfo& ctxInfo){$/;"	f	class:SolidityExprTranslator	signature:(Literal const* litExpr, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(MemberAccess const* memAccExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(MemberAccess const* memAccExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(TupleExpression const* tupleExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(TupleExpression const* tupleExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.cpp	/^translate(UnaryOperation const* unaryExp, ContextInfo& ctxInfo) {$/;"	f	class:SolidityExprTranslator	signature:(UnaryOperation const* unaryExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::BinaryOperation const* binaryExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::BinaryOperation const* binaryExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::Expression const* aExpr, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::FunctionCall const* functioncallExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::FunctionCall const* functioncallExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::Identifier const* idExpr, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::Identifier const* idExpr, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::IndexAccess const* indexAccessExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::IndexAccess const* indexAccessExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::Literal const* litExpr, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::Literal const* litExpr, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::MemberAccess const* memAccExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::MemberAccess const* memAccExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::TupleExpression const* tupleExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::TupleExpression const* tupleExp, ContextInfo& ctxInfo)
translate	solse/SolidityExprTranslator.h	/^    z3::expr translate(dev::solidity::UnaryOperation const* unaryExp, ContextInfo& ctxInfo);$/;"	p	class:SolidityExprTranslator	access:public	signature:(dev::solidity::UnaryOperation const* unaryExp, ContextInfo& ctxInfo)
translateIdentifier	libyul/optimiser/ASTCopier.h	/^	virtual YulString translateIdentifier(YulString _name) { return _name; }$/;"	f	class:yul::ASTCopier	access:protected	signature:(YulString _name)
translateIdentifier	libyul/optimiser/Disambiguator.cpp	/^YulString Disambiguator::translateIdentifier(YulString _originalName)$/;"	f	class:Disambiguator	signature:(YulString _originalName)
translateIdentifier	libyul/optimiser/FullInliner.cpp	/^YulString BodyCopier::translateIdentifier(YulString _name)$/;"	f	class:BodyCopier	signature:(YulString _name)
translateOptimiserSettings	libsolidity/codegen/CompilerContext.cpp	/^eth::Assembly::OptimiserSettings CompilerContext::translateOptimiserSettings(OptimiserSettings const& _settings)$/;"	f	class:dev::solidity::CompilerContext	signature:(OptimiserSettings const& _settings)
translateOptimiserSettings	libsolidity/codegen/CompilerContext.h	/^	eth::Assembly::OptimiserSettings translateOptimiserSettings(OptimiserSettings const& _settings);$/;"	p	class:dev::solidity::CompilerContext	access:private	signature:(OptimiserSettings const& _settings)
translatePositionToLineColumn	liblangutil/CharStream.cpp	/^tuple<int, int> CharStream::translatePositionToLineColumn(int _position) const$/;"	f	class:CharStream	signature:(int _position) const
translatePositionToLineColumn	liblangutil/CharStream.h	/^	std::tuple<int, int> translatePositionToLineColumn(int _position) const;$/;"	p	class:langutil::CharStream	access:public	signature:(int _position) const
translatePositionToLineColumn	liblangutil/Scanner.h	/^	std::tuple<int, int> translatePositionToLineColumn(int _position) const { return m_source->translatePositionToLineColumn(_position); }$/;"	f	class:langutil::Scanner	access:public	signature:(int _position) const
translateVector	libyul/optimiser/ASTCopier.h	/^	std::vector<T> translateVector(std::vector<T> const& _values);$/;"	p	class:yul::ASTCopier	access:protected	signature:(std::vector<T> const& _values)
translateVector	libyul/optimiser/ASTCopier.h	/^std::vector<T> ASTCopier::translateVector(std::vector<T> const& _values)$/;"	f	class:yul::ASTCopier	signature:(std::vector<T> const& _values)
trueExpression	libsolidity/ast/AST.h	/^	Expression const& trueExpression() const { return *m_trueExpression; }$/;"	f	class:dev::solidity::Conditional	access:public	signature:() const
trueStatement	libsolidity/ast/AST.h	/^	Statement const& trueStatement() const { return *m_trueBody; }$/;"	f	class:dev::solidity::IfStatement	access:public	signature:() const
truth_assertions	solse/SymExecEngine.cpp	/^std::vector<z3::expr> truth_assertions;$/;"	v
truth_count	solse/SymExecEngine.cpp	/^unsigned truth_count = 0;$/;"	v
tryInlineStatement	libyul/optimiser/FullInliner.cpp	/^boost::optional<vector<Statement>> InlineModifier::tryInlineStatement(Statement& _statement)$/;"	f	class:InlineModifier	signature:(Statement& _statement)
tryInlineStatement	libyul/optimiser/FullInliner.h	/^	boost::optional<std::vector<Statement>> tryInlineStatement(Statement& _statement);$/;"	p	class:yul::InlineModifier	access:private	signature:(Statement& _statement)
tryParseIndexAccessedPath	libsolidity/parsing/Parser.cpp	/^pair<Parser::LookAheadInfo, Parser::IndexAccessedPath> Parser::tryParseIndexAccessedPath()$/;"	f	class:dev::solidity::Parser	signature:()
tryParseIndexAccessedPath	libsolidity/parsing/Parser.h	/^	std::pair<LookAheadInfo, IndexAccessedPath> tryParseIndexAccessedPath();$/;"	p	class:dev::solidity::Parser	access:private	signature:()
tryToSimplify	libevmasm/ExpressionClasses.cpp	/^ExpressionClasses::Id ExpressionClasses::tryToSimplify(Expression const& _expr)$/;"	f	class:ExpressionClasses	signature:(Expression const& _expr)
tryToSimplify	libevmasm/ExpressionClasses.h	/^	Id tryToSimplify(Expression const& _expr);$/;"	p	class:dev::eth::ExpressionClasses	access:private	signature:(Expression const& _expr)
tupleDecoder	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::tupleDecoder(TypePointers const& _types, bool _fromMemory)$/;"	f	class:ABIFunctions	signature:(TypePointers const& _types, bool _fromMemory)
tupleDecoder	libsolidity/codegen/ABIFunctions.h	/^	std::string tupleDecoder(TypePointers const& _types, bool _fromMemory = false);$/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:(TypePointers const& _types, bool _fromMemory = false)
tupleEncoder	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::tupleEncoder($/;"	f	class:ABIFunctions	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes )
tupleEncoder	libsolidity/codegen/ABIFunctions.h	/^	std::string tupleEncoder($/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes, bool _encodeAsLibraryTypes = false )
tupleEncoderPacked	libsolidity/codegen/ABIFunctions.cpp	/^string ABIFunctions::tupleEncoderPacked($/;"	f	class:ABIFunctions	signature:( TypePointers const& _givenTypes, TypePointers const& _targetTypes )
tupleEncoderPacked	libsolidity/codegen/ABIFunctions.h	/^	std::string tupleEncoderPacked(TypePointers const& _givenTypes, TypePointers const& _targetTypes);$/;"	p	class:dev::solidity::ABIFunctions	access:public	signature:(TypePointers const& _givenTypes, TypePointers const& _targetTypes)
tupleZ3Test	solse/main.cpp	/^void tupleZ3Test() {$/;"	f	signature:()
tupleZ3Test	solse/main.cpp	/^void tupleZ3Test();$/;"	p	file:	signature:()
txCreateGas	libevmasm/GasMeter.h	/^	static unsigned const txCreateGas = 53000;$/;"	m	namespace:dev::eth::GasCosts
txDataNonZeroGas	libevmasm/GasMeter.h	/^	static unsigned const txDataNonZeroGas = 68;$/;"	m	namespace:dev::eth::GasCosts
txDataZeroGas	libevmasm/GasMeter.h	/^	static unsigned const txDataZeroGas = 4;$/;"	m	namespace:dev::eth::GasCosts
txGas	libevmasm/GasMeter.h	/^	static unsigned const txGas = 21000;$/;"	m	namespace:dev::eth::GasCosts
type	libevmasm/AssemblyItem.h	/^	AssemblyItemType type() const { return m_type; }$/;"	f	class:dev::eth::AssemblyItem	access:public	signature:() const
type	libevmasm/SimplificationRules.h	/^	AssemblyItemType type() const { return m_type; }$/;"	f	class:dev::eth::Pattern	access:public	signature:() const
type	liblangutil/Exceptions.h	/^	Type type() const { return m_type; }$/;"	f	class:langutil::Error	access:public	signature:() const
type	libsolidity/analysis/ConstantEvaluator.cpp	/^TypePointer ConstantEvaluator::type(ASTNode const& _node)$/;"	f	class:ConstantEvaluator	signature:(ASTNode const& _node)
type	libsolidity/analysis/ConstantEvaluator.h	/^	TypePointer type(ASTNode const& _node);$/;"	p	class:dev::solidity::ConstantEvaluator	access:private	signature:(ASTNode const& _node)
type	libsolidity/analysis/TypeChecker.cpp	/^TypePointer const& TypeChecker::type(Expression const& _expression) const$/;"	f	class:TypeChecker	signature:(Expression const& _expression) const
type	libsolidity/analysis/TypeChecker.cpp	/^TypePointer const& TypeChecker::type(VariableDeclaration const& _variable) const$/;"	f	class:TypeChecker	signature:(VariableDeclaration const& _variable) const
type	libsolidity/analysis/TypeChecker.h	/^	TypePointer const& type(Expression const& _expression) const;$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(Expression const& _expression) const
type	libsolidity/analysis/TypeChecker.h	/^	TypePointer const& type(VariableDeclaration const& _variable) const;$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(VariableDeclaration const& _variable) const
type	libsolidity/ast/AST.cpp	/^TypePointer ContractDefinition::type() const$/;"	f	class:ContractDefinition	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer EnumDefinition::type() const$/;"	f	class:EnumDefinition	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer EnumValue::type() const$/;"	f	class:EnumValue	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer EventDefinition::type() const$/;"	f	class:EventDefinition	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer FunctionDefinition::type() const$/;"	f	class:FunctionDefinition	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer ImportDirective::type() const$/;"	f	class:ImportDirective	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer ModifierDefinition::type() const$/;"	f	class:ModifierDefinition	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer StructDefinition::type() const$/;"	f	class:StructDefinition	signature:() const
type	libsolidity/ast/AST.cpp	/^TypePointer VariableDeclaration::type() const$/;"	f	class:VariableDeclaration	signature:() const
type	libsolidity/ast/AST.h	/^	virtual TypePointer type() const = 0;$/;"	p	class:dev::solidity::Declaration	access:public	signature:() const
type	libsolidity/ast/ASTAnnotations.h	/^	TypePointer type;$/;"	m	struct:dev::solidity::ExpressionAnnotation	access:public
type	libsolidity/ast/ASTAnnotations.h	/^	TypePointer type;$/;"	m	struct:dev::solidity::TypeNameAnnotation	access:public
type	libsolidity/ast/ASTAnnotations.h	/^	TypePointer type;$/;"	m	struct:dev::solidity::VariableDeclarationAnnotation	access:public
type	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::type(Expression const& _expression)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Expression const& _expression)
type	libsolidity/ast/ASTJsonConverter.cpp	/^string ASTJsonConverter::type(VariableDeclaration const& _varDecl)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclaration const& _varDecl)
type	libsolidity/ast/ASTJsonConverter.h	/^	static std::string type(Expression const& _expression);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(Expression const& _expression)
type	libsolidity/ast/ASTJsonConverter.h	/^	static std::string type(VariableDeclaration const& _varDecl);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(VariableDeclaration const& _varDecl)
type	libsolidity/ast/Types.h	/^		TypePointer type;$/;"	m	struct:dev::solidity::MemberList::Member	access:public
type	libsolidity/formal/SMTChecker.h	/^		enum class Type { Underflow, Overflow, All } type;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	typeref:class:dev::solidity::SMTChecker::OverflowTarget::Type	access:public
type	libsolidity/formal/SymbolicVariables.h	/^	TypePointer const& type() const { return m_type; }$/;"	f	class:dev::solidity::SymbolicVariable	access:public	signature:() const
type	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
type	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	m	struct:yul::TypedName	access:public
type	libyul/AsmScope.h	/^	struct Variable { YulType type; };$/;"	m	struct:yul::Scope::Variable	access:public
typeArgument	libsolidity/ast/Types.cpp	/^TypePointer MagicType::typeArgument() const$/;"	f	class:MagicType	signature:() const
typeArgument	libsolidity/ast/Types.h	/^	TypePointer typeArgument() const;$/;"	p	class:dev::solidity::MagicType	access:public	signature:() const
typeCanBeExpressed	libsolidity/analysis/TypeChecker.cpp	/^bool typeCanBeExpressed(vector<ASTPointer<VariableDeclaration>> const& decls)$/;"	f	namespace:__anon10	signature:(vector<ASTPointer<VariableDeclaration>> const& decls)
typeCheckABIDecodeAndRetrieveReturnType	libsolidity/analysis/TypeChecker.cpp	/^TypePointers TypeChecker::typeCheckABIDecodeAndRetrieveReturnType(FunctionCall const& _functionCall, bool _abiEncoderV2)$/;"	f	class:TypeChecker	signature:(FunctionCall const& _functionCall, bool _abiEncoderV2)
typeCheckABIDecodeAndRetrieveReturnType	libsolidity/analysis/TypeChecker.h	/^	TypePointers typeCheckABIDecodeAndRetrieveReturnType($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, bool _abiEncoderV2 )
typeCheckABIEncodeFunctions	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::typeCheckABIEncodeFunctions($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
typeCheckABIEncodeFunctions	libsolidity/analysis/TypeChecker.h	/^	void typeCheckABIEncodeFunctions($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
typeCheckFunctionCall	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::typeCheckFunctionCall($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
typeCheckFunctionCall	libsolidity/analysis/TypeChecker.h	/^	void typeCheckFunctionCall($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
typeCheckFunctionGeneralChecks	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::typeCheckFunctionGeneralChecks($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
typeCheckFunctionGeneralChecks	libsolidity/analysis/TypeChecker.h	/^	void typeCheckFunctionGeneralChecks($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall, FunctionTypePointer _functionType )
typeCheckMetaTypeFunctionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.cpp	/^TypePointers TypeChecker::typeCheckMetaTypeFunctionAndRetrieveReturnType(FunctionCall const& _functionCall)$/;"	f	class:TypeChecker	signature:(FunctionCall const& _functionCall)
typeCheckMetaTypeFunctionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.h	/^	TypePointers typeCheckMetaTypeFunctionAndRetrieveReturnType(FunctionCall const& _functionCall);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(FunctionCall const& _functionCall)
typeCheckTypeConversionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.cpp	/^TypePointer TypeChecker::typeCheckTypeConversionAndRetrieveReturnType($/;"	f	class:TypeChecker	signature:( FunctionCall const& _functionCall )
typeCheckTypeConversionAndRetrieveReturnType	libsolidity/analysis/TypeChecker.h	/^	TypePointer typeCheckTypeConversionAndRetrieveReturnType($/;"	p	class:dev::solidity::TypeChecker	access:private	signature:( FunctionCall const& _functionCall )
typeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::typeError(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation, string const& _description)
typeError	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::typeError(SourceLocation const& _location, string const& _description)$/;"	f	class:ErrorReporter	signature:(SourceLocation const& _location, string const& _description)
typeError	liblangutil/ErrorReporter.h	/^	void typeError($/;"	p	class:langutil::ErrorReporter	access:public	signature:( SourceLocation const& _location, SecondarySourceLocation const& _secondaryLocation = SecondarySourceLocation(), std::string const& _description = std::string() )
typeError	liblangutil/ErrorReporter.h	/^	void typeError(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
typeError	libsolidity/analysis/PostTypeChecker.h	/^	void typeError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::PostTypeChecker	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
typeError	libsolidity/analysis/ReferencesResolver.cpp	/^void ReferencesResolver::typeError(SourceLocation const& _location, string const& _description)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(SourceLocation const& _location, string const& _description)
typeError	libsolidity/analysis/ReferencesResolver.h	/^	void typeError(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:dev::solidity::ReferencesResolver	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
typeErrorConcatenateDescriptions	liblangutil/ErrorReporter.h	/^	void typeErrorConcatenateDescriptions(SourceLocation const& _location, Strings const&... _descriptions)$/;"	f	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, Strings const&... _descriptions)
typeName	liblangutil/Exceptions.h	/^	std::string const& typeName() const { return m_typeName; }$/;"	f	class:langutil::Error::std	access:public	signature:() const
typeName	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken const& typeName() const { return m_type; }$/;"	f	class:dev::solidity::ElementaryTypeName	access:public	signature:() const
typeName	libsolidity/ast/AST.h	/^	ElementaryTypeNameToken const& typeName() const { return m_typeToken; }$/;"	f	class:dev::solidity::ElementaryTypeNameExpression	access:public	signature:() const
typeName	libsolidity/ast/AST.h	/^	TypeName const& typeName() const { return *m_typeName; }$/;"	f	class:dev::solidity::NewExpression	access:public	signature:() const
typeName	libsolidity/ast/AST.h	/^	TypeName const* typeName() const { return m_typeName.get(); }$/;"	f	class:dev::solidity::UsingForDirective	access:public	signature:() const
typeName	libsolidity/ast/AST.h	/^	TypeName* typeName() const { return m_typeName.get(); }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
typeNameFromIndexAccessStructure	libsolidity/parsing/Parser.cpp	/^ASTPointer<TypeName> Parser::typeNameFromIndexAccessStructure(Parser::IndexAccessedPath const& _iap)$/;"	f	class:dev::solidity::Parser	signature:(Parser::IndexAccessedPath const& _iap)
typeNameFromIndexAccessStructure	libsolidity/parsing/Parser.h	/^	ASTPointer<TypeName> typeNameFromIndexAccessStructure(IndexAccessedPath const& _pathAndIndices);$/;"	p	class:dev::solidity::Parser	access:private	signature:(IndexAccessedPath const& _pathAndIndices)
typePointerToJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value ASTJsonConverter::typePointerToJson(TypePointer _tp, bool _short)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(TypePointer _tp, bool _short)
typePointerToJson	libsolidity/ast/ASTJsonConverter.cpp	/^Json::Value ASTJsonConverter::typePointerToJson(std::shared_ptr<std::vector<TypePointer>> _tps)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(std::shared_ptr<std::vector<TypePointer>> _tps)
typePointerToJson	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value typePointerToJson(TypePointer _tp, bool _short = false);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(TypePointer _tp, bool _short = false)
typePointerToJson	libsolidity/ast/ASTJsonConverter.h	/^	static Json::Value typePointerToJson(std::shared_ptr<std::vector<TypePointer>> _tps);$/;"	p	class:dev::solidity::ASTJsonConverter	access:private	signature:(std::shared_ptr<std::vector<TypePointer>> _tps)
typeSortInZ3	solse/SymExecEngine.cpp	/^typeSortInZ3(TypePointer const typePtr){$/;"	f	class:SymExecEngine	signature:(TypePointer const typePtr)
typeSortInZ3	solse/SymExecEngine.h	/^    z3::sort typeSortInZ3(dev::solidity::TypePointer const typePtr);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::TypePointer const typePtr)
typeSupportedByOldABIEncoder	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::typeSupportedByOldABIEncoder(Type const& _type, bool _isLibraryCall)$/;"	f	class:TypeChecker	signature:(Type const& _type, bool _isLibraryCall)
typeSupportedByOldABIEncoder	libsolidity/analysis/TypeChecker.h	/^	static bool typeSupportedByOldABIEncoder(Type const& _type, bool _isLibraryCall);$/;"	p	class:dev::solidity::TypeChecker	access:public	signature:(Type const& _type, bool _isLibraryCall)
u2s	libdevcore/Common.h	/^inline s256 u2s(u256 _u)$/;"	f	namespace:dev	signature:(u256 _u)
uint256	libsolidity/ast/Types.h	/^	static IntegerType& uint256() { static std::shared_ptr<IntegerType> uint256(std::make_shared<IntegerType>(256)); return *uint256; }$/;"	f	class:dev::solidity::IntegerType	access:public	signature:()
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult AddressType::unaryOperatorResult(Token _operator) const$/;"	f	class:AddressType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult BoolType::unaryOperatorResult(Token _operator) const$/;"	f	class:BoolType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult ContractType::unaryOperatorResult(Token _operator) const$/;"	f	class:ContractType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult EnumType::unaryOperatorResult(Token _operator) const$/;"	f	class:EnumType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedBytesType::unaryOperatorResult(Token _operator) const$/;"	f	class:FixedBytesType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FixedPointType::unaryOperatorResult(Token _operator) const$/;"	f	class:FixedPointType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult FunctionType::unaryOperatorResult(Token _operator) const$/;"	f	class:FunctionType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult IntegerType::unaryOperatorResult(Token _operator) const$/;"	f	class:IntegerType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult RationalNumberType::unaryOperatorResult(Token _operator) const$/;"	f	class:RationalNumberType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.cpp	/^TypeResult ReferenceType::unaryOperatorResult(Token _operator) const$/;"	f	class:ReferenceType	signature:(Token _operator) const
unaryOperatorResult	libsolidity/ast/Types.h	/^	virtual TypeResult unaryOperatorResult(Token) const { return TypePointer(); }$/;"	f	class:dev::solidity::Type	access:public	signature:(Token) const
unhandledQueries	libsolidity/formal/SMTChecker.h	/^	std::vector<std::string> unhandledQueries() { return m_interface->unhandledQueries(); }$/;"	f	class:dev::solidity::SMTChecker	access:public	signature:()
unhandledQueries	libsolidity/formal/SMTPortfolio.cpp	/^vector<string> SMTPortfolio::unhandledQueries()$/;"	f	class:SMTPortfolio	signature:()
unhandledQueries	libsolidity/formal/SolverInterface.h	/^	virtual std::vector<std::string> unhandledQueries() { return {}; }$/;"	f	class:dev::solidity::smt::SolverInterface	access:public	signature:()
unhandledSMTLib2Queries	libsolidity/interface/CompilerStack.h	/^	std::vector<std::string> const& unhandledSMTLib2Queries() const { return m_unhandledSMTLib2Queries; }$/;"	f	class:dev::solidity::CompilerStack::std	access:public	signature:() const
unimplementedFunctions	libsolidity/ast/ASTAnnotations.h	/^	std::vector<FunctionDefinition const*> unimplementedFunctions;$/;"	m	struct:dev::solidity::ContractDefinitionAnnotation	access:public
unindent	libdevcore/IndentedWriter.cpp	/^void IndentedWriter::unindent()$/;"	f	class:IndentedWriter	signature:()
unindent	libdevcore/IndentedWriter.h	/^	void unindent();$/;"	p	class:dev::IndentedWriter	access:public	signature:()
uniqueSymbol	libsolidity/formal/SymbolicVariables.cpp	/^string SymbolicVariable::uniqueSymbol(unsigned _index) const$/;"	f	class:SymbolicVariable	signature:(unsigned _index) const
uniqueSymbol	libsolidity/formal/SymbolicVariables.h	/^	std::string uniqueSymbol(unsigned _index) const;$/;"	p	class:dev::solidity::SymbolicVariable	access:protected	signature:(unsigned _index) const
unlimitedCalldataEncodedSize	libsolidity/ast/Types.cpp	/^bigint ArrayType::unlimitedCalldataEncodedSize(bool _padded) const$/;"	f	class:ArrayType	signature:(bool _padded) const
unlimitedCalldataEncodedSize	libsolidity/ast/Types.h	/^	bigint unlimitedCalldataEncodedSize(bool _padded) const;$/;"	p	class:dev::solidity::ArrayType	access:private	signature:(bool _padded) const
unreferenced	libyul/backends/evm/EVMCodeTransform.cpp	/^bool CodeTransform::unreferenced(Scope::Variable const& _var) const$/;"	f	class:CodeTransform	signature:(Scope::Variable const& _var) const
unreferenced	libyul/backends/evm/EVMCodeTransform.h	/^	bool unreferenced(Scope::Variable const& _var) const;$/;"	p	class:yul::CodeTransform	access:protected	signature:(Scope::Variable const& _var) const
updateCodeSize	libyul/optimiser/FullInliner.cpp	/^void FullInliner::updateCodeSize(FunctionDefinition const& _fun)$/;"	f	class:FullInliner	signature:(FunctionDefinition const& _fun)
updateCodeSize	libyul/optimiser/FullInliner.h	/^	void updateCodeSize(FunctionDefinition const& _fun);$/;"	p	class:yul::FullInliner	access:private	signature:(FunctionDefinition const& _fun)
updateContextInfo	solse/SymExecEngine.cpp	/^updateContextInfo(Expression const* exp, z3::expr rightExpr, ContextInfo& preCond) {$/;"	f	class:SymExecEngine	signature:(Expression const* exp, z3::expr rightExpr, ContextInfo& preCond)
updateContextInfo	solse/SymExecEngine.h	/^    void updateContextInfo(dev::solidity::Expression const* exp, z3::expr rightExpr, ContextInfo& preCond);$/;"	p	class:SymExecEngine	access:protected	signature:(dev::solidity::Expression const* exp, z3::expr rightExpr, ContextInfo& preCond)
updateDeclaration	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool NameAndTypeResolver::updateDeclaration(Declaration const& _declaration)$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:(Declaration const& _declaration)
updateDeclaration	libsolidity/analysis/NameAndTypeResolver.h	/^	bool updateDeclaration(Declaration const& _declaration);$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:(Declaration const& _declaration)
updateReference	libyul/backends/evm/EVMAssembly.cpp	/^void EVMAssembly::updateReference(size_t pos, size_t size, u256 value)$/;"	f	class:EVMAssembly	signature:(size_t pos, size_t size, u256 value)
updateReference	libyul/backends/evm/EVMAssembly.h	/^	void updateReference(size_t pos, size_t size, dev::u256 value);$/;"	p	class:yul::EVMAssembly	access:private	signature:(size_t pos, size_t size, dev::u256 value)
updateSourceLocation	libsolidity/codegen/CompilerContext.cpp	/^void CompilerContext::updateSourceLocation()$/;"	f	class:dev::solidity::CompilerContext	signature:()
updateSourceLocation	libsolidity/codegen/CompilerContext.h	/^	void updateSourceLocation();$/;"	p	class:dev::solidity::CompilerContext	access:private	signature:()
useMetadataLiteralSources	libsolidity/interface/CompilerStack.cpp	/^void CompilerStack::useMetadataLiteralSources(bool _metadataLiteralSources)$/;"	f	class:CompilerStack	signature:(bool _metadataLiteralSources)
useMetadataLiteralSources	libsolidity/interface/CompilerStack.h	/^	void useMetadataLiteralSources(bool _metadataLiteralSources);$/;"	p	class:dev::solidity::CompilerStack	access:public	signature:(bool _metadataLiteralSources)
used	libyul/optimiser/UnusedPruner.cpp	/^bool UnusedPruner::used(YulString _name) const$/;"	f	class:UnusedPruner	signature:(YulString _name) const
used	libyul/optimiser/UnusedPruner.h	/^	bool used(YulString _name) const;$/;"	p	class:yul::UnusedPruner	access:private	signature:(YulString _name) const
userDocumentation	libsolidity/interface/CompilerStack.h	/^		mutable std::unique_ptr<Json::Value const> userDocumentation;$/;"	m	struct:dev::solidity::CompilerStack::Contract	access:public
userDocumentation	libsolidity/interface/Natspec.cpp	/^Json::Value Natspec::userDocumentation(ContractDefinition const& _contractDef)$/;"	f	class:Natspec	signature:(ContractDefinition const& _contractDef)
userDocumentation	libsolidity/interface/Natspec.h	/^	static Json::Value userDocumentation(ContractDefinition const& _contractDef);$/;"	p	class:dev::solidity::Natspec	access:public	signature:(ContractDefinition const& _contractDef)
usingForDirectives	libsolidity/ast/AST.h	/^	std::vector<UsingForDirective const*> usingForDirectives() const { return filteredNodes<UsingForDirective>(m_subNodes); }$/;"	f	class:dev::solidity::ContractDefinition	access:public	signature:() const
utilities	solse/mechanism.h	/^		std::vector<std::vector<z3::expr> > utilities; $/;"	m	class:Mechanism	access:public
utils	libsolidity/codegen/ExpressionCompiler.cpp	/^CompilerUtils ExpressionCompiler::utils()$/;"	f	class:dev::solidity::ExpressionCompiler	signature:()
utils	libsolidity/codegen/ExpressionCompiler.h	/^	CompilerUtils utils();$/;"	p	class:dev::solidity::ExpressionCompiler	access:private	signature:()
validForCalldata	libsolidity/ast/Types.cpp	/^bool ArrayType::validForCalldata() const$/;"	f	class:ArrayType	signature:() const
validForCalldata	libsolidity/ast/Types.h	/^	bool validForCalldata() const;$/;"	p	class:dev::solidity::ArrayType	access:public	signature:() const
validateUTF8	libdevcore/UTF8.cpp	/^bool validateUTF8(std::string const& _input, size_t& _invalidPosition)$/;"	f	namespace:dev	signature:(std::string const& _input, size_t& _invalidPosition)
validateUTF8	libdevcore/UTF8.cpp	/^bool validateUTF8(unsigned char const* _input, size_t _length, size_t& _invalidPosition)$/;"	f	namespace:dev::__anon21	signature:(unsigned char const* _input, size_t _length, size_t& _invalidPosition)
validateUTF8	libdevcore/UTF8.h	/^bool validateUTF8(std::string const& _input, size_t& _invalidPosition);$/;"	p	namespace:dev	signature:(std::string const& _input, size_t& _invalidPosition)
validateUTF8	libdevcore/UTF8.h	/^inline bool validateUTF8(std::string const& _input)$/;"	f	namespace:dev	signature:(std::string const& _input)
value	libevmasm/GasMeter.h	/^		u256 value;$/;"	m	struct:dev::eth::GasMeter::GasConsumption	access:public
value	libsolidity/ast/AST.h	/^	ASTPointer<Expression> const& value() const { return m_value; }$/;"	f	class:dev::solidity::VariableDeclaration	access:public	signature:() const
value	libsolidity/ast/AST.h	/^	ASTString const& value() const { return *m_value; }$/;"	f	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
value	libsolidity/ast/Types.h	/^	std::string const& value() const { return m_value; }$/;"	f	class:dev::solidity::StringLiteralType::std	access:public	signature:() const
value	libsolidity/formal/SMTChecker.h	/^		smt::Expression value;$/;"	m	struct:dev::solidity::SMTChecker::OverflowTarget	access:public
value	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::Assignment	access:public
value	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	m	struct:yul::Case	access:public
value	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
value	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::VariableDeclaration	access:public
value	libyul/optimiser/SSAValueTracker.h	/^	Expression const* value(YulString _name) const { return m_values.at(_name); }$/;"	f	class:yul::SSAValueTracker	access:public	signature:(YulString _name) const
valueAtIndex	libsolidity/formal/SMTChecker.cpp	/^smt::Expression SMTChecker::valueAtIndex(VariableDeclaration const& _decl, int _index)$/;"	f	class:SMTChecker	signature:(VariableDeclaration const& _decl, int _index)
valueAtIndex	libsolidity/formal/SMTChecker.h	/^	smt::Expression valueAtIndex(VariableDeclaration const& _decl, int _index);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(VariableDeclaration const& _decl, int _index)
valueAtIndex	libsolidity/formal/SymbolicVariables.cpp	/^smt::Expression SymbolicVariable::valueAtIndex(int _index) const$/;"	f	class:SymbolicVariable	signature:(int _index) const
valueAtIndex	libsolidity/formal/SymbolicVariables.h	/^	virtual smt::Expression valueAtIndex(int _index) const;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:(int _index) const
valueOfBoolLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfBoolLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
valueOfBoolLiteral	libyul/Utilities.h	/^dev::u256 valueOfBoolLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
valueOfLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
valueOfLiteral	libyul/Utilities.h	/^dev::u256 valueOfLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
valueOfNumberLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfNumberLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
valueOfNumberLiteral	libyul/Utilities.h	/^dev::u256 valueOfNumberLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
valueOfStringLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfStringLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
valueOfStringLiteral	libyul/Utilities.h	/^dev::u256 valueOfStringLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
valueSet	libsolidity/ast/Types.h	/^	bool valueSet() const { return m_valueSet; }$/;"	f	class:dev::solidity::FunctionType	access:public	signature:() const
valueSize	libsolidity/ast/ASTAnnotations.h	/^		size_t valueSize = size_t(-1);$/;"	m	struct:dev::solidity::InlineAssemblyAnnotation::ExternalIdentifierInfo	access:public
valueType	libsolidity/ast/AST.h	/^	TypeName const& valueType() const { return *m_valueType; }$/;"	f	class:dev::solidity::Mapping	access:public	signature:() const
valueType	libsolidity/ast/Types.h	/^	TypePointer const& valueType() const { return m_valueType; }$/;"	f	class:dev::solidity::MappingType	access:public	signature:() const
valueWithoutUnderscores	libsolidity/ast/AST.cpp	/^ASTString Literal::valueWithoutUnderscores() const$/;"	f	class:Literal	signature:() const
valueWithoutUnderscores	libsolidity/ast/AST.h	/^	ASTString valueWithoutUnderscores() const;$/;"	p	class:dev::solidity::Literal::SubDenomination	access:private	signature:() const
values	libyul/optimiser/SSAValueTracker.h	/^	std::map<YulString, Expression const*> const& values() const { return m_values; }$/;"	f	class:yul::SSAValueTracker::std	access:public	signature:() const
variable	libyul/backends/evm/EVMCodeTransform.h	/^	YulString variable;$/;"	m	struct:yul::StackTooDeepError	access:public
variableHeightDiff	libyul/backends/evm/EVMCodeTransform.cpp	/^int CodeTransform::variableHeightDiff(Scope::Variable const& _var, YulString _varName, bool _forSwap)$/;"	f	class:CodeTransform	signature:(Scope::Variable const& _var, YulString _varName, bool _forSwap)
variableHeightDiff	libyul/backends/evm/EVMCodeTransform.h	/^	int variableHeightDiff(Scope::Variable const& _var, YulString _name, bool _forSwap);$/;"	p	class:yul::CodeTransform	access:private	signature:(Scope::Variable const& _var, YulString _name, bool _forSwap)
variableName	libyul/AsmData.h	/^struct StackAssignment { langutil::SourceLocation location; Identifier variableName; };$/;"	m	struct:yul::StackAssignment	access:public
variableNames	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::Assignment	access:public
variableOccurrences	libsolidity/analysis/ControlFlowGraph.h	/^	std::vector<VariableOccurrence> variableOccurrences;$/;"	m	struct:dev::solidity::CFGNode	access:public
variableReferences	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Variable const*, unsigned> variableReferences;$/;"	m	struct:yul::CodeTransformContext	access:public
variableStackHeights	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Variable const*, int> variableStackHeights;$/;"	m	struct:yul::CodeTransformContext	access:public
variables	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::VariableDeclaration	access:public
variables	libyul/optimiser/DataFlowAnalyzer.h	/^		std::set<YulString> variables;$/;"	m	struct:yul::DataFlowAnalyzer::Scope	access:public
variables	solse/mechanism.h	/^  	std::vector<z3::expr> variables;$/;"	m	class:Mechanism	access:public
variables_smt	solse/mechanism.h	/^    std::vector<z3::expr> variables_smt;$/;"	m	class:Mechanism	access:public
variables_smt_str	solse/mechanism.h	/^    std::vector<std::string> variables_smt_str;$/;"	m	class:Mechanism	access:public
variables_str	solse/mechanism.h	/^    std::vector<std::string> variables_str;$/;"	m	class:Mechanism	access:public
vector_ref	libdevcore/vector_ref.h	/^	vector_ref(): m_data(nullptr), m_count(0) {}$/;"	f	class:dev::vector_ref	access:public	signature:()
vector_ref	libdevcore/vector_ref.h	/^	vector_ref(_T* _data, size_t _count): m_data(_data), m_count(_count) {}$/;"	f	class:dev::vector_ref	access:public	signature:(_T* _data, size_t _count)
vector_ref	libdevcore/vector_ref.h	/^	vector_ref(string_type& _data): vector_ref(&_data) {}$/;"	f	class:dev::vector_ref	access:public	signature:(string_type& _data)
vector_ref	libdevcore/vector_ref.h	/^	vector_ref(string_type* _data): m_data(reinterpret_cast<_T*>(_data->data())), m_count(_data->size() \/ sizeof(_T)) {}$/;"	f	class:dev::vector_ref	access:public	signature:(string_type* _data)
vector_ref	libdevcore/vector_ref.h	/^	vector_ref(vector_type* _data): m_data(_data->data()), m_count(_data->size()) {}$/;"	f	class:dev::vector_ref	access:public	signature:(vector_type* _data)
vector_ref	libdevcore/vector_ref.h	/^class vector_ref$/;"	c	namespace:dev
version	libsolidity/analysis/SemVerHandler.h	/^		SemVerVersion version;$/;"	m	struct:dev::solidity::SemVerMatchExpression::MatchComponent	access:public
version	solse/CommandLineInterface.cpp	/^static void version()$/;"	f	namespace:dev::solidity	signature:()
verticesToTraverse	libdevcore/Algorithms.h	/^	std::set<V const*> verticesToTraverse;$/;"	m	struct:dev::BreadthFirstSearch	access:public
virtualBlocks	libyul/AsmAnalysisInfo.h	/^	std::map<FunctionDefinition const*, std::shared_ptr<Block const>> virtualBlocks;$/;"	m	struct:yul::AsmAnalysisInfo	access:public
visibility	libsolidity/ast/AST.h	/^	Declaration::Visibility visibility() const$/;"	f	class:dev::solidity::FunctionTypeName	access:public	signature:() const
visibility	libsolidity/ast/AST.h	/^	Visibility visibility() const { return m_visibility == Visibility::Default ? defaultVisibility() : m_visibility; }$/;"	f	class:dev::solidity::Declaration	access:public	signature:() const
visibility	libsolidity/parsing/Parser.h	/^		Declaration::Visibility visibility = Declaration::Visibility::Default;$/;"	m	struct:dev::solidity::Parser::FunctionHeaderParserResult	access:public
visibilityToString	libsolidity/ast/AST.h	/^	static std::string visibilityToString(Declaration::Visibility _visibility)$/;"	f	class:dev::solidity::Declaration	access:public	signature:(Declaration::Visibility _visibility)
visit	libsolidity/analysis/ControlFlowAnalyzer.cpp	/^bool ControlFlowAnalyzer::visit(FunctionDefinition const& _function)$/;"	f	class:ControlFlowAnalyzer	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(BinaryOperation const& _operation)$/;"	f	class:ControlFlowBuilder	signature:(BinaryOperation const& _operation)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Break const& _break)$/;"	f	class:ControlFlowBuilder	signature:(Break const& _break)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Conditional const& _conditional)$/;"	f	class:ControlFlowBuilder	signature:(Conditional const& _conditional)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Continue const& _continue)$/;"	f	class:ControlFlowBuilder	signature:(Continue const& _continue)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(ForStatement const& _forStatement)$/;"	f	class:ControlFlowBuilder	signature:(ForStatement const& _forStatement)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(FunctionCall const& _functionCall)$/;"	f	class:ControlFlowBuilder	signature:(FunctionCall const& _functionCall)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(FunctionDefinition const& _functionDefinition)$/;"	f	class:ControlFlowBuilder	signature:(FunctionDefinition const& _functionDefinition)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(FunctionTypeName const& _functionTypeName)$/;"	f	class:ControlFlowBuilder	signature:(FunctionTypeName const& _functionTypeName)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Identifier const& _identifier)$/;"	f	class:ControlFlowBuilder	signature:(Identifier const& _identifier)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(IfStatement const& _ifStatement)$/;"	f	class:ControlFlowBuilder	signature:(IfStatement const& _ifStatement)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:ControlFlowBuilder	signature:(InlineAssembly const& _inlineAssembly)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(ModifierInvocation const& _modifierInvocation)$/;"	f	class:ControlFlowBuilder	signature:(ModifierInvocation const& _modifierInvocation)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(PlaceholderStatement const&)$/;"	f	class:ControlFlowBuilder	signature:(PlaceholderStatement const&)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Return const& _return)$/;"	f	class:ControlFlowBuilder	signature:(Return const& _return)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(Throw const& _throw)$/;"	f	class:ControlFlowBuilder	signature:(Throw const& _throw)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(VariableDeclaration const& _variableDeclaration)$/;"	f	class:ControlFlowBuilder	signature:(VariableDeclaration const& _variableDeclaration)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(VariableDeclarationStatement const& _variableDeclarationStatement)$/;"	f	class:ControlFlowBuilder	signature:(VariableDeclarationStatement const& _variableDeclarationStatement)
visit	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visit(WhileStatement const& _whileStatement)$/;"	f	class:ControlFlowBuilder	signature:(WhileStatement const& _whileStatement)
visit	libsolidity/analysis/ControlFlowGraph.cpp	/^bool CFG::visit(FunctionDefinition const& _function)$/;"	f	class:CFG	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/ControlFlowGraph.h	/^	virtual bool visit(FunctionDefinition const& _function) { return visitNode(_function); }$/;"	f	class:dev::solidity::CFGConstVisitor	access:public	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/ControlFlowPrinter.cpp	/^bool ControlFlowPrinter::visit(FunctionDefinition const& _function)$/;"	f	class:ControlFlowPrinter	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(ContractDefinition const& _contract)$/;"	f	class:DocStringAnalyser	signature:(ContractDefinition const& _contract)
visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(EventDefinition const& _event)$/;"	f	class:DocStringAnalyser	signature:(EventDefinition const& _event)
visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(FunctionDefinition const& _function)$/;"	f	class:DocStringAnalyser	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/DocStringAnalyser.cpp	/^bool DocStringAnalyser::visit(ModifierDefinition const& _modifier)$/;"	f	class:DocStringAnalyser	signature:(ModifierDefinition const& _modifier)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(Block& _block)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(Block& _block)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ContractDefinition& _contract)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ContractDefinition& _contract)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(EnumDefinition& _enum)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EnumDefinition& _enum)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(EnumValue& _value)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EnumValue& _value)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(EventDefinition& _event)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(EventDefinition& _event)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ForStatement& _for)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ForStatement& _for)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(FunctionDefinition& _function)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionDefinition& _function)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(FunctionTypeName& _funTypeName)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(FunctionTypeName& _funTypeName)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ImportDirective& _import)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ImportDirective& _import)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(ModifierDefinition& _modifier)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(ModifierDefinition& _modifier)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(SourceUnit& _sourceUnit)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(SourceUnit& _sourceUnit)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(StructDefinition& _struct)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(StructDefinition& _struct)
visit	libsolidity/analysis/NameAndTypeResolver.cpp	/^bool DeclarationRegistrationHelper::visit(VariableDeclaration& _declaration)$/;"	f	class:dev::solidity::DeclarationRegistrationHelper	signature:(VariableDeclaration& _declaration)
visit	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::visit(ContractDefinition const&)$/;"	f	class:PostTypeChecker	signature:(ContractDefinition const&)
visit	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::visit(Identifier const& _identifier)$/;"	f	class:PostTypeChecker	signature:(Identifier const& _identifier)
visit	libsolidity/analysis/PostTypeChecker.cpp	/^bool PostTypeChecker::visit(VariableDeclaration const& _variable)$/;"	f	class:PostTypeChecker	signature:(VariableDeclaration const& _variable)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(Block const& _block)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Block const& _block)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(ElementaryTypeName const& _typeName)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ElementaryTypeName const& _typeName)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(ForStatement const& _for)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ForStatement const& _for)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(FunctionDefinition const& _functionDefinition)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(FunctionDefinition const& _functionDefinition)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(Identifier const& _identifier)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Identifier const& _identifier)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(InlineAssembly const& _inlineAssembly)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(ModifierDefinition const&)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(ModifierDefinition const&)
visit	libsolidity/analysis/ReferencesResolver.cpp	/^bool ReferencesResolver::visit(Return const& _return)$/;"	f	class:dev::solidity::ReferencesResolver	signature:(Return const& _return)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(BinaryOperation const& _operation)$/;"	f	class:StaticAnalyzer	signature:(BinaryOperation const& _operation)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(ContractDefinition const& _contract)$/;"	f	class:StaticAnalyzer	signature:(ContractDefinition const& _contract)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(ExpressionStatement const& _statement)$/;"	f	class:StaticAnalyzer	signature:(ExpressionStatement const& _statement)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(FunctionCall const& _functionCall)$/;"	f	class:StaticAnalyzer	signature:(FunctionCall const& _functionCall)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(FunctionDefinition const& _function)$/;"	f	class:StaticAnalyzer	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(Identifier const& _identifier)$/;"	f	class:StaticAnalyzer	signature:(Identifier const& _identifier)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:StaticAnalyzer	signature:(InlineAssembly const& _inlineAssembly)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(MemberAccess const& _memberAccess)$/;"	f	class:StaticAnalyzer	signature:(MemberAccess const& _memberAccess)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(Return const& _return)$/;"	f	class:StaticAnalyzer	signature:(Return const& _return)
visit	libsolidity/analysis/StaticAnalyzer.cpp	/^bool StaticAnalyzer::visit(VariableDeclaration const& _variable)$/;"	f	class:StaticAnalyzer	signature:(VariableDeclaration const& _variable)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Break const& _breakStatement)$/;"	f	class:SyntaxChecker	signature:(Break const& _breakStatement)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Continue const& _continueStatement)$/;"	f	class:SyntaxChecker	signature:(Continue const& _continueStatement)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(ContractDefinition const& _contract)$/;"	f	class:SyntaxChecker	signature:(ContractDefinition const& _contract)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(ForStatement const& _forStatement)$/;"	f	class:SyntaxChecker	signature:(ForStatement const& _forStatement)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(FunctionDefinition const& _function)$/;"	f	class:SyntaxChecker	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(FunctionTypeName const& _node)$/;"	f	class:SyntaxChecker	signature:(FunctionTypeName const& _node)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(IfStatement const& _ifStatement)$/;"	f	class:SyntaxChecker	signature:(IfStatement const& _ifStatement)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Literal const& _literal)$/;"	f	class:SyntaxChecker	signature:(Literal const& _literal)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(ModifierDefinition const&)$/;"	f	class:SyntaxChecker	signature:(ModifierDefinition const&)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(PlaceholderStatement const&)$/;"	f	class:SyntaxChecker	signature:(PlaceholderStatement const&)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(PragmaDirective const& _pragma)$/;"	f	class:SyntaxChecker	signature:(PragmaDirective const& _pragma)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(SourceUnit const& _sourceUnit)$/;"	f	class:SyntaxChecker	signature:(SourceUnit const& _sourceUnit)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(StructDefinition const& _struct)$/;"	f	class:SyntaxChecker	signature:(StructDefinition const& _struct)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(Throw const& _throwStatement)$/;"	f	class:SyntaxChecker	signature:(Throw const& _throwStatement)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(UnaryOperation const& _operation)$/;"	f	class:SyntaxChecker	signature:(UnaryOperation const& _operation)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(VariableDeclarationStatement const& _statement)$/;"	f	class:SyntaxChecker	signature:(VariableDeclarationStatement const& _statement)
visit	libsolidity/analysis/SyntaxChecker.cpp	/^bool SyntaxChecker::visit(WhileStatement const& _whileStatement)$/;"	f	class:SyntaxChecker	signature:(WhileStatement const& _whileStatement)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(Assignment const& _assignment)$/;"	f	class:TypeChecker	signature:(Assignment const& _assignment)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(Conditional const& _conditional)$/;"	f	class:TypeChecker	signature:(Conditional const& _conditional)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(ContractDefinition const& _contract)$/;"	f	class:TypeChecker	signature:(ContractDefinition const& _contract)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(EventDefinition const& _eventDef)$/;"	f	class:TypeChecker	signature:(EventDefinition const& _eventDef)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(ForStatement const& _forStatement)$/;"	f	class:TypeChecker	signature:(ForStatement const& _forStatement)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(FunctionCall const& _functionCall)$/;"	f	class:TypeChecker	signature:(FunctionCall const& _functionCall)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(FunctionDefinition const& _function)$/;"	f	class:TypeChecker	signature:(FunctionDefinition const& _function)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(Identifier const& _identifier)$/;"	f	class:TypeChecker	signature:(Identifier const& _identifier)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(IfStatement const& _ifStatement)$/;"	f	class:TypeChecker	signature:(IfStatement const& _ifStatement)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(IndexAccess const& _access)$/;"	f	class:TypeChecker	signature:(IndexAccess const& _access)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:TypeChecker	signature:(InlineAssembly const& _inlineAssembly)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(MemberAccess const& _memberAccess)$/;"	f	class:TypeChecker	signature:(MemberAccess const& _memberAccess)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(StructDefinition const& _struct)$/;"	f	class:TypeChecker	signature:(StructDefinition const& _struct)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(TupleExpression const& _tuple)$/;"	f	class:TypeChecker	signature:(TupleExpression const& _tuple)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(UnaryOperation const& _operation)$/;"	f	class:TypeChecker	signature:(UnaryOperation const& _operation)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(VariableDeclaration const& _variable)$/;"	f	class:TypeChecker	signature:(VariableDeclaration const& _variable)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(VariableDeclarationStatement const& _statement)$/;"	f	class:TypeChecker	signature:(VariableDeclarationStatement const& _statement)
visit	libsolidity/analysis/TypeChecker.cpp	/^bool TypeChecker::visit(WhileStatement const& _whileStatement)$/;"	f	class:TypeChecker	signature:(WhileStatement const& _whileStatement)
visit	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::visit(FunctionDefinition const& _funDef)$/;"	f	class:ViewPureChecker	signature:(FunctionDefinition const& _funDef)
visit	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::visit(MemberAccess const& _memberAccess)$/;"	f	class:ViewPureChecker	signature:(MemberAccess const& _memberAccess)
visit	libsolidity/analysis/ViewPureChecker.cpp	/^bool ViewPureChecker::visit(ModifierDefinition const& _modifier)$/;"	f	class:ViewPureChecker	signature:(ModifierDefinition const& _modifier)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ArrayTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ArrayTypeName const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Assignment const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Assignment const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(BinaryOperation const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(BinaryOperation const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Block const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Block const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Break const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Break const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Conditional const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Conditional const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Continue const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Continue const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ContractDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ContractDefinition const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ElementaryTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ElementaryTypeName const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ElementaryTypeNameExpression const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ElementaryTypeNameExpression const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EmitStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EmitStatement const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EnumDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EnumDefinition const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EnumValue const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EnumValue const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(EventDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(EventDefinition const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ExpressionStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ExpressionStatement const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ForStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ForStatement const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(FunctionCall const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionCall const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(FunctionDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionDefinition const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(FunctionTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(FunctionTypeName const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Identifier const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Identifier const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(IfStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(IfStatement const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ImportDirective const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ImportDirective const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(IndexAccess const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(IndexAccess const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(InheritanceSpecifier const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(InheritanceSpecifier const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(InlineAssembly const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(InlineAssembly const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Literal const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Literal const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Mapping const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Mapping const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(MemberAccess const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(MemberAccess const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ModifierDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ModifierDefinition const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ModifierInvocation const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ModifierInvocation const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(NewExpression const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(NewExpression const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(ParameterList const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(ParameterList const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(PlaceholderStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(PlaceholderStatement const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(PragmaDirective const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(PragmaDirective const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Return const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Return const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(SourceUnit const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(SourceUnit const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(StructDefinition const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(StructDefinition const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(Throw const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(Throw const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(TupleExpression const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(TupleExpression const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(UnaryOperation const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(UnaryOperation const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(UserDefinedTypeName const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(UserDefinedTypeName const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(UsingForDirective const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(UsingForDirective const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(VariableDeclaration const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclaration const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(VariableDeclarationStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(VariableDeclarationStatement const& _node)
visit	libsolidity/ast/ASTJsonConverter.cpp	/^bool ASTJsonConverter::visit(WhileStatement const& _node)$/;"	f	class:dev::solidity::ASTJsonConverter	signature:(WhileStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ArrayTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ArrayTypeName const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Assignment const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Assignment const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(BinaryOperation const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(BinaryOperation const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Block const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Block const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Break const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Break const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Conditional const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Conditional const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Continue const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Continue const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ContractDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ContractDefinition const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ElementaryTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeName const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ElementaryTypeNameExpression const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ElementaryTypeNameExpression const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EmitStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EmitStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EnumDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumDefinition const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EnumValue const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EnumValue const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(EventDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(EventDefinition const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ExpressionStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ExpressionStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ForStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ForStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(FunctionCall const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionCall const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(FunctionDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionDefinition const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(FunctionTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(FunctionTypeName const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Identifier const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Identifier const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(IfStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IfStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ImportDirective const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ImportDirective const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(IndexAccess const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(IndexAccess const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(InheritanceSpecifier const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InheritanceSpecifier const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(InlineAssembly const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(InlineAssembly const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Literal const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Literal const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Mapping const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Mapping const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(MemberAccess const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(MemberAccess const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ModifierDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierDefinition const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ModifierInvocation const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ModifierInvocation const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(NewExpression const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(NewExpression const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(ParameterList const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(ParameterList const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(PlaceholderStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PlaceholderStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(PragmaDirective const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(PragmaDirective const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Return const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Return const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(StructDefinition const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(StructDefinition const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(Throw const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(Throw const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(TupleExpression const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(TupleExpression const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(UnaryOperation const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UnaryOperation const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(UserDefinedTypeName const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UserDefinedTypeName const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(UsingForDirective const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(UsingForDirective const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(VariableDeclaration const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclaration const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(VariableDeclarationStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(VariableDeclarationStatement const& _node)
visit	libsolidity/ast/ASTPrinter.cpp	/^bool ASTPrinter::visit(WhileStatement const& _node)$/;"	f	class:dev::solidity::ASTPrinter	signature:(WhileStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ArrayTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ArrayTypeName const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ArrayTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ArrayTypeName& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Assignment const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Assignment const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Assignment& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Assignment& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(BinaryOperation const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(BinaryOperation const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(BinaryOperation& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(BinaryOperation& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Block const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Block const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Block& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Block& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Break const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Break const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Break& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Break& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Conditional const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Conditional const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Conditional& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Conditional& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Continue const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Continue const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Continue& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Continue& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ContractDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ContractDefinition const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ContractDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ContractDefinition& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeName const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeName& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeNameExpression const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ElementaryTypeNameExpression const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ElementaryTypeNameExpression& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ElementaryTypeNameExpression& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EmitStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EmitStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EmitStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EmitStatement& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumDefinition const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumDefinition& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumValue const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EnumValue const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EnumValue& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EnumValue& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EventDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(EventDefinition const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(EventDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(EventDefinition& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ExpressionStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ExpressionStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ExpressionStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ExpressionStatement& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ForStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ForStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ForStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ForStatement& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionCall const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionCall const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionCall& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionCall& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionDefinition const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionDefinition& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(FunctionTypeName const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(FunctionTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(FunctionTypeName& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Identifier const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Identifier const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Identifier& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Identifier& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IfStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IfStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IfStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IfStatement& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ImportDirective const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ImportDirective const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ImportDirective& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ImportDirective& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IndexAccess const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(IndexAccess const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(IndexAccess& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(IndexAccess& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InheritanceSpecifier const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InheritanceSpecifier const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InheritanceSpecifier& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InheritanceSpecifier& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InlineAssembly const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(InlineAssembly const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(InlineAssembly& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(InlineAssembly& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Literal const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Literal const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Literal& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Literal& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Mapping const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Mapping const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Mapping& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Mapping& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(MemberAccess const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(MemberAccess const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(MemberAccess& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(MemberAccess& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierDefinition const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierDefinition& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierInvocation const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ModifierInvocation const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ModifierInvocation& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ModifierInvocation& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(NewExpression const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(NewExpression const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(NewExpression& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(NewExpression& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ParameterList const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(ParameterList const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(ParameterList& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(ParameterList& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PlaceholderStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PlaceholderStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PlaceholderStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PlaceholderStatement& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PragmaDirective const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(PragmaDirective const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(PragmaDirective& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(PragmaDirective& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Return const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Return const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Return& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Return& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(SourceUnit const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(SourceUnit const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(SourceUnit& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(SourceUnit& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(StructDefinition const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(StructDefinition const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(StructDefinition& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(StructDefinition& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Throw const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(Throw const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(Throw& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(Throw& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(TupleExpression const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(TupleExpression const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(TupleExpression& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(TupleExpression& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UnaryOperation const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UnaryOperation const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UnaryOperation& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UnaryOperation& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UserDefinedTypeName const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UserDefinedTypeName const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UserDefinedTypeName& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UserDefinedTypeName& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UsingForDirective const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(UsingForDirective const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(UsingForDirective& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(UsingForDirective& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclaration const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclaration const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclaration& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclaration& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclarationStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(VariableDeclarationStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(VariableDeclarationStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(VariableDeclarationStatement& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(WhileStatement const& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTConstVisitor	access:public	signature:(WhileStatement const& _node)
visit	libsolidity/ast/ASTVisitor.h	/^	virtual bool visit(WhileStatement& _node) { return visitNode(_node); }$/;"	f	class:dev::solidity::ASTVisitor	access:public	signature:(WhileStatement& _node)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Block const& _block)$/;"	f	class:ContractCompiler	signature:(Block const& _block)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Break const& _breakStatement)$/;"	f	class:ContractCompiler	signature:(Break const& _breakStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Continue const& _continueStatement)$/;"	f	class:ContractCompiler	signature:(Continue const& _continueStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(EmitStatement const& _emit)$/;"	f	class:ContractCompiler	signature:(EmitStatement const& _emit)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(ExpressionStatement const& _expressionStatement)$/;"	f	class:ContractCompiler	signature:(ExpressionStatement const& _expressionStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(ForStatement const& _forStatement)$/;"	f	class:ContractCompiler	signature:(ForStatement const& _forStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(FunctionDefinition const& _function)$/;"	f	class:ContractCompiler	signature:(FunctionDefinition const& _function)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(IfStatement const& _ifStatement)$/;"	f	class:ContractCompiler	signature:(IfStatement const& _ifStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(InlineAssembly const& _inlineAssembly)$/;"	f	class:ContractCompiler	signature:(InlineAssembly const& _inlineAssembly)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(PlaceholderStatement const& _placeholderStatement)$/;"	f	class:ContractCompiler	signature:(PlaceholderStatement const& _placeholderStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Return const& _return)$/;"	f	class:ContractCompiler	signature:(Return const& _return)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(Throw const&)$/;"	f	class:ContractCompiler	signature:(Throw const&)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(VariableDeclaration const& _variableDeclaration)$/;"	f	class:ContractCompiler	signature:(VariableDeclaration const& _variableDeclaration)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(VariableDeclarationStatement const& _variableDeclarationStatement)$/;"	f	class:ContractCompiler	signature:(VariableDeclarationStatement const& _variableDeclarationStatement)
visit	libsolidity/codegen/ContractCompiler.cpp	/^bool ContractCompiler::visit(WhileStatement const& _whileStatement)$/;"	f	class:ContractCompiler	signature:(WhileStatement const& _whileStatement)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(Assignment const& _assignment)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Assignment const& _assignment)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(BinaryOperation const& _binaryOperation)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(BinaryOperation const& _binaryOperation)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(Conditional const& _condition)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(Conditional const& _condition)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(FunctionCall const& _functionCall)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(FunctionCall const& _functionCall)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(IndexAccess const& _indexAccess)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(MemberAccess const& _memberAccess)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(MemberAccess const& _memberAccess)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(NewExpression const&)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(NewExpression const&)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(TupleExpression const& _tuple)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(TupleExpression const& _tuple)
visit	libsolidity/codegen/ExpressionCompiler.cpp	/^bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)$/;"	f	class:dev::solidity::ExpressionCompiler	signature:(UnaryOperation const& _unaryOperation)
visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(ContractDefinition const& _contract)$/;"	f	class:SMTChecker	signature:(ContractDefinition const& _contract)
visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(ForStatement const& _node)$/;"	f	class:SMTChecker	signature:(ForStatement const& _node)
visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(FunctionDefinition const& _function)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const& _function)
visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(IfStatement const& _node)$/;"	f	class:SMTChecker	signature:(IfStatement const& _node)
visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(MemberAccess const& _memberAccess)$/;"	f	class:SMTChecker	signature:(MemberAccess const& _memberAccess)
visit	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visit(WhileStatement const& _node)$/;"	f	class:SMTChecker	signature:(WhileStatement const& _node)
visit	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::visit(Expression& _e)$/;"	f	class:ASTModifier	signature:(Expression& _e)
visit	libyul/optimiser/ASTWalker.cpp	/^void ASTModifier::visit(Statement& _st)$/;"	f	class:ASTModifier	signature:(Statement& _st)
visit	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::visit(Expression const& _e)$/;"	f	class:ASTWalker	signature:(Expression const& _e)
visit	libyul/optimiser/ASTWalker.cpp	/^void ASTWalker::visit(Statement const& _st)$/;"	f	class:ASTWalker	signature:(Statement const& _st)
visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Expression const& _e);$/;"	p	class:yul::ASTWalker	access:public	signature:(Expression const& _e)
visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Expression& _e);$/;"	p	class:yul::ASTModifier	access:public	signature:(Expression& _e)
visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Statement const& _st);$/;"	p	class:yul::ASTWalker	access:public	signature:(Statement const& _st)
visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Statement& _st);$/;"	p	class:yul::ASTModifier	access:public	signature:(Statement& _st)
visit	libyul/optimiser/CommonSubexpressionEliminator.cpp	/^void CommonSubexpressionEliminator::visit(Expression& _e)$/;"	f	class:CommonSubexpressionEliminator	signature:(Expression& _e)
visit	libyul/optimiser/ExpressionInliner.cpp	/^void ExpressionInliner::visit(Expression& _expression)$/;"	f	class:ExpressionInliner	signature:(Expression& _expression)
visit	libyul/optimiser/ExpressionJoiner.cpp	/^void ExpressionJoiner::visit(Expression& _e)$/;"	f	class:ExpressionJoiner	signature:(Expression& _e)
visit	libyul/optimiser/ExpressionSimplifier.cpp	/^void ExpressionSimplifier::visit(Expression& _expression)$/;"	f	class:ExpressionSimplifier	signature:(Expression& _expression)
visit	libyul/optimiser/ExpressionSimplifier.h	/^	virtual void visit(Expression& _expression);$/;"	p	class:yul::ExpressionSimplifier	access:public	signature:(Expression& _expression)
visit	libyul/optimiser/Metrics.cpp	/^void CodeCost::visit(Expression const& _expression)$/;"	f	class:CodeCost	signature:(Expression const& _expression)
visit	libyul/optimiser/Metrics.cpp	/^void CodeCost::visit(Statement const& _statement)$/;"	f	class:CodeCost	signature:(Statement const& _statement)
visit	libyul/optimiser/Metrics.cpp	/^void CodeSize::visit(Expression const& _expression)$/;"	f	class:CodeSize	signature:(Expression const& _expression)
visit	libyul/optimiser/Metrics.cpp	/^void CodeSize::visit(Statement const& _statement)$/;"	f	class:CodeSize	signature:(Statement const& _statement)
visit	libyul/optimiser/Rematerialiser.cpp	/^void Rematerialiser::visit(Expression& _e)$/;"	f	class:Rematerialiser	signature:(Expression& _e)
visit	libyul/optimiser/Semantics.cpp	/^void MovableChecker::visit(Statement const&)$/;"	f	class:MovableChecker	signature:(Statement const&)
visit	solse/SymExecEngine.cpp	/^bool SymExecEngine::visit(ContractDefinition const& _node){$/;"	f	class:SymExecEngine	signature:(ContractDefinition const& _node)
visit	solse/SymExecEngine.cpp	/^visit(BinaryOperation const& _node) {$/;"	f	class:SymExecEngine	signature:(BinaryOperation const& _node)
visit	solse/SymExecEngine.cpp	/^visit(FunctionDefinition const& _node) {$/;"	f	class:SymExecEngine	signature:(FunctionDefinition const& _node)
visit	solse/SymExecEngine.cpp	/^visit(Literal const& _node) {$/;"	f	class:SymExecEngine	signature:(Literal const& _node)
visit	solse/SymExecEngine.cpp	/^visit(StructDefinition const& _node) {$/;"	f	class:SymExecEngine	signature:(StructDefinition const& _node)
visit	solse/SymExecEngine.cpp	/^visit(VariableDeclaration const& _node) {$/;"	f	class:SymExecEngine	signature:(VariableDeclaration const& _node)
visitAssert	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitAssert(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
visitAssert	libsolidity/formal/SMTChecker.h	/^	void visitAssert(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
visitBranch	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::VariableIndices SMTChecker::visitBranch(Statement const& _statement, smt::Expression _condition)$/;"	f	class:SMTChecker	signature:(Statement const& _statement, smt::Expression _condition)
visitBranch	libsolidity/formal/SMTChecker.cpp	/^SMTChecker::VariableIndices SMTChecker::visitBranch(Statement const& _statement, smt::Expression const* _condition)$/;"	f	class:SMTChecker	signature:(Statement const& _statement, smt::Expression const* _condition)
visitBranch	libsolidity/formal/SMTChecker.h	/^	VariableIndices visitBranch(Statement const& _statement, smt::Expression _condition);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Statement const& _statement, smt::Expression _condition)
visitDeclaration	libyul/optimiser/SyntacticalEquality.cpp	/^bool SyntacticallyEqual::visitDeclaration(TypedName const& _lhs, TypedName const& _rhs)$/;"	f	class:SyntacticallyEqual	signature:(TypedName const& _lhs, TypedName const& _rhs)
visitDeclaration	libyul/optimiser/SyntacticalEquality.h	/^	bool visitDeclaration(TypedName const& _lhs, TypedName const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(TypedName const& _lhs, TypedName const& _rhs)
visitExpression	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::visitExpression(Expression const& _expression)$/;"	f	class:CodeTransform	signature:(Expression const& _expression)
visitExpression	libyul/backends/evm/EVMCodeTransform.h	/^	void visitExpression(Expression const& _expression);$/;"	p	class:yul::CodeTransform	access:private	signature:(Expression const& _expression)
visitFunctionIdentifier	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitFunctionIdentifier(Identifier const& _identifier)$/;"	f	class:SMTChecker	signature:(Identifier const& _identifier)
visitFunctionIdentifier	libsolidity/formal/SMTChecker.h	/^	void visitFunctionIdentifier(Identifier const& _identifier);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(Identifier const& _identifier)
visitGasLeft	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitGasLeft(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
visitGasLeft	libsolidity/formal/SMTChecker.h	/^	void visitGasLeft(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
visitManually	libsolidity/analysis/TypeChecker.cpp	/^void TypeChecker::visitManually($/;"	f	class:TypeChecker	signature:( ModifierInvocation const& _modifier, vector<ContractDefinition const*> const& _bases )
visitManually	libsolidity/analysis/TypeChecker.h	/^	void visitManually(ModifierInvocation const& _modifier, std::vector<ContractDefinition const*> const& _bases);$/;"	p	class:dev::solidity::TypeChecker	access:private	signature:(ModifierInvocation const& _modifier, std::vector<ContractDefinition const*> const& _bases)
visitNode	libsolidity/analysis/ControlFlowBuilder.cpp	/^bool ControlFlowBuilder::visitNode(ASTNode const& _node)$/;"	f	class:ControlFlowBuilder	signature:(ASTNode const& _node)
visitNode	libsolidity/analysis/ControlFlowGraph.h	/^  virtual bool visitNode(ASTNode const&){ return true; }$/;"	f	class:dev::solidity::CFGConstVisitor	access:protected	signature:(ASTNode const&)
visitNode	libsolidity/ast/ASTVisitor.h	/^	virtual bool visitNode(ASTNode const&) { return true; }$/;"	f	class:dev::solidity::ASTConstVisitor	access:protected	signature:(ASTNode const&)
visitNode	libsolidity/ast/ASTVisitor.h	/^	virtual bool visitNode(ASTNode&) { return true; }$/;"	f	class:dev::solidity::ASTVisitor	access:protected	signature:(ASTNode&)
visitNumber	solse/SymExecEngine.h	/^    unsigned int visitNumber;$/;"	m	class:SymExecEngine	access:private
visitRequire	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitRequire(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
visitRequire	libsolidity/formal/SMTChecker.h	/^	void visitRequire(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
visitStatements	libyul/backends/evm/EVMCodeTransform.cpp	/^void CodeTransform::visitStatements(vector<Statement> const& _statements)$/;"	f	class:CodeTransform	signature:(vector<Statement> const& _statements)
visitStatements	libyul/backends/evm/EVMCodeTransform.h	/^	void visitStatements(std::vector<Statement> const& _statements);$/;"	p	class:yul::CodeTransform	access:private	signature:(std::vector<Statement> const& _statements)
visitTypeConversion	libsolidity/formal/SMTChecker.cpp	/^void SMTChecker::visitTypeConversion(FunctionCall const& _funCall)$/;"	f	class:SMTChecker	signature:(FunctionCall const& _funCall)
visitTypeConversion	libsolidity/formal/SMTChecker.h	/^	void visitTypeConversion(FunctionCall const& _funCall);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionCall const& _funCall)
visitedFunction	libsolidity/formal/SMTChecker.cpp	/^bool SMTChecker::visitedFunction(FunctionDefinition const* _funDef)$/;"	f	class:SMTChecker	signature:(FunctionDefinition const* _funDef)
visitedFunction	libsolidity/formal/SMTChecker.h	/^	bool visitedFunction(FunctionDefinition const* _funDef);$/;"	p	class:dev::solidity::SMTChecker	access:private	signature:(FunctionDefinition const* _funDef)
visitedJumpdests	libevmasm/PathGasMeter.h	/^	std::set<size_t> visitedJumpdests;$/;"	m	struct:dev::eth::GasPath	access:public
walkVector	libyul/optimiser/ASTWalker.h	/^	void walkVector(T const& _statements)$/;"	f	class:yul::ASTWalker	access:protected	signature:(T const& _statements)
walkVector	libyul/optimiser/ASTWalker.h	/^	void walkVector(T&& _statements)$/;"	f	class:yul::ASTModifier	access:protected	signature:(T&& _statements)
warnOnInstructions	libyul/AsmAnalysis.cpp	/^void AsmAnalyzer::warnOnInstructions(solidity::Instruction _instr, SourceLocation const& _location)$/;"	f	class:AsmAnalyzer	signature:(solidity::Instruction _instr, SourceLocation const& _location)
warnOnInstructions	libyul/AsmAnalysis.h	/^	void warnOnInstructions(dev::solidity::Instruction _instr, langutil::SourceLocation const& _location);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(dev::solidity::Instruction _instr, langutil::SourceLocation const& _location)
warnVariablesNamedLikeInstructions	libsolidity/analysis/NameAndTypeResolver.cpp	/^void NameAndTypeResolver::warnVariablesNamedLikeInstructions()$/;"	f	class:dev::solidity::NameAndTypeResolver	signature:()
warnVariablesNamedLikeInstructions	libsolidity/analysis/NameAndTypeResolver.h	/^	void warnVariablesNamedLikeInstructions();$/;"	p	class:dev::solidity::NameAndTypeResolver	access:public	signature:()
warning	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::warning($/;"	f	class:ErrorReporter	signature:( SourceLocation const& _location, string const& _description )
warning	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::warning($/;"	f	class:ErrorReporter	signature:( SourceLocation const& _location, string const& _description, SecondarySourceLocation const& _secondaryLocation )
warning	liblangutil/ErrorReporter.cpp	/^void ErrorReporter::warning(string const& _description)$/;"	f	class:ErrorReporter	signature:(string const& _description)
warning	liblangutil/ErrorReporter.h	/^	void warning($/;"	p	class:langutil::ErrorReporter	access:public	signature:( SourceLocation const& _location, std::string const& _description, SecondarySourceLocation const& _secondaryLocation )
warning	liblangutil/ErrorReporter.h	/^	void warning(SourceLocation const& _location, std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(SourceLocation const& _location, std::string const& _description)
warning	liblangutil/ErrorReporter.h	/^	void warning(std::string const& _description);$/;"	p	class:langutil::ErrorReporter	access:public	signature:(std::string const& _description)
windowSize	libevmasm/PeepholeOptimiser.h	/^	virtual size_t windowSize() const;$/;"	p	class:dev::eth::PeepholeOptimisationMethod	access:public	signature:() const
wordGas	libevmasm/GasMeter.cpp	/^GasMeter::GasConsumption GasMeter::wordGas(u256 const& _multiplier, ExpressionClasses::Id _value)$/;"	f	class:GasMeter	signature:(u256 const& _multiplier, ExpressionClasses::Id _value)
wordGas	libevmasm/GasMeter.h	/^	GasConsumption wordGas(u256 const& _multiplier, ExpressionClasses::Id _value);$/;"	p	class:dev::eth::GasMeter	access:private	signature:(u256 const& _multiplier, ExpressionClasses::Id _value)
write	libsolidity/formal/SMTLib2Interface.cpp	/^void SMTLib2Interface::write(string _data)$/;"	f	class:SMTLib2Interface	signature:(string _data)
write	libsolidity/formal/SMTLib2Interface.h	/^	void write(std::string _data);$/;"	p	class:dev::solidity::smt::SMTLib2Interface	access:private	signature:(std::string _data)
writeLine	libsolidity/analysis/ControlFlowPrinter.cpp	/^void ControlFlowPrinter::writeLine(string const& _line) const$/;"	f	class:ControlFlowPrinter	signature:(string const& _line) const
writeLine	libsolidity/analysis/ControlFlowPrinter.h	/^  void writeLine(std::string const& _line) const;$/;"	p	class:dev::solidity::ControlFlowPrinter	access:private	signature:(std::string const& _line) const
writeLine	libsolidity/ast/ASTPrinter.cpp	/^void ASTPrinter::writeLine(string const& _line)$/;"	f	class:dev::solidity::ASTPrinter	signature:(string const& _line)
writeLine	libsolidity/ast/ASTPrinter.h	/^	void writeLine(std::string const& _line);$/;"	p	class:dev::solidity::ASTPrinter	access:private	signature:(std::string const& _line)
writeLinkedFiles	solse/CommandLineInterface.cpp	/^void CommandLineInterface::writeLinkedFiles()$/;"	f	class:dev::solidity::CommandLineInterface	signature:()
writeLinkedFiles	solse/CommandLineInterface.h	/^	void writeLinkedFiles();$/;"	p	class:dev::solidity::DocumentationType	access:private	signature:()
yul	libsolidity/ast/AST.h	/^namespace yul$/;"	n
yul	libsolidity/ast/ASTAnnotations.h	/^namespace yul$/;"	n
yul	libyul/AsmAnalysis.h	/^namespace yul$/;"	n
yul	libyul/AsmAnalysisInfo.h	/^namespace yul$/;"	n
yul	libyul/AsmData.h	/^namespace yul$/;"	n
yul	libyul/AsmDataForward.h	/^namespace yul$/;"	n
yul	libyul/AsmParser.h	/^namespace yul$/;"	n
yul	libyul/AsmPrinter.h	/^namespace yul$/;"	n
yul	libyul/AsmScope.h	/^namespace yul$/;"	n
yul	libyul/AsmScopeFiller.h	/^namespace yul$/;"	n
yul	libyul/AssemblyStack.h	/^namespace yul$/;"	n
yul	libyul/CompilabilityChecker.h	/^namespace yul$/;"	n
yul	libyul/Dialect.h	/^	static std::shared_ptr<Dialect> yul()$/;"	f	struct:yul::Dialect	access:public	signature:()
yul	libyul/Dialect.h	/^namespace yul$/;"	n
yul	libyul/Exceptions.h	/^namespace yul$/;"	n
yul	libyul/Object.h	/^namespace yul$/;"	n
yul	libyul/ObjectParser.h	/^namespace yul$/;"	n
yul	libyul/Utilities.h	/^namespace yul$/;"	n
yul	libyul/YulString.h	/^namespace yul$/;"	n
yul	libyul/backends/evm/AsmCodeGen.h	/^namespace yul$/;"	n
yul	libyul/backends/evm/EVMAssembly.h	/^namespace yul$/;"	n
yul	libyul/backends/evm/EVMCodeTransform.h	/^namespace yul$/;"	n
yul	libyul/backends/evm/EVMDialect.h	/^namespace yul$/;"	n
yul	libyul/backends/evm/EVMObjectCompiler.h	/^namespace yul$/;"	n
yul	libyul/backends/evm/NoOutputAssembly.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ASTCopier.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ASTWalker.h	/^namespace yul$/;"	n
yul	libyul/optimiser/BlockFlattener.h	/^namespace yul$/;"	n
yul	libyul/optimiser/CommonSubexpressionEliminator.h	/^namespace yul$/;"	n
yul	libyul/optimiser/DataFlowAnalyzer.h	/^namespace yul$/;"	n
yul	libyul/optimiser/Disambiguator.h	/^namespace yul$/;"	n
yul	libyul/optimiser/EquivalentFunctionCombiner.h	/^namespace yul$/;"	n
yul	libyul/optimiser/EquivalentFunctionDetector.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ExpressionInliner.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ExpressionJoiner.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ExpressionSimplifier.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ExpressionSplitter.h	/^namespace yul$/;"	n
yul	libyul/optimiser/ForLoopInitRewriter.h	/^namespace yul$/;"	n
yul	libyul/optimiser/FullInliner.h	/^namespace yul$/;"	n
yul	libyul/optimiser/FunctionGrouper.h	/^namespace yul$/;"	n
yul	libyul/optimiser/FunctionHoister.h	/^namespace yul$/;"	n
yul	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^namespace yul$/;"	n
yul	libyul/optimiser/MainFunction.h	/^namespace yul$/;"	n
yul	libyul/optimiser/Metrics.h	/^namespace yul$/;"	n
yul	libyul/optimiser/NameCollector.h	/^namespace yul$/;"	n
yul	libyul/optimiser/NameDispenser.h	/^namespace yul$/;"	n
yul	libyul/optimiser/OptimizerUtilities.h	/^namespace yul$/;"	n
yul	libyul/optimiser/RedundantAssignEliminator.h	/^namespace yul$/;"	n
yul	libyul/optimiser/Rematerialiser.h	/^namespace yul$/;"	n
yul	libyul/optimiser/SSAReverser.h	/^namespace yul$/;"	n
yul	libyul/optimiser/SSATransform.h	/^namespace yul$/;"	n
yul	libyul/optimiser/SSAValueTracker.h	/^namespace yul$/;"	n
yul	libyul/optimiser/Semantics.h	/^namespace yul$/;"	n
yul	libyul/optimiser/SimplificationRules.h	/^namespace yul$/;"	n
yul	libyul/optimiser/StackCompressor.h	/^namespace yul$/;"	n
yul	libyul/optimiser/StructuralSimplifier.h	/^namespace yul$/;"	n
yul	libyul/optimiser/Substitution.h	/^namespace yul$/;"	n
yul	libyul/optimiser/Suite.h	/^namespace yul$/;"	n
yul	libyul/optimiser/SyntacticalEquality.h	/^namespace yul$/;"	n
yul	libyul/optimiser/UnusedPruner.h	/^namespace yul$/;"	n
yul	libyul/optimiser/VarDeclInitializer.h	/^namespace yul$/;"	n
yul	libyul/optimiser/VarNameCleaner.h	/^namespace yul$/;"	n
yul::ASTCopier	libyul/optimiser/ASTCopier.h	/^class ASTCopier: public ExpressionCopier, public StatementCopier$/;"	c	namespace:yul	inherits:ExpressionCopier,StatementCopier
yul::ASTCopier::enterFunction	libyul/optimiser/ASTCopier.h	/^	virtual void enterFunction(FunctionDefinition const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(FunctionDefinition const&)
yul::ASTCopier::enterScope	libyul/optimiser/ASTCopier.h	/^	virtual void enterScope(Block const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(Block const&)
yul::ASTCopier::leaveFunction	libyul/optimiser/ASTCopier.h	/^	virtual void leaveFunction(FunctionDefinition const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(FunctionDefinition const&)
yul::ASTCopier::leaveScope	libyul/optimiser/ASTCopier.h	/^	virtual void leaveScope(Block const&) { }$/;"	f	class:yul::ASTCopier	access:protected	signature:(Block const&)
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(FunctionCall const&) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(FunctionalInstruction const& _instr) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(Identifier const& _identifier) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Expression operator()(Literal const& _literal) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Assignment const& _assignment) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Block const& _block) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(ExpressionStatement const& _statement) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(ForLoop const&) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(FunctionDefinition const&) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(If const& _if) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Instruction const& _instruction) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Label const& _label) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(StackAssignment const& _assignment) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(Switch const& _switch) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::override	libyul/optimiser/ASTCopier.h	/^	Statement operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::ASTCopier	access:public
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	Block translate(Block const& _block);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Block const& _block)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	Case translate(Case const& _case);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Case const& _case)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	Identifier translate(Identifier const& _identifier);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Identifier const& _identifier)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	Literal translate(Literal const& _literal);$/;"	p	class:yul::ASTCopier	access:protected	signature:(Literal const& _literal)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	TypedName translate(TypedName const& _typedName);$/;"	p	class:yul::ASTCopier	access:protected	signature:(TypedName const& _typedName)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	std::unique_ptr<T> translate(std::unique_ptr<T> const& _v)$/;"	f	class:yul::ASTCopier	access:protected	signature:(std::unique_ptr<T> const& _v)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	virtual Expression translate(Expression const& _expression);$/;"	p	class:yul::ASTCopier	access:public	signature:(Expression const& _expression)
yul::ASTCopier::translate	libyul/optimiser/ASTCopier.h	/^	virtual Statement translate(Statement const& _statement);$/;"	p	class:yul::ASTCopier	access:public	signature:(Statement const& _statement)
yul::ASTCopier::translateIdentifier	libyul/optimiser/ASTCopier.h	/^	virtual YulString translateIdentifier(YulString _name) { return _name; }$/;"	f	class:yul::ASTCopier	access:protected	signature:(YulString _name)
yul::ASTCopier::translateVector	libyul/optimiser/ASTCopier.h	/^	std::vector<T> translateVector(std::vector<T> const& _values);$/;"	p	class:yul::ASTCopier	access:protected	signature:(std::vector<T> const& _values)
yul::ASTCopier::translateVector	libyul/optimiser/ASTCopier.h	/^std::vector<T> ASTCopier::translateVector(std::vector<T> const& _values)$/;"	f	class:yul::ASTCopier	signature:(std::vector<T> const& _values)
yul::ASTCopier::~ASTCopier	libyul/optimiser/ASTCopier.h	/^	virtual ~ASTCopier() = default;$/;"	p	class:yul::ASTCopier	access:public	signature:()
yul::ASTModifier	libyul/optimiser/ASTWalker.h	/^class ASTModifier: public boost::static_visitor<>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Assignment& _assignment);$/;"	p	class:yul::ASTModifier	access:public	signature:(Assignment& _assignment)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Block& _block);$/;"	p	class:yul::ASTModifier	access:public	signature:(Block& _block)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ExpressionStatement& _statement);$/;"	p	class:yul::ASTModifier	access:public	signature:(ExpressionStatement& _statement)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ForLoop&);$/;"	p	class:yul::ASTModifier	access:public	signature:(ForLoop&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionCall& _funCall);$/;"	p	class:yul::ASTModifier	access:public	signature:(FunctionCall& _funCall)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionDefinition&);$/;"	p	class:yul::ASTModifier	access:public	signature:(FunctionDefinition&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionalInstruction& _instr);$/;"	p	class:yul::ASTModifier	access:public	signature:(FunctionalInstruction& _instr)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Identifier&) {}$/;"	f	class:yul::ASTModifier	access:public	signature:(Identifier&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(If& _if);$/;"	p	class:yul::ASTModifier	access:public	signature:(If& _if)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Instruction&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTModifier	access:public	signature:(Instruction&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Label&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTModifier	access:public	signature:(Label&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Literal&) {}$/;"	f	class:yul::ASTModifier	access:public	signature:(Literal&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(StackAssignment&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTModifier	access:public	signature:(StackAssignment&)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Switch& _switch);$/;"	p	class:yul::ASTModifier	access:public	signature:(Switch& _switch)
yul::ASTModifier::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(VariableDeclaration& _varDecl);$/;"	p	class:yul::ASTModifier	access:public	signature:(VariableDeclaration& _varDecl)
yul::ASTModifier::visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Expression& _e);$/;"	p	class:yul::ASTModifier	access:public	signature:(Expression& _e)
yul::ASTModifier::visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Statement& _st);$/;"	p	class:yul::ASTModifier	access:public	signature:(Statement& _st)
yul::ASTModifier::walkVector	libyul/optimiser/ASTWalker.h	/^	void walkVector(T&& _statements)$/;"	f	class:yul::ASTModifier	access:protected	signature:(T&& _statements)
yul::ASTModifier::~ASTModifier	libyul/optimiser/ASTWalker.h	/^	virtual ~ASTModifier() = default;$/;"	p	class:yul::ASTModifier	access:public	signature:()
yul::ASTWalker	libyul/optimiser/ASTWalker.h	/^class ASTWalker: public boost::static_visitor<>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Assignment const& _assignment);$/;"	p	class:yul::ASTWalker	access:public	signature:(Assignment const& _assignment)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Block const& _block);$/;"	p	class:yul::ASTWalker	access:public	signature:(Block const& _block)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ExpressionStatement const& _statement);$/;"	p	class:yul::ASTWalker	access:public	signature:(ExpressionStatement const& _statement)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(ForLoop const&);$/;"	p	class:yul::ASTWalker	access:public	signature:(ForLoop const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionCall const& _funCall);$/;"	p	class:yul::ASTWalker	access:public	signature:(FunctionCall const& _funCall)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionDefinition const&);$/;"	p	class:yul::ASTWalker	access:public	signature:(FunctionDefinition const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(FunctionalInstruction const& _instr);$/;"	p	class:yul::ASTWalker	access:public	signature:(FunctionalInstruction const& _instr)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Identifier const&) {}$/;"	f	class:yul::ASTWalker	access:public	signature:(Identifier const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(If const& _if);$/;"	p	class:yul::ASTWalker	access:public	signature:(If const& _if)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Instruction const&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTWalker	access:public	signature:(Instruction const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Label const&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTWalker	access:public	signature:(Label const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Literal const&) {}$/;"	f	class:yul::ASTWalker	access:public	signature:(Literal const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(StackAssignment const&) { assertThrow(false, OptimizerException, ""); }$/;"	f	class:yul::ASTWalker	access:public	signature:(StackAssignment const&)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(Switch const& _switch);$/;"	p	class:yul::ASTWalker	access:public	signature:(Switch const& _switch)
yul::ASTWalker::operator ()	libyul/optimiser/ASTWalker.h	/^	virtual void operator()(VariableDeclaration const& _varDecl);$/;"	p	class:yul::ASTWalker	access:public	signature:(VariableDeclaration const& _varDecl)
yul::ASTWalker::visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Expression const& _e);$/;"	p	class:yul::ASTWalker	access:public	signature:(Expression const& _e)
yul::ASTWalker::visit	libyul/optimiser/ASTWalker.h	/^	virtual void visit(Statement const& _st);$/;"	p	class:yul::ASTWalker	access:public	signature:(Statement const& _st)
yul::ASTWalker::walkVector	libyul/optimiser/ASTWalker.h	/^	void walkVector(T const& _statements)$/;"	f	class:yul::ASTWalker	access:protected	signature:(T const& _statements)
yul::ASTWalker::~ASTWalker	libyul/optimiser/ASTWalker.h	/^	virtual ~ASTWalker() = default;$/;"	p	class:yul::ASTWalker	access:public	signature:()
yul::AsmAnalysisInfo	libyul/AsmAnalysisInfo.h	/^struct AsmAnalysisInfo$/;"	s	namespace:yul
yul::AsmAnalysisInfo::stackHeightInfo	libyul/AsmAnalysisInfo.h	/^	StackHeightInfo stackHeightInfo;$/;"	m	struct:yul::AsmAnalysisInfo	access:public
yul::AsmAnalysisInfo::virtualBlocks	libyul/AsmAnalysisInfo.h	/^	std::map<FunctionDefinition const*, std::shared_ptr<Block const>> virtualBlocks;$/;"	m	struct:yul::AsmAnalysisInfo	access:public
yul::AsmAnalyzer	libyul/AsmAnalysis.h	/^class AsmAnalyzer: public boost::static_visitor<bool>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::AsmAnalyzer::AsmAnalyzer	libyul/AsmAnalysis.h	/^	explicit AsmAnalyzer($/;"	f	class:yul::AsmAnalyzer	access:public	signature:( AsmAnalysisInfo& _analysisInfo, langutil::ErrorReporter& _errorReporter, boost::optional<langutil::Error::Type> _errorTypeForLoose, std::shared_ptr<Dialect> _dialect, ExternalIdentifierAccess::Resolver const& _resolver = ExternalIdentifierAccess::Resolver() )
yul::AsmAnalyzer::analyze	libyul/AsmAnalysis.h	/^	bool analyze(Block const& _block);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Block const& _block)
yul::AsmAnalyzer::analyzeStrictAssertCorrect	libyul/AsmAnalysis.h	/^	static AsmAnalysisInfo analyzeStrictAssertCorrect($/;"	p	class:yul::AsmAnalyzer	access:public	signature:( std::shared_ptr<Dialect> _dialect, Block const& _ast )
yul::AsmAnalyzer::checkAssignment	libyul/AsmAnalysis.h	/^	bool checkAssignment(Identifier const& _assignment, size_t _valueSize = size_t(-1));$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(Identifier const& _assignment, size_t _valueSize = size_t(-1))
yul::AsmAnalyzer::checkLooseFeature	libyul/AsmAnalysis.h	/^	void checkLooseFeature(langutil::SourceLocation const& _location, std::string const& _description);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(langutil::SourceLocation const& _location, std::string const& _description)
yul::AsmAnalyzer::expectDeposit	libyul/AsmAnalysis.h	/^	bool expectDeposit(int _deposit, int _oldHeight, langutil::SourceLocation const& _location);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(int _deposit, int _oldHeight, langutil::SourceLocation const& _location)
yul::AsmAnalyzer::expectExpression	libyul/AsmAnalysis.h	/^	bool expectExpression(Expression const& _expr);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(Expression const& _expr)
yul::AsmAnalyzer::expectValidType	libyul/AsmAnalysis.h	/^	void expectValidType(std::string const& type, langutil::SourceLocation const& _location);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(std::string const& type, langutil::SourceLocation const& _location)
yul::AsmAnalyzer::m_activeVariables	libyul/AsmAnalysis.h	/^	std::set<Scope::Variable const*> m_activeVariables;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_currentScope	libyul/AsmAnalysis.h	/^	Scope* m_currentScope = nullptr;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_dialect	libyul/AsmAnalysis.h	/^	std::shared_ptr<Dialect> m_dialect;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_errorReporter	libyul/AsmAnalysis.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_errorTypeForLoose	libyul/AsmAnalysis.h	/^	boost::optional<langutil::Error::Type> m_errorTypeForLoose;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_evmVersion	libyul/AsmAnalysis.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_info	libyul/AsmAnalysis.h	/^	AsmAnalysisInfo& m_info;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_resolver	libyul/AsmAnalysis.h	/^	yul::ExternalIdentifierAccess::Resolver m_resolver;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::m_stackHeight	libyul/AsmAnalysis.h	/^	int m_stackHeight = 0;$/;"	m	class:yul::AsmAnalyzer	access:private
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Assignment const& _assignment);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Assignment const& _assignment)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Block const& _block);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Block const& _block)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(ExpressionStatement const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(ExpressionStatement const&)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(ForLoop const& _forLoop);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(ForLoop const& _forLoop)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(FunctionCall const& _functionCall);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(FunctionCall const& _functionCall)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(FunctionDefinition const& _functionDefinition);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(FunctionDefinition const& _functionDefinition)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(FunctionalInstruction const& _functionalInstruction);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(FunctionalInstruction const& _functionalInstruction)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Identifier const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Identifier const&)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(If const& _if);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(If const& _if)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Instruction const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Instruction const&)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Label const& _label);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Label const& _label)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Literal const& _literal);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Literal const& _literal)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(StackAssignment const&);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(StackAssignment const&)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(Switch const& _switch);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(Switch const& _switch)
yul::AsmAnalyzer::operator ()	libyul/AsmAnalysis.h	/^	bool operator()(VariableDeclaration const& _variableDeclaration);$/;"	p	class:yul::AsmAnalyzer	access:public	signature:(VariableDeclaration const& _variableDeclaration)
yul::AsmAnalyzer::scope	libyul/AsmAnalysis.h	/^	Scope& scope(Block const* _block);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(Block const* _block)
yul::AsmAnalyzer::warnOnInstructions	libyul/AsmAnalysis.h	/^	void warnOnInstructions(dev::solidity::Instruction _instr, langutil::SourceLocation const& _location);$/;"	p	class:yul::AsmAnalyzer	access:private	signature:(dev::solidity::Instruction _instr, langutil::SourceLocation const& _location)
yul::AsmFlavour	libyul/Dialect.h	/^enum class AsmFlavour$/;"	c	namespace:yul
yul::AsmFlavour::Loose	libyul/Dialect.h	/^	Loose,  \/\/ no types, EVM instructions as function, jumps and direct stack manipulations$/;"	m	class:yul::AsmFlavour	access:private
yul::AsmFlavour::Strict	libyul/Dialect.h	/^	Strict, \/\/ no types, EVM instructions as functions, but no jumps and no direct stack manipulations$/;"	m	class:yul::AsmFlavour	access:private
yul::AsmPrinter	libyul/AsmPrinter.h	/^class AsmPrinter: public boost::static_visitor<std::string>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::AsmPrinter::AsmPrinter	libyul/AsmPrinter.h	/^	explicit AsmPrinter(bool _yul = false): m_yul(_yul) {}$/;"	f	class:yul::AsmPrinter	access:public	signature:(bool _yul = false)
yul::AsmPrinter::appendTypeName	libyul/AsmPrinter.h	/^	std::string appendTypeName(YulString _type) const;$/;"	p	class:yul::AsmPrinter	access:private	signature:(YulString _type) const
yul::AsmPrinter::formatTypedName	libyul/AsmPrinter.h	/^	std::string formatTypedName(TypedName _variable) const;$/;"	p	class:yul::AsmPrinter	access:private	signature:(TypedName _variable) const
yul::AsmPrinter::m_yul	libyul/AsmPrinter.h	/^	bool m_yul = false;$/;"	m	class:yul::AsmPrinter	access:private
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Assignment const& _assignment) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Assignment const& _assignment) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Block const& _block) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Block const& _block) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(ExpressionStatement const& _expr) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(ExpressionStatement const& _expr) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(ForLoop const& _forLoop) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(ForLoop const& _forLoop) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(FunctionCall const& _functionCall) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(FunctionCall const& _functionCall) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(FunctionDefinition const& _functionDefinition) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(FunctionDefinition const& _functionDefinition) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(FunctionalInstruction const& _functionalInstruction) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(FunctionalInstruction const& _functionalInstruction) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Identifier const& _identifier) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Identifier const& _identifier) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(If const& _if) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(If const& _if) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Instruction const& _instruction) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Instruction const& _instruction) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Label const& _label) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Label const& _label) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Literal const& _literal) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Literal const& _literal) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(StackAssignment const& _assignment) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(StackAssignment const& _assignment) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(Switch const& _switch) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(Switch const& _switch) const
yul::AsmPrinter::operator ()	libyul/AsmPrinter.h	/^	std::string operator()(VariableDeclaration const& _variableDeclaration) const;$/;"	p	class:yul::AsmPrinter	access:public	signature:(VariableDeclaration const& _variableDeclaration) const
yul::AssemblyStack	libyul/AssemblyStack.h	/^class AssemblyStack$/;"	c	namespace:yul
yul::AssemblyStack::AssemblyStack	libyul/AssemblyStack.h	/^	explicit AssemblyStack(langutil::EVMVersion _evmVersion = langutil::EVMVersion(), Language _language = Language::Assembly):$/;"	f	class:yul::AssemblyStack	access:public	signature:(langutil::EVMVersion _evmVersion = langutil::EVMVersion(), Language _language = Language::Assembly)
yul::AssemblyStack::Language	libyul/AssemblyStack.h	/^	enum class Language { Yul, Assembly, StrictAssembly };$/;"	c	class:yul::AssemblyStack	access:public
yul::AssemblyStack::Language::Assembly	libyul/AssemblyStack.h	/^	enum class Language { Yul, Assembly, StrictAssembly };$/;"	m	class:yul::AssemblyStack::Language	access:private
yul::AssemblyStack::Language::Yul	libyul/AssemblyStack.h	/^	enum class Language { Yul, Assembly, StrictAssembly };$/;"	m	class:yul::AssemblyStack::Language	access:private
yul::AssemblyStack::Machine	libyul/AssemblyStack.h	/^	enum class Machine { EVM, EVM15, eWasm };$/;"	c	class:yul::AssemblyStack	access:public
yul::AssemblyStack::Machine::EVM	libyul/AssemblyStack.h	/^	enum class Machine { EVM, EVM15, eWasm };$/;"	m	class:yul::AssemblyStack::Machine	access:private
yul::AssemblyStack::Machine::EVM15	libyul/AssemblyStack.h	/^	enum class Machine { EVM, EVM15, eWasm };$/;"	m	class:yul::AssemblyStack::Machine	access:private
yul::AssemblyStack::analyzeParsed	libyul/AssemblyStack.h	/^	bool analyzeParsed();$/;"	p	class:yul::AssemblyStack	access:private	signature:()
yul::AssemblyStack::analyzeParsed	libyul/AssemblyStack.h	/^	bool analyzeParsed(yul::Object& _object);$/;"	p	class:yul::AssemblyStack	access:private	signature:(yul::Object& _object)
yul::AssemblyStack::assemble	libyul/AssemblyStack.h	/^	MachineAssemblyObject assemble(Machine _machine, bool _optimize = false) const;$/;"	p	class:yul::AssemblyStack	access:public	signature:(Machine _machine, bool _optimize = false) const
yul::AssemblyStack::compileEVM	libyul/AssemblyStack.h	/^	void compileEVM(yul::AbstractAssembly& _assembly, bool _evm15, bool _optimize) const;$/;"	p	class:yul::AssemblyStack	access:private	signature:(yul::AbstractAssembly& _assembly, bool _evm15, bool _optimize) const
yul::AssemblyStack::langutil::errors	libyul/AssemblyStack.h	/^	langutil::ErrorList const& errors() const { return m_errors; }$/;"	f	class:yul::AssemblyStack::langutil	access:public	signature:() const
yul::AssemblyStack::langutil::scanner	libyul/AssemblyStack.h	/^	langutil::Scanner const& scanner() const;$/;"	p	class:yul::AssemblyStack::langutil	access:public	signature:() const
yul::AssemblyStack::m_analysisSuccessful	libyul/AssemblyStack.h	/^	bool m_analysisSuccessful = false;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::m_errorReporter	libyul/AssemblyStack.h	/^	langutil::ErrorReporter m_errorReporter;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::m_errors	libyul/AssemblyStack.h	/^	langutil::ErrorList m_errors;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::m_evmVersion	libyul/AssemblyStack.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::m_language	libyul/AssemblyStack.h	/^	Language m_language = Language::Assembly;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::m_parserResult	libyul/AssemblyStack.h	/^	std::shared_ptr<yul::Object> m_parserResult;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::m_scanner	libyul/AssemblyStack.h	/^	std::shared_ptr<langutil::Scanner> m_scanner;$/;"	m	class:yul::AssemblyStack	access:private
yul::AssemblyStack::optimize	libyul/AssemblyStack.h	/^	void optimize();$/;"	p	class:yul::AssemblyStack	access:public	signature:()
yul::AssemblyStack::optimize	libyul/AssemblyStack.h	/^	void optimize(yul::Object& _object);$/;"	p	class:yul::AssemblyStack	access:private	signature:(yul::Object& _object)
yul::AssemblyStack::parseAndAnalyze	libyul/AssemblyStack.h	/^	bool parseAndAnalyze(std::string const& _sourceName, std::string const& _source);$/;"	p	class:yul::AssemblyStack	access:public	signature:(std::string const& _sourceName, std::string const& _source)
yul::AssemblyStack::parserResult	libyul/AssemblyStack.h	/^	std::shared_ptr<Object> parserResult() const;$/;"	p	class:yul::AssemblyStack	access:public	signature:() const
yul::AssemblyStack::print	libyul/AssemblyStack.h	/^	std::string print() const;$/;"	p	class:yul::AssemblyStack	access:public	signature:() const
yul::Assignment	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	s	namespace:yul
yul::Assignment::location	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::Assignment	access:public
yul::Assignment::value	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::Assignment	access:public
yul::Assignment::variableNames	libyul/AsmData.h	/^struct Assignment { langutil::SourceLocation location; std::vector<Identifier> variableNames; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::Assignment	access:public
yul::AssignmentCounter	libyul/optimiser/Metrics.h	/^class AssignmentCounter: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::AssignmentCounter::assignmentCount	libyul/optimiser/Metrics.h	/^	std::size_t assignmentCount(YulString _name) const;$/;"	p	class:yul::AssignmentCounter	access:public	signature:(YulString _name) const
yul::AssignmentCounter::m_assignmentCounters	libyul/optimiser/Metrics.h	/^	std::map<YulString, size_t> m_assignmentCounters;$/;"	m	class:yul::AssignmentCounter	access:private
yul::AssignmentCounter::override	libyul/optimiser/Metrics.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::AssignmentCounter	access:public
yul::AssignmentRemover	libyul/optimiser/RedundantAssignEliminator.h	/^class AssignmentRemover: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::AssignmentRemover::AssignmentRemover	libyul/optimiser/RedundantAssignEliminator.h	/^	explicit AssignmentRemover(std::set<Assignment const*> const& _toRemove):$/;"	f	class:yul::AssignmentRemover	access:public	signature:(std::set<Assignment const*> const& _toRemove)
yul::AssignmentRemover::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::AssignmentRemover	access:public
yul::AssignmentRemover::std::m_toRemove	libyul/optimiser/RedundantAssignEliminator.h	/^	std::set<Assignment const*> const& m_toRemove;$/;"	m	class:yul::AssignmentRemover::std	access:private
yul::Assignments	libyul/optimiser/NameCollector.h	/^class Assignments: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::Assignments::m_names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> m_names;$/;"	m	class:yul::Assignments	access:private
yul::Assignments::override	libyul/optimiser/NameCollector.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::Assignments	access:public
yul::Assignments::std::names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> const& names() const { return m_names; }$/;"	f	class:yul::Assignments::std	access:public	signature:() const
yul::Block	libyul/AsmData.h	/^struct Block { langutil::SourceLocation location; std::vector<Statement> statements; };$/;"	s	namespace:yul
yul::Block::location	libyul/AsmData.h	/^struct Block { langutil::SourceLocation location; std::vector<Statement> statements; };$/;"	m	struct:yul::Block	access:public
yul::Block::statements	libyul/AsmData.h	/^struct Block { langutil::SourceLocation location; std::vector<Statement> statements; };$/;"	m	struct:yul::Block	access:public
yul::BlockFlattener	libyul/optimiser/BlockFlattener.h	/^class BlockFlattener: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::BlockFlattener::override	libyul/optimiser/BlockFlattener.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::BlockFlattener	access:public
yul::BodyCopier	libyul/optimiser/FullInliner.h	/^class BodyCopier: public ASTCopier$/;"	c	namespace:yul	inherits:ASTCopier
yul::BodyCopier::BodyCopier	libyul/optimiser/FullInliner.h	/^	BodyCopier($/;"	f	class:yul::BodyCopier	access:public	signature:( NameDispenser& _nameDispenser, std::map<YulString, YulString> const& _variableReplacements )
yul::BodyCopier::m_nameDispenser	libyul/optimiser/FullInliner.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::BodyCopier	access:public
yul::BodyCopier::m_variableReplacements	libyul/optimiser/FullInliner.h	/^	std::map<YulString, YulString> m_variableReplacements;$/;"	m	class:yul::BodyCopier	access:public
yul::BodyCopier::override	libyul/optimiser/FullInliner.h	/^	Statement operator()(FunctionDefinition const& _funDef) override;$/;"	m	class:yul::BodyCopier	access:public
yul::BodyCopier::override	libyul/optimiser/FullInliner.h	/^	Statement operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::BodyCopier	access:public
yul::BodyCopier::override	libyul/optimiser/FullInliner.h	/^	YulString translateIdentifier(YulString _name) override;$/;"	m	class:yul::BodyCopier	access:public
yul::BuiltinFunction	libyul/Dialect.h	/^struct BuiltinFunction$/;"	s	namespace:yul
yul::BuiltinFunction::literalArguments	libyul/Dialect.h	/^	bool literalArguments = false;$/;"	m	struct:yul::BuiltinFunction	access:public
yul::BuiltinFunction::movable	libyul/Dialect.h	/^	bool movable = false;$/;"	m	struct:yul::BuiltinFunction	access:public
yul::BuiltinFunction::name	libyul/Dialect.h	/^	YulString name;$/;"	m	struct:yul::BuiltinFunction	access:public
yul::BuiltinFunction::parameters	libyul/Dialect.h	/^	std::vector<Type> parameters;$/;"	m	struct:yul::BuiltinFunction	access:public
yul::BuiltinFunction::returns	libyul/Dialect.h	/^	std::vector<Type> returns;$/;"	m	struct:yul::BuiltinFunction	access:public
yul::BuiltinFunctionForEVM	libyul/backends/evm/EVMDialect.h	/^struct BuiltinFunctionForEVM: BuiltinFunction$/;"	s	namespace:yul	inherits:BuiltinFunction
yul::BuiltinFunctionForEVM::generateCode	libyul/backends/evm/EVMDialect.h	/^	std::function<void(FunctionCall const&, AbstractAssembly&, std::function<void()>)> generateCode;$/;"	m	struct:yul::BuiltinFunctionForEVM	access:public
yul::Case	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	s	namespace:yul
yul::Case::body	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	m	struct:yul::Case	access:public
yul::Case::location	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	m	struct:yul::Case	access:public
yul::Case::value	libyul/AsmData.h	/^struct Case { langutil::SourceLocation location; std::unique_ptr<Literal> value; Block body; };$/;"	m	struct:yul::Case	access:public
yul::CodeCost	libyul/optimiser/Metrics.h	/^class CodeCost: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::CodeCost::codeCost	libyul/optimiser/Metrics.h	/^	static size_t codeCost(Expression const& _expression);$/;"	p	class:yul::CodeCost	access:public	signature:(Expression const& _expression)
yul::CodeCost::m_cost	libyul/optimiser/Metrics.h	/^	size_t m_cost = 0;$/;"	m	class:yul::CodeCost	access:private
yul::CodeCost::override	libyul/optimiser/Metrics.h	/^	void operator()(FunctionCall const& _funCall) override;$/;"	m	class:yul::CodeCost	access:private
yul::CodeCost::override	libyul/optimiser/Metrics.h	/^	void operator()(FunctionalInstruction const& _instr) override;$/;"	m	class:yul::CodeCost	access:private
yul::CodeCost::override	libyul/optimiser/Metrics.h	/^	void operator()(Literal const& _literal) override;$/;"	m	class:yul::CodeCost	access:private
yul::CodeCost::override	libyul/optimiser/Metrics.h	/^	void visit(Expression const& _expression) override;$/;"	m	class:yul::CodeCost	access:private
yul::CodeCost::override	libyul/optimiser/Metrics.h	/^	void visit(Statement const& _statement) override;$/;"	m	class:yul::CodeCost	access:private
yul::CodeGenerator	libyul/backends/evm/AsmCodeGen.h	/^class CodeGenerator$/;"	c	namespace:yul
yul::CodeGenerator::assemble	libyul/backends/evm/AsmCodeGen.h	/^	static void assemble($/;"	p	class:yul::CodeGenerator	access:public	signature:( Block const& _parsedData, AsmAnalysisInfo& _analysisInfo, dev::eth::Assembly& _assembly, langutil::EVMVersion _evmVersion, ExternalIdentifierAccess const& _identifierAccess = ExternalIdentifierAccess(), bool _useNamedLabelsForFunctions = false, bool _optimize = false )
yul::CodeSize	libyul/optimiser/Metrics.h	/^class CodeSize: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::CodeSize::CodeSize	libyul/optimiser/Metrics.h	/^	CodeSize(bool _ignoreFunctions = true): m_ignoreFunctions(_ignoreFunctions) {}$/;"	f	class:yul::CodeSize	access:private	signature:(bool _ignoreFunctions = true)
yul::CodeSize::codeSize	libyul/optimiser/Metrics.h	/^	static size_t codeSize(Block const& _block);$/;"	p	class:yul::CodeSize	access:public	signature:(Block const& _block)
yul::CodeSize::codeSize	libyul/optimiser/Metrics.h	/^	static size_t codeSize(Expression const& _expression);$/;"	p	class:yul::CodeSize	access:public	signature:(Expression const& _expression)
yul::CodeSize::codeSize	libyul/optimiser/Metrics.h	/^	static size_t codeSize(Statement const& _statement);$/;"	p	class:yul::CodeSize	access:public	signature:(Statement const& _statement)
yul::CodeSize::codeSizeIncludingFunctions	libyul/optimiser/Metrics.h	/^	static size_t codeSizeIncludingFunctions(Block const& _block);$/;"	p	class:yul::CodeSize	access:public	signature:(Block const& _block)
yul::CodeSize::m_ignoreFunctions	libyul/optimiser/Metrics.h	/^	bool m_ignoreFunctions;$/;"	m	class:yul::CodeSize	access:private
yul::CodeSize::m_size	libyul/optimiser/Metrics.h	/^	size_t m_size = 0;$/;"	m	class:yul::CodeSize	access:private
yul::CodeSize::override	libyul/optimiser/Metrics.h	/^	void visit(Expression const& _expression) override;$/;"	m	class:yul::CodeSize	access:private
yul::CodeSize::override	libyul/optimiser/Metrics.h	/^	void visit(Statement const& _statement) override;$/;"	m	class:yul::CodeSize	access:private
yul::CodeTransform	libyul/backends/evm/EVMCodeTransform.h	/^class CodeTransform: public boost::static_visitor<>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::CodeTransform::CodeTransform	libyul/backends/evm/EVMCodeTransform.h	/^	CodeTransform($/;"	f	class:yul::CodeTransform	access:public	signature:( AbstractAssembly& _assembly, AsmAnalysisInfo& _analysisInfo, Block const& _block, EVMDialect const& _dialect, bool _allowStackOpt = false, bool _evm15 = false, ExternalIdentifierAccess const& _identifierAccess = ExternalIdentifierAccess(), bool _useNamedLabelsForFunctions = false )
yul::CodeTransform::checkStackHeight	libyul/backends/evm/EVMCodeTransform.h	/^	void checkStackHeight(void const* _astElement) const;$/;"	p	class:yul::CodeTransform	access:private	signature:(void const* _astElement) const
yul::CodeTransform::decreaseReference	libyul/backends/evm/EVMCodeTransform.h	/^	void decreaseReference(YulString _name, Scope::Variable const& _var);$/;"	p	class:yul::CodeTransform	access:protected	signature:(YulString _name, Scope::Variable const& _var)
yul::CodeTransform::deleteVariable	libyul/backends/evm/EVMCodeTransform.h	/^	void deleteVariable(Scope::Variable const& _var);$/;"	p	class:yul::CodeTransform	access:protected	signature:(Scope::Variable const& _var)
yul::CodeTransform::expectDeposit	libyul/backends/evm/EVMCodeTransform.h	/^	void expectDeposit(int _deposit, int _oldHeight) const;$/;"	p	class:yul::CodeTransform	access:private	signature:(int _deposit, int _oldHeight) const
yul::CodeTransform::finalizeBlock	libyul/backends/evm/EVMCodeTransform.h	/^	void finalizeBlock(Block const& _block, int _blockStartStackHeight);$/;"	p	class:yul::CodeTransform	access:private	signature:(Block const& _block, int _blockStartStackHeight)
yul::CodeTransform::freeUnusedVariables	libyul/backends/evm/EVMCodeTransform.h	/^	void freeUnusedVariables();$/;"	p	class:yul::CodeTransform	access:protected	signature:()
yul::CodeTransform::functionEntryID	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly::LabelID functionEntryID(YulString _name, Scope::Function const& _function);$/;"	p	class:yul::CodeTransform	access:private	signature:(YulString _name, Scope::Function const& _function)
yul::CodeTransform::generateAssignment	libyul/backends/evm/EVMCodeTransform.h	/^	void generateAssignment(Identifier const& _variableName);$/;"	p	class:yul::CodeTransform	access:private	signature:(Identifier const& _variableName)
yul::CodeTransform::generateMultiAssignment	libyul/backends/evm/EVMCodeTransform.h	/^	void generateMultiAssignment(std::vector<Identifier> const& _variableNames);$/;"	p	class:yul::CodeTransform	access:private	signature:(std::vector<Identifier> const& _variableNames)
yul::CodeTransform::labelFromIdentifier	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly::LabelID labelFromIdentifier(Identifier const& _identifier);$/;"	p	class:yul::CodeTransform	access:private	signature:(Identifier const& _identifier)
yul::CodeTransform::labelID	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly::LabelID labelID(Scope::Label const& _label);$/;"	p	class:yul::CodeTransform	access:private	signature:(Scope::Label const& _label)
yul::CodeTransform::m_allowStackOpt	libyul/backends/evm/EVMCodeTransform.h	/^	bool const m_allowStackOpt = true;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_assembly	libyul/backends/evm/EVMCodeTransform.h	/^	AbstractAssembly& m_assembly;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_context	libyul/backends/evm/EVMCodeTransform.h	/^	std::shared_ptr<Context> m_context;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_dialect	libyul/backends/evm/EVMCodeTransform.h	/^	EVMDialect const& m_dialect;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_evm15	libyul/backends/evm/EVMCodeTransform.h	/^	bool const m_evm15 = false;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_identifierAccess	libyul/backends/evm/EVMCodeTransform.h	/^	ExternalIdentifierAccess m_identifierAccess;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_info	libyul/backends/evm/EVMCodeTransform.h	/^	AsmAnalysisInfo& m_info;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_scope	libyul/backends/evm/EVMCodeTransform.h	/^	Scope* m_scope = nullptr;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_stackAdjustment	libyul/backends/evm/EVMCodeTransform.h	/^	int m_stackAdjustment = 0;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_stackErrors	libyul/backends/evm/EVMCodeTransform.h	/^	std::vector<StackTooDeepError> m_stackErrors;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_unusedStackSlots	libyul/backends/evm/EVMCodeTransform.h	/^	std::set<int> m_unusedStackSlots;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_useNamedLabelsForFunctions	libyul/backends/evm/EVMCodeTransform.h	/^	bool const m_useNamedLabelsForFunctions = false;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::m_variablesScheduledForDeletion	libyul/backends/evm/EVMCodeTransform.h	/^	std::set<Scope::Variable const*> m_variablesScheduledForDeletion;$/;"	m	class:yul::CodeTransform	access:private
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Assignment const& _assignment);$/;"	p	class:yul::CodeTransform	access:public	signature:(Assignment const& _assignment)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Block const& _block);$/;"	p	class:yul::CodeTransform	access:public	signature:(Block const& _block)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(ExpressionStatement const& _statement);$/;"	p	class:yul::CodeTransform	access:public	signature:(ExpressionStatement const& _statement)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(ForLoop const&);$/;"	p	class:yul::CodeTransform	access:public	signature:(ForLoop const&)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionCall const&);$/;"	p	class:yul::CodeTransform	access:public	signature:(FunctionCall const&)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionDefinition const&);$/;"	p	class:yul::CodeTransform	access:public	signature:(FunctionDefinition const&)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionalInstruction const& _instr);$/;"	p	class:yul::CodeTransform	access:public	signature:(FunctionalInstruction const& _instr)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Identifier const& _identifier);$/;"	p	class:yul::CodeTransform	access:public	signature:(Identifier const& _identifier)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(If const& _if);$/;"	p	class:yul::CodeTransform	access:public	signature:(If const& _if)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Instruction const& _instruction);$/;"	p	class:yul::CodeTransform	access:public	signature:(Instruction const& _instruction)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Label const& _label);$/;"	p	class:yul::CodeTransform	access:public	signature:(Label const& _label)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Literal const& _literal);$/;"	p	class:yul::CodeTransform	access:public	signature:(Literal const& _literal)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(StackAssignment const& _assignment);$/;"	p	class:yul::CodeTransform	access:public	signature:(StackAssignment const& _assignment)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Switch const& _switch);$/;"	p	class:yul::CodeTransform	access:public	signature:(Switch const& _switch)
yul::CodeTransform::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(VariableDeclaration const& _varDecl);$/;"	p	class:yul::CodeTransform	access:public	signature:(VariableDeclaration const& _varDecl)
yul::CodeTransform::stackError	libyul/backends/evm/EVMCodeTransform.h	/^	void stackError(StackTooDeepError _error, int _targetStackSize);$/;"	p	class:yul::CodeTransform	access:private	signature:(StackTooDeepError _error, int _targetStackSize)
yul::CodeTransform::std::stackErrors	libyul/backends/evm/EVMCodeTransform.h	/^	std::vector<StackTooDeepError> const& stackErrors() const { return m_stackErrors; }$/;"	f	class:yul::CodeTransform::std	access:public	signature:() const
yul::CodeTransform::unreferenced	libyul/backends/evm/EVMCodeTransform.h	/^	bool unreferenced(Scope::Variable const& _var) const;$/;"	p	class:yul::CodeTransform	access:protected	signature:(Scope::Variable const& _var) const
yul::CodeTransform::variableHeightDiff	libyul/backends/evm/EVMCodeTransform.h	/^	int variableHeightDiff(Scope::Variable const& _var, YulString _name, bool _forSwap);$/;"	p	class:yul::CodeTransform	access:private	signature:(Scope::Variable const& _var, YulString _name, bool _forSwap)
yul::CodeTransform::visitExpression	libyul/backends/evm/EVMCodeTransform.h	/^	void visitExpression(Expression const& _expression);$/;"	p	class:yul::CodeTransform	access:private	signature:(Expression const& _expression)
yul::CodeTransform::visitStatements	libyul/backends/evm/EVMCodeTransform.h	/^	void visitStatements(std::vector<Statement> const& _statements);$/;"	p	class:yul::CodeTransform	access:private	signature:(std::vector<Statement> const& _statements)
yul::CodeTransformContext	libyul/backends/evm/EVMCodeTransform.h	/^struct CodeTransformContext$/;"	s	namespace:yul
yul::CodeTransformContext::functionEntryIDs	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Function const*, AbstractAssembly::LabelID> functionEntryIDs;$/;"	m	struct:yul::CodeTransformContext	access:public
yul::CodeTransformContext::labelIDs	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Label const*, AbstractAssembly::LabelID> labelIDs;$/;"	m	struct:yul::CodeTransformContext	access:public
yul::CodeTransformContext::variableReferences	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Variable const*, unsigned> variableReferences;$/;"	m	struct:yul::CodeTransformContext	access:public
yul::CodeTransformContext::variableStackHeights	libyul/backends/evm/EVMCodeTransform.h	/^	std::map<Scope::Variable const*, int> variableStackHeights;$/;"	m	struct:yul::CodeTransformContext	access:public
yul::CodegenException	libyul/Exceptions.h	/^struct CodegenException: virtual YulException {};$/;"	s	namespace:yul	inherits:YulException
yul::CommonSubexpressionEliminator	libyul/optimiser/CommonSubexpressionEliminator.h	/^class CommonSubexpressionEliminator: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
yul::CommonSubexpressionEliminator::CommonSubexpressionEliminator	libyul/optimiser/CommonSubexpressionEliminator.h	/^	CommonSubexpressionEliminator(Dialect const& _dialect): DataFlowAnalyzer(_dialect) {}$/;"	f	class:yul::CommonSubexpressionEliminator	access:public	signature:(Dialect const& _dialect)
yul::CommonSubexpressionEliminator::override	libyul/optimiser/CommonSubexpressionEliminator.h	/^	void visit(Expression& _e) override;$/;"	m	class:yul::CommonSubexpressionEliminator	access:protected
yul::CompilabilityChecker	libyul/CompilabilityChecker.h	/^class CompilabilityChecker$/;"	c	namespace:yul
yul::CompilabilityChecker::run	libyul/CompilabilityChecker.h	/^	static std::map<YulString, int> run(std::shared_ptr<Dialect> _dialect, Block const& _ast);$/;"	p	class:yul::CompilabilityChecker	access:public	signature:(std::shared_ptr<Dialect> _dialect, Block const& _ast)
yul::Data	libyul/Object.h	/^struct Data: ObjectNode$/;"	s	namespace:yul	inherits:ObjectNode
yul::Data::Data	libyul/Object.h	/^	Data(YulString _name, dev::bytes _data): data(std::move(_data)) { name = _name; }$/;"	f	struct:yul::Data	access:public	signature:(YulString _name, dev::bytes _data)
yul::Data::data	libyul/Object.h	/^	dev::bytes data;$/;"	m	struct:yul::Data	access:public
yul::Data::override	libyul/Object.h	/^	std::string toString(bool _yul) const override;$/;"	m	struct:yul::Data	access:public
yul::DataFlowAnalyzer	libyul/optimiser/DataFlowAnalyzer.h	/^class DataFlowAnalyzer: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::DataFlowAnalyzer::DataFlowAnalyzer	libyul/optimiser/DataFlowAnalyzer.h	/^	explicit DataFlowAnalyzer(Dialect const& _dialect): m_dialect(_dialect) {}$/;"	f	class:yul::DataFlowAnalyzer	access:public	signature:(Dialect const& _dialect)
yul::DataFlowAnalyzer::Scope	libyul/optimiser/DataFlowAnalyzer.h	/^	struct Scope$/;"	s	class:yul::DataFlowAnalyzer	access:protected
yul::DataFlowAnalyzer::Scope::Scope	libyul/optimiser/DataFlowAnalyzer.h	/^		explicit Scope(bool _isFunction): isFunction(_isFunction) {}$/;"	f	struct:yul::DataFlowAnalyzer::Scope	access:public	signature:(bool _isFunction)
yul::DataFlowAnalyzer::Scope::isFunction	libyul/optimiser/DataFlowAnalyzer.h	/^		bool isFunction;$/;"	m	struct:yul::DataFlowAnalyzer::Scope	access:public
yul::DataFlowAnalyzer::Scope::variables	libyul/optimiser/DataFlowAnalyzer.h	/^		std::set<YulString> variables;$/;"	m	struct:yul::DataFlowAnalyzer::Scope	access:public
yul::DataFlowAnalyzer::clearValues	libyul/optimiser/DataFlowAnalyzer.h	/^	void clearValues(std::set<YulString> _names);$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(std::set<YulString> _names)
yul::DataFlowAnalyzer::handleAssignment	libyul/optimiser/DataFlowAnalyzer.h	/^	void handleAssignment(std::set<YulString> const& _names, Expression* _value);$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(std::set<YulString> const& _names, Expression* _value)
yul::DataFlowAnalyzer::inScope	libyul/optimiser/DataFlowAnalyzer.h	/^	bool inScope(YulString _variableName) const;$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(YulString _variableName) const
yul::DataFlowAnalyzer::m_dialect	libyul/optimiser/DataFlowAnalyzer.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
yul::DataFlowAnalyzer::m_referencedBy	libyul/optimiser/DataFlowAnalyzer.h	/^	std::map<YulString, std::set<YulString>> m_referencedBy;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
yul::DataFlowAnalyzer::m_references	libyul/optimiser/DataFlowAnalyzer.h	/^	std::map<YulString, std::set<YulString>> m_references;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
yul::DataFlowAnalyzer::m_value	libyul/optimiser/DataFlowAnalyzer.h	/^	std::map<YulString, Expression const*> m_value;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
yul::DataFlowAnalyzer::m_variableScopes	libyul/optimiser/DataFlowAnalyzer.h	/^	std::vector<Scope> m_variableScopes;$/;"	m	class:yul::DataFlowAnalyzer	access:protected
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(Assignment& _assignment) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(ForLoop&) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(FunctionDefinition&) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(If& _if) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(Switch& _switch) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::override	libyul/optimiser/DataFlowAnalyzer.h	/^	void operator()(VariableDeclaration& _varDecl) override;$/;"	m	class:yul::DataFlowAnalyzer	access:public
yul::DataFlowAnalyzer::popScope	libyul/optimiser/DataFlowAnalyzer.h	/^	void popScope();$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:()
yul::DataFlowAnalyzer::pushScope	libyul/optimiser/DataFlowAnalyzer.h	/^	void pushScope(bool _functionScope);$/;"	p	class:yul::DataFlowAnalyzer	access:protected	signature:(bool _functionScope)
yul::Dialect	libyul/Dialect.h	/^struct Dialect: boost::noncopyable$/;"	s	namespace:yul	inherits:boost::noncopyable
yul::Dialect::Dialect	libyul/Dialect.h	/^	Dialect(AsmFlavour _flavour): flavour(_flavour) {}$/;"	f	struct:yul::Dialect	access:public	signature:(AsmFlavour _flavour)
yul::Dialect::builtin	libyul/Dialect.h	/^	virtual BuiltinFunction const* builtin(YulString \/*_name*\/) const { return nullptr; }$/;"	f	struct:yul::Dialect	access:public	signature:(YulString ) const
yul::Dialect::flavour	libyul/Dialect.h	/^	AsmFlavour const flavour = AsmFlavour::Loose;$/;"	m	struct:yul::Dialect	access:public
yul::Dialect::yul	libyul/Dialect.h	/^	static std::shared_ptr<Dialect> yul()$/;"	f	struct:yul::Dialect	access:public	signature:()
yul::Dialect::~Dialect	libyul/Dialect.h	/^	virtual ~Dialect() = default;$/;"	p	struct:yul::Dialect	access:public	signature:()
yul::Disambiguator	libyul/optimiser/Disambiguator.h	/^class Disambiguator: public ASTCopier$/;"	c	namespace:yul	inherits:ASTCopier
yul::Disambiguator::Disambiguator	libyul/optimiser/Disambiguator.h	/^	explicit Disambiguator($/;"	f	class:yul::Disambiguator	access:public	signature:( Dialect const& _dialect, AsmAnalysisInfo const& _analysisInfo, std::set<YulString> const& _externallyUsedIdentifiers = {} )
yul::Disambiguator::enterScopeInternal	libyul/optimiser/Disambiguator.h	/^	void enterScopeInternal(Scope& _scope);$/;"	p	class:yul::Disambiguator	access:protected	signature:(Scope& _scope)
yul::Disambiguator::leaveScopeInternal	libyul/optimiser/Disambiguator.h	/^	void leaveScopeInternal(Scope& _scope);$/;"	p	class:yul::Disambiguator	access:protected	signature:(Scope& _scope)
yul::Disambiguator::m_dialect	libyul/optimiser/Disambiguator.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::m_info	libyul/optimiser/Disambiguator.h	/^	AsmAnalysisInfo const& m_info;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::m_nameDispenser	libyul/optimiser/Disambiguator.h	/^	NameDispenser m_nameDispenser;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::m_scopes	libyul/optimiser/Disambiguator.h	/^	std::vector<Scope*> m_scopes;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::m_translations	libyul/optimiser/Disambiguator.h	/^	std::map<void const*, YulString> m_translations;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::override	libyul/optimiser/Disambiguator.h	/^	YulString translateIdentifier(YulString _name) override;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::override	libyul/optimiser/Disambiguator.h	/^	void enterFunction(FunctionDefinition const& _function) override;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::override	libyul/optimiser/Disambiguator.h	/^	void enterScope(Block const& _block) override;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::override	libyul/optimiser/Disambiguator.h	/^	void leaveFunction(FunctionDefinition const& _function) override;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::override	libyul/optimiser/Disambiguator.h	/^	void leaveScope(Block const& _block) override;$/;"	m	class:yul::Disambiguator	access:protected
yul::Disambiguator::std::m_externallyUsedIdentifiers	libyul/optimiser/Disambiguator.h	/^	std::set<YulString> const& m_externallyUsedIdentifiers;$/;"	m	class:yul::Disambiguator::std	access:protected
yul::EVMAssembly	libyul/backends/evm/EVMAssembly.h	/^class EVMAssembly: public AbstractAssembly$/;"	c	namespace:yul	inherits:AbstractAssembly
yul::EVMAssembly::EVMAssembly	libyul/backends/evm/EVMAssembly.h	/^	explicit EVMAssembly(bool _evm15 = false): m_evm15(_evm15) { }$/;"	f	class:yul::EVMAssembly	access:public	signature:(bool _evm15 = false)
yul::EVMAssembly::appendLabelReferenceInternal	libyul/backends/evm/EVMAssembly.h	/^	void appendLabelReferenceInternal(AbstractAssembly::LabelID _labelId);$/;"	p	class:yul::EVMAssembly	access:private	signature:(AbstractAssembly::LabelID _labelId)
yul::EVMAssembly::finalize	libyul/backends/evm/EVMAssembly.h	/^	dev::eth::LinkerObject finalize();$/;"	p	class:yul::EVMAssembly	access:public	signature:()
yul::EVMAssembly::m_assemblySizePositions	libyul/backends/evm/EVMAssembly.h	/^	std::vector<size_t> m_assemblySizePositions;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_bytecode	libyul/backends/evm/EVMAssembly.h	/^	dev::bytes m_bytecode;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_evm15	libyul/backends/evm/EVMAssembly.h	/^	bool m_evm15 = false; \/\/\/< if true, switch to evm1.5 mode$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_labelPositions	libyul/backends/evm/EVMAssembly.h	/^	std::map<LabelID, size_t> m_labelPositions;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_labelReferences	libyul/backends/evm/EVMAssembly.h	/^	std::map<size_t, LabelID> m_labelReferences;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_namedLabels	libyul/backends/evm/EVMAssembly.h	/^	std::map<std::string, LabelID> m_namedLabels;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_nextLabelId	libyul/backends/evm/EVMAssembly.h	/^	LabelID m_nextLabelId = 0;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::m_stackHeight	libyul/backends/evm/EVMAssembly.h	/^	int m_stackHeight = 0;$/;"	m	class:yul::EVMAssembly	access:private
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	LabelID namedLabel(std::string const& _name) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	LabelID newLabelId() override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	SubID appendData(dev::bytes const& _data) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendAssemblySize() override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendBeginsub(LabelID _labelId, int _arguments) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendConstant(dev::u256 const& _constant) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendDataOffset(SubID _sub) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendDataSize(SubID _sub) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendInstruction(dev::solidity::Instruction _instruction) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendJump(int _stackDiffAfter) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendJumpTo(LabelID _labelId, int _stackDiffAfter) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendJumpToIf(LabelID _labelId) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendJumpsub(LabelID _labelId, int _arguments, int _returns) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendLabel(LabelID _labelId) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendLabelReference(LabelID _labelId) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendLinkerSymbol(std::string const& _name) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void appendReturnsub(int _returns, int _stackDiffAfter) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::override	libyul/backends/evm/EVMAssembly.h	/^	void setSourceLocation(langutil::SourceLocation const& _location) override;$/;"	m	class:yul::EVMAssembly	access:public
yul::EVMAssembly::setLabelToCurrentPosition	libyul/backends/evm/EVMAssembly.h	/^	void setLabelToCurrentPosition(AbstractAssembly::LabelID _labelId);$/;"	p	class:yul::EVMAssembly	access:private	signature:(AbstractAssembly::LabelID _labelId)
yul::EVMAssembly::updateReference	libyul/backends/evm/EVMAssembly.h	/^	void updateReference(size_t pos, size_t size, dev::u256 value);$/;"	p	class:yul::EVMAssembly	access:private	signature:(size_t pos, size_t size, dev::u256 value)
yul::EVMAssembly::~EVMAssembly	libyul/backends/evm/EVMAssembly.h	/^	virtual ~EVMAssembly() = default;$/;"	p	class:yul::EVMAssembly	access:public	signature:()
yul::EVMDialect	libyul/backends/evm/EVMDialect.h	/^struct EVMDialect: public Dialect$/;"	s	namespace:yul	inherits:Dialect
yul::EVMDialect::EVMDialect	libyul/backends/evm/EVMDialect.h	/^	EVMDialect(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion);$/;"	p	struct:yul::EVMDialect	access:public	signature:(AsmFlavour _flavour, bool _objectAccess, langutil::EVMVersion _evmVersion)
yul::EVMDialect::addFunction	libyul/backends/evm/EVMDialect.h	/^	void addFunction($/;"	p	struct:yul::EVMDialect	access:protected	signature:( std::string _name, size_t _params, size_t _returns, bool _movable, bool _literalArguments, std::function<void(FunctionCall const&, AbstractAssembly&, std::function<void()>)> _generateCode )
yul::EVMDialect::evmVersion	libyul/backends/evm/EVMDialect.h	/^	langutil::EVMVersion evmVersion() const { return m_evmVersion; }$/;"	f	struct:yul::EVMDialect	access:public	signature:() const
yul::EVMDialect::looseAssemblyForEVM	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> looseAssemblyForEVM(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
yul::EVMDialect::m_currentObject	libyul/backends/evm/EVMDialect.h	/^	Object const* m_currentObject = nullptr;$/;"	m	struct:yul::EVMDialect	access:protected
yul::EVMDialect::m_evmVersion	libyul/backends/evm/EVMDialect.h	/^	langutil::EVMVersion m_evmVersion;$/;"	m	struct:yul::EVMDialect	access:protected
yul::EVMDialect::m_functions	libyul/backends/evm/EVMDialect.h	/^	std::map<YulString, BuiltinFunctionForEVM> m_functions;$/;"	m	struct:yul::EVMDialect	access:protected
yul::EVMDialect::m_objectAccess	libyul/backends/evm/EVMDialect.h	/^	bool m_objectAccess;$/;"	m	struct:yul::EVMDialect	access:protected
yul::EVMDialect::m_subIDs	libyul/backends/evm/EVMDialect.h	/^	std::map<YulString, AbstractAssembly::SubID> m_subIDs;$/;"	m	struct:yul::EVMDialect	access:protected
yul::EVMDialect::override	libyul/backends/evm/EVMDialect.h	/^	BuiltinFunctionForEVM const* builtin(YulString _name) const override;$/;"	m	struct:yul::EVMDialect	access:public
yul::EVMDialect::providesObjectAccess	libyul/backends/evm/EVMDialect.h	/^	bool providesObjectAccess() const { return m_objectAccess; }$/;"	f	struct:yul::EVMDialect	access:public	signature:() const
yul::EVMDialect::setCurrentObject	libyul/backends/evm/EVMDialect.h	/^	void setCurrentObject(Object const* _object);$/;"	p	struct:yul::EVMDialect	access:public	signature:(Object const* _object)
yul::EVMDialect::setSubIDs	libyul/backends/evm/EVMDialect.h	/^	void setSubIDs(std::map<YulString, AbstractAssembly::SubID> _subIDs);$/;"	p	struct:yul::EVMDialect	access:public	signature:(std::map<YulString, AbstractAssembly::SubID> _subIDs)
yul::EVMDialect::strictAssemblyForEVM	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> strictAssemblyForEVM(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
yul::EVMDialect::strictAssemblyForEVMObjects	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> strictAssemblyForEVMObjects(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
yul::EVMDialect::yulForEVM	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> yulForEVM(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
yul::EVMObjectCompiler	libyul/backends/evm/EVMObjectCompiler.h	/^class EVMObjectCompiler$/;"	c	namespace:yul
yul::EVMObjectCompiler::EVMObjectCompiler	libyul/backends/evm/EVMObjectCompiler.h	/^	EVMObjectCompiler(AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15):$/;"	f	class:yul::EVMObjectCompiler	access:private	signature:(AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15)
yul::EVMObjectCompiler::compile	libyul/backends/evm/EVMObjectCompiler.h	/^	static void compile(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize);$/;"	p	class:yul::EVMObjectCompiler	access:public	signature:(Object& _object, AbstractAssembly& _assembly, EVMDialect& _dialect, bool _evm15, bool _optimize)
yul::EVMObjectCompiler::m_assembly	libyul/backends/evm/EVMObjectCompiler.h	/^	AbstractAssembly& m_assembly;$/;"	m	class:yul::EVMObjectCompiler	access:private
yul::EVMObjectCompiler::m_dialect	libyul/backends/evm/EVMObjectCompiler.h	/^	EVMDialect& m_dialect;$/;"	m	class:yul::EVMObjectCompiler	access:private
yul::EVMObjectCompiler::m_evm15	libyul/backends/evm/EVMObjectCompiler.h	/^	bool m_evm15 = false;$/;"	m	class:yul::EVMObjectCompiler	access:private
yul::EVMObjectCompiler::run	libyul/backends/evm/EVMObjectCompiler.h	/^	void run(Object& _object, bool _optimize);$/;"	p	class:yul::EVMObjectCompiler	access:private	signature:(Object& _object, bool _optimize)
yul::EquivalentFunctionCombiner	libyul/optimiser/EquivalentFunctionCombiner.h	/^class EquivalentFunctionCombiner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::EquivalentFunctionCombiner::EquivalentFunctionCombiner	libyul/optimiser/EquivalentFunctionCombiner.h	/^	EquivalentFunctionCombiner(std::map<YulString, FunctionDefinition const*> _duplicates): m_duplicates(std::move(_duplicates)) {}$/;"	f	class:yul::EquivalentFunctionCombiner	access:private	signature:(std::map<YulString, FunctionDefinition const*> _duplicates)
yul::EquivalentFunctionCombiner::m_duplicates	libyul/optimiser/EquivalentFunctionCombiner.h	/^	std::map<YulString, FunctionDefinition const*> m_duplicates;$/;"	m	class:yul::EquivalentFunctionCombiner	access:private
yul::EquivalentFunctionCombiner::override	libyul/optimiser/EquivalentFunctionCombiner.h	/^	void operator()(FunctionCall& _funCall) override;$/;"	m	class:yul::EquivalentFunctionCombiner	access:public
yul::EquivalentFunctionCombiner::run	libyul/optimiser/EquivalentFunctionCombiner.h	/^	static void run(Block& _ast);$/;"	p	class:yul::EquivalentFunctionCombiner	access:public	signature:(Block& _ast)
yul::EquivalentFunctionDetector	libyul/optimiser/EquivalentFunctionDetector.h	/^class EquivalentFunctionDetector: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::EquivalentFunctionDetector::EquivalentFunctionDetector	libyul/optimiser/EquivalentFunctionDetector.h	/^	EquivalentFunctionDetector() = default;$/;"	p	class:yul::EquivalentFunctionDetector	access:private	signature:()
yul::EquivalentFunctionDetector::RoughHeuristic	libyul/optimiser/EquivalentFunctionDetector.h	/^	class RoughHeuristic$/;"	c	class:yul::EquivalentFunctionDetector	access:private
yul::EquivalentFunctionDetector::RoughHeuristic::RoughHeuristic	libyul/optimiser/EquivalentFunctionDetector.h	/^		RoughHeuristic(FunctionDefinition const& _fun): m_fun(_fun) {}$/;"	f	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:public	signature:(FunctionDefinition const& _fun)
yul::EquivalentFunctionDetector::RoughHeuristic::codeSize	libyul/optimiser/EquivalentFunctionDetector.h	/^		std::size_t codeSize() const;$/;"	p	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:private	signature:() const
yul::EquivalentFunctionDetector::RoughHeuristic::m_codeSize	libyul/optimiser/EquivalentFunctionDetector.h	/^		mutable boost::optional<std::size_t> m_codeSize;$/;"	m	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:private
yul::EquivalentFunctionDetector::RoughHeuristic::m_fun	libyul/optimiser/EquivalentFunctionDetector.h	/^		FunctionDefinition const& m_fun;$/;"	m	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:private
yul::EquivalentFunctionDetector::RoughHeuristic::operator <	libyul/optimiser/EquivalentFunctionDetector.h	/^		bool operator<(RoughHeuristic const& _rhs) const;$/;"	p	class:yul::EquivalentFunctionDetector::RoughHeuristic	access:public	signature:(RoughHeuristic const& _rhs) const
yul::EquivalentFunctionDetector::m_candidates	libyul/optimiser/EquivalentFunctionDetector.h	/^	std::map<RoughHeuristic, std::vector<FunctionDefinition const*>> m_candidates;$/;"	m	class:yul::EquivalentFunctionDetector	access:private
yul::EquivalentFunctionDetector::m_duplicates	libyul/optimiser/EquivalentFunctionDetector.h	/^	std::map<YulString, FunctionDefinition const*> m_duplicates;$/;"	m	class:yul::EquivalentFunctionDetector	access:private
yul::EquivalentFunctionDetector::override	libyul/optimiser/EquivalentFunctionDetector.h	/^	void operator()(FunctionDefinition const& _fun) override;$/;"	m	class:yul::EquivalentFunctionDetector	access:public
yul::EquivalentFunctionDetector::run	libyul/optimiser/EquivalentFunctionDetector.h	/^	static std::map<YulString, FunctionDefinition const*> run(Block& _block)$/;"	f	class:yul::EquivalentFunctionDetector	access:public	signature:(Block& _block)
yul::EthAssemblyAdapter	libyul/backends/evm/AsmCodeGen.h	/^class EthAssemblyAdapter: public AbstractAssembly$/;"	c	namespace:yul	inherits:AbstractAssembly
yul::EthAssemblyAdapter::EthAssemblyAdapter	libyul/backends/evm/AsmCodeGen.h	/^	explicit EthAssemblyAdapter(dev::eth::Assembly& _assembly);$/;"	p	class:yul::EthAssemblyAdapter	access:public	signature:(dev::eth::Assembly& _assembly)
yul::EthAssemblyAdapter::assemblyTagToIdentifier	libyul/backends/evm/AsmCodeGen.h	/^	static LabelID assemblyTagToIdentifier(dev::eth::AssemblyItem const& _tag);$/;"	p	class:yul::EthAssemblyAdapter	access:private	signature:(dev::eth::AssemblyItem const& _tag)
yul::EthAssemblyAdapter::m_assembly	libyul/backends/evm/AsmCodeGen.h	/^	dev::eth::Assembly& m_assembly;$/;"	m	class:yul::EthAssemblyAdapter	access:private
yul::EthAssemblyAdapter::m_dataHashBySubId	libyul/backends/evm/AsmCodeGen.h	/^	std::map<SubID, dev::u256> m_dataHashBySubId;$/;"	m	class:yul::EthAssemblyAdapter	access:private
yul::EthAssemblyAdapter::m_nextDataCounter	libyul/backends/evm/AsmCodeGen.h	/^	size_t m_nextDataCounter = std::numeric_limits<size_t>::max() \/ 2;$/;"	m	class:yul::EthAssemblyAdapter	access:private
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	SubID appendData(dev::bytes const& _data) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	int stackHeight() const override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	size_t namedLabel(std::string const& _name) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	size_t newLabelId() override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendAssemblySize() override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendBeginsub(LabelID, int) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendConstant(dev::u256 const& _constant) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendDataOffset(SubID _sub) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendDataSize(SubID _sub) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendInstruction(dev::solidity::Instruction _instruction) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJump(int _stackDiffAfter) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJumpTo(LabelID _labelId, int _stackDiffAfter) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJumpToIf(LabelID _labelId) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendJumpsub(LabelID, int, int) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendLabel(LabelID _labelId) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendLabelReference(LabelID _labelId) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendLinkerSymbol(std::string const& _linkerSymbol) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void appendReturnsub(int, int) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::EthAssemblyAdapter::override	libyul/backends/evm/AsmCodeGen.h	/^	void setSourceLocation(langutil::SourceLocation const& _location) override;$/;"	m	class:yul::EthAssemblyAdapter	access:public
yul::ExpressionCopier	libyul/optimiser/ASTCopier.h	/^class ExpressionCopier: public boost::static_visitor<Expression>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::ExpressionCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(FunctionCall const&) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(FunctionCall const&)
yul::ExpressionCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(FunctionalInstruction const& _instr) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(FunctionalInstruction const& _instr)
yul::ExpressionCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(Identifier const& _identifier) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(Identifier const& _identifier)
yul::ExpressionCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Expression operator()(Literal const& _literal) = 0;$/;"	p	class:yul::ExpressionCopier	access:public	signature:(Literal const& _literal)
yul::ExpressionCopier::~ExpressionCopier	libyul/optimiser/ASTCopier.h	/^	virtual ~ExpressionCopier() = default;$/;"	p	class:yul::ExpressionCopier	access:public	signature:()
yul::ExpressionInliner	libyul/optimiser/ExpressionInliner.h	/^class ExpressionInliner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::ExpressionInliner::ExpressionInliner	libyul/optimiser/ExpressionInliner.h	/^	ExpressionInliner(Dialect const& _dialect, Block& _block):$/;"	f	class:yul::ExpressionInliner	access:public	signature:(Dialect const& _dialect, Block& _block)
yul::ExpressionInliner::m_block	libyul/optimiser/ExpressionInliner.h	/^	Block& m_block;$/;"	m	class:yul::ExpressionInliner	access:private
yul::ExpressionInliner::m_currentFunctions	libyul/optimiser/ExpressionInliner.h	/^	std::set<YulString> m_currentFunctions;$/;"	m	class:yul::ExpressionInliner	access:private
yul::ExpressionInliner::m_dialect	libyul/optimiser/ExpressionInliner.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::ExpressionInliner	access:private
yul::ExpressionInliner::m_inlinableFunctions	libyul/optimiser/ExpressionInliner.h	/^	std::map<YulString, FunctionDefinition const*> m_inlinableFunctions;$/;"	m	class:yul::ExpressionInliner	access:private
yul::ExpressionInliner::m_varReplacements	libyul/optimiser/ExpressionInliner.h	/^	std::map<YulString, YulString> m_varReplacements;$/;"	m	class:yul::ExpressionInliner	access:private
yul::ExpressionInliner::override	libyul/optimiser/ExpressionInliner.h	/^	void operator()(FunctionDefinition& _fun) override;$/;"	m	class:yul::ExpressionInliner	access:public
yul::ExpressionInliner::override	libyul/optimiser/ExpressionInliner.h	/^	void visit(Expression& _expression) override;$/;"	m	class:yul::ExpressionInliner	access:public
yul::ExpressionInliner::run	libyul/optimiser/ExpressionInliner.h	/^	void run();$/;"	p	class:yul::ExpressionInliner	access:public	signature:()
yul::ExpressionJoiner	libyul/optimiser/ExpressionJoiner.h	/^class ExpressionJoiner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::ExpressionJoiner::ExpressionJoiner	libyul/optimiser/ExpressionJoiner.h	/^	explicit ExpressionJoiner(Block& _ast);$/;"	p	class:yul::ExpressionJoiner	access:private	signature:(Block& _ast)
yul::ExpressionJoiner::decrementLatestStatementPointer	libyul/optimiser/ExpressionJoiner.h	/^	void decrementLatestStatementPointer();$/;"	p	class:yul::ExpressionJoiner	access:private	signature:()
yul::ExpressionJoiner::handleArguments	libyul/optimiser/ExpressionJoiner.h	/^	void handleArguments(std::vector<Expression>& _arguments);$/;"	p	class:yul::ExpressionJoiner	access:private	signature:(std::vector<Expression>& _arguments)
yul::ExpressionJoiner::isLatestStatementVarDeclJoinable	libyul/optimiser/ExpressionJoiner.h	/^	bool isLatestStatementVarDeclJoinable(Identifier const& _identifier);$/;"	p	class:yul::ExpressionJoiner	access:private	signature:(Identifier const& _identifier)
yul::ExpressionJoiner::latestStatement	libyul/optimiser/ExpressionJoiner.h	/^	Statement* latestStatement();$/;"	p	class:yul::ExpressionJoiner	access:private	signature:()
yul::ExpressionJoiner::m_currentBlock	libyul/optimiser/ExpressionJoiner.h	/^	Block* m_currentBlock = nullptr;		\/\/\/< Pointer to current block holding the statement being visited.$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::m_latestStatementInBlock	libyul/optimiser/ExpressionJoiner.h	/^	size_t m_latestStatementInBlock = 0;		\/\/\/< Offset to m_currentBlock's statements of the last visited statement.$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::m_references	libyul/optimiser/ExpressionJoiner.h	/^	std::map<YulString, size_t> m_references;	\/\/\/< Holds reference counts to all variable declarations in current block.$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::override	libyul/optimiser/ExpressionJoiner.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::override	libyul/optimiser/ExpressionJoiner.h	/^	void operator()(FunctionCall&) override;$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::override	libyul/optimiser/ExpressionJoiner.h	/^	void operator()(FunctionalInstruction&) override;$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::override	libyul/optimiser/ExpressionJoiner.h	/^	void visit(Expression& _e) override;$/;"	m	class:yul::ExpressionJoiner	access:private
yul::ExpressionJoiner::resetLatestStatementPointer	libyul/optimiser/ExpressionJoiner.h	/^	void resetLatestStatementPointer();$/;"	p	class:yul::ExpressionJoiner	access:private	signature:()
yul::ExpressionJoiner::run	libyul/optimiser/ExpressionJoiner.h	/^	static void run(Block& _ast);$/;"	p	class:yul::ExpressionJoiner	access:public	signature:(Block& _ast)
yul::ExpressionSimplifier	libyul/optimiser/ExpressionSimplifier.h	/^class ExpressionSimplifier: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
yul::ExpressionSimplifier::ExpressionSimplifier	libyul/optimiser/ExpressionSimplifier.h	/^	explicit ExpressionSimplifier(Dialect const& _dialect): DataFlowAnalyzer(_dialect) {}$/;"	f	class:yul::ExpressionSimplifier	access:private	signature:(Dialect const& _dialect)
yul::ExpressionSimplifier::run	libyul/optimiser/ExpressionSimplifier.h	/^	static void run(Dialect const& _dialect, Block& _ast);$/;"	p	class:yul::ExpressionSimplifier	access:public	signature:(Dialect const& _dialect, Block& _ast)
yul::ExpressionSimplifier::visit	libyul/optimiser/ExpressionSimplifier.h	/^	virtual void visit(Expression& _expression);$/;"	p	class:yul::ExpressionSimplifier	access:public	signature:(Expression& _expression)
yul::ExpressionSplitter	libyul/optimiser/ExpressionSplitter.h	/^class ExpressionSplitter: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::ExpressionSplitter::ExpressionSplitter	libyul/optimiser/ExpressionSplitter.h	/^	explicit ExpressionSplitter(Dialect const& _dialect, NameDispenser& _nameDispenser):$/;"	f	class:yul::ExpressionSplitter	access:public	signature:(Dialect const& _dialect, NameDispenser& _nameDispenser)
yul::ExpressionSplitter::m_dialect	libyul/optimiser/ExpressionSplitter.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::ExpressionSplitter	access:private
yul::ExpressionSplitter::m_nameDispenser	libyul/optimiser/ExpressionSplitter.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::ExpressionSplitter	access:private
yul::ExpressionSplitter::m_statementsToPrefix	libyul/optimiser/ExpressionSplitter.h	/^	std::vector<Statement> m_statementsToPrefix;$/;"	m	class:yul::ExpressionSplitter	access:private
yul::ExpressionSplitter::outlineExpression	libyul/optimiser/ExpressionSplitter.h	/^	void outlineExpression(Expression& _expr);$/;"	p	class:yul::ExpressionSplitter	access:private	signature:(Expression& _expr)
yul::ExpressionSplitter::override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::ExpressionSplitter	access:public
yul::ExpressionSplitter::override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(ForLoop&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
yul::ExpressionSplitter::override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(FunctionCall&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
yul::ExpressionSplitter::override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(FunctionalInstruction&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
yul::ExpressionSplitter::override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(If&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
yul::ExpressionSplitter::override	libyul/optimiser/ExpressionSplitter.h	/^	void operator()(Switch&) override;$/;"	m	class:yul::ExpressionSplitter	access:public
yul::ExpressionStatement	libyul/AsmData.h	/^struct ExpressionStatement { langutil::SourceLocation location; Expression expression; };$/;"	s	namespace:yul
yul::ExpressionStatement::expression	libyul/AsmData.h	/^struct ExpressionStatement { langutil::SourceLocation location; Expression expression; };$/;"	m	struct:yul::ExpressionStatement	access:public
yul::ExpressionStatement::location	libyul/AsmData.h	/^struct ExpressionStatement { langutil::SourceLocation location; Expression expression; };$/;"	m	struct:yul::ExpressionStatement	access:public
yul::ForLoop	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	s	namespace:yul
yul::ForLoop::body	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
yul::ForLoop::condition	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
yul::ForLoop::location	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
yul::ForLoop::post	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
yul::ForLoop::pre	libyul/AsmData.h	/^struct ForLoop { langutil::SourceLocation location; Block pre; std::unique_ptr<Expression> condition; Block post; Block body; };$/;"	m	struct:yul::ForLoop	access:public
yul::ForLoopInitRewriter	libyul/optimiser/ForLoopInitRewriter.h	/^class ForLoopInitRewriter: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::ForLoopInitRewriter::override	libyul/optimiser/ForLoopInitRewriter.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::ForLoopInitRewriter	access:public
yul::FullInliner	libyul/optimiser/FullInliner.h	/^class FullInliner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::FullInliner::FullInliner	libyul/optimiser/FullInliner.h	/^	explicit FullInliner(Block& _ast, NameDispenser& _dispenser);$/;"	p	class:yul::FullInliner	access:public	signature:(Block& _ast, NameDispenser& _dispenser)
yul::FullInliner::function	libyul/optimiser/FullInliner.h	/^	FunctionDefinition* function(YulString _name)$/;"	f	class:yul::FullInliner	access:public	signature:(YulString _name)
yul::FullInliner::handleBlock	libyul/optimiser/FullInliner.h	/^	void handleBlock(YulString _currentFunctionName, Block& _block);$/;"	p	class:yul::FullInliner	access:private	signature:(YulString _currentFunctionName, Block& _block)
yul::FullInliner::m_ast	libyul/optimiser/FullInliner.h	/^	Block& m_ast;$/;"	m	class:yul::FullInliner	access:private
yul::FullInliner::m_constants	libyul/optimiser/FullInliner.h	/^	std::set<YulString> m_constants;$/;"	m	class:yul::FullInliner	access:private
yul::FullInliner::m_functionSizes	libyul/optimiser/FullInliner.h	/^	std::map<YulString, size_t> m_functionSizes;$/;"	m	class:yul::FullInliner	access:private
yul::FullInliner::m_functions	libyul/optimiser/FullInliner.h	/^	std::map<YulString, FunctionDefinition*> m_functions;$/;"	m	class:yul::FullInliner	access:private
yul::FullInliner::m_nameDispenser	libyul/optimiser/FullInliner.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::FullInliner	access:private
yul::FullInliner::m_singleUse	libyul/optimiser/FullInliner.h	/^	std::set<YulString> m_singleUse;$/;"	m	class:yul::FullInliner	access:private
yul::FullInliner::run	libyul/optimiser/FullInliner.h	/^	void run();$/;"	p	class:yul::FullInliner	access:public	signature:()
yul::FullInliner::shallInline	libyul/optimiser/FullInliner.h	/^	bool shallInline(FunctionCall const& _funCall, YulString _callSite);$/;"	p	class:yul::FullInliner	access:public	signature:(FunctionCall const& _funCall, YulString _callSite)
yul::FullInliner::tentativelyUpdateCodeSize	libyul/optimiser/FullInliner.h	/^	void tentativelyUpdateCodeSize(YulString _function, YulString _callSite);$/;"	p	class:yul::FullInliner	access:public	signature:(YulString _function, YulString _callSite)
yul::FullInliner::updateCodeSize	libyul/optimiser/FullInliner.h	/^	void updateCodeSize(FunctionDefinition const& _fun);$/;"	p	class:yul::FullInliner	access:private	signature:(FunctionDefinition const& _fun)
yul::FunctionCall	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	s	namespace:yul
yul::FunctionCall::arguments	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionCall	access:public
yul::FunctionCall::functionName	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionCall	access:public
yul::FunctionCall::location	libyul/AsmData.h	/^struct FunctionCall { langutil::SourceLocation location; Identifier functionName; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionCall	access:public
yul::FunctionDefinition	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	s	namespace:yul
yul::FunctionDefinition::body	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
yul::FunctionDefinition::location	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
yul::FunctionDefinition::name	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
yul::FunctionDefinition::parameters	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
yul::FunctionDefinition::returnVariables	libyul/AsmData.h	/^struct FunctionDefinition { langutil::SourceLocation location; YulString name; TypedNameList parameters; TypedNameList returnVariables; Block body; };$/;"	m	struct:yul::FunctionDefinition	access:public
yul::FunctionGrouper	libyul/optimiser/FunctionGrouper.h	/^class FunctionGrouper$/;"	c	namespace:yul
yul::FunctionGrouper::alreadyGrouped	libyul/optimiser/FunctionGrouper.h	/^	bool alreadyGrouped(Block const& _block);$/;"	p	class:yul::FunctionGrouper	access:private	signature:(Block const& _block)
yul::FunctionGrouper::operator ()	libyul/optimiser/FunctionGrouper.h	/^	void operator()(Block& _block);$/;"	p	class:yul::FunctionGrouper	access:public	signature:(Block& _block)
yul::FunctionHoister	libyul/optimiser/FunctionHoister.h	/^class FunctionHoister: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::FunctionHoister::m_functions	libyul/optimiser/FunctionHoister.h	/^	std::vector<Statement> m_functions;$/;"	m	class:yul::FunctionHoister	access:private
yul::FunctionHoister::m_isTopLevel	libyul/optimiser/FunctionHoister.h	/^	bool m_isTopLevel = true;$/;"	m	class:yul::FunctionHoister	access:private
yul::FunctionHoister::operator ()	libyul/optimiser/FunctionHoister.h	/^	virtual void operator()(Block& _block);$/;"	p	class:yul::FunctionHoister	access:public	signature:(Block& _block)
yul::FunctionalInstruction	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	s	namespace:yul
yul::FunctionalInstruction::arguments	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionalInstruction	access:public
yul::FunctionalInstruction::instruction	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionalInstruction	access:public
yul::FunctionalInstruction::location	libyul/AsmData.h	/^struct FunctionalInstruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; std::vector<Expression> arguments; };$/;"	m	struct:yul::FunctionalInstruction	access:public
yul::Identifier	libyul/AsmData.h	/^struct Identifier { langutil::SourceLocation location; YulString name; };$/;"	s	namespace:yul
yul::Identifier::location	libyul/AsmData.h	/^struct Identifier { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Identifier	access:public
yul::Identifier::name	libyul/AsmData.h	/^struct Identifier { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Identifier	access:public
yul::If	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	s	namespace:yul
yul::If::body	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	m	struct:yul::If	access:public
yul::If::condition	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	m	struct:yul::If	access:public
yul::If::location	libyul/AsmData.h	/^struct If { langutil::SourceLocation location; std::unique_ptr<Expression> condition; Block body; };$/;"	m	struct:yul::If	access:public
yul::InlinableExpressionFunctionFinder	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^class InlinableExpressionFunctionFinder: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::InlinableExpressionFunctionFinder::checkAllowed	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void checkAllowed(YulString _name)$/;"	f	class:yul::InlinableExpressionFunctionFinder	access:private	signature:(YulString _name)
yul::InlinableExpressionFunctionFinder::m_disallowedIdentifiers	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	std::set<YulString> m_disallowedIdentifiers;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:private
yul::InlinableExpressionFunctionFinder::m_foundDisallowedIdentifier	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	bool m_foundDisallowedIdentifier = false;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:private
yul::InlinableExpressionFunctionFinder::m_inlinableFunctions	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	std::map<YulString, FunctionDefinition const*> m_inlinableFunctions;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:private
yul::InlinableExpressionFunctionFinder::override	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void operator()(FunctionCall const& _funCall) override;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:public
yul::InlinableExpressionFunctionFinder::override	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void operator()(FunctionDefinition const& _function) override;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:public
yul::InlinableExpressionFunctionFinder::override	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	void operator()(Identifier const& _identifier) override;$/;"	m	class:yul::InlinableExpressionFunctionFinder	access:public
yul::InlinableExpressionFunctionFinder::std::inlinableFunctions	libyul/optimiser/InlinableExpressionFunctionFinder.h	/^	std::map<YulString, FunctionDefinition const*> const& inlinableFunctions() const$/;"	f	class:yul::InlinableExpressionFunctionFinder::std	access:public	signature:() const
yul::InlineModifier	libyul/optimiser/FullInliner.h	/^class InlineModifier: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::InlineModifier::InlineModifier	libyul/optimiser/FullInliner.h	/^	InlineModifier(FullInliner& _driver, NameDispenser& _nameDispenser, YulString _functionName):$/;"	f	class:yul::InlineModifier	access:public	signature:(FullInliner& _driver, NameDispenser& _nameDispenser, YulString _functionName)
yul::InlineModifier::m_currentFunction	libyul/optimiser/FullInliner.h	/^	YulString m_currentFunction;$/;"	m	class:yul::InlineModifier	access:private
yul::InlineModifier::m_driver	libyul/optimiser/FullInliner.h	/^	FullInliner& m_driver;$/;"	m	class:yul::InlineModifier	access:private
yul::InlineModifier::m_nameDispenser	libyul/optimiser/FullInliner.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::InlineModifier	access:private
yul::InlineModifier::override	libyul/optimiser/FullInliner.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::InlineModifier	access:public
yul::InlineModifier::performInline	libyul/optimiser/FullInliner.h	/^	std::vector<Statement> performInline(Statement& _statement, FunctionCall& _funCall);$/;"	p	class:yul::InlineModifier	access:private	signature:(Statement& _statement, FunctionCall& _funCall)
yul::InlineModifier::tryInlineStatement	libyul/optimiser/FullInliner.h	/^	boost::optional<std::vector<Statement>> tryInlineStatement(Statement& _statement);$/;"	p	class:yul::InlineModifier	access:private	signature:(Statement& _statement)
yul::Instruction	libyul/AsmData.h	/^struct Instruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; };$/;"	s	namespace:yul
yul::Instruction::instruction	libyul/AsmData.h	/^struct Instruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; };$/;"	m	struct:yul::Instruction	access:public
yul::Instruction::location	libyul/AsmData.h	/^struct Instruction { langutil::SourceLocation location; dev::solidity::Instruction instruction; };$/;"	m	struct:yul::Instruction	access:public
yul::Label	libyul/AsmData.h	/^struct Label { langutil::SourceLocation location; YulString name; };$/;"	s	namespace:yul
yul::Label::location	libyul/AsmData.h	/^struct Label { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Label	access:public
yul::Label::name	libyul/AsmData.h	/^struct Label { langutil::SourceLocation location; YulString name; };$/;"	m	struct:yul::Label	access:public
yul::Less	libyul/Utilities.h	/^struct Less$/;"	s	namespace:yul
yul::Less	libyul/Utilities.h	/^struct Less<T*>$/;"	s	namespace:yul
yul::Less::operator ()	libyul/Utilities.h	/^	bool operator()(T const& _lhs, T const& _rhs) const;$/;"	p	struct:yul::Less	access:public	signature:(T const& _lhs, T const& _rhs) const
yul::Less::operator ()	libyul/Utilities.h	/^	bool operator()(T const* _lhs, T const* _rhs) const$/;"	f	struct:yul::Less	access:public	signature:(T const* _lhs, T const* _rhs) const
yul::Less::operator ()	libyul/Utilities.h	/^template<> bool Less<Literal>::operator()(Literal const& _lhs, Literal const& _rhs) const;$/;"	p	class:yul::Less	signature:(Literal const& _lhs, Literal const& _rhs) const
yul::Literal	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	s	namespace:yul
yul::Literal::kind	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
yul::Literal::location	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
yul::Literal::type	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
yul::Literal::value	libyul/AsmData.h	/^struct Literal { langutil::SourceLocation location; LiteralKind kind; YulString value; Type type; };$/;"	m	struct:yul::Literal	access:public
yul::LiteralKind	libyul/AsmData.h	/^enum class LiteralKind { Number, Boolean, String };$/;"	c	namespace:yul
yul::LiteralKind::Boolean	libyul/AsmData.h	/^enum class LiteralKind { Number, Boolean, String };$/;"	m	class:yul::LiteralKind	access:private
yul::LiteralKind::Number	libyul/AsmData.h	/^enum class LiteralKind { Number, Boolean, String };$/;"	m	class:yul::LiteralKind	access:private
yul::LocationExtractor	libyul/AsmData.h	/^struct LocationExtractor: boost::static_visitor<langutil::SourceLocation>$/;"	s	namespace:yul	inherits:boost::static_visitor
yul::LocationExtractor::operator ()	libyul/AsmData.h	/^	template <class T> langutil::SourceLocation operator()(T const& _node) const$/;"	f	struct:yul::LocationExtractor	access:public	signature:(T const& _node) const
yul::MachineAssemblyObject	libyul/AssemblyStack.h	/^struct MachineAssemblyObject$/;"	s	namespace:yul
yul::MachineAssemblyObject::assembly	libyul/AssemblyStack.h	/^	std::string assembly;$/;"	m	struct:yul::MachineAssemblyObject	access:public
yul::MachineAssemblyObject::bytecode	libyul/AssemblyStack.h	/^	std::shared_ptr<dev::eth::LinkerObject> bytecode;$/;"	m	struct:yul::MachineAssemblyObject	access:public
yul::MainFunction	libyul/optimiser/MainFunction.h	/^class MainFunction$/;"	c	namespace:yul
yul::MainFunction::operator ()	libyul/optimiser/MainFunction.h	/^	void operator()(Block& _block);$/;"	p	class:yul::MainFunction	access:public	signature:(Block& _block)
yul::MovableChecker	libyul/optimiser/Semantics.h	/^class MovableChecker: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::MovableChecker::MovableChecker	libyul/optimiser/Semantics.h	/^	MovableChecker(Dialect const& _dialect, Expression const& _expression);$/;"	p	class:yul::MovableChecker	access:public	signature:(Dialect const& _dialect, Expression const& _expression)
yul::MovableChecker::MovableChecker	libyul/optimiser/Semantics.h	/^	explicit MovableChecker(Dialect const& _dialect);$/;"	p	class:yul::MovableChecker	access:public	signature:(Dialect const& _dialect)
yul::MovableChecker::m_dialect	libyul/optimiser/Semantics.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::MovableChecker	access:private
yul::MovableChecker::m_movable	libyul/optimiser/Semantics.h	/^	bool m_movable = true;$/;"	m	class:yul::MovableChecker	access:private
yul::MovableChecker::m_variableReferences	libyul/optimiser/Semantics.h	/^	std::set<YulString> m_variableReferences;$/;"	m	class:yul::MovableChecker	access:private
yul::MovableChecker::movable	libyul/optimiser/Semantics.h	/^	bool movable() const { return m_movable; }$/;"	f	class:yul::MovableChecker	access:public	signature:() const
yul::MovableChecker::override	libyul/optimiser/Semantics.h	/^	void operator()(FunctionCall const& _functionCall) override;$/;"	m	class:yul::MovableChecker	access:public
yul::MovableChecker::override	libyul/optimiser/Semantics.h	/^	void operator()(FunctionalInstruction const& _functionalInstruction) override;$/;"	m	class:yul::MovableChecker	access:public
yul::MovableChecker::override	libyul/optimiser/Semantics.h	/^	void operator()(Identifier const& _identifier) override;$/;"	m	class:yul::MovableChecker	access:public
yul::MovableChecker::override	libyul/optimiser/Semantics.h	/^	void visit(Statement const&) override;$/;"	m	class:yul::MovableChecker	access:public
yul::MovableChecker::std::referencedVariables	libyul/optimiser/Semantics.h	/^	std::set<YulString> const& referencedVariables() const { return m_variableReferences; }$/;"	f	class:yul::MovableChecker::std	access:public	signature:() const
yul::NameCollector	libyul/optimiser/NameCollector.h	/^class NameCollector: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::NameCollector::NameCollector	libyul/optimiser/NameCollector.h	/^	explicit NameCollector(Block const& _block)$/;"	f	class:yul::NameCollector	access:public	signature:(Block const& _block)
yul::NameCollector::m_names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> m_names;$/;"	m	class:yul::NameCollector	access:private
yul::NameCollector::names	libyul/optimiser/NameCollector.h	/^	std::set<YulString> names() const { return m_names; }$/;"	f	class:yul::NameCollector	access:public	signature:() const
yul::NameCollector::override	libyul/optimiser/NameCollector.h	/^	void operator()(FunctionDefinition const& _funDef) override;$/;"	m	class:yul::NameCollector	access:public
yul::NameCollector::override	libyul/optimiser/NameCollector.h	/^	void operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::NameCollector	access:public
yul::NameDispenser	libyul/optimiser/NameDispenser.h	/^class NameDispenser$/;"	c	namespace:yul
yul::NameDispenser::NameDispenser	libyul/optimiser/NameDispenser.h	/^	explicit NameDispenser(Dialect const& _dialect, Block const& _ast);$/;"	p	class:yul::NameDispenser	access:public	signature:(Dialect const& _dialect, Block const& _ast)
yul::NameDispenser::NameDispenser	libyul/optimiser/NameDispenser.h	/^	explicit NameDispenser(Dialect const& _dialect, std::set<YulString> _usedNames);$/;"	p	class:yul::NameDispenser	access:public	signature:(Dialect const& _dialect, std::set<YulString> _usedNames)
yul::NameDispenser::m_counter	libyul/optimiser/NameDispenser.h	/^	size_t m_counter = 0;$/;"	m	class:yul::NameDispenser	access:private
yul::NameDispenser::m_dialect	libyul/optimiser/NameDispenser.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::NameDispenser	access:private
yul::NameDispenser::m_usedNames	libyul/optimiser/NameDispenser.h	/^	std::set<YulString> m_usedNames;$/;"	m	class:yul::NameDispenser	access:private
yul::NameDispenser::newName	libyul/optimiser/NameDispenser.h	/^	YulString newName(YulString _nameHint);$/;"	p	class:yul::NameDispenser	access:public	signature:(YulString _nameHint)
yul::NoOutputAssembly	libyul/backends/evm/NoOutputAssembly.h	/^class NoOutputAssembly: public AbstractAssembly$/;"	c	namespace:yul	inherits:AbstractAssembly
yul::NoOutputAssembly::NoOutputAssembly	libyul/backends/evm/NoOutputAssembly.h	/^	explicit NoOutputAssembly(bool _evm15 = false): m_evm15(_evm15) { }$/;"	f	class:yul::NoOutputAssembly	access:public	signature:(bool _evm15 = false)
yul::NoOutputAssembly::m_evm15	libyul/backends/evm/NoOutputAssembly.h	/^	bool m_evm15 = false; \/\/\/< if true, switch to evm1.5 mode$/;"	m	class:yul::NoOutputAssembly	access:private
yul::NoOutputAssembly::m_stackHeight	libyul/backends/evm/NoOutputAssembly.h	/^	int m_stackHeight = 0;$/;"	m	class:yul::NoOutputAssembly	access:private
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	LabelID namedLabel(std::string const& _name) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	LabelID newLabelId() override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	SubID appendData(dev::bytes const& _data) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly() override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendAssemblySize() override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendBeginsub(LabelID _labelId, int _arguments) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendConstant(dev::u256 const& _constant) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendDataOffset(SubID _sub) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendDataSize(SubID _sub) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendInstruction(dev::solidity::Instruction _instruction) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJump(int _stackDiffAfter) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJumpTo(LabelID _labelId, int _stackDiffAfter) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJumpToIf(LabelID _labelId) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendJumpsub(LabelID _labelId, int _arguments, int _returns) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendLabel(LabelID _labelId) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendLabelReference(LabelID _labelId) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendLinkerSymbol(std::string const& _name) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::override	libyul/backends/evm/NoOutputAssembly.h	/^	void appendReturnsub(int _returns, int _stackDiffAfter) override;$/;"	m	class:yul::NoOutputAssembly	access:public
yul::NoOutputAssembly::~NoOutputAssembly	libyul/backends/evm/NoOutputAssembly.h	/^	virtual ~NoOutputAssembly() = default;$/;"	p	class:yul::NoOutputAssembly	access:public	signature:()
yul::NoOutputEVMDialect	libyul/backends/evm/NoOutputAssembly.h	/^struct NoOutputEVMDialect: public EVMDialect$/;"	s	namespace:yul	inherits:EVMDialect
yul::NoOutputEVMDialect::NoOutputEVMDialect	libyul/backends/evm/NoOutputAssembly.h	/^	explicit NoOutputEVMDialect(std::shared_ptr<EVMDialect> const& _copyFrom);$/;"	p	struct:yul::NoOutputEVMDialect	access:public	signature:(std::shared_ptr<EVMDialect> const& _copyFrom)
yul::Object	libyul/Object.h	/^struct Object: ObjectNode$/;"	s	namespace:yul	inherits:ObjectNode
yul::Object::analysisInfo	libyul/Object.h	/^	std::shared_ptr<yul::AsmAnalysisInfo> analysisInfo;$/;"	m	struct:yul::Object	access:public
yul::Object::code	libyul/Object.h	/^	std::shared_ptr<Block> code;$/;"	m	struct:yul::Object	access:public
yul::Object::override	libyul/Object.h	/^	std::string toString(bool _yul) const override;$/;"	m	struct:yul::Object	access:public
yul::Object::subIndexByName	libyul/Object.h	/^	std::map<YulString, size_t> subIndexByName;$/;"	m	struct:yul::Object	access:public
yul::Object::subObjects	libyul/Object.h	/^	std::vector<std::shared_ptr<ObjectNode>> subObjects;$/;"	m	struct:yul::Object	access:public
yul::ObjectNode	libyul/Object.h	/^struct ObjectNode$/;"	s	namespace:yul
yul::ObjectNode::name	libyul/Object.h	/^	YulString name;$/;"	m	struct:yul::ObjectNode	access:public
yul::ObjectNode::toString	libyul/Object.h	/^	virtual std::string toString(bool _yul) const = 0;$/;"	p	struct:yul::ObjectNode	access:public	signature:(bool _yul) const
yul::ObjectNode::~ObjectNode	libyul/Object.h	/^	virtual ~ObjectNode() = default;$/;"	p	struct:yul::ObjectNode	access:public	signature:()
yul::ObjectParser	libyul/ObjectParser.h	/^class ObjectParser: public langutil::ParserBase$/;"	c	namespace:yul	inherits:langutil::ParserBase
yul::ObjectParser::ObjectParser	libyul/ObjectParser.h	/^	explicit ObjectParser($/;"	f	class:yul::ObjectParser	access:public	signature:( langutil::ErrorReporter& _errorReporter, std::shared_ptr<Dialect> _dialect )
yul::ObjectParser::addNamedSubObject	libyul/ObjectParser.h	/^	void addNamedSubObject(Object& _container, YulString _name, std::shared_ptr<ObjectNode> _subObject);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object& _container, YulString _name, std::shared_ptr<ObjectNode> _subObject)
yul::ObjectParser::m_dialect	libyul/ObjectParser.h	/^	std::shared_ptr<Dialect> m_dialect;$/;"	m	class:yul::ObjectParser	access:private
yul::ObjectParser::parse	libyul/ObjectParser.h	/^	std::shared_ptr<Object> parse(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner);$/;"	p	class:yul::ObjectParser	access:public	signature:(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner)
yul::ObjectParser::parseBlock	libyul/ObjectParser.h	/^	std::shared_ptr<Block> parseBlock();$/;"	p	class:yul::ObjectParser	access:private	signature:()
yul::ObjectParser::parseCode	libyul/ObjectParser.h	/^	std::shared_ptr<Block> parseCode();$/;"	p	class:yul::ObjectParser	access:private	signature:()
yul::ObjectParser::parseData	libyul/ObjectParser.h	/^	void parseData(Object& _containingObject);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object& _containingObject)
yul::ObjectParser::parseObject	libyul/ObjectParser.h	/^	std::shared_ptr<Object> parseObject(Object* _containingObject = nullptr);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object* _containingObject = nullptr)
yul::ObjectParser::parseUniqueName	libyul/ObjectParser.h	/^	YulString parseUniqueName(Object const* _containingObject);$/;"	p	class:yul::ObjectParser	access:private	signature:(Object const* _containingObject)
yul::OptimiserSuite	libyul/optimiser/Suite.h	/^class OptimiserSuite$/;"	c	namespace:yul
yul::OptimiserSuite::run	libyul/optimiser/Suite.h	/^	static void run($/;"	p	class:yul::OptimiserSuite	access:public	signature:( std::shared_ptr<Dialect> const& _dialect, Block& _ast, AsmAnalysisInfo const& _analysisInfo, std::set<YulString> const& _externallyUsedIdentifiers = {} )
yul::OptimizerException	libyul/Exceptions.h	/^struct OptimizerException: virtual YulException {};$/;"	s	namespace:yul	inherits:YulException
yul::Parser	libyul/AsmParser.h	/^class Parser: public langutil::ParserBase$/;"	c	namespace:yul	inherits:langutil::ParserBase
yul::Parser::Parser	libyul/AsmParser.h	/^	explicit Parser(langutil::ErrorReporter& _errorReporter, std::shared_ptr<Dialect> _dialect):$/;"	f	class:yul::Parser	access:public	signature:(langutil::ErrorReporter& _errorReporter, std::shared_ptr<Dialect> _dialect)
yul::Parser::createWithLocation	libyul/AsmParser.h	/^	template <class T> T createWithLocation(langutil::SourceLocation const& _loc = {}) const$/;"	f	class:yul::Parser	access:protected	signature:(langutil::SourceLocation const& _loc = {}) const
yul::Parser::expectAsmIdentifier	libyul/AsmParser.h	/^	YulString expectAsmIdentifier();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::isValidNumberLiteral	libyul/AsmParser.h	/^	static bool isValidNumberLiteral(std::string const& _literal);$/;"	p	class:yul::Parser	access:protected	signature:(std::string const& _literal)
yul::Parser::location	libyul/AsmParser.h	/^	langutil::SourceLocation location() const { return {position(), endPosition(), m_scanner->charStream()}; }$/;"	f	class:yul::Parser	access:protected	signature:() const
yul::Parser::m_dialect	libyul/AsmParser.h	/^	std::shared_ptr<Dialect> m_dialect;$/;"	m	class:yul::Parser	access:private
yul::Parser::parse	libyul/AsmParser.h	/^	std::shared_ptr<Block> parse(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner);$/;"	p	class:yul::Parser	access:public	signature:(std::shared_ptr<langutil::Scanner> const& _scanner, bool _reuseScanner)
yul::Parser::parseBlock	libyul/AsmParser.h	/^	Block parseBlock();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseCall	libyul/AsmParser.h	/^	Expression parseCall(ElementaryOperation&& _initialOp);$/;"	p	class:yul::Parser	access:protected	signature:(ElementaryOperation&& _initialOp)
yul::Parser::parseCase	libyul/AsmParser.h	/^	Case parseCase();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseElementaryOperation	libyul/AsmParser.h	/^	ElementaryOperation parseElementaryOperation();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseExpression	libyul/AsmParser.h	/^	Expression parseExpression();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseForLoop	libyul/AsmParser.h	/^	ForLoop parseForLoop();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseFunctionDefinition	libyul/AsmParser.h	/^	FunctionDefinition parseFunctionDefinition();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseStatement	libyul/AsmParser.h	/^	Statement parseStatement();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseTypedName	libyul/AsmParser.h	/^	TypedName parseTypedName();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::parseVariableDeclaration	libyul/AsmParser.h	/^	VariableDeclaration parseVariableDeclaration();$/;"	p	class:yul::Parser	access:protected	signature:()
yul::Parser::std::instructionNames	libyul/AsmParser.h	/^	static std::map<dev::solidity::Instruction, std::string> const& instructionNames();$/;"	p	class:yul::Parser::std	access:protected	signature:()
yul::Parser::std::instructions	libyul/AsmParser.h	/^	static std::map<std::string, dev::solidity::Instruction> const& instructions();$/;"	p	class:yul::Parser::std	access:protected	signature:()
yul::Pattern	libyul/optimiser/SimplificationRules.h	/^class Pattern$/;"	c	namespace:yul
yul::Pattern::Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(PatternKind _kind = PatternKind::Any): m_kind(_kind) {}$/;"	f	class:yul::Pattern	access:public	signature:(PatternKind _kind = PatternKind::Any)
yul::Pattern::Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(dev::solidity::Instruction _instruction, std::vector<Pattern> const& _arguments = {});$/;"	p	class:yul::Pattern	access:public	signature:(dev::solidity::Instruction _instruction, std::vector<Pattern> const& _arguments = {})
yul::Pattern::Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(dev::u256 const& _value): m_kind(PatternKind::Constant), m_data(std::make_shared<dev::u256>(_value)) {}$/;"	f	class:yul::Pattern	access:public	signature:(dev::u256 const& _value)
yul::Pattern::Pattern	libyul/optimiser/SimplificationRules.h	/^	Pattern(unsigned _value): Pattern(dev::u256(_value)) {}$/;"	f	class:yul::Pattern	access:public	signature:(unsigned _value)
yul::Pattern::arguments	libyul/optimiser/SimplificationRules.h	/^	std::vector<Pattern> arguments() const { return m_arguments; }$/;"	f	class:yul::Pattern	access:public	signature:() const
yul::Pattern::d	libyul/optimiser/SimplificationRules.h	/^	dev::u256 d() const;$/;"	p	class:yul::Pattern	access:public	signature:() const
yul::Pattern::instruction	libyul/optimiser/SimplificationRules.h	/^	dev::solidity::Instruction instruction() const;$/;"	p	class:yul::Pattern	access:public	signature:() const
yul::Pattern::m_arguments	libyul/optimiser/SimplificationRules.h	/^	std::vector<Pattern> m_arguments;$/;"	m	class:yul::Pattern	access:private
yul::Pattern::m_data	libyul/optimiser/SimplificationRules.h	/^	std::shared_ptr<dev::u256> m_data; \/\/\/< Only valid if m_kind is Constant$/;"	m	class:yul::Pattern	access:private
yul::Pattern::m_instruction	libyul/optimiser/SimplificationRules.h	/^	dev::solidity::Instruction m_instruction; \/\/\/< Only valid if m_kind is Operation$/;"	m	class:yul::Pattern	access:private
yul::Pattern::m_kind	libyul/optimiser/SimplificationRules.h	/^	PatternKind m_kind = PatternKind::Any;$/;"	m	class:yul::Pattern	access:private
yul::Pattern::m_matchGroup	libyul/optimiser/SimplificationRules.h	/^	unsigned m_matchGroup = 0;$/;"	m	class:yul::Pattern	access:private
yul::Pattern::m_matchGroups	libyul/optimiser/SimplificationRules.h	/^	std::map<unsigned, Expression const*>* m_matchGroups = nullptr;$/;"	m	class:yul::Pattern	access:private
yul::Pattern::matchGroup	libyul/optimiser/SimplificationRules.h	/^	unsigned matchGroup() const { return m_matchGroup; }$/;"	f	class:yul::Pattern	access:public	signature:() const
yul::Pattern::matchGroupValue	libyul/optimiser/SimplificationRules.h	/^	Expression const& matchGroupValue() const;$/;"	p	class:yul::Pattern	access:private	signature:() const
yul::Pattern::matches	libyul/optimiser/SimplificationRules.h	/^	bool matches($/;"	p	class:yul::Pattern	access:public	signature:( Expression const& _expr, Dialect const& _dialect, std::map<YulString, Expression const*> const& _ssaValues ) const
yul::Pattern::setMatchGroup	libyul/optimiser/SimplificationRules.h	/^	void setMatchGroup(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups);$/;"	p	class:yul::Pattern	access:public	signature:(unsigned _group, std::map<unsigned, Expression const*>& _matchGroups)
yul::Pattern::toExpression	libyul/optimiser/SimplificationRules.h	/^	Expression toExpression(langutil::SourceLocation const& _location) const;$/;"	p	class:yul::Pattern	access:public	signature:(langutil::SourceLocation const& _location) const
yul::PatternKind	libyul/optimiser/SimplificationRules.h	/^enum class PatternKind$/;"	c	namespace:yul
yul::PatternKind::Constant	libyul/optimiser/SimplificationRules.h	/^	Constant,$/;"	m	class:yul::PatternKind	access:private
yul::PatternKind::Operation	libyul/optimiser/SimplificationRules.h	/^	Operation,$/;"	m	class:yul::PatternKind	access:private
yul::RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^class RedundantAssignEliminator: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::RedundantAssignEliminator::BlockScope	libyul/optimiser/RedundantAssignEliminator.h	/^	class BlockScope$/;"	c	class:yul::RedundantAssignEliminator	access:private
yul::RedundantAssignEliminator::BlockScope::BlockScope	libyul/optimiser/RedundantAssignEliminator.h	/^		explicit BlockScope(RedundantAssignEliminator& _rae): m_rae(_rae)$/;"	f	class:yul::RedundantAssignEliminator::BlockScope	access:public	signature:(RedundantAssignEliminator& _rae)
yul::RedundantAssignEliminator::BlockScope::m_outerDeclaredVariables	libyul/optimiser/RedundantAssignEliminator.h	/^		std::set<YulString> m_outerDeclaredVariables;$/;"	m	class:yul::RedundantAssignEliminator::BlockScope	access:private
yul::RedundantAssignEliminator::BlockScope::m_rae	libyul/optimiser/RedundantAssignEliminator.h	/^		RedundantAssignEliminator& m_rae;$/;"	m	class:yul::RedundantAssignEliminator::BlockScope	access:private
yul::RedundantAssignEliminator::BlockScope::~BlockScope	libyul/optimiser/RedundantAssignEliminator.h	/^		~BlockScope()$/;"	f	class:yul::RedundantAssignEliminator::BlockScope	access:public	signature:()
yul::RedundantAssignEliminator::RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator() = default;$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:()
yul::RedundantAssignEliminator::RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator(RedundantAssignEliminator const&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator const&)
yul::RedundantAssignEliminator::RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator(RedundantAssignEliminator&&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator&&)
yul::RedundantAssignEliminator::RedundantAssignEliminator	libyul/optimiser/RedundantAssignEliminator.h	/^	explicit RedundantAssignEliminator(Dialect const& _dialect): m_dialect(&_dialect) {}$/;"	f	class:yul::RedundantAssignEliminator	access:public	signature:(Dialect const& _dialect)
yul::RedundantAssignEliminator::State	libyul/optimiser/RedundantAssignEliminator.h	/^	class State$/;"	c	class:yul::RedundantAssignEliminator	access:private
yul::RedundantAssignEliminator::State::State	libyul/optimiser/RedundantAssignEliminator.h	/^		State(Value _value = Undecided): m_value(_value) {}$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(Value _value = Undecided)
yul::RedundantAssignEliminator::State::Undecided	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	e	enum:yul::RedundantAssignEliminator::State::Value
yul::RedundantAssignEliminator::State::Unused	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	e	enum:yul::RedundantAssignEliminator::State::Value
yul::RedundantAssignEliminator::State::Used	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	e	enum:yul::RedundantAssignEliminator::State::Value
yul::RedundantAssignEliminator::State::Value	libyul/optimiser/RedundantAssignEliminator.h	/^		enum Value { Unused, Undecided, Used };$/;"	g	class:yul::RedundantAssignEliminator::State	access:public
yul::RedundantAssignEliminator::State::join	libyul/optimiser/RedundantAssignEliminator.h	/^		static inline void join(State& _a, State const& _b)$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(State& _a, State const& _b)
yul::RedundantAssignEliminator::State::m_value	libyul/optimiser/RedundantAssignEliminator.h	/^		Value m_value = Undecided;$/;"	m	class:yul::RedundantAssignEliminator::State	access:private
yul::RedundantAssignEliminator::State::operator !=	libyul/optimiser/RedundantAssignEliminator.h	/^		inline bool operator!=(State _other) const { return !operator==(_other); }$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(State _other) const
yul::RedundantAssignEliminator::State::operator ==	libyul/optimiser/RedundantAssignEliminator.h	/^		inline bool operator==(State _other) const { return m_value == _other.m_value; }$/;"	f	class:yul::RedundantAssignEliminator::State	access:public	signature:(State _other) const
yul::RedundantAssignEliminator::changeUndecidedTo	libyul/optimiser/RedundantAssignEliminator.h	/^	void changeUndecidedTo(YulString _variable, State _newState);$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:(YulString _variable, State _newState)
yul::RedundantAssignEliminator::finalize	libyul/optimiser/RedundantAssignEliminator.h	/^	void finalize(YulString _variable);$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:(YulString _variable)
yul::RedundantAssignEliminator::join	libyul/optimiser/RedundantAssignEliminator.h	/^	void join(RedundantAssignEliminator& _other);$/;"	p	class:yul::RedundantAssignEliminator	access:private	signature:(RedundantAssignEliminator& _other)
yul::RedundantAssignEliminator::m_assignments	libyul/optimiser/RedundantAssignEliminator.h	/^	std::map<YulString, std::map<Assignment const*, State>> m_assignments;$/;"	m	class:yul::RedundantAssignEliminator	access:private
yul::RedundantAssignEliminator::m_assignmentsToRemove	libyul/optimiser/RedundantAssignEliminator.h	/^	std::set<Assignment const*> m_assignmentsToRemove;$/;"	m	class:yul::RedundantAssignEliminator	access:private
yul::RedundantAssignEliminator::m_declaredVariables	libyul/optimiser/RedundantAssignEliminator.h	/^	std::set<YulString> m_declaredVariables;$/;"	m	class:yul::RedundantAssignEliminator	access:private
yul::RedundantAssignEliminator::m_dialect	libyul/optimiser/RedundantAssignEliminator.h	/^	Dialect const* m_dialect;$/;"	m	class:yul::RedundantAssignEliminator	access:private
yul::RedundantAssignEliminator::operator =	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator& operator=(RedundantAssignEliminator const&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator const&)
yul::RedundantAssignEliminator::operator =	libyul/optimiser/RedundantAssignEliminator.h	/^	RedundantAssignEliminator& operator=(RedundantAssignEliminator&&) = default;$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(RedundantAssignEliminator&&)
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Block const& _block) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(ForLoop const&) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(FunctionDefinition const&) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Identifier const& _identifier) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(If const& _if) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(Switch const& _switch) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::override	libyul/optimiser/RedundantAssignEliminator.h	/^	void operator()(VariableDeclaration const& _variableDeclaration) override;$/;"	m	class:yul::RedundantAssignEliminator	access:public
yul::RedundantAssignEliminator::run	libyul/optimiser/RedundantAssignEliminator.h	/^	static void run(Dialect const& _dialect, Block& _ast);$/;"	p	class:yul::RedundantAssignEliminator	access:public	signature:(Dialect const& _dialect, Block& _ast)
yul::ReferencesCounter	libyul/optimiser/NameCollector.h	/^class ReferencesCounter: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::ReferencesCounter::countReferences	libyul/optimiser/NameCollector.h	/^	static std::map<YulString, size_t> countReferences(Block const& _block);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(Block const& _block)
yul::ReferencesCounter::countReferences	libyul/optimiser/NameCollector.h	/^	static std::map<YulString, size_t> countReferences(Expression const& _expression);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(Expression const& _expression)
yul::ReferencesCounter::countReferences	libyul/optimiser/NameCollector.h	/^	static std::map<YulString, size_t> countReferences(FunctionDefinition const& _function);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(FunctionDefinition const& _function)
yul::ReferencesCounter::m_references	libyul/optimiser/NameCollector.h	/^	std::map<YulString, size_t> m_references;$/;"	m	class:yul::ReferencesCounter	access:private
yul::ReferencesCounter::operator ()	libyul/optimiser/NameCollector.h	/^	virtual void operator()(FunctionCall const& _funCall);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(FunctionCall const& _funCall)
yul::ReferencesCounter::operator ()	libyul/optimiser/NameCollector.h	/^	virtual void operator()(Identifier const& _identifier);$/;"	p	class:yul::ReferencesCounter	access:public	signature:(Identifier const& _identifier)
yul::ReferencesCounter::std::references	libyul/optimiser/NameCollector.h	/^	std::map<YulString, size_t> const& references() const { return m_references; }$/;"	f	class:yul::ReferencesCounter::std	access:public	signature:() const
yul::Rematerialiser	libyul/optimiser/Rematerialiser.h	/^class Rematerialiser: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
yul::Rematerialiser::Rematerialiser	libyul/optimiser/Rematerialiser.h	/^	Rematerialiser($/;"	p	class:yul::Rematerialiser	access:protected	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> _varsToAlwaysRematerialize = {} )
yul::Rematerialiser::Rematerialiser	libyul/optimiser/Rematerialiser.h	/^	Rematerialiser($/;"	p	class:yul::Rematerialiser	access:protected	signature:( Dialect const& _dialect, FunctionDefinition& _function, std::set<YulString> _varsToAlwaysRematerialize = {} )
yul::Rematerialiser::m_referenceCounts	libyul/optimiser/Rematerialiser.h	/^	std::map<YulString, size_t> m_referenceCounts;$/;"	m	class:yul::Rematerialiser	access:protected
yul::Rematerialiser::m_varsToAlwaysRematerialize	libyul/optimiser/Rematerialiser.h	/^	std::set<YulString> m_varsToAlwaysRematerialize;$/;"	m	class:yul::Rematerialiser	access:protected
yul::Rematerialiser::override	libyul/optimiser/Rematerialiser.h	/^	void visit(Expression& _e) override;$/;"	m	class:yul::Rematerialiser	access:protected
yul::Rematerialiser::run	libyul/optimiser/Rematerialiser.h	/^	static void run($/;"	p	class:yul::Rematerialiser	access:public	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> _varsToAlwaysRematerialize = {} )
yul::Rematerialiser::run	libyul/optimiser/Rematerialiser.h	/^	static void run($/;"	p	class:yul::Rematerialiser	access:public	signature:( Dialect const& _dialect, FunctionDefinition& _function, std::set<YulString> _varsToAlwaysRematerialize = {} )
yul::SSAReverser	libyul/optimiser/SSAReverser.h	/^class SSAReverser: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::SSAReverser::SSAReverser	libyul/optimiser/SSAReverser.h	/^	SSAReverser(AssignmentCounter const& _assignmentCounter): m_assignmentCounter(_assignmentCounter) {}$/;"	f	class:yul::SSAReverser	access:private	signature:(AssignmentCounter const& _assignmentCounter)
yul::SSAReverser::m_assignmentCounter	libyul/optimiser/SSAReverser.h	/^	AssignmentCounter const& m_assignmentCounter;$/;"	m	class:yul::SSAReverser	access:private
yul::SSAReverser::override	libyul/optimiser/SSAReverser.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::SSAReverser	access:public
yul::SSAReverser::run	libyul/optimiser/SSAReverser.h	/^	static void run(Block& _block);$/;"	p	class:yul::SSAReverser	access:public	signature:(Block& _block)
yul::SSATransform	libyul/optimiser/SSATransform.h	/^class SSATransform: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::SSATransform::SSATransform	libyul/optimiser/SSATransform.h	/^	explicit SSATransform(NameDispenser& _nameDispenser, std::set<YulString> const& _variablesToReplace):$/;"	f	class:yul::SSATransform	access:private	signature:(NameDispenser& _nameDispenser, std::set<YulString> const& _variablesToReplace)
yul::SSATransform::m_currentVariableValues	libyul/optimiser/SSATransform.h	/^	std::map<YulString, YulString> m_currentVariableValues;$/;"	m	class:yul::SSATransform	access:private
yul::SSATransform::m_nameDispenser	libyul/optimiser/SSATransform.h	/^	NameDispenser& m_nameDispenser;$/;"	m	class:yul::SSATransform	access:private
yul::SSATransform::override	libyul/optimiser/SSATransform.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::SSATransform	access:public
yul::SSATransform::override	libyul/optimiser/SSATransform.h	/^	void operator()(ForLoop&) override;$/;"	m	class:yul::SSATransform	access:public
yul::SSATransform::override	libyul/optimiser/SSATransform.h	/^	void operator()(Identifier&) override;$/;"	m	class:yul::SSATransform	access:public
yul::SSATransform::run	libyul/optimiser/SSATransform.h	/^	static void run(Block& _ast, NameDispenser& _nameDispenser);$/;"	p	class:yul::SSATransform	access:public	signature:(Block& _ast, NameDispenser& _nameDispenser)
yul::SSATransform::std::m_variablesToReplace	libyul/optimiser/SSATransform.h	/^	std::set<YulString> const& m_variablesToReplace;$/;"	m	class:yul::SSATransform::std	access:private
yul::SSAValueTracker	libyul/optimiser/SSAValueTracker.h	/^class SSAValueTracker: public ASTWalker$/;"	c	namespace:yul	inherits:ASTWalker
yul::SSAValueTracker::m_values	libyul/optimiser/SSAValueTracker.h	/^	std::map<YulString, Expression const*> m_values;$/;"	m	class:yul::SSAValueTracker	access:private
yul::SSAValueTracker::override	libyul/optimiser/SSAValueTracker.h	/^	void operator()(Assignment const& _assignment) override;$/;"	m	class:yul::SSAValueTracker	access:public
yul::SSAValueTracker::override	libyul/optimiser/SSAValueTracker.h	/^	void operator()(FunctionDefinition const& _funDef) override;$/;"	m	class:yul::SSAValueTracker	access:public
yul::SSAValueTracker::override	libyul/optimiser/SSAValueTracker.h	/^	void operator()(VariableDeclaration const& _varDecl) override;$/;"	m	class:yul::SSAValueTracker	access:public
yul::SSAValueTracker::setValue	libyul/optimiser/SSAValueTracker.h	/^	void setValue(YulString _name, Expression const* _value);$/;"	p	class:yul::SSAValueTracker	access:private	signature:(YulString _name, Expression const* _value)
yul::SSAValueTracker::std::values	libyul/optimiser/SSAValueTracker.h	/^	std::map<YulString, Expression const*> const& values() const { return m_values; }$/;"	f	class:yul::SSAValueTracker::std	access:public	signature:() const
yul::SSAValueTracker::value	libyul/optimiser/SSAValueTracker.h	/^	Expression const* value(YulString _name) const { return m_values.at(_name); }$/;"	f	class:yul::SSAValueTracker	access:public	signature:(YulString _name) const
yul::Scope	libyul/AsmScope.h	/^struct Scope$/;"	s	namespace:yul
yul::Scope::Function	libyul/AsmScope.h	/^	struct Function$/;"	s	struct:yul::Scope	access:public
yul::Scope::Function::arguments	libyul/AsmScope.h	/^		std::vector<YulType> arguments;$/;"	m	struct:yul::Scope::Function	access:public
yul::Scope::Function::returns	libyul/AsmScope.h	/^		std::vector<YulType> returns;$/;"	m	struct:yul::Scope::Function	access:public
yul::Scope::Label	libyul/AsmScope.h	/^	struct Label { };$/;"	s	struct:yul::Scope	access:public
yul::Scope::Variable	libyul/AsmScope.h	/^	struct Variable { YulType type; };$/;"	s	struct:yul::Scope	access:public
yul::Scope::Variable::type	libyul/AsmScope.h	/^	struct Variable { YulType type; };$/;"	m	struct:yul::Scope::Variable	access:public
yul::Scope::exists	libyul/AsmScope.h	/^	bool exists(YulString _name) const;$/;"	p	struct:yul::Scope	access:public	signature:(YulString _name) const
yul::Scope::functionScope	libyul/AsmScope.h	/^	bool functionScope = false;$/;"	m	struct:yul::Scope	access:public
yul::Scope::identifiers	libyul/AsmScope.h	/^	std::map<YulString, Identifier> identifiers;$/;"	m	struct:yul::Scope	access:public
yul::Scope::insideFunction	libyul/AsmScope.h	/^	bool insideFunction() const;$/;"	p	struct:yul::Scope	access:public	signature:() const
yul::Scope::lookup	libyul/AsmScope.h	/^	Identifier* lookup(YulString _name);$/;"	p	struct:yul::Scope	access:public	signature:(YulString _name)
yul::Scope::lookup	libyul/AsmScope.h	/^	bool lookup(YulString _name, V const& _visitor)$/;"	f	struct:yul::Scope	access:public	signature:(YulString _name, V const& _visitor)
yul::Scope::numberOfVariables	libyul/AsmScope.h	/^	size_t numberOfVariables() const;$/;"	p	struct:yul::Scope	access:public	signature:() const
yul::Scope::registerFunction	libyul/AsmScope.h	/^	bool registerFunction($/;"	p	struct:yul::Scope	access:public	signature:( YulString _name, std::vector<YulType> const& _arguments, std::vector<YulType> const& _returns )
yul::Scope::registerLabel	libyul/AsmScope.h	/^	bool registerLabel(YulString _name);$/;"	p	struct:yul::Scope	access:public	signature:(YulString _name)
yul::Scope::superScope	libyul/AsmScope.h	/^	Scope* superScope = nullptr;$/;"	m	struct:yul::Scope	access:public
yul::ScopeFiller	libyul/AsmScopeFiller.h	/^class ScopeFiller: public boost::static_visitor<bool>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::ScopeFiller::ScopeFiller	libyul/AsmScopeFiller.h	/^	ScopeFiller(AsmAnalysisInfo& _info, langutil::ErrorReporter& _errorReporter);$/;"	p	class:yul::ScopeFiller	access:public	signature:(AsmAnalysisInfo& _info, langutil::ErrorReporter& _errorReporter)
yul::ScopeFiller::m_currentScope	libyul/AsmScopeFiller.h	/^	Scope* m_currentScope = nullptr;$/;"	m	class:yul::ScopeFiller	access:private
yul::ScopeFiller::m_errorReporter	libyul/AsmScopeFiller.h	/^	langutil::ErrorReporter& m_errorReporter;$/;"	m	class:yul::ScopeFiller	access:private
yul::ScopeFiller::m_info	libyul/AsmScopeFiller.h	/^	AsmAnalysisInfo& m_info;$/;"	m	class:yul::ScopeFiller	access:private
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Assignment const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Assignment const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Block const& _block);$/;"	p	class:yul::ScopeFiller	access:public	signature:(Block const& _block)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(ExpressionStatement const& _expr);$/;"	p	class:yul::ScopeFiller	access:public	signature:(ExpressionStatement const& _expr)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(ForLoop const& _forLoop);$/;"	p	class:yul::ScopeFiller	access:public	signature:(ForLoop const& _forLoop)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(FunctionCall const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(FunctionCall const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(FunctionDefinition const& _functionDefinition);$/;"	p	class:yul::ScopeFiller	access:public	signature:(FunctionDefinition const& _functionDefinition)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(FunctionalInstruction const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(FunctionalInstruction const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Identifier const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Identifier const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(If const& _if);$/;"	p	class:yul::ScopeFiller	access:public	signature:(If const& _if)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Instruction const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Instruction const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Label const& _label);$/;"	p	class:yul::ScopeFiller	access:public	signature:(Label const& _label)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Literal const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(Literal const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(StackAssignment const&) { return true; }$/;"	f	class:yul::ScopeFiller	access:public	signature:(StackAssignment const&)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(Switch const& _switch);$/;"	p	class:yul::ScopeFiller	access:public	signature:(Switch const& _switch)
yul::ScopeFiller::operator ()	libyul/AsmScopeFiller.h	/^	bool operator()(VariableDeclaration const& _variableDeclaration);$/;"	p	class:yul::ScopeFiller	access:public	signature:(VariableDeclaration const& _variableDeclaration)
yul::ScopeFiller::registerVariable	libyul/AsmScopeFiller.h	/^	bool registerVariable($/;"	p	class:yul::ScopeFiller	access:private	signature:( TypedName const& _name, langutil::SourceLocation const& _location, Scope& _scope )
yul::ScopeFiller::scope	libyul/AsmScopeFiller.h	/^	Scope& scope(Block const* _block);$/;"	p	class:yul::ScopeFiller	access:private	signature:(Block const* _block)
yul::SimplificationRules	libyul/optimiser/SimplificationRules.h	/^class SimplificationRules: public boost::noncopyable$/;"	c	namespace:yul	inherits:boost::noncopyable
yul::SimplificationRules::SimplificationRules	libyul/optimiser/SimplificationRules.h	/^	SimplificationRules();$/;"	p	class:yul::SimplificationRules	access:public	signature:()
yul::SimplificationRules::addRule	libyul/optimiser/SimplificationRules.h	/^	void addRule(SimplificationRule<Pattern> const& _rule);$/;"	p	class:yul::SimplificationRules	access:private	signature:(SimplificationRule<Pattern> const& _rule)
yul::SimplificationRules::addRules	libyul/optimiser/SimplificationRules.h	/^	void addRules(std::vector<SimplificationRule<Pattern>> const& _rules);$/;"	p	class:yul::SimplificationRules	access:private	signature:(std::vector<SimplificationRule<Pattern>> const& _rules)
yul::SimplificationRules::findFirstMatch	libyul/optimiser/SimplificationRules.h	/^	static SimplificationRule<Pattern> const* findFirstMatch($/;"	p	class:yul::SimplificationRules	access:public	signature:( Expression const& _expr, Dialect const& _dialect, std::map<YulString, Expression const*> const& _ssaValues )
yul::SimplificationRules::isInitialized	libyul/optimiser/SimplificationRules.h	/^	bool isInitialized() const;$/;"	p	class:yul::SimplificationRules	access:public	signature:() const
yul::SimplificationRules::m_matchGroups	libyul/optimiser/SimplificationRules.h	/^	std::map<unsigned, Expression const*> m_matchGroups;$/;"	m	class:yul::SimplificationRules	access:private
yul::SimplificationRules::m_rules	libyul/optimiser/SimplificationRules.h	/^	std::vector<SimplificationRule<Pattern>> m_rules[256];$/;"	m	class:yul::SimplificationRules	access:private
yul::SimplificationRules::resetMatchGroups	libyul/optimiser/SimplificationRules.h	/^	void resetMatchGroups() { m_matchGroups.clear(); }$/;"	f	class:yul::SimplificationRules	access:private	signature:()
yul::StackAssignment	libyul/AsmData.h	/^struct StackAssignment { langutil::SourceLocation location; Identifier variableName; };$/;"	s	namespace:yul
yul::StackAssignment::location	libyul/AsmData.h	/^struct StackAssignment { langutil::SourceLocation location; Identifier variableName; };$/;"	m	struct:yul::StackAssignment	access:public
yul::StackAssignment::variableName	libyul/AsmData.h	/^struct StackAssignment { langutil::SourceLocation location; Identifier variableName; };$/;"	m	struct:yul::StackAssignment	access:public
yul::StackCompressor	libyul/optimiser/StackCompressor.h	/^class StackCompressor$/;"	c	namespace:yul
yul::StackCompressor::run	libyul/optimiser/StackCompressor.h	/^	static bool run(std::shared_ptr<Dialect> const& _dialect, Block& _ast);$/;"	p	class:yul::StackCompressor	access:public	signature:(std::shared_ptr<Dialect> const& _dialect, Block& _ast)
yul::StackTooDeepError	libyul/backends/evm/EVMCodeTransform.h	/^struct StackTooDeepError: virtual YulException$/;"	s	namespace:yul	inherits:YulException
yul::StackTooDeepError::StackTooDeepError	libyul/backends/evm/EVMCodeTransform.h	/^	StackTooDeepError(YulString _functionName, YulString _variable, int _depth):$/;"	f	struct:yul::StackTooDeepError	access:public	signature:(YulString _functionName, YulString _variable, int _depth)
yul::StackTooDeepError::StackTooDeepError	libyul/backends/evm/EVMCodeTransform.h	/^	StackTooDeepError(YulString _variable, int _depth): variable(_variable), depth(_depth) {}$/;"	f	struct:yul::StackTooDeepError	access:public	signature:(YulString _variable, int _depth)
yul::StackTooDeepError::depth	libyul/backends/evm/EVMCodeTransform.h	/^	int depth;$/;"	m	struct:yul::StackTooDeepError	access:public
yul::StackTooDeepError::functionName	libyul/backends/evm/EVMCodeTransform.h	/^	YulString functionName;$/;"	m	struct:yul::StackTooDeepError	access:public
yul::StackTooDeepError::variable	libyul/backends/evm/EVMCodeTransform.h	/^	YulString variable;$/;"	m	struct:yul::StackTooDeepError	access:public
yul::StatementCopier	libyul/optimiser/ASTCopier.h	/^class StatementCopier: public boost::static_visitor<Statement>$/;"	c	namespace:yul	inherits:boost::static_visitor
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Assignment const& _assignment) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Assignment const& _assignment)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Block const& _block) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Block const& _block)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(ExpressionStatement const& _statement) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(ExpressionStatement const& _statement)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(ForLoop const&) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(ForLoop const&)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(FunctionDefinition const&) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(FunctionDefinition const&)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(If const& _if) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(If const& _if)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Instruction const& _instruction) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Instruction const& _instruction)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Label const& _label) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Label const& _label)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(StackAssignment const& _assignment) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(StackAssignment const& _assignment)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(Switch const& _switch) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(Switch const& _switch)
yul::StatementCopier::operator ()	libyul/optimiser/ASTCopier.h	/^	virtual Statement operator()(VariableDeclaration const& _varDecl) = 0;$/;"	p	class:yul::StatementCopier	access:public	signature:(VariableDeclaration const& _varDecl)
yul::StatementCopier::~StatementCopier	libyul/optimiser/ASTCopier.h	/^	virtual ~StatementCopier() = default;$/;"	p	class:yul::StatementCopier	access:public	signature:()
yul::StructuralSimplifier	libyul/optimiser/StructuralSimplifier.h	/^class StructuralSimplifier: public DataFlowAnalyzer$/;"	c	namespace:yul	inherits:DataFlowAnalyzer
yul::StructuralSimplifier::StructuralSimplifier	libyul/optimiser/StructuralSimplifier.h	/^	explicit StructuralSimplifier(Dialect const& _dialect): DataFlowAnalyzer(_dialect) {}$/;"	f	class:yul::StructuralSimplifier	access:public	signature:(Dialect const& _dialect)
yul::StructuralSimplifier::expressionAlwaysFalse	libyul/optimiser/StructuralSimplifier.h	/^	bool expressionAlwaysFalse(Expression const& _expression);$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(Expression const& _expression)
yul::StructuralSimplifier::expressionAlwaysTrue	libyul/optimiser/StructuralSimplifier.h	/^	bool expressionAlwaysTrue(Expression const& _expression);$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(Expression const& _expression)
yul::StructuralSimplifier::hasLiteralValue	libyul/optimiser/StructuralSimplifier.h	/^	boost::optional<dev::u256> hasLiteralValue(Expression const& _expression) const;$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(Expression const& _expression) const
yul::StructuralSimplifier::override	libyul/optimiser/StructuralSimplifier.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::StructuralSimplifier	access:public
yul::StructuralSimplifier::simplify	libyul/optimiser/StructuralSimplifier.h	/^	void simplify(std::vector<Statement>& _statements);$/;"	p	class:yul::StructuralSimplifier	access:private	signature:(std::vector<Statement>& _statements)
yul::Substitution	libyul/optimiser/Substitution.h	/^class Substitution: public ASTCopier$/;"	c	namespace:yul	inherits:ASTCopier
yul::Substitution::Substitution	libyul/optimiser/Substitution.h	/^	Substitution(std::map<YulString, Expression const*> const& _substitutions):$/;"	f	class:yul::Substitution	access:public	signature:(std::map<YulString, Expression const*> const& _substitutions)
yul::Substitution::override	libyul/optimiser/Substitution.h	/^	Expression translate(Expression const& _expression) override;$/;"	m	class:yul::Substitution	access:public
yul::Substitution::std::m_substitutions	libyul/optimiser/Substitution.h	/^	std::map<YulString, Expression const*> const& m_substitutions;$/;"	m	class:yul::Substitution::std	access:private
yul::Switch	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	s	namespace:yul
yul::Switch::cases	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	m	struct:yul::Switch	access:public
yul::Switch::expression	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	m	struct:yul::Switch	access:public
yul::Switch::location	libyul/AsmData.h	/^struct Switch { langutil::SourceLocation location; std::unique_ptr<Expression> expression; std::vector<Case> cases; };$/;"	m	struct:yul::Switch	access:public
yul::SyntacticallyEqual	libyul/optimiser/SyntacticalEquality.h	/^class SyntacticallyEqual$/;"	c	namespace:yul
yul::SyntacticallyEqual::compareUniquePtr	libyul/optimiser/SyntacticalEquality.h	/^	bool compareUniquePtr(std::unique_ptr<T> const& _lhs, std::unique_ptr<T> const& _rhs)$/;"	f	class:yul::SyntacticallyEqual	access:private	signature:(std::unique_ptr<T> const& _lhs, std::unique_ptr<T> const& _rhs)
yul::SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(FunctionCall const& _lhs, FunctionCall const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(FunctionCall const& _lhs, FunctionCall const& _rhs)
yul::SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(FunctionalInstruction const& _lhs, FunctionalInstruction const& _rhs)
yul::SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(Identifier const& _lhs, Identifier const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Identifier const& _lhs, Identifier const& _rhs)
yul::SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(Literal const& _lhs, Literal const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Literal const& _lhs, Literal const& _rhs)
yul::SyntacticallyEqual::expressionEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool expressionEqual(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)$/;"	f	class:yul::SyntacticallyEqual	access:private	signature:(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)
yul::SyntacticallyEqual::m_identifiersLHS	libyul/optimiser/SyntacticalEquality.h	/^	std::map<YulString, std::size_t> m_identifiersLHS;$/;"	m	class:yul::SyntacticallyEqual	access:private
yul::SyntacticallyEqual::m_identifiersRHS	libyul/optimiser/SyntacticalEquality.h	/^	std::map<YulString, std::size_t> m_identifiersRHS;$/;"	m	class:yul::SyntacticallyEqual	access:private
yul::SyntacticallyEqual::m_idsUsed	libyul/optimiser/SyntacticalEquality.h	/^	std::size_t m_idsUsed = 0;$/;"	m	class:yul::SyntacticallyEqual	access:private
yul::SyntacticallyEqual::operator ()	libyul/optimiser/SyntacticalEquality.h	/^	bool operator()(Expression const& _lhs, Expression const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Expression const& _lhs, Expression const& _rhs)
yul::SyntacticallyEqual::operator ()	libyul/optimiser/SyntacticalEquality.h	/^	bool operator()(Statement const& _lhs, Statement const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Statement const& _lhs, Statement const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Assignment const& _lhs, Assignment const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Assignment const& _lhs, Assignment const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Block const& _lhs, Block const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Block const& _lhs, Block const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(ExpressionStatement const& _lhs, ExpressionStatement const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(ForLoop const& _lhs, ForLoop const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(ForLoop const& _lhs, ForLoop const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(FunctionDefinition const& _lhs, FunctionDefinition const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(If const& _lhs, If const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(If const& _lhs, If const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Instruction const& _lhs, Instruction const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(Instruction const& _lhs, Instruction const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Label const& _lhs, Label const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(Label const& _lhs, Label const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(StackAssignment const& _lhs, StackAssignment const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(StackAssignment const& _lhs, StackAssignment const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(Switch const& _lhs, Switch const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Switch const& _lhs, Switch const& _rhs)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)$/;"	f	class:yul::SyntacticallyEqual	access:private	signature:(U const&, V const&, std::enable_if_t<!std::is_same<U, V>::value>* = nullptr)
yul::SyntacticallyEqual::statementEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool statementEqual(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(VariableDeclaration const& _lhs, VariableDeclaration const& _rhs)
yul::SyntacticallyEqual::switchCaseEqual	libyul/optimiser/SyntacticalEquality.h	/^	bool switchCaseEqual(Case const& _lhs, Case const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:public	signature:(Case const& _lhs, Case const& _rhs)
yul::SyntacticallyEqual::visitDeclaration	libyul/optimiser/SyntacticalEquality.h	/^	bool visitDeclaration(TypedName const& _lhs, TypedName const& _rhs);$/;"	p	class:yul::SyntacticallyEqual	access:private	signature:(TypedName const& _lhs, TypedName const& _rhs)
yul::TypedName	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	s	namespace:yul
yul::TypedName::location	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	m	struct:yul::TypedName	access:public
yul::TypedName::name	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	m	struct:yul::TypedName	access:public
yul::TypedName::type	libyul/AsmData.h	/^struct TypedName { langutil::SourceLocation location; YulString name; Type type; };$/;"	m	struct:yul::TypedName	access:public
yul::UnusedPruner	libyul/optimiser/UnusedPruner.h	/^class UnusedPruner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::UnusedPruner::UnusedPruner	libyul/optimiser/UnusedPruner.h	/^	UnusedPruner($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> const& _externallyUsedFunctions = {} )
yul::UnusedPruner::UnusedPruner	libyul/optimiser/UnusedPruner.h	/^	UnusedPruner($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, FunctionDefinition& _function, std::set<YulString> const& _externallyUsedFunctions = {} )
yul::UnusedPruner::m_dialect	libyul/optimiser/UnusedPruner.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::UnusedPruner	access:private
yul::UnusedPruner::m_references	libyul/optimiser/UnusedPruner.h	/^	std::map<YulString, size_t> m_references;$/;"	m	class:yul::UnusedPruner	access:private
yul::UnusedPruner::m_shouldRunAgain	libyul/optimiser/UnusedPruner.h	/^	bool m_shouldRunAgain = false;$/;"	m	class:yul::UnusedPruner	access:private
yul::UnusedPruner::override	libyul/optimiser/UnusedPruner.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::UnusedPruner	access:public
yul::UnusedPruner::runUntilStabilised	libyul/optimiser/UnusedPruner.h	/^	static void runUntilStabilised($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, Block& _ast, std::set<YulString> const& _externallyUsedFunctions = {} )
yul::UnusedPruner::runUntilStabilised	libyul/optimiser/UnusedPruner.h	/^	static void runUntilStabilised($/;"	p	class:yul::UnusedPruner	access:public	signature:( Dialect const& _dialect, FunctionDefinition& _functionDefinition, std::set<YulString> const& _externallyUsedFunctions = {} )
yul::UnusedPruner::shouldRunAgain	libyul/optimiser/UnusedPruner.h	/^	bool shouldRunAgain() const { return m_shouldRunAgain; }$/;"	f	class:yul::UnusedPruner	access:public	signature:() const
yul::UnusedPruner::subtractReferences	libyul/optimiser/UnusedPruner.h	/^	void subtractReferences(std::map<YulString, size_t> const& _subtrahend);$/;"	p	class:yul::UnusedPruner	access:private	signature:(std::map<YulString, size_t> const& _subtrahend)
yul::UnusedPruner::used	libyul/optimiser/UnusedPruner.h	/^	bool used(YulString _name) const;$/;"	p	class:yul::UnusedPruner	access:private	signature:(YulString _name) const
yul::VarDeclInitializer	libyul/optimiser/VarDeclInitializer.h	/^class VarDeclInitializer: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::VarDeclInitializer::override	libyul/optimiser/VarDeclInitializer.h	/^	void operator()(Block& _block) override;$/;"	m	class:yul::VarDeclInitializer	access:public
yul::VarNameCleaner	libyul/optimiser/VarNameCleaner.h	/^class VarNameCleaner: public ASTModifier$/;"	c	namespace:yul	inherits:ASTModifier
yul::VarNameCleaner::VarNameCleaner	libyul/optimiser/VarNameCleaner.h	/^	VarNameCleaner($/;"	p	class:yul::VarNameCleaner	access:public	signature:( Block const& _ast, Dialect const& _dialect, std::set<YulString> _blacklist = {} )
yul::VarNameCleaner::findCleanName	libyul/optimiser/VarNameCleaner.h	/^	YulString findCleanName(YulString const& name) const;$/;"	p	class:yul::VarNameCleaner	access:private	signature:(YulString const& name) const
yul::VarNameCleaner::isUsedName	libyul/optimiser/VarNameCleaner.h	/^	bool isUsedName(YulString const& _name) const;$/;"	p	class:yul::VarNameCleaner	access:private	signature:(YulString const& _name) const
yul::VarNameCleaner::m_blacklist	libyul/optimiser/VarNameCleaner.h	/^	std::set<YulString> m_blacklist;$/;"	m	class:yul::VarNameCleaner	access:private
yul::VarNameCleaner::m_dialect	libyul/optimiser/VarNameCleaner.h	/^	Dialect const& m_dialect;$/;"	m	class:yul::VarNameCleaner	access:private
yul::VarNameCleaner::m_insideFunction	libyul/optimiser/VarNameCleaner.h	/^	bool m_insideFunction = false;$/;"	m	class:yul::VarNameCleaner	access:private
yul::VarNameCleaner::m_translatedNames	libyul/optimiser/VarNameCleaner.h	/^	std::map<YulString, YulString> m_translatedNames;$/;"	m	class:yul::VarNameCleaner	access:private
yul::VarNameCleaner::m_usedNames	libyul/optimiser/VarNameCleaner.h	/^	std::set<YulString> m_usedNames;$/;"	m	class:yul::VarNameCleaner	access:private
yul::VarNameCleaner::override	libyul/optimiser/VarNameCleaner.h	/^	void operator()(FunctionDefinition& _funDef) override;$/;"	m	class:yul::VarNameCleaner	access:public
yul::VarNameCleaner::override	libyul/optimiser/VarNameCleaner.h	/^	void operator()(Identifier& _identifier) override;$/;"	m	class:yul::VarNameCleaner	access:public
yul::VarNameCleaner::override	libyul/optimiser/VarNameCleaner.h	/^	void operator()(VariableDeclaration& _varDecl) override;$/;"	m	class:yul::VarNameCleaner	access:public
yul::VarNameCleaner::renameVariables	libyul/optimiser/VarNameCleaner.h	/^	void renameVariables(std::vector<TypedName>& _variables);$/;"	p	class:yul::VarNameCleaner	access:private	signature:(std::vector<TypedName>& _variables)
yul::VarNameCleaner::stripSuffix	libyul/optimiser/VarNameCleaner.h	/^	YulString stripSuffix(YulString const& _name) const;$/;"	p	class:yul::VarNameCleaner	access:private	signature:(YulString const& _name) const
yul::VariableDeclaration	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	s	namespace:yul
yul::VariableDeclaration::location	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::VariableDeclaration	access:public
yul::VariableDeclaration::value	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::VariableDeclaration	access:public
yul::VariableDeclaration::variables	libyul/AsmData.h	/^struct VariableDeclaration { langutil::SourceLocation location; TypedNameList variables; std::unique_ptr<Expression> value; };$/;"	m	struct:yul::VariableDeclaration	access:public
yul::VariableReferenceCounter	libyul/backends/evm/EVMCodeTransform.h	/^class VariableReferenceCounter: public yul::ASTWalker$/;"	c	namespace:yul	inherits:yul::ASTWalker
yul::VariableReferenceCounter::VariableReferenceCounter	libyul/backends/evm/EVMCodeTransform.h	/^	explicit VariableReferenceCounter($/;"	f	class:yul::VariableReferenceCounter	access:public	signature:( CodeTransformContext& _context, AsmAnalysisInfo const& _assemblyInfo )
yul::VariableReferenceCounter::increaseRefIfFound	libyul/backends/evm/EVMCodeTransform.h	/^	void increaseRefIfFound(YulString _variableName);$/;"	p	class:yul::VariableReferenceCounter	access:private	signature:(YulString _variableName)
yul::VariableReferenceCounter::m_context	libyul/backends/evm/EVMCodeTransform.h	/^	CodeTransformContext& m_context;$/;"	m	class:yul::VariableReferenceCounter	access:private
yul::VariableReferenceCounter::m_info	libyul/backends/evm/EVMCodeTransform.h	/^	AsmAnalysisInfo const& m_info;$/;"	m	class:yul::VariableReferenceCounter	access:private
yul::VariableReferenceCounter::m_scope	libyul/backends/evm/EVMCodeTransform.h	/^	Scope* m_scope = nullptr;$/;"	m	class:yul::VariableReferenceCounter	access:private
yul::VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Block const& _block);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(Block const& _block)
yul::VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(ForLoop const&);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(ForLoop const&)
yul::VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(FunctionDefinition const&);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(FunctionDefinition const&)
yul::VariableReferenceCounter::operator ()	libyul/backends/evm/EVMCodeTransform.h	/^	void operator()(Identifier const& _identifier);$/;"	p	class:yul::VariableReferenceCounter	access:public	signature:(Identifier const& _identifier)
yul::YulAssertion	libyul/Exceptions.h	/^struct YulAssertion: virtual YulException {};$/;"	s	namespace:yul	inherits:YulException
yul::YulException	libyul/Exceptions.h	/^struct YulException: virtual dev::Exception {};$/;"	s	namespace:yul	inherits:dev::Exception
yul::YulString	libyul/YulString.h	/^class YulString$/;"	c	namespace:yul
yul::YulString::YulString	libyul/YulString.h	/^	YulString() = default;$/;"	p	class:yul::YulString	access:public	signature:()
yul::YulString::YulString	libyul/YulString.h	/^	YulString(YulString const&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString const&)
yul::YulString::YulString	libyul/YulString.h	/^	YulString(YulString&&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString&&)
yul::YulString::YulString	libyul/YulString.h	/^	explicit YulString(std::string const& _s): m_handle(YulStringRepository::instance().stringToHandle(_s)) {}$/;"	f	class:yul::YulString	access:public	signature:(std::string const& _s)
yul::YulString::empty	libyul/YulString.h	/^	bool empty() const { return m_handle.id == 0; }$/;"	f	class:yul::YulString	access:public	signature:() const
yul::YulString::operator !=	libyul/YulString.h	/^	bool operator!=(YulString const& _other) const { return m_handle.id != _other.m_handle.id; }$/;"	f	class:yul::YulString	access:public	signature:(YulString const& _other) const
yul::YulString::operator <	libyul/YulString.h	/^	bool operator<(YulString const& _other) const$/;"	f	class:yul::YulString	access:public	signature:(YulString const& _other) const
yul::YulString::operator =	libyul/YulString.h	/^	YulString& operator=(YulString const&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString const&)
yul::YulString::operator =	libyul/YulString.h	/^	YulString& operator=(YulString&&) = default;$/;"	p	class:yul::YulString	access:public	signature:(YulString&&)
yul::YulString::operator ==	libyul/YulString.h	/^	bool operator==(YulString const& _other) const { return m_handle.id == _other.m_handle.id; }$/;"	f	class:yul::YulString	access:public	signature:(YulString const& _other) const
yul::YulString::std::str	libyul/YulString.h	/^	std::string const& str() const$/;"	f	class:yul::YulString::std	access:public	signature:() const
yul::YulStringRepository	libyul/YulString.h	/^class YulStringRepository: boost::noncopyable$/;"	c	namespace:yul	inherits:boost::noncopyable
yul::YulStringRepository::Handle	libyul/YulString.h	/^	struct Handle$/;"	s	class:yul::YulStringRepository	access:public
yul::YulStringRepository::Handle::hash	libyul/YulString.h	/^		std::uint64_t hash;$/;"	m	struct:yul::YulStringRepository::Handle	access:public
yul::YulStringRepository::Handle::id	libyul/YulString.h	/^		size_t id;$/;"	m	struct:yul::YulStringRepository::Handle	access:public
yul::YulStringRepository::YulStringRepository	libyul/YulString.h	/^	YulStringRepository() = default;$/;"	p	class:yul::YulStringRepository	access:public	signature:()
yul::YulStringRepository::emptyHash	libyul/YulString.h	/^	static constexpr std::uint64_t emptyHash() { return 14695981039346656037u; }$/;"	f	class:yul::YulStringRepository	access:public	signature:()
yul::YulStringRepository::hash	libyul/YulString.h	/^	static std::uint64_t hash(std::string const& v)$/;"	f	class:yul::YulStringRepository	access:public	signature:(std::string const& v)
yul::YulStringRepository::instance	libyul/YulString.h	/^	static YulStringRepository& instance()$/;"	f	class:yul::YulStringRepository	access:public	signature:()
yul::YulStringRepository::m_hashToID	libyul/YulString.h	/^	std::unordered_multimap<std::uint64_t, size_t> m_hashToID = {{emptyHash(), 0}};$/;"	m	class:yul::YulStringRepository	access:private
yul::YulStringRepository::m_strings	libyul/YulString.h	/^	std::vector<std::shared_ptr<std::string>> m_strings = {std::make_shared<std::string>()};$/;"	m	class:yul::YulStringRepository	access:private
yul::YulStringRepository::std::idToString	libyul/YulString.h	/^	std::string const& idToString(size_t _id) const	{ return *m_strings.at(_id); }$/;"	f	class:yul::YulStringRepository::std	access:public	signature:(size_t _id) const
yul::YulStringRepository::stringToHandle	libyul/YulString.h	/^	Handle stringToHandle(std::string const& _string)$/;"	f	class:yul::YulStringRepository	access:public	signature:(std::string const& _string)
yul::_yulstring	libyul/YulString.h	/^inline YulString operator "" _yulstring(char const* _string, std::size_t _size)$/;"	f	namespace:yul	signature:(char const* _string, std::size_t _size)
yul::locationOf	libyul/AsmData.h	/^template <class T> inline langutil::SourceLocation locationOf(T const& _node)$/;"	f	namespace:yul	signature:(T const& _node)
yul::removeEmptyBlocks	libyul/optimiser/OptimizerUtilities.cpp	/^void yul::removeEmptyBlocks(Block& _block)$/;"	f	class:yul	signature:(Block& _block)
yul::removeEmptyBlocks	libyul/optimiser/OptimizerUtilities.h	/^void removeEmptyBlocks(Block& _block);$/;"	p	namespace:yul	signature:(Block& _block)
yul::valueOfBoolLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfBoolLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
yul::valueOfBoolLiteral	libyul/Utilities.h	/^dev::u256 valueOfBoolLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
yul::valueOfLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
yul::valueOfLiteral	libyul/Utilities.h	/^dev::u256 valueOfLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
yul::valueOfNumberLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfNumberLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
yul::valueOfNumberLiteral	libyul/Utilities.h	/^dev::u256 valueOfNumberLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
yul::valueOfStringLiteral	libyul/Utilities.cpp	/^u256 yul::valueOfStringLiteral(Literal const& _literal)$/;"	f	class:yul	signature:(Literal const& _literal)
yul::valueOfStringLiteral	libyul/Utilities.h	/^dev::u256 valueOfStringLiteral(Literal const& _literal);$/;"	p	namespace:yul	signature:(Literal const& _literal)
yulAssert	libyul/Exceptions.h	35;"	d
yulForEVM	libyul/backends/evm/EVMDialect.cpp	/^shared_ptr<yul::EVMDialect> EVMDialect::yulForEVM(langutil::EVMVersion _version)$/;"	f	class:EVMDialect	signature:(langutil::EVMVersion _version)
yulForEVM	libyul/backends/evm/EVMDialect.h	/^	static std::shared_ptr<EVMDialect> yulForEVM(langutil::EVMVersion _version);$/;"	p	struct:yul::EVMDialect	access:public	signature:(langutil::EVMVersion _version)
z3Sort	libsolidity/formal/Z3Interface.cpp	/^z3::sort Z3Interface::z3Sort(Sort const& _sort)$/;"	f	class:Z3Interface	signature:(Sort const& _sort)
z3Sort	libsolidity/formal/Z3Interface.cpp	/^z3::sort_vector Z3Interface::z3Sort(vector<SortPointer> const& _sorts)$/;"	f	class:Z3Interface	signature:(vector<SortPointer> const& _sorts)
z3Sort	libsolidity/formal/Z3Interface.h	/^	z3::sort z3Sort(smt::Sort const& _sort);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(smt::Sort const& _sort)
z3Sort	libsolidity/formal/Z3Interface.h	/^	z3::sort_vector z3Sort(std::vector<smt::SortPointer> const& _sorts);$/;"	p	class:dev::solidity::smt::Z3Interface	access:private	signature:(std::vector<smt::SortPointer> const& _sorts)
z3_collusion_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr, z3::expr,z3::expr, z3::expr, z3::expr> > z3_collusion_check_exprs;$/;"	m	class:ContextInfo	access:public
z3_ctx	solse/SolidityExprTranslator.h	/^    z3::context& z3_ctx;$/;"	m	class:SolidityExprTranslator	access:private
z3_ctx	solse/SymExecEngine.h	/^    z3::context& z3_ctx;$/;"	m	class:SymExecEngine	access:private
z3_efficient_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr, ASTPointer<Expression const >, ASTPointer<Expression const>> > z3_efficient_check_exprs;$/;"	m	class:ContextInfo	access:public
z3_efficient_expectation_register	solse/SolidityExprTranslator.h	/^    std::map<std::pair<std::string, std::string>, z3::expr> z3_efficient_expectation_register;$/;"	m	class:ContextInfo	access:public
z3_max_exps	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_max_exps;$/;"	m	class:ContextInfo	access:public
z3_min_exps	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_min_exps;$/;"	m	class:ContextInfo	access:public
z3_optimal_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr,ASTPointer<Expression const >, ASTPointer<Expression const> > > z3_optimal_check_exprs;$/;"	m	class:ContextInfo	access:public
z3_optimal_payment_register	solse/SolidityExprTranslator.h	/^    std::map<std::pair<std::string, std::string>, z3::expr> z3_optimal_payment_register;$/;"	m	class:ContextInfo	access:public
z3_revenue	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_revenue;$/;"	m	class:ContextInfo	access:public
z3_truth_check_exprs	solse/SolidityExprTranslator.h	/^    std::vector< std::tuple<z3::expr, z3::expr, z3::expr> > z3_truth_check_exprs;$/;"	m	class:ContextInfo	access:public
z3_utilities	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_utilities;$/;"	m	class:ContextInfo	access:public
z3_validate_outcome_postconditions	solse/SolidityExprTranslator.h	/^    std::map<std::string, z3::expr> z3_validate_outcome_postconditions;$/;"	m	class:ContextInfo	access:public
z3_winners	solse/SolidityExprTranslator.h	/^    std::vector<z3::expr> z3_winners;$/;"	m	class:ContextInfo	access:public
zeroInitialiseMemoryArray	libsolidity/codegen/CompilerUtils.cpp	/^void CompilerUtils::zeroInitialiseMemoryArray(ArrayType const& _type)$/;"	f	class:dev::solidity::CompilerUtils	signature:(ArrayType const& _type)
zeroInitialiseMemoryArray	libsolidity/codegen/CompilerUtils.h	/^	void zeroInitialiseMemoryArray(ArrayType const& _type);$/;"	p	class:dev::solidity::CompilerUtils	access:public	signature:(ArrayType const& _type)
zeroPointer	libsolidity/codegen/CompilerUtils.cpp	/^size_t const CompilerUtils::zeroPointer = CompilerUtils::freeMemoryPointer + 32;$/;"	m	class:dev::solidity::CompilerUtils	file:
zeroPointer	libsolidity/codegen/CompilerUtils.h	/^	static size_t const zeroPointer;$/;"	m	class:dev::solidity::CompilerUtils	access:public
~ASTAnnotation	libsolidity/ast/ASTAnnotations.h	/^	virtual ~ASTAnnotation() = default;$/;"	p	struct:dev::solidity::ASTAnnotation	access:public	signature:()
~ASTConstVisitor	libsolidity/ast/ASTVisitor.h	/^	virtual ~ASTConstVisitor() = default;$/;"	p	class:dev::solidity::ASTConstVisitor	access:public	signature:()
~ASTCopier	libyul/optimiser/ASTCopier.h	/^	virtual ~ASTCopier() = default;$/;"	p	class:yul::ASTCopier	access:public	signature:()
~ASTModifier	libyul/optimiser/ASTWalker.h	/^	virtual ~ASTModifier() = default;$/;"	p	class:yul::ASTModifier	access:public	signature:()
~ASTNode	libsolidity/ast/AST.cpp	/^ASTNode::~ASTNode()$/;"	f	class:ASTNode	signature:()
~ASTNode	libsolidity/ast/AST.h	/^	virtual ~ASTNode();$/;"	p	class:dev::solidity::ASTNode	access:public	signature:()
~ASTVisitor	libsolidity/ast/ASTVisitor.h	/^	virtual ~ASTVisitor() = default;$/;"	p	class:dev::solidity::ASTVisitor	access:public	signature:()
~ASTWalker	libyul/optimiser/ASTWalker.h	/^	virtual ~ASTWalker() = default;$/;"	p	class:yul::ASTWalker	access:public	signature:()
~AnsiColorized	libdevcore/AnsiColorized.h	/^	~AnsiColorized()$/;"	f	class:dev::AnsiColorized	access:public	signature:()
~BlockScope	libyul/optimiser/RedundantAssignEliminator.h	/^		~BlockScope()$/;"	f	class:yul::RedundantAssignEliminator::BlockScope	access:public	signature:()
~BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.cpp	/^ControlFlowBuilder::BreakContinueScope::~BreakContinueScope()$/;"	f	class:ControlFlowBuilder::BreakContinueScope	signature:()
~BreakContinueScope	libsolidity/analysis/ControlFlowBuilder.h	/^		~BreakContinueScope();$/;"	p	class:dev::solidity::ControlFlowBuilder::BreakContinueScope	access:public	signature:()
~CFGConstVisitor	libsolidity/analysis/ControlFlowGraph.h	/^	virtual ~CFGConstVisitor() = default;$/;"	p	class:dev::solidity::CFGConstVisitor	access:public	signature:()
~ConstantOptimisationMethod	libevmasm/ConstantOptimiser.h	/^	virtual ~ConstantOptimisationMethod() = default;$/;"	p	class:dev::eth::ConstantOptimisationMethod	access:protected	signature:()
~Dialect	libyul/Dialect.h	/^	virtual ~Dialect() = default;$/;"	p	struct:yul::Dialect	access:public	signature:()
~DisableConsoleBuffering	libdevcore/CommonIO.cpp	/^	~DisableConsoleBuffering()$/;"	f	class:DisableConsoleBuffering	access:public	signature:()
~Documented	libsolidity/ast/AST.h	/^	virtual ~Documented() = default;$/;"	p	class:dev::solidity::Documented	access:public	signature:()
~DocumentedAnnotation	libsolidity/ast/ASTAnnotations.h	/^	virtual ~DocumentedAnnotation() = default;$/;"	p	struct:dev::solidity::DocumentedAnnotation	access:public	signature:()
~EVMAssembly	libyul/backends/evm/EVMAssembly.h	/^	virtual ~EVMAssembly() = default;$/;"	p	class:yul::EVMAssembly	access:public	signature:()
~ExpressionCopier	libyul/optimiser/ASTCopier.h	/^	virtual ~ExpressionCopier() = default;$/;"	p	class:yul::ExpressionCopier	access:public	signature:()
~FunctionFlow	libsolidity/analysis/ControlFlowGraph.h	/^	virtual ~FunctionFlow() = default;$/;"	p	struct:dev::solidity::FunctionFlow	access:public	signature:()
~ImplementationOptional	libsolidity/ast/AST.h	/^	virtual ~ImplementationOptional() = default;$/;"	p	class:dev::solidity::ImplementationOptional	access:public	signature:()
~LValue	libsolidity/codegen/LValue.h	/^	virtual ~LValue() = default;$/;"	p	class:dev::solidity::LValue	access:public	signature:()
~LiteralScope	liblangutil/Scanner.cpp	/^	~LiteralScope()$/;"	f	class:langutil::LiteralScope	access:public	signature:()
~NoOutputAssembly	libyul/backends/evm/NoOutputAssembly.h	/^	virtual ~NoOutputAssembly() = default;$/;"	p	class:yul::NoOutputAssembly	access:public	signature:()
~ObjectNode	libyul/Object.h	/^	virtual ~ObjectNode() = default;$/;"	p	struct:yul::ObjectNode	access:public	signature:()
~PeepholeOptimisationMethod	libevmasm/PeepholeOptimiser.h	/^	virtual ~PeepholeOptimisationMethod() = default;$/;"	p	class:dev::eth::PeepholeOptimisationMethod	access:public	signature:()
~PeepholeOptimiser	libevmasm/PeepholeOptimiser.h	/^	virtual ~PeepholeOptimiser() = default;$/;"	p	class:dev::eth::PeepholeOptimiser	access:public	signature:()
~RecursionGuard	liblangutil/ParserBase.h	/^		~RecursionGuard() { m_parser.decreaseRecursionDepth(); }$/;"	f	class:langutil::ParserBase::RecursionGuard	access:public	signature:()
~Scopable	libsolidity/ast/AST.h	/^	virtual ~Scopable() = default;$/;"	p	class:dev::solidity::Scopable	access:public	signature:()
~ScopeGuard	libdevcore/Common.h	/^	~ScopeGuard() { m_f(); }$/;"	f	class:dev::ScopeGuard	access:public	signature:()
~SolverInterface	libsolidity/formal/SolverInterface.h	/^	virtual ~SolverInterface() = default;$/;"	p	class:dev::solidity::smt::SolverInterface	access:public	signature:()
~Sort	libsolidity/formal/SolverInterface.h	/^	virtual ~Sort() = default;$/;"	p	struct:dev::solidity::smt::Sort	access:public	signature:()
~SourceReferenceFormatter	liblangutil/SourceReferenceFormatter.h	/^	virtual ~SourceReferenceFormatter() = default;$/;"	p	class:langutil::SourceReferenceFormatter	access:public	signature:()
~StatementCopier	libyul/optimiser/ASTCopier.h	/^	virtual ~StatementCopier() = default;$/;"	p	class:yul::StatementCopier	access:public	signature:()
~StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.cpp	/^StaticAnalyzer::~StaticAnalyzer()$/;"	f	class:StaticAnalyzer	signature:()
~StaticAnalyzer	libsolidity/analysis/StaticAnalyzer.h	/^	~StaticAnalyzer();$/;"	p	class:dev::solidity::StaticAnalyzer	access:public	signature:()
~SymExecEngine	solse/SymExecEngine.cpp	/^~SymExecEngine(){$/;"	f	class:SymExecEngine	signature:()
~SymExecEngine	solse/SymExecEngine.h	/^    ~SymExecEngine();$/;"	p	class:SymExecEngine	access:public	signature:()
~SymbolicVariable	libsolidity/formal/SymbolicVariables.h	/^	virtual ~SymbolicVariable() = default;$/;"	p	class:dev::solidity::SymbolicVariable	access:public	signature:()
~Type	libsolidity/ast/Types.h	/^	virtual ~Type() = default;$/;"	p	class:dev::solidity::Type	access:public	signature:()
~VariableScope	libsolidity/ast/AST.h	/^	virtual ~VariableScope() = default;$/;"	p	class:dev::solidity::VariableScope	access:public	signature:()
